<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>The Procedural Index (Row-Major)</title>
<script src="https://cdn.tailwindcss.com"></script>
<style>
    :root { --bg: #0f172a; --panel: #1e293b; --accent: #22d3ee; --text: #e2e8f0; --dim: #64748b; }
    body { background: var(--bg); color: var(--text); font-family: 'Courier New', monospace; padding: 20px; display: flex; flex-direction: column; align-items: center; }
    
    .dashboard { width: 100%; max-width: 900px; display: flex; flex-direction: column; gap: 20px; }
    
    /* CONTROL PANEL */
    .controls { background: var(--panel); padding: 20px; border-radius: 12px; border: 1px solid #334155; box-shadow: 0 10px 25px rgba(0,0,0,0.5); }
    .input-group { display: flex; gap: 10px; margin-bottom: 10px; }
    input { background: #020617; border: 1px solid #475569; color: #fff; padding: 12px; flex: 1; border-radius: 6px; font-weight: bold; text-align: center; font-family: inherit; }
    button { background: var(--accent); color: #000; font-weight: 900; padding: 0 20px; border-radius: 6px; cursor: pointer; text-transform: uppercase; border: none; }
    button:hover { filter: brightness(1.1); }
    
    .label { font-size: 0.7rem; color: var(--dim); font-weight: bold; text-transform: uppercase; margin-bottom: 5px; letter-spacing: 1px; }

    /* DATA TABLE */
    .table-frame { background: #000; border: 1px solid #334155; border-radius: 8px; overflow: hidden; }
    .data-row { display: grid; grid-template-columns: 0.8fr 0.5fr 0.5fr 1.5fr 1fr 0.8fr; padding: 10px; border-bottom: 1px solid #1e293b; font-size: 0.9rem; align-items: center; }
    .data-row:last-child { border-bottom: none; }
    .head-row { background: #1e293b; color: var(--accent); font-weight: bold; font-size: 0.75rem; text-transform: uppercase; letter-spacing: 1px; border-bottom: 2px solid #334155; }
    
    .col-id { color: var(--accent); font-weight: bold; }
    .col-geo { color: #94a3b8; }
    .col-calc { color: #fff; }
    .col-meta { color: var(--dim); font-size: 0.8rem; text-align: right; }
    
    .highlight { background: rgba(34, 211, 238, 0.1); }
</style>
</head>
<body>

<div class="dashboard">

    <div class="controls">
        <div class="label">Reverse Lookup (Find ID from Geometry)</div>
        <div class="input-group">
            <input id="inpP2" placeholder="Spine Factor (P2)">
            <input id="inpP1" placeholder="Offset Factor (P1)">
            <button onclick="reverseLookup()">Find ID</button>
        </div>
    </div>

    <div class="controls">
        <div class="label">Forward Indexing (Jump to ID)</div>
        <div class="input-group">
            <input id="inpL" placeholder="Enter Tape ID (L)..." value="1">
            <button onclick="renderTable()">Jump</button>
        </div>
    </div>

    <div class="table-frame">
        <div class="data-row head-row">
            <div>ID (L)</div>
            <div>Row</div>
            <div>Pos</div>
            <div>Factors (P2 × P1)</div>
            <div>Cargo (N)</div>
            <div style="text-align:right">Geo (a.b)</div>
        </div>
        <div id="tableBody"></div>
    </div>
    
    <div style="text-align:center; margin-top:10px; color:#64748b; font-size:0.8rem;">
        <button onclick="nextPage()" style="background:#1e293b; color:#fff; border:1px solid #475569; width:100%; padding:15px;">LOAD NEXT 20 ▼</button>
    </div>

</div>

<script>
// --- THE CORE LOGIC (From row-major.txt) ---
function unpackRowMajor(L_in) {
    const L = BigInt(L_in);
    if (L < 1n) return null;

    // 1. Find Row (m)
    // Triangular number approximation: m ≈ sqrt(2L)
    // m(m-1)/2 < L <= m(m+1)/2
    // Math.sqrt works for small numbers, but for BigInt we need precision.
    // Let's use a safe BigInt Sqrt.
    
    function sqrtBI(n) {
        if (n < 2n) return n;
        let x = n; let y = (x + 1n) / 2n;
        while (y < x) { x = y; y = (x + n / x) / 2n; }
        return x;
    }

    // Solve 2L ≈ m^2 -> m ≈ sqrt(2L)
    let m = sqrtBI(2n * L);
    
    // Adjust to find exact triangular range
    // Tri(m) = m*(m+1)/2
    let triM = (m * (m + 1n)) / 2n;
    
    // If our estimate is too low (L is greater than the full triangle of m)
    while (triM < L) {
        m++;
        triM = (m * (m + 1n)) / 2n;
    }
    // If our estimate is too high (L is inside the previous triangle)
    // But since we approached from sqrt(2L), we are usually close.
    // We need the smallest m where Tri(m) >= L.
    // Let's check m-1.
    let triPrev = ((m - 1n) * m) / 2n;
    while (triPrev >= L) {
        m--;
        triM = triPrev;
        triPrev = ((m - 1n) * m) / 2n;
    }

    const row = m;
    const posInRow = L - triPrev;

    // 2. Calculate Geometry
    const P2 = row * 2n + 1n; // Spine (Larger Factor)
    
    // P1 logic from your file:
    // P1 decreases by 2 for each position.
    // Pos 1 -> P1 = P2 (Square)
    // Pos 2 -> P1 = P2 - 2
    const offset = (posInRow - 1n) * 2n;
    const P1 = P2 - offset;

    const N = P2 * P1;
    const a = (P2 + P1) / 2n;
    const b = (P2 - P1) / 2n;

    return {
        L: L.toString(),
        row: row.toString(),
        pos: posInRow.toString(),
        P2: P2.toString(),
        P1: P1.toString(),
        N: N.toString(),
        geo: `${a}.${b}`
    };
}

// --- REVERSE LOOKUP (Factors -> L) ---
function packRowMajor(P2, P1) {
    // 1. Get Row (m) from P2
    // P2 = 2m + 1  ->  m = (P2 - 1) / 2
    const m = (P2 - 1n) / 2n;
    
    // 2. Get Position from P1
    // P1 = P2 - offset
    // offset = P2 - P1
    // offset = (pos - 1) * 2
    // pos - 1 = (P2 - P1) / 2
    // pos = ((P2 - P1) / 2) + 1
    const pos = ((P2 - P1) / 2n) + 1n;
    
    // 3. Calculate L
    // L = Tri(m-1) + pos
    const prevM = m - 1n;
    const triPrev = (prevM * (prevM + 1n)) / 2n;
    const L = triPrev + pos;
    
    return L;
}

// --- UI LOGIC ---
let currentStartL = 1n;

function renderTable() {
    const table = document.getElementById('tableBody');
    table.innerHTML = '';
    
    const inputVal = document.getElementById('inpL').value.trim();
    if(!inputVal) return;
    currentStartL = BigInt(inputVal);

    for(let i=0; i<20; i++) {
        const L = currentStartL + BigInt(i);
        const data = unpackRowMajor(L);
        
        if(data) {
            const html = `
                <div class="data-row ${i===0 ? 'highlight' : ''}">
                    <div class="col-id">#${data.L}</div>
                    <div class="col-geo">${data.row}</div>
                    <div class="col-geo">${data.pos}</div>
                    <div class="col-calc">${data.P2} × ${data.P1}</div>
                    <div class="col-calc">${data.N}</div>
                    <div class="col-meta">${data.geo}</div>
                </div>
            `;
            table.insertAdjacentHTML('beforeend', html);
        }
    }
}

function nextPage() {
    currentStartL += 20n;
    document.getElementById('inpL').value = currentStartL.toString();
    renderTable();
}

function reverseLookup() {
    try {
        const sP2 = document.getElementById('inpP2').value.trim();
        const sP1 = document.getElementById('inpP1').value.trim();
        if(!sP2 || !sP1) return;
        
        const P2 = BigInt(sP2);
        const P1 = BigInt(sP1);
        
        // Ensure P2 is the larger one (Spine)
        const big = P2 > P1 ? P2 : P1;
        const small = P2 > P1 ? P1 : P2;
        
        const L = packRowMajor(big, small);
        document.getElementById('inpL').value = L.toString();
        renderTable();
    } catch(e) {
        alert("Invalid Factors");
    }
}

// Init
renderTable();

</script>
</body>
</html>
