<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Gnomon Volume Sum</title>
    <link href="https://fonts.googleapis.com/css2?family=Architects+Daughter&family=Roboto+Mono:wght@500&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-paper: #f9f3e3;
            --ink-black: #1a1a1a;
            --ink-red: #c0392b;
            --ink-blue: #2980b9;
            --font-hand: 'Architects Daughter', cursive;
            --font-mono: 'Roboto Mono', monospace;
        }

        body {
            margin: 0;
            background-color: var(--bg-paper);
            color: var(--ink-black);
            font-family: var(--font-hand);
            overflow: hidden;
            touch-action: none;
        }

        /* Paper Noise */
        body::before {
            content: "";
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background-image: url("data:image/svg+xml,%3Csvg width='100' height='100' viewBox='0 0 100 100' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.8' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100' height='100' filter='url(%23noise)' opacity='0.08'/%3E%3C/svg%3E");
            pointer-events: none;
            z-index: -1;
        }

        .controls {
            position: absolute;
            top: 20px; left: 20px;
            z-index: 10;
        }

        button {
            background: #fff;
            border: 2px solid var(--ink-black);
            font-family: var(--font-hand);
            font-size: 1rem;
            padding: 8px 16px;
            cursor: pointer;
            border-radius: 255px 15px 225px 15px/15px 225px 15px 255px;
            box-shadow: 2px 3px 0 rgba(0,0,0,0.1);
            transition: transform 0.1s;
        }
        button:active { transform: scale(0.95); }

        canvas { display: block; width: 100%; height: 100%; }

        /* Thematic Paper Note */
        .paper-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(44, 62, 80, 0.3);
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0; pointer-events: none;
            transition: opacity 0.2s;
            z-index: 100;
        }
        .paper-overlay.active { opacity: 1; pointer-events: auto; }

        .paper-card {
            width: 85%; max-width: 340px;
            background: #fff;
            border: 3px solid var(--ink-black);
            border-radius: 255px 15px 225px 15px/15px 225px 15px 255px;
            padding: 15px 20px;
            box-shadow: 10px 10px 0 rgba(0,0,0,0.1);
            transform: translateY(20px) scale(0.95);
            transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            text-align: center;
            position: relative;
        }
        .paper-overlay.active .paper-card { transform: translateY(0) scale(1); }

        .card-header {
            font-size: 1.1rem;
            border-bottom: 2px dashed var(--ink-red);
            padding-bottom: 8px; margin-bottom: 12px;
            color: var(--ink-red);
            font-weight: bold;
        }

        .card-value {
            font-family: var(--font-mono);
            font-size: 1.3rem;
            word-break: break-all;
            margin: 10px 0;
            color: var(--ink-black);
            background: #f4f4f4;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #ddd;
        }

        .card-meta {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            font-size: 0.85rem;
            color: var(--ink-blue);
            margin-bottom: 10px;
            text-align: left;
        }
        
        .close-x {
            position: absolute; top: 5px; right: 10px;
            font-size: 1.5rem; cursor: pointer; color: var(--ink-black);
            padding: 5px;
        }

    </style>
</head>
<body>

    <div class="controls">
        <button onclick="resetView()">Origin</button>
    </div>

    <canvas id="sketchCanvas"></canvas>

    <div class="paper-overlay" id="paperModal" onclick="closeCard()">
        <div class="paper-card" onclick="event.stopPropagation()">
            <div class="close-x" onclick="closeCard()">×</div>
            <div class="card-header">CELL INSPECTION</div>
            
            <div style="font-size:0.7rem; color:#888;">FULL VALUE</div>
            <div class="card-value" id="fullVal">0</div>
            
            <div class="card-meta">
                <div>
                    <span style="color:#888">PHASE ID</span><br>
                    <span id="fullAQR" style="word-break: break-all;">--</span>
                </div>
                <div>
                    <span style="color:#888">TAPE ID</span><br>
                    <span id="fullTape" style="word-break: break-all;">--</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('sketchCanvas');
        const ctx = canvas.getContext('2d');
        const paperModal = document.getElementById('paperModal');
        
        // Viewport State
        let scale = 110; 
        let offsetX = 0;
        let offsetY = 150;
        
        // Logical Selection
        let selectedIndices = null; 
        let selectedNodeData = null; 

        // Touch/Pan State
        let isDragging = false;
        let isPanning = false; 
        let lastX = 0, lastY = 0;
        
        // Zoom State
        let lastDist = 0;
        let pinchCenter = { x: 0, y: 0 };
        
        // Hit Cache
        let visibleNodes = [];
        let expandBtnHit = null; 

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            if(offsetX === 0) offsetX = canvas.width / 2;
            draw();
        }
        window.addEventListener('resize', resize);

        // --- Math & Truncation ---
        
        function smartTruncate(str, maxLen=8) {
            str = str.toString();
            if (str.length <= maxLen) return str;
            const front = 3; 
            const back = 3; 
            return str.substring(0, front) + ".." + str.substring(str.length - back);
        }

        function getNode(k, col) {
            const bk = BigInt(k);
            const root = (bk * 2n) + 1n;
            const spineSq = root * root;
            const stride = root * 2n;
            
            const absCol = BigInt(Math.abs(col));
            let val = spineSq - (absCol * stride);
            if (col < 0) val = -val;

            // Tape ID
            const tapeVal = (bk * bk) + bk + BigInt(col) + 1n;

            // IDs
            const r = val < 0n ? (-val % root) : (val % root); 
            const aqr = `${root}.${absCol}.${r}`;
            
            const A = root - absCol;
            const B = absCol;
            const ab = `${A}.${B}`;
            
            const tape = `${tapeVal}`;

            return { k, col, val, ab, aqr, tape };
        }

        // --- Drawing Helpers ---
        function drawSketchLine(x1, y1, x2, y2, color, width=2) {
            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.lineWidth = width;
            ctx.lineCap = 'round';
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.lineWidth = width * 0.6;
            ctx.moveTo(x1, y1);
            ctx.quadraticCurveTo((x1+x2)/2 + (Math.random()-0.5), (y1+y2)/2 + (Math.random()-0.5), x2, y2);
            ctx.stroke();
        }

        function drawSketchCircle(x, y, r, color) {
            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.lineWidth = 3;
            ctx.ellipse(x, y, r, r*0.95, 0.1, 0, Math.PI*2);
            ctx.stroke();
        }
        
        function drawSketchRect(x, y, w, h, color) {
            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.lineWidth = 2.5;
            ctx.rect(x, y, w, h);
            ctx.stroke();
            ctx.beginPath();
            ctx.lineWidth = 1;
            ctx.rect(x - 1, y - 1, w + 2, h + 2);
            ctx.stroke();
        }

        function drawRowFlag(x, y, k, size) {
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(x, y, size, size);
            ctx.fillStyle = '#fff';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.font = `bold ${size * 0.6}px 'Roboto Mono'`;
            ctx.fillText(k, x + size/2, y + size/2);
        }

        // --- Main Draw Loop ---
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            visibleNodes = [];
            expandBtnHit = null;

            const triH = scale * 0.9;
            const startRow = Math.max(0, Math.floor((-offsetY + 100) / triH));
            const endRow = startRow + Math.ceil(canvas.height / triH) + 2;

            // 1. Hypotenuse Borders
            const apexX = offsetX;
            const apexY = offsetY;
            const rightTrivialX = offsetX + (endRow * scale);
            const rightTrivialY = offsetY + (endRow * triH);
            const leftTrivialX = offsetX - (endRow * scale);
            const leftTrivialY = offsetY + (endRow * triH);

            drawSketchLine(apexX, apexY, rightTrivialX, rightTrivialY, '#1a1a1a', 3);
            drawSketchLine(apexX, apexY, leftTrivialX, leftTrivialY, '#1a1a1a', 3);

            // 2. Draw Nodes
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            for (let k = startRow; k <= endRow; k++) {
                const cy = offsetY + (k * triH);
                
                const rightLimit = Math.min(k, Math.floor((canvas.width - offsetX)/scale) + 2);
                for (let c = 0; c <= rightLimit; c++) {
                    const rx = offsetX + (c * scale);
                    if (rx > -scale) drawNode(k, c, cy);
                }
                const leftLimit = Math.min(k, Math.floor(offsetX/scale) + 2);
                for (let c = 1; c <= leftLimit; c++) {
                    const lx = offsetX - (c * scale);
                    if (lx < canvas.width + scale) drawNode(k, -c, cy);
                }
            }

            // 3. Selection HUD
            if (selectedIndices) {
                const k = selectedIndices.k;
                const c = selectedIndices.col;
                const sx = offsetX + (c * scale);
                const sy = offsetY + (k * triH);
                drawAnalysis(k, c, sx, sy);
            }
        }

        function drawNode(k, c, cy) {
            const cx = offsetX + (c * scale);
            const data = getNode(k, c);
            const r = scale * 0.45;

            visibleNodes.push({x: cx, y: cy, r: r, k: k, col: c, data: data});

            // Spine Highlight
            if (c === 0) {
                const boxSize = scale * 0.8;
                drawSketchRect(cx - boxSize/2, cy - boxSize/2, boxSize, boxSize, '#c0392b');
                const flagSize = scale * 0.25;
                drawRowFlag(cx + boxSize/2 - flagSize, cy - boxSize/2, k, flagSize);
            }

            // Truncation
            const displayVal = smartTruncate(data.val, 9);
            const displayAQR = smartTruncate(data.aqr, 8);
            const displayTape = smartTruncate(data.tape, 8);

            // 1. Value (Black)
            ctx.fillStyle = '#1a1a1a'; 
            ctx.font = `bold ${scale * 0.25}px 'Architects Daughter'`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(displayVal, cx, cy);

            // 2. Metadata (Blue) - Stacked Top Left
            ctx.fillStyle = '#2980b9';
            ctx.textAlign = 'left';
            ctx.font = `${scale * 0.12}px 'Architects Daughter'`;
            
            ctx.fillText(displayAQR, cx - (r*0.75), cy - (r*0.65));
            ctx.fillText(displayTape, cx - (r*0.75), cy - (r*0.45));

            // A.B (Bottom Center) - Black
            ctx.textAlign = 'center';
            ctx.fillStyle = '#1a1a1a';
            ctx.font = `${scale * 0.15}px 'Architects Daughter'`;
            ctx.fillText(data.ab, cx, cy + (r*0.6));
        }

        function drawAnalysis(k, col, x, y) {
            const nodeData = getNode(k, col);
            const triH = scale * 0.9;

            // 1. Red Circle
            drawSketchCircle(x, y, scale * 0.5, '#c0392b');

            // 2. Vertical Arm
            const startRow = Math.abs(col); 
            const topY = offsetY + (startRow * triH);
            drawSketchLine(x, y - (scale*0.5), x, topY, '#c0392b', 2);

            // 3. Horizontal Arm
            const leftX = offsetX + (-k * scale);
            const rightX = offsetX + (k * scale);
            drawSketchLine(leftX, y, x - (scale*0.5), y, '#c0392b', 2);
            drawSketchLine(x + (scale*0.5), y, rightX, y, '#c0392b', 2);

            // 4. Sums
            // Col Sum
            let colSum = 0n;
            for (let i = Math.abs(col); i <= k; i++) {
                colSum += getNode(i, col).val;
            }

            // Row Sum (Positive side only per visual logic)
            let rowSum = 0n;
            for (let j = 0; j <= k; j++) {
                rowSum += getNode(k, j).val;
            }

            // Gnomon Sum
            const gnomonSum = colSum + rowSum - nodeData.val;
            
            // VOLUME SUM (Optimized)
            // Volume = Sum of all Row Sums from 0 to k
            // Formula for Row i Sum = (i+1)^2 * (2i+1)
            let volSum = 0n;
            for(let i=0; i<=k; i++) {
                // For speed in JS loop we can use the formula directly
                // Sum = (i+1)^2 * (2i+1)
                const bi = BigInt(i);
                const rSum = (bi + 1n)**2n * (2n * bi + 1n);
                volSum += rSum;
            }

            // 5. Display Text (Upper Right)
            ctx.textAlign = 'left';
            ctx.fillStyle = '#c0392b';
            ctx.font = `bold ${scale * 0.2}px 'Architects Daughter'`;
            
            const tx = x + (scale * 0.6);
            const ty = y - (scale * 0.7);
            const lh = scale * 0.25;

            ctx.fillText(`Col Σ: ${smartTruncate(colSum, 8)}`, tx, ty);
            ctx.fillText(`Row Σ: ${smartTruncate(rowSum, 8)}`, tx, ty + lh);
            ctx.fillText(`Gnomon Σ: ${smartTruncate(gnomonSum, 8)}`, tx, ty + lh*2);
            ctx.fillText(`Vol Σ: ${smartTruncate(volSum, 8)}`, tx, ty + lh*3);

            // 6. Inspect Button
            const btnX = x + (scale * 0.65);
            const btnY = y + (scale * 0.3);
            const btnSize = scale * 0.25;

            ctx.fillStyle = '#fff';
            ctx.strokeStyle = '#c0392b';
            ctx.lineWidth = 2;
            ctx.fillRect(btnX, btnY, btnSize, btnSize);
            ctx.strokeRect(btnX, btnY, btnSize, btnSize);

            ctx.beginPath();
            ctx.moveTo(btnX + btnSize*0.2, btnY + btnSize*0.5);
            ctx.lineTo(btnX + btnSize*0.8, btnY + btnSize*0.5);
            ctx.moveTo(btnX + btnSize*0.5, btnY + btnSize*0.2);
            ctx.lineTo(btnX + btnSize*0.5, btnY + btnSize*0.8);
            ctx.stroke();

            expandBtnHit = { x: btnX, y: btnY, w: btnSize, h: btnSize, data: nodeData };
        }

        // --- Interaction ---

        function handleTap(x, y) {
            if (expandBtnHit) {
                if (x >= expandBtnHit.x && x <= expandBtnHit.x + expandBtnHit.w &&
                    y >= expandBtnHit.y && y <= expandBtnHit.y + expandBtnHit.h) {
                    showCard(expandBtnHit.data);
                    return;
                }
            }

            let hit = false;
            for(let n of visibleNodes) {
                const dx = x - n.x;
                const dy = y - n.y;
                if(dx*dx + dy*dy < n.r*n.r) {
                    selectedIndices = { k: n.k, col: n.col };
                    selectedNodeData = n.data;
                    hit = true;
                    draw();
                    return;
                }
            }

            if (!hit && selectedIndices) {
                selectedIndices = null;
                selectedNodeData = null;
                draw();
            }
        }

        function showCard(d) {
            document.getElementById('fullVal').innerText = d.val.toString();
            document.getElementById('fullAQR').innerText = d.aqr;
            document.getElementById('fullTape').innerText = d.tape;
            paperModal.classList.add('active');
        }

        function closeCard() {
            paperModal.classList.remove('active');
        }

        // --- Events ---
        canvas.addEventListener('touchstart', e => {
            if(e.touches.length === 1) {
                isDragging = true; isPanning = false; 
                lastX = e.touches[0].clientX; 
                lastY = e.touches[0].clientY;
            } else if (e.touches.length === 2) {
                isDragging = false;
                const t1 = e.touches[0];
                const t2 = e.touches[1];
                lastDist = Math.hypot(t1.clientX - t2.clientX, t1.clientY - t2.clientY);
                pinchCenter = { x: (t1.clientX + t2.clientX) / 2, y: (t1.clientY + t2.clientY) / 2 };
            }
        }, {passive:false});

        canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            if(e.touches.length === 1 && isDragging) {
                const cx = e.touches[0].clientX; 
                const cy = e.touches[0].clientY;
                const dx = cx - lastX;
                const dy = cy - lastY;
                
                if (Math.hypot(dx, dy) > 2) isPanning = true;
                
                if (isPanning) { 
                    offsetX += dx; 
                    offsetY += dy; 
                    draw(); 
                }
                lastX = cx; 
                lastY = cy;
            } else if (e.touches.length === 2) {
                const t1 = e.touches[0];
                const t2 = e.touches[1];
                const newDist = Math.hypot(t1.clientX - t2.clientX, t1.clientY - t2.clientY);
                const factor = newDist / lastDist;
                const newScale = scale * factor;
                
                if (newScale >= 40 && newScale <= 250) {
                    const worldX = (pinchCenter.x - offsetX) / scale;
                    const worldY = (pinchCenter.y - offsetY) / scale;
                    offsetX = pinchCenter.x - (worldX * newScale);
                    offsetY = pinchCenter.y - (worldY * newScale);
                    scale = newScale;
                }
                lastDist = newDist;
                draw();
            }
        }, {passive:false});

        canvas.addEventListener('touchend', e => {
            if (!isPanning && isDragging && e.touches.length === 0) {
                handleTap(lastX, lastY);
            }
            isDragging = false;
        });

        canvas.addEventListener('mousedown', e => { isDragging=true; isPanning=false; lastX=e.clientX; lastY=e.clientY; });
        canvas.addEventListener('mousemove', e => { 
            if(isDragging) { 
                if(Math.hypot(e.clientX-lastX, e.clientY-lastY)>2) isPanning=true; 
                if(isPanning){ offsetX+=e.clientX-lastX; offsetY+=e.clientY-lastY; draw();} 
                lastX=e.clientX; lastY=e.clientY;
            } 
        });
        canvas.addEventListener('mouseup', e => { if(!isPanning && isDragging) handleTap(e.clientX, e.clientY); isDragging=false; });
        canvas.addEventListener('wheel', e => {
            e.preventDefault();
            const factor = e.deltaY > 0 ? 0.9 : 1.1;
            const newScale = scale * factor;
            if(newScale >= 40 && newScale <= 250) {
                const worldX = (e.clientX - offsetX) / scale;
                const worldY = (e.clientY - offsetY) / scale;
                offsetX = e.clientX - (worldX * newScale);
                offsetY = e.clientY - (worldY * newScale);
                scale = newScale;
                draw();
            }
        });

        function resetView() {
            scale = 110; offsetX = canvas.width/2; offsetY = 150;
            selectedIndices = null; draw();
        }

        resize();

    </script>
</body>
</html>
