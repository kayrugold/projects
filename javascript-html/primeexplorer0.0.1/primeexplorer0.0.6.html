<!doctype html>
<html lang="en">
<head>
 <meta charset="utf-8"/>
 <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
 <title>Prime Explorer 0.0.6</title>
 <script src="https://unpkg.com/big-integer@1.6.48/BigInteger.min.js"></script>
 <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
 <style>
   body {
     margin: 0;
     overflow: hidden;
     touch-action: none; /* Prevent browser gestures */
     font-family: 'Inter', sans-serif;
     background-color: #f0f0f0;
   }
   canvas {
     display: block;
     background: #fff;
     touch-action: none;
     transition: background-color 0.5s ease; /* Smooth color transition */
   }
   #info {
     position: absolute;
     top: 10px;
     left: 10px;
     background: rgba(255, 255, 255, 0.9);
     padding: 10px;
     border: 1px solid #ccc;
     font-family: Arial, sans-serif;
     font-size: 14px;
     border-radius: 8px;
     box-shadow: 0 2px 10px rgba(0,0,0,0.1);
     max-width: 280px;
   }
   .info-group {
     display: flex;
     align-items: center;
     margin-bottom: 5px;
   }
   .info-group label {
     margin-right: 5px;
     white-space: nowrap;
   }
   .info-input {
     width: 100%;
     padding: 5px;
     border: 1px solid #ccc;
     border-radius: 4px;
   }
   #status {
     margin-top: 5px;
     color: gray;
     font-style: italic;
   }
   hr {
     margin: 10px 0;
     border: 0;
     border-top: 1px solid #ddd;
   }
   .red-text { color: #d9534f; }
   .green-text { color: #5cb85c; font-weight: bold; }
   .yellow-text { color: #f0ad4e; }
   .gray-text { color:#666; }
   .badge { padding:1px 6px; border-radius:10px; border:1px solid; font-size:12px; margin-left:6px; }
   #congruenceResults span {
     font-weight: bold;
   }
 </style>
</head>
<body>
<canvas id="gridCanvas"></canvas>
<div id="info">
 <div class="info-group">
   <label for="valueInput">Number (N):</label>
   <input type="text" id="valueInput" class="info-input" value="35" inputmode="text">
 </div>
 <div class="info-group">
   <label><input type="checkbox" id="primeToggle" checked> Prime check (≤ 1e12)</label>
 </div>
 <div id="status"></div>
 <hr>
 <!-- Main Factorization Controls -->
 <div id="factorizationControls">
    <span id="labelTotalBlocks">Total Blocks:</span> <span id="totalBlocksDisplay"></span><br>
    <span id="widthLabel">Width (A):</span> <span id="width"></span><span id="widthPrime" class="badge gray-text"></span><br>
    <span id="heightLabel">Height (B):</span> <span id="height"></span><span id="heightPrime" class="badge gray-text"></span><br>
    <span id="labelBlocksRemaining">Blocks Remaining:</span> <span id="blocks"></span><br>
    <span id="labelModRemainder" style="display:none;">Mod Remainder:</span> <span id="modRemainder" style="display:none;"></span><br>
    Diagonal Slope: <span id="slope"></span><br>
    Diagonal Angle: <span id="angle"></span>°<br>
    Center Point: <span id="centerPoint"></span>
 </div>
 <hr>
 <!-- Congruence of Squares Controls -->
 <div class="info-group">
   <label><input type="checkbox" id="congruenceToggle"> Congruence of Squares</label>
 </div>
 <div id="congruenceControls" style="display:none;">
   <div class="info-group">
     <label for="xValueInput">Value for x:</label>
     <input type="text" id="xValueInput" class="info-input" value="">
   </div>
   <div id="congruenceResults" style="margin-top: 8px;">
     N: <span id="congruenceN"></span><br>
     x² mod N: <span id="x2ModN"></span><br>
     y = √(x² mod N): <span id="yValue"></span><br>
     gcd(x-y, N): <span id="factor1"></span><br>
     gcd(x+y, N): <span id="factor2"></span>
   </div>
 </div>
</div>

<script>
// --- Canvas & DOM Setup ---
const canvas = document.getElementById("gridCanvas");
const ctx = canvas.getContext("2d");
const body = document.body;

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const valueInput = document.getElementById('valueInput');
const statusDiv = document.getElementById('status');
const totalBlocksDisplay = document.getElementById('totalBlocksDisplay');
const infoWidth = document.getElementById('width');
const infoHeight = document.getElementById('height');
const infoBlocks = document.getElementById('blocks');
const infoModRemainder = document.getElementById('modRemainder');
const labelTotalBlocks = document.getElementById('labelTotalBlocks');
const labelBlocksRemaining = document.getElementById('labelBlocksRemaining');
const labelModRemainder = document.getElementById('labelModRemainder');
const infoSlope = document.getElementById('slope');
const infoAngle = document.getElementById('angle');
const infoCenterPoint = document.getElementById('centerPoint');
const primeToggleEl = document.getElementById('primeToggle');
const widthLabel = document.getElementById('widthLabel');
const heightLabel = document.getElementById('heightLabel');

// --- State Variables ---
let gridSize = 20;
let scale = 1;
let offsetX = 0, offsetY = 0;
let lastPan = null;
let isCongruenceMode = false;
let totalBlocks = bigInt(35);
let originalInput = bigInt(35);
let totalBase = null, totalExponent = null, totalMultiplication = null, totalAddition = null;
let isBigNumberMode = false;
let rect = {x: 2, y: 2, w: 0, h: 0};
let exactWidth = bigInt(0);
let exactHeight = bigInt(0);
let handles = [];
let xSquare = { x: 2, y: 2, size: 50 };
let yValue = bigInt.zero;
let ySquareSize = 0;
let xSquareHandle = { x: 0, y: 0 };
let activeTool = null;
let activeHandleName = null;
let lastTouchDist = 0;
const logarithmicThreshold = 75;
let fireworks = [];
let isSuccessState = false;

// --- Lightweight prime check (cached, only when value changes) ---
const PRIME_CHECK_LIMIT = bigInt("1000000000000"); // 1e12
const SMALL_PRIMES = [2,3,5,7,11,13,17,19,23,29,31];
const MR_BASES = [2,3,5,7,11];
const primeCache = new Map();
let lastWidthStr  = "";
let lastHeightStr = "";

function isTooLargeForPrimeCheck(n) {
 return n.greater(PRIME_CHECK_LIMIT);
}

function trialDivisionSmall(n) {
 for (const p of SMALL_PRIMES) {
   const bp = bigInt(p);
   if (n.equals(bp)) return true;
   if (n.mod(bp).isZero()) return false;
 }
 return null; // inconclusive
}

function millerRabin(n) {
 if (n.lesser(2)) return false;
 if (n.equals(2)) return true;
 if (n.isEven()) return false;
 let d = n.minus(1);
 let s = 0;
 while (d.isEven()) { d = d.divide(2); s++; }
 for (const a of MR_BASES) {
   const A = bigInt(a);
   if (A.greaterOrEquals(n)) continue;
   let x = A.modPow(d, n);
   if (x.equals(1) || x.equals(n.minus(1))) continue;
   let cont = false;
   for (let r = 1; r < s; r++) {
     x = x.multiply(x).mod(n);
     if (x.equals(n.minus(1))) { cont = true; break; }
   }
   if (!cont) return false;
 }
 return true;
}

function primeStatus(n) {
 const key = n.toString();
 if (primeCache.has(key)) return primeCache.get(key);
 if (n.lesser(2)) { primeCache.set(key, "composite"); return "composite"; }
 if (isTooLargeForPrimeCheck(n)) { primeCache.set(key, "too-large"); return "too-large"; }
 const td = trialDivisionSmall(n);
 let res;
 if (td === true) res = "prime";
 else if (td === false) res = "composite";
 else res = millerRabin(n) ? "prime" : "composite";
 primeCache.set(key, res);
 return res;
}

function setPrimeBadge(el, status) {
 if (!el) return;
 if (status === "prime")   { el.textContent = "Prime";      el.className = "badge green-text"; }
 else if (status === "composite") { el.textContent = "Composite";  el.className = "badge red-text"; }
 else { el.textContent = "Too large"; el.className = "badge gray-text"; }
}


// --- Main App Logic ---
function parseInput(inputString) {
    const sanitizedInput = inputString.replace(/\s/g, '');
    const prothPattern = /^(\d+)\*2\^(\d+)\+1$/;
    const mersennePattern = /^2\^(\d+)-1$/;
    const powerPattern = /^(\d+)\^(.+?)(?:\+(\d+))?$/;
    // --- START FIX ---
    // New regex to handle scientific notation like 1e9+19
    const scientificPattern = /^(\d*\.?\d*)e(\d+)(?:\+(\d+))?$/i;
    // --- END FIX ---
    let match;

    // --- START FIX ---
    // Check for scientific notation first
    match = sanitizedInput.match(scientificPattern);
    if (match) {
        // Coefficient before 'e', defaults to 1
        const multiplication = match[1] && match[1] !== '' ? bigInt(match[1]) : bigInt(1);
        const exponent = bigInt(match[2]);
        const addition = match[3] ? bigInt(match[3]) : bigInt(0);

        // Decide whether to treat as a big number based on the exponent
        if (exponent.greaterOrEquals(logarithmicThreshold)) {
            return { type: 'bigNumber', base: bigInt(10), exponent: exponent, multiplication: multiplication, addition: addition };
        } else {
            const total = multiplication.multiply(bigInt(10).pow(exponent)).plus(addition);
            return { type: 'number', total: total };
        }
    }
    // --- END FIX ---

    match = sanitizedInput.match(prothPattern);
    if (match) {
        const k = bigInt(match[1]), n = bigInt(match[2]);
        return n.greaterOrEquals(logarithmicThreshold) ?
            { type: 'bigNumber', base: bigInt(2), exponent: n, multiplication: k, addition: bigInt(1) } :
            { type: 'number', total: k.multiply(bigInt(2).pow(n)).plus(1) };
    }
    match = sanitizedInput.match(mersennePattern);
    if (match) {
        const exponent = bigInt(match[1]);
        return exponent.greaterOrEquals(logarithmicThreshold) ?
            { type: 'bigNumber', base: bigInt(2), exponent: exponent, multiplication: bigInt(1), addition: bigInt(-1) } :
            { type: 'number', total: bigInt(2).pow(exponent).minus(1) };
    }
    match = sanitizedInput.match(powerPattern);
    if (match) {
        const base = bigInt(match[1]), exponentStr = match[2], addition = match[3] ? bigInt(match[3]) : bigInt(0);
        // Exponent could also be in scientific notation, handle that.
        const exponent = exponentStr.toLowerCase().includes('e') ? bigInt(Number(exponentStr)) : bigInt(exponentStr);
        return exponent.greaterOrEquals(logarithmicThreshold) ?
            { type: 'bigNumber', base, exponent, multiplication: bigInt(1), addition } :
            { type: 'number', total: base.pow(exponent).plus(addition) };
    }
    return { type: 'number', total: bigInt(sanitizedInput) };
}


function performCalculation() {
 statusDiv.innerText = "Calculating...";
 try {
   const result = parseInput(valueInput.value);
   isBigNumberMode = (result.type === 'bigNumber');

   if (isBigNumberMode) {
     originalInput = bigInt(0);
     totalBase = result.base; totalExponent = result.exponent;
     totalMultiplication = result.multiplication; totalAddition = result.addition;
     totalBlocks = null;
     const side = totalExponent;
     exactWidth = side; exactHeight = side;
     rect.w = side.toJSNumber(); rect.h = side.toJSNumber();
   } else {
     originalInput = result.total;
     totalBase = null; totalExponent = null; totalMultiplication = null; totalAddition = null;
     totalBlocks = result.total;
     if (totalBlocks.isNegative()) { statusDiv.innerText = "Error: Input must be non-negative."; return; }
     const side = customSqrt(totalBlocks);
     exactWidth = side; exactHeight = side;
     rect.w = side.toJSNumber(); rect.h = side.toJSNumber();
   }
   
   document.getElementById('xValueInput').value = customSqrt(originalInput).plus(1).toString();
   updateCongruence();
   zoomToFit(isCongruenceMode ? xSquare : rect);
   updateHandles();
   statusDiv.innerText = "Ready.";
 } catch (error) {
   console.error("Calculation Error:", error);
   statusDiv.innerText = "Error: Invalid input format.";
 }
}

function updateCongruence() {
    if (isBigNumberMode || originalInput.isZero() || originalInput.isUnit()) {
        document.getElementById('congruenceControls').style.color = '#aaa';
        return;
    }
    document.getElementById('congruenceControls').style.color = 'inherit';
    const N = originalInput;
    let x;
    try {
        x = bigInt(document.getElementById('xValueInput').value);
        if(x.isZero()) return;
    } catch (e) { return; }
    
    if (!isCongruenceMode) { xSquare.size = x.toJSNumber(); }
    const x2 = x.square();
    const x2ModN = x2.mod(N);
    yValue = customSqrt(x2ModN);
    let factor1Str = "N/A", factor2Str = "N/A", yStr = "Not a perfect square";
    let factor1Class = '', factor2Class = '';
    ySquareSize = 0;
    if (yValue.square().equals(x2ModN)) {
        ySquareSize = yValue.toJSNumber();
        yStr = formatNumberWithCommas(yValue);
        const xMinusY = x.minus(yValue);
        const xPlusY = x.plus(yValue);
        if (x.equals(yValue) || x.mod(N).equals(yValue) || x.plus(yValue).mod(N).isZero()) {
            factor1Str = "Trivial"; factor2Str = "Trivial";
        } else {
            const f1 = bigInt.gcd(xMinusY, N);
            const f2 = bigInt.gcd(xPlusY, N);
            factor1Str = formatNumberWithCommas(f1);
            factor2Str = formatNumberWithCommas(f2);
            if (!f1.isUnit() && !f1.equals(N)) { factor1Class = 'green-text'; }
            if (!f2.isUnit() && !f2.equals(N)) { factor2Class = 'green-text'; }
        }
    }
    document.getElementById('congruenceN').innerText = formatNumberWithCommas(N);
    document.getElementById('x2ModN').innerText = formatNumberWithCommas(x2ModN);
    document.getElementById('yValue').innerText = yStr;
    document.getElementById('factor1').innerText = factor1Str;
    document.getElementById('factor2').innerText = factor2Str;
    document.getElementById('factor1').className = factor1Class;
    document.getElementById('factor2').className = factor2Class;
}

// --- Drawing & Visualization ---
function draw() {
 ctx.clearRect(0, 0, canvas.width, canvas.height);
 drawFireworks();
 ctx.save();
 ctx.translate(offsetX, offsetY);
 ctx.scale(scale, scale);
 drawGridLines();
 if (isCongruenceMode) { drawCongruenceVisualization(); } else { drawFactorizationVisualization(); }
 ctx.restore();
 updateInfoPanel();
 requestAnimationFrame(draw);
}

function drawGridLines() {
 const minX = -offsetX / scale / gridSize, maxX = (canvas.width - offsetX) / scale / gridSize;
 const minY = -offsetY / scale / gridSize, maxY = (canvas.height - offsetY) / scale / gridSize;
 ctx.strokeStyle = "#ddd"; ctx.lineWidth = 1 / scale;
 const isLog = isBigNumberMode && totalExponent && totalExponent.greaterOrEquals(logarithmicThreshold);
 const scaleType = isLog ? d3.scaleLog() : d3.scaleLinear();
 const xScale = scaleType.copy().domain([Math.max(1, minX), maxX]).range([Math.max(1, minX), maxX]);
 const yScale = scaleType.copy().domain([Math.max(1, minY), maxY]).range([Math.max(1, minY), maxY]);
 xScale.ticks(20).forEach(tick => { ctx.beginPath(); ctx.moveTo(tick * gridSize, minY * gridSize); ctx.lineTo(tick * gridSize, maxY * gridSize); ctx.stroke(); });
 yScale.ticks(20).forEach(tick => { ctx.beginPath(); ctx.moveTo(minX * gridSize, tick * gridSize); ctx.lineTo(maxX * gridSize, tick * gridSize); ctx.stroke(); });
}

function drawFactorizationVisualization() {
    ctx.strokeStyle = "blue"; ctx.lineWidth = 2/scale;
    ctx.strokeRect(rect.x * gridSize, rect.y * gridSize, rect.w * gridSize, rect.h * gridSize);
    ctx.strokeStyle = "red"; ctx.beginPath(); ctx.moveTo(rect.x * gridSize, rect.y * gridSize); ctx.lineTo((rect.x + rect.w) * gridSize, (rect.y + rect.h) * gridSize); ctx.stroke();
    ctx.strokeStyle = "green"; ctx.beginPath(); ctx.moveTo((rect.x + rect.w) * gridSize, rect.y * gridSize); ctx.lineTo(rect.x * gridSize, (rect.y + rect.h) * gridSize); ctx.stroke();
    
    if ((!isBigNumberMode && totalBlocks && totalBlocks.greater(0)) || (isBigNumberMode && totalExponent)) {
       let side;
       if (isBigNumberMode) {
           side = totalExponent.divide(2).toJSNumber();
       } else {
           side = customSqrt(totalBlocks).toJSNumber();
       }
       
       ctx.strokeStyle = "yellow";
       ctx.lineWidth = 2 / scale;
       ctx.setLineDash([10 / scale, 10 / scale]);
       ctx.strokeRect(rect.x * gridSize, rect.y * gridSize, side * gridSize, side * gridSize);
       ctx.setLineDash([]);
    }
    
    let handleSize = Math.max(10, 10/scale);
    for (let h of handles) {
      ctx.fillStyle = (activeTool === 'handle' && activeHandleName === h.name) ? "blue" : "orange";
      ctx.fillRect(h.x * gridSize - handleSize/2, h.y * gridSize - handleSize/2, handleSize, handleSize);
    }
}

function drawCongruenceVisualization() {
    if (ySquareSize > 0) {
        ctx.fillStyle = "rgba(92, 184, 92, 0.5)"; ctx.strokeStyle = "green"; ctx.lineWidth = 2/scale;
        ctx.fillRect(xSquare.x * gridSize, xSquare.y * gridSize, ySquareSize * gridSize, ySquareSize * gridSize);
        ctx.strokeRect(xSquare.x * gridSize, xSquare.y * gridSize, ySquareSize * gridSize, ySquareSize * gridSize);
        ctx.fillStyle = "green";
        ctx.font = `${14 / scale}px Arial`;
        ctx.fillText(`y = ${formatNumberWithCommas(yValue)}`, (xSquare.x + ySquareSize) * gridSize + 5/scale, xSquare.y * gridSize + 15/scale);
    }
    ctx.fillStyle = "rgba(2, 117, 216, 0.3)"; ctx.strokeStyle = "blue"; ctx.lineWidth = 2/scale;
    ctx.fillRect(xSquare.x * gridSize, xSquare.y * gridSize, xSquare.size * gridSize, xSquare.size * gridSize);
    ctx.strokeRect(xSquare.x * gridSize, xSquare.y * gridSize, xSquare.size * gridSize, xSquare.size * gridSize);
    ctx.fillStyle = "blue";
    ctx.font = `${14 / scale}px Arial`;
    ctx.fillText(`x = ${document.getElementById('xValueInput').value}`, (xSquare.x + xSquare.size) * gridSize + 5/scale, xSquare.y * gridSize + 15/scale);
    let handleSize = Math.max(10, 10/scale);
    ctx.fillStyle = (activeTool === 'xHandle') ? "blue" : "orange";
    ctx.fillRect(xSquareHandle.x * gridSize - handleSize/2, xSquareHandle.y * gridSize - handleSize/2, handleSize, handleSize);
}


// --- Event Handlers & Controls ---

// MOUSE CONTROLS
function mousedown(e) {
 let mx = (e.offsetX - offsetX) / scale, my = (e.offsetY - offsetY) / scale;
 const handleSize = Math.max(15, 15/scale);
 if (isCongruenceMode) {
    if (dist(mx, my, xSquareHandle.x * gridSize, xSquareHandle.y * gridSize) < handleSize) { activeTool = 'xHandle'; return; }
 } else {
    for (let h of handles) {
        if (dist(mx, my, h.x * gridSize, h.y * gridSize) < handleSize) { activeTool = 'handle'; activeHandleName = h.name; return; }
    }
 }
 activeTool = 'pan';
 lastPan = {x: e.clientX, y: e.clientY};
}

function mousemove(e) {
 if (!activeTool) return;
 let mx = (e.offsetX - offsetX) / scale / gridSize;
 let my = (e.offsetY - offsetY) / scale / gridSize;

 if (activeTool === 'handle') {
    handleResize(mx, my);
    autoPanOnEdgeDrag(e.clientX, e.clientY);
 } else if (activeTool === 'xHandle') {
    const newSize = Math.max(1, Math.round(mx - xSquare.x));
    xSquare.size = newSize;
    document.getElementById('xValueInput').value = newSize;
    updateCongruence();
    updateHandles();
    autoPanOnEdgeDrag(e.clientX, e.clientY);
 } else if (activeTool === 'pan' && lastPan) {
    offsetX += e.clientX - lastPan.x;
    offsetY += e.clientY - lastPan.y;
    lastPan = {x: e.clientX, y: e.clientY};
 }
}

canvas.addEventListener("mousedown", mousedown);
canvas.addEventListener("mousemove", mousemove);
canvas.addEventListener("mouseup", () => { activeTool = null; activeHandleName = null; lastPan = null; });
canvas.addEventListener("mouseleave", () => { activeTool = null; activeHandleName = null; lastPan = null; });
canvas.addEventListener('wheel', e => {
    e.preventDefault();
    const factor = Math.pow(1.001, -e.deltaY);
    offsetX = e.offsetX - (e.offsetX - offsetX) * factor;
    offsetY = e.offsetY - (e.offsetY - offsetY) * factor;
    scale *= factor;
}, { passive: false });


// TOUCH CONTROLS
function touchstart(e) {
    e.preventDefault();
    const touches = e.touches;
    if (touches.length === 1) {
        let mx = (touches[0].clientX - offsetX) / scale, my = (touches[0].clientY - offsetY) / scale;
        const handleSize = Math.max(25, 25/scale);
        if (isCongruenceMode) {
            if (dist(mx, my, xSquareHandle.x * gridSize, xSquareHandle.y * gridSize) < handleSize) { activeTool = 'xHandle'; return; }
        } else {
            for (let h of handles) {
                if (dist(mx, my, h.x * gridSize, h.y * gridSize) < handleSize) { activeTool = 'handle'; activeHandleName = h.name; return; }
            }
        }
        activeTool = 'pan';
        lastPan = { x: touches[0].clientX, y: touches[0].clientY };
    } else if (touches.length === 2) {
        activeTool = 'zoom';
        lastTouchDist = dist(touches[0].clientX, touches[0].clientY, touches[1].clientX, touches[1].clientY);
        lastPan = { x: (touches[0].clientX + touches[1].clientX) / 2, y: (touches[0].clientY + touches[1].clientY) / 2 };
    }
}

function touchmove(e) {
    e.preventDefault();
    if (!activeTool) return;
    const touches = e.touches;
    if (touches.length === 1) {
        const touch = touches[0];
        if (activeTool === 'pan') {
            offsetX += touch.clientX - lastPan.x;
            offsetY += touch.clientY - lastPan.y;
            lastPan = { x: touch.clientX, y: touch.clientY };
        } else if (activeTool === 'handle' || activeTool === 'xHandle') {
            let mx = (touch.clientX - offsetX) / scale / gridSize;
            let my = (touch.clientY - offsetY) / scale / gridSize;
            if (activeTool === 'handle') { handleResize(mx, my); }
            else {
                const newSize = Math.max(1, Math.round(mx - xSquare.x));
                xSquare.size = newSize;
                document.getElementById('xValueInput').value = newSize;
                updateCongruence();
                updateHandles();
            }
            autoPanOnEdgeDrag(touch.clientX, touch.clientY);
        }
    } else if (activeTool === 'zoom' && touches.length === 2) {
        let newDist = dist(touches[0].clientX, touches[0].clientY, touches[1].clientX, touches[1].clientY);
        let factor = newDist / lastTouchDist;
        let mid = { x: (touches[0].clientX + touches[1].clientX) / 2, y: (touches[0].clientY + touches[1].clientY) / 2 };
        offsetX += mid.x - lastPan.x;
        offsetY += mid.y - lastPan.y;
        offsetX = mid.x - ((mid.x - offsetX) * factor);
        offsetY = mid.y - ((mid.y - offsetY) * factor);
        scale *= factor;
        lastTouchDist = newDist;
        lastPan = mid;
    }
}

function touchend(e) {
    e.preventDefault();
    if (e.touches.length < 2) lastTouchDist = 0;
    if (e.touches.length === 0) { activeTool = null; activeHandleName = null; }
}

canvas.addEventListener("touchstart", touchstart, { passive: false });
canvas.addEventListener("touchmove", touchmove, { passive: false });
canvas.addEventListener("touchend", touchend, { passive: false });
canvas.addEventListener("touchcancel", touchend, { passive: false });

// --- UTILITY FUNCTIONS ---
function autoPanOnEdgeDrag(clientX, clientY) {
    const panThreshold = canvas.width * 0.10; // 10% from the edge
    const panSpeedFactor = 1.5;
    if (clientX < panThreshold) { offsetX += (panThreshold - clientX) * panSpeedFactor; }
    else if (clientX > canvas.width - panThreshold) { offsetX -= (clientX - (canvas.width - panThreshold)) * panSpeedFactor; }
    if (clientY < panThreshold) { offsetY += (panThreshold - clientY) * panSpeedFactor; }
    else if (clientY > canvas.height - panThreshold) { offsetY -= (clientY - (canvas.height - panThreshold)) * panSpeedFactor; }
}

function handleResize(mx, my) {
    const right = rect.x + rect.w, bottom = rect.y + rect.h;
    switch (activeHandleName) {
        case "tl": rect.x = mx; rect.y = my; rect.w = right - rect.x; rect.h = bottom - rect.y; break;
        case "tr": rect.y = my; rect.w = mx - rect.x; rect.h = bottom - rect.y; break;
        case "bl": rect.x = mx; rect.w = right - rect.x; rect.h = my - rect.y; break;
        case "br": rect.w = mx - rect.x; rect.h = my - rect.y; break;
    }
    let swappedX = false, swappedY = false;
    if (rect.w < 0) { rect.x += rect.w; rect.w *= -1; swappedX = true; }
    if (rect.h < 0) { rect.y += rect.h; rect.h *= -1; swappedY = true; }
    if (swappedX) activeHandleName = activeHandleName.includes('l') ? activeHandleName.replace('l', 'r') : activeHandleName.replace('r', 'l');
    if (swappedY) activeHandleName = activeHandleName.includes('t') ? activeHandleName.replace('t', 'b') : activeHandleName.replace('b', 't');
    rect.w = Math.max(1, Math.round(rect.w)); rect.h = Math.max(1, Math.round(rect.h));
    rect.x = Math.round(rect.x); rect.y = Math.round(rect.y);
    exactWidth = bigInt(rect.w); exactHeight = bigInt(rect.h);
    updateHandles();
}

window.addEventListener('resize', () => { canvas.width = window.innerWidth; canvas.height = window.innerHeight; });
valueInput.addEventListener('keyup', e => { if (e.key === 'Enter') performCalculation(); });
document.getElementById('xValueInput').addEventListener('input', () => {
    try {
        const val = bigInt(document.getElementById('xValueInput').value);
        if (val.geq(0)) { xSquare.size = val.toJSNumber(); updateCongruence(); }
    } catch(e) {/* ignore */}
});
document.getElementById('congruenceToggle').addEventListener('change', (e) => {
    isCongruenceMode = e.target.checked;
    document.getElementById('congruenceControls').style.display = isCongruenceMode ? 'block' : 'none';
    document.getElementById('factorizationControls').style.display = isCongruenceMode ? 'none' : 'block';
    if (isCongruenceMode) {
        try {
            const xVal = bigInt(document.getElementById('xValueInput').value);
            if (xVal.geq(0)) { xSquare.size = xVal.toJSNumber(); }
        } catch(err) { /* ignore invalid input */ }
        updateCongruence();
        updateHandles();
        zoomToFit(xSquare);
    }
    else {
        updateHandles();
        zoomToFit(rect);
    }
});

function zoomToFit(target) {
    const padding = 1.5;
    const targetW = 'size' in target ? target.size : target.w, targetH = 'size' in target ? target.size : target.h;
    if(targetW === 0 || targetH === 0) return;
    const scaleX = canvas.width / (targetW * gridSize * padding), scaleY = canvas.height / (targetH * gridSize * padding);
    scale = Math.min(scaleX, scaleY, 2);
    const cX = target.x + targetW / 2, cY = target.y + targetH / 2;
    offsetX = (canvas.width / 2) - (cX * gridSize * scale);
    offsetY = (canvas.height / 2) - (cY * gridSize * scale);
}

function updateHandles() {
 if (isCongruenceMode) {
    xSquareHandle = { x: xSquare.x + xSquare.size, y: xSquare.y + xSquare.size };
 } else {
    handles = [
        {x: rect.x, y: rect.y, name: "tl"}, {x: rect.x + rect.w, y: rect.y, name: "tr"},
        {x: rect.x, y: rect.y + rect.h, name: "bl"}, {x: rect.x + rect.w, y: rect.y + rect.h, name: "br"}
    ];
 }
}

function updateInfoPanel() {
    if (isCongruenceMode) return;
    const blocksUsed = exactWidth.times(exactHeight);
    let isWDiv = false, isHDiv = false;

    if (!isBigNumberMode) {
        isWDiv = exactWidth.greater(0) && originalInput.mod(exactWidth).isZero();
        isHDiv = exactHeight.greater(0) && originalInput.mod(exactHeight).isZero();
    } else {
        if (totalBase && totalExponent && totalMultiplication && totalAddition) {
            if (exactWidth.greater(0)) {
                let term1 = totalMultiplication.mod(exactWidth);
                let term2 = totalBase.modPow(totalExponent, exactWidth);
                let rem = term1.multiply(term2).plus(totalAddition).mod(exactWidth);
                if (rem.isNegative()) rem = rem.add(exactWidth);
                isWDiv = rem.isZero();
            }
            if (exactHeight.greater(0)) {
                let term1 = totalMultiplication.mod(exactHeight);
                let term2 = totalBase.modPow(totalExponent, exactHeight);
                let rem = term1.multiply(term2).plus(totalAddition).mod(exactHeight);
                if (rem.isNegative()) rem = rem.add(exactHeight);
                isHDiv = rem.isZero();
            }
        }
    }

    infoWidth.className = isWDiv ? "green-text" : "red-text";
    infoHeight.className = isHDiv ? "green-text" : "red-text";

    if (isBigNumberMode) {
        widthLabel.innerText = "Width (log):";
        heightLabel.innerText = "Height (log):";
        labelTotalBlocks.style.display = 'inline';
        labelBlocksRemaining.style.display = 'none';
        labelModRemainder.style.display = 'inline';
        infoBlocks.style.display = 'none';
        infoModRemainder.style.display = 'inline';

        let baseStr = totalBase.toString();
        let multStr = totalMultiplication.toString();
        let addStr = totalAddition.isNegative() ? ` - ${totalAddition.abs()}` : totalAddition.isZero() ? "" : ` + ${totalAddition}`;

        if (multStr === "1") {
            totalBlocksDisplay.innerText = `${baseStr}^${formatNumberWithCommas(totalExponent)}${addStr}`;
        } else {
            totalBlocksDisplay.innerText = `${multStr} * ${baseStr}^${formatNumberWithCommas(totalExponent)}${addStr}`;
        }

        if (blocksUsed.isZero()) {
            infoModRemainder.innerText = "N/A";
            infoModRemainder.className = "";
        } else {
            const term1 = totalMultiplication.mod(blocksUsed);
            const term2 = totalBase.modPow(totalExponent, blocksUsed);
            let totalRemainder = term1.multiply(term2).plus(totalAddition).mod(blocksUsed);
            if (totalRemainder.isNegative()) {
                totalRemainder = totalRemainder.add(blocksUsed);
            }
            infoModRemainder.innerText = formatNumberWithCommas(totalRemainder);
            infoModRemainder.className = totalRemainder.isZero() ? "green-text" : "red-text";
        }
    }
    else {
        widthLabel.innerText = "Width (A):";
        heightLabel.innerText = "Height (B):";
        
        labelModRemainder.style.display='none'; infoModRemainder.style.display='none';
        labelBlocksRemaining.style.display='inline'; infoBlocks.style.display='inline';
        totalBlocksDisplay.innerText = formatNumberWithCommas(totalBlocks);
        const rem = totalBlocks.minus(blocksUsed);
        infoBlocks.innerText = formatNumberWithCommas(rem);
        infoBlocks.className = rem.isZero() ? "green-text" : "red-text";
    }
    infoWidth.innerText = formatNumberWithCommas(exactWidth);
    infoHeight.innerText = formatNumberWithCommas(exactHeight);
    infoSlope.innerText = rect.w === 0 ? 'inf' : (rect.h / rect.w).toFixed(2);
    infoAngle.innerText = (Math.atan2(rect.h, rect.w) * 180 / Math.PI).toFixed(1);
    infoCenterPoint.innerText = `(${(rect.w / 2).toFixed(1)}, ${(rect.h / 2).toFixed(1)})`;
    
    // Prime badges
    if (primeToggleEl.checked) {
        const wStr = exactWidth.toString();
        const hStr = exactHeight.toString();
        const widthPrimeEl = document.getElementById('widthPrime');
        const heightPrimeEl = document.getElementById('heightPrime');
        if (wStr !== lastWidthStr) {
            lastWidthStr = wStr;
            setPrimeBadge(widthPrimeEl, primeStatus(exactWidth));
        }
        if (hStr !== lastHeightStr) {
            lastHeightStr = hStr;
            setPrimeBadge(heightPrimeEl, primeStatus(exactHeight));
        }
    } else {
        setPrimeBadge(document.getElementById('widthPrime'), "too-large");
        setPrimeBadge(document.getElementById('heightPrime'), "too-large");
    }

    const blocksMatch = isBigNumberMode ? (infoModRemainder.className === 'green-text') : blocksUsed.equals(originalInput);
    const bothFactors = isWDiv && isHDiv && blocksMatch;
    if (bothFactors) {
      canvas.style.backgroundColor = "lime";
      if (!isSuccessState) { createFireworks(); isSuccessState = true; }
    } else if (isWDiv || isHDiv) {
      canvas.style.backgroundColor = "yellow"; isSuccessState = false;
    } else {
      canvas.style.backgroundColor = "#fff"; isSuccessState = false;
    }
}

function customSqrt(n) { if (n.isNegative()) return bigInt(-1); if (n.lesserOrEquals(1)) return n; let x = n.shiftRight(1), y; while (true) { y = x.add(n.divide(x)).shiftRight(1); if (y.geq(x)) return x; x = y; }}
function dist(x1, y1, x2, y2) { return Math.hypot(x2 - x1, y2 - y1); }
function formatNumberWithCommas(n) { return !n ? "" : n.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ","); }
const FIREWORK_COUNT = 200, FIREWORK_LIFETIME = 200;
function createFireworks() { fireworks = []; const maxVel = Math.max(canvas.width, canvas.height) * 0.02; for (let i = 0; i < FIREWORK_COUNT; i++) { fireworks.push({ x: canvas.width / 2, y: canvas.height / 2, vx: (Math.random() - 0.5) * maxVel, vy: (Math.random() - 0.5) * maxVel, radius: 3 + Math.random() * 2, color: `hsl(${Math.random() * 360}, 100%, 50%)`, alpha: 1, life: FIREWORK_LIFETIME }); } }
function drawFireworks() { for (let i = fireworks.length - 1; i >= 0; i--) { let p = fireworks[i]; p.x += p.vx; p.y += p.vy; p.vy += 0.05; p.alpha = p.life / FIREWORK_LIFETIME; p.life--; if (p.life <= 0) { fireworks.splice(i, 1); continue; } ctx.fillStyle = p.color; ctx.globalAlpha = p.alpha; ctx.beginPath(); ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2); ctx.fill(); } ctx.globalAlpha = 1; }

window.onload = function() { performCalculation(); requestAnimationFrame(draw); };
</script>
</body>
</html>
