<!doctype html>
<html lang="en">
<head>
 <meta charset="utf-8"/>
 <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
 <title>Prime Explorer 0.2.1 (Compare)</title>
 <script src="https://unpkg.com/big-integer@1.6.48/BigInteger.min.js"></script>
 <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
 <style>
   body {
     margin: 0;
     overflow: hidden;
     touch-action: none; /* Prevent browser gestures */
     font-family: 'Inter', sans-serif;
     background-color: #f0f0f0;
   }
   canvas {
     display: block;
     background: #fff;
     touch-action: none;
     transition: background-color 0.5s ease; /* Smooth color transition */
   }
   #info {
     position: absolute;
     top: 10px;
     left: 10px;
     background: rgba(255, 255, 255, 0.9);
     padding: 10px;
     border: 1px solid #ccc;
     font-family: Arial, sans-serif;
     font-size: 14px;
     border-radius: 8px;
     box-shadow: 0 2px 10px rgba(0,0,0,0.1);
     max-width: 280px;
     max-height: calc(100vh - 20px);
     overflow-y: auto;
   }
   .info-group {
     display: flex;
     align-items: center;
     margin-bottom: 5px;
   }
   .info-group label {
     margin-right: 5px;
     white-space: nowrap;
   }
   .info-input {
     width: 100%;
     padding: 5px;
     border: 1px solid #ccc;
     border-radius: 4px;
   }
   #status {
     margin-top: 5px;
     color: gray;
     font-style: italic;
   }
   hr {
     margin: 10px 0;
     border: 0;
     border-top: 1px solid #ddd;
   }
   .red-text { color: #d9534f; }
   .green-text { color: #5cb85c; font-weight: bold; }
   .yellow-text { color: #f0ad4e; }
   .gray-text { color:#666; }
   .badge { padding:1px 6px; border-radius:10px; border:1px solid; font-size:12px; margin-left:6px; }
   #congruenceResults span, #triangleResults span, #hyperbolaResults span, #mSearchResults span {
     font-weight: bold;
   }
    #hyperbolaResults2 span, #mSearchResults2 span {
     font-weight: bold;
   }
   .formula-panel {
       font-family: monospace;
       font-size: 12px;
       background-color: #f8f9fa;
       padding: 8px;
       border-radius: 4px;
       border: 1px solid #e9ecef;
   }
   .formula-panel h5 {
       margin-top: 0;
       margin-bottom: 5px;
       font-weight: bold;
   }
   .formula-panel p {
       margin: 2px 0;
   }
 </style>
</head>
<body>
<canvas id="gridCanvas"></canvas>
<div id="info">
 <div class="info-group">
   <label for="valueInput1">Number 1 (N1):</label>
   <input type="text" id="valueInput1" class="info-input" value="1729" inputmode="text" list="number_suggestions">
 </div>
 <div class="info-group">
   <label><input type="checkbox" id="primeToggle" checked> Prime check (≤ 1e12)</label>
 </div>
 <div class="info-group">
   <label><input type="checkbox" id="compareToggle"> Compare Numbers</label>
 </div>
 <div id="compareControls" style="display:none;">
    <div class="info-group">
        <label for="valueInput2">Number 2 (N2):</label>
        <input type="text" id="valueInput2" class="info-input" value="1007" inputmode="text" list="number_suggestions">
    </div>
 </div>
 <div id="status"></div>
 <hr>
 <!-- Congruence of Squares Controls -->
 <div class="info-group" id="congruenceToggleContainer">
   <label><input type="checkbox" id="congruenceToggle"> Congruence of Squares</label>
 </div>
 <div id="congruenceControls" style="display:none;">
   <div class="info-group">
     <label for="xValueInput">Value for x:</label>
     <input type="text" id="xValueInput" class="info-input" value="">
   </div>
   <div id="congruenceResults" style="margin-top: 8px;">
     N: <span id="congruenceN"></span><br>
     x² mod N: <span id="x2ModN"></span><br>
     y = √(x² mod N): <span id="yValue"></span><br>
     gcd(x-y, N): <span id="factor1"></span><br>
     gcd(x+y, N): <span id="factor2"></span>
   </div>
 </div>
 <hr>
 <div>
   <label><b>Visualization Mode:</b></label>
   <div id="modeSelector" style="padding: 5px 0; display: flex; flex-wrap: wrap;">
     <label style="margin-right: 10px;"><input type="radio" name="visMode" value="rectangle" checked> Rectangle</label>
     <label style="margin-right: 10px;"><input type="radio" name="visMode" value="factorTriangle"> Gnomon</label>
     <label style="margin-right: 10px;"><input type="radio" name="visMode" value="hyperbola"> Hyperbola</label>
     <label><input type="radio" name="visMode" value="m_search"> M-Search</label>
   </div>
 </div>
 <hr>
 <!-- Main Factorization Controls -->
 <div id="factorizationControls">
    <span id="labelTotalBlocks">Total Blocks:</span> <span id="totalBlocksDisplay"></span><br>
    <span id="widthLabel">Width (A):</span> <span id="width"></span><span id="widthPrime" class="badge gray-text"></span><br>
    <span id="heightLabel">Height (B):</span> <span id="height"></span><span id="heightPrime" class="badge gray-text"></span><br>
    <span id="labelBlocksRemaining">Blocks Remaining:</span> <span id="blocks"></span><br>
    <span id="labelModRemainder" style="display:none;">Mod Remainder:</span> <span id="modRemainder" style="display:none;"></span><br>
    Diagonal Slope: <span id="slope"></span><br>
    Diagonal Angle: <span id="angle"></span>°<br>
    Center Point: <span id="centerPoint"></span>
 </div>
 <!-- Gnomon (Factor Geometry) Controls -->
 <div id="factorTriangleControls" style="display:none;">
    <div class="info-group">
        <label for="aValueInput">Value for A (≥ √N):</label>
        <input type="text" id="aValueInput" class="info-input" value="">
    </div>
    <div id="triangleResults" style="margin-top: 8px;">
        A² - N: <span id="a2MinusN"></span><br>
        B = √(A² - N): <span id="bValue"></span><br>
        Factor 1 (A+B): <span id="triangleFactor1"></span><br>
        Factor 2 (A-B): <span id="triangleFactor2"></span>
    </div>
 </div>
 <!-- Hyperbola Controls -->
 <div id="hyperbolaControls" style="display:none;">
    <div class="info-group">
        <label for="sValueInput1">Sum (S1 = F₁+F₂):</label>
        <input type="text" id="sValueInput1" class="info-input" value="">
    </div>
    <div class="info-group" id="s2Controls" style="display:none;">
        <label for="sValueInput2">Sum (S2):</label>
        <input type="text" id="sValueInput2" class="info-input" value="">
    </div>
    <div id="hyperbolaResults" style="margin-top: 8px;">
        <b>N1:</b><br>
        S₁² - 4N₁: <span id="s2Minus4N"></span><br>
        √(S₁² - 4N₁): <span id="s2Minus4N_sqrt"></span><br>
        Factor 1: <span id="hyperbolaFactor1"></span><br>
        Factor 2: <span id="hyperbolaFactor2"></span>
    </div>
     <div id="hyperbolaResults2" style="margin-top: 8px; display:none; border-top: 1px solid #ccc; padding-top: 8px;">
        <b>N2:</b><br>
        S₂² - 4N₂: <span id="s2Minus4N_2"></span><br>
        √(S₂² - 4N₂): <span id="s2Minus4N_sqrt_2"></span><br>
        Factor 1: <span id="hyperbolaFactor1_2"></span><br>
        Factor 2: <span id="hyperbolaFactor2_2"></span>
    </div>
 </div>
  <!-- M-Search Controls -->
  <div id="mSearchControls" style="display:none;">
    <div class="info-group">
        <label for="mValueInput1">Slope (M1 = F₁-F₂):</label>
        <input type="text" id="mValueInput1" class="info-input" value="">
    </div>
     <div class="info-group" id="m2Controls" style="display:none;">
        <label for="mValueInput2">Slope (M2):</label>
        <input type="text" id="mValueInput2" class="info-input" value="">
    </div>
    <div id="mSearchResults" style="margin-top: 8px;">
        <b>N1:</b><br>
        D₁ = M₁²+4N₁: <span id="m_discriminant"></span><br>
        √D₁: <span id="m_discriminant_sqrt"></span><br>
        Factor 1 (F₁): <span id="m_factor1"></span><br>
        Factor 2 (F₂): <span id="m_factor2"></span>
    </div>
    <div id="mSearchResults2" style="margin-top: 8px; display:none; border-top: 1px solid #ccc; padding-top: 8px;">
        <b>N2:</b><br>
        D₂ = M₂²+4N₂: <span id="m_discriminant_2"></span><br>
        √D₂: <span id="m_discriminant_sqrt_2"></span><br>
        Factor 1 (F₁): <span id="m_factor1_2"></span><br>
        Factor 2 (F₂): <span id="m_factor2_2"></span>
    </div>
 </div>
 <div id="formulaContainer" style="margin-top:10px; display:none;">
    <details>
        <summary>Relevant Formulas</summary>
        <div id="gnomonFormulas" class="formula-panel" style="display:none;">
            <h5>Gnomon (Difference of Squares)</h5>
            <p>N = A² - B²</p>
            <p><span id="f_N1">N</span> = <span id="f_A1_val">A</span>² - <span id="f_B1_val">B</span>²</p>
            <hr>
            <p>F₁ = A + B</p>
            <p>F₂ = A - B</p>
        </div>
        <div id="hyperbolaFormulas" class="formula-panel" style="display:none;">
            <h5>Hyperbola (Sum Search)</h5>
            <p>k² = S² - 4N</p>
            <p><span id="f_k2_val_s">k</span>² = <span id="f_S2_val">S</span>² - 4*<span id="f_N2">N</span></p>
            <hr>
            <p>F₁ = (S + k)/2</p>
            <p>F₂ = (S - k)/2</p>
            <p><small>*where k = √(S² - 4N) = M</small></p>
        </div>
        <div id="msearchFormulas" class="formula-panel" style="display:none;">
            <h5>M-Search (Difference Search)</h5>
            <p>x² - Mx - N = 0</p>
            <p>x² - <span id="f_M1_val">M</span>x - <span id="f_N3">N</span> = 0</p>
            <hr>
            <p>k² = M² + 4N</p>
            <p><span id="f_k2_val_m">k</span>² = <span id="f_M2_val">M</span>² + 4*<span id="f_N4">N</span></p>
            <hr>
            <p>F₁ = (M + k)/2</p>
            <p>F₂ = (-M + k)/2</p>
             <p><small>*where k = √(M² + 4N) = S</small></p>
        </div>
    </details>
 </div>
</div>
<datalist id="number_suggestions">
    <!-- Ramanujan-Hardy Number -->
    <option value="1729"></option>
    <!-- First Carmichael Number -->
    <option value="561"></option>
    <!-- A small semiprime -->
    <option value="91"></option>
    <!-- Another semiprime -->
    <option value="1007"></option>
    <!-- Square of a prime -->
    <option value="121"></option>
    <!-- A larger semiprime -->
    <option value="8989"></option>
    <!-- A Fermat number F5 composite -->
    <option value="4294967297"></option>
</datalist>

<script>
// --- Canvas & DOM Setup ---
const canvas = document.getElementById("gridCanvas");
const ctx = canvas.getContext("2d");
const body = document.body;

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const valueInput1 = document.getElementById('valueInput1');
const valueInput2 = document.getElementById('valueInput2');
const statusDiv = document.getElementById('status');
const totalBlocksDisplay = document.getElementById('totalBlocksDisplay');
const infoWidth = document.getElementById('width');
const infoHeight = document.getElementById('height');
const infoBlocks = document.getElementById('blocks');
const infoModRemainder = document.getElementById('modRemainder');
const labelTotalBlocks = document.getElementById('labelTotalBlocks');
const labelBlocksRemaining = document.getElementById('labelBlocksRemaining');
const labelModRemainder = document.getElementById('labelModRemainder');
const infoSlope = document.getElementById('slope');
const infoAngle = document.getElementById('angle');
const infoCenterPoint = document.getElementById('centerPoint');
const primeToggleEl = document.getElementById('primeToggle');
const widthLabel = document.getElementById('widthLabel');
const heightLabel = document.getElementById('heightLabel');

// --- State Variables ---
let gridSize = 20;
let scale = 1;
let offsetX = 0, offsetY = 0;
let lastPan = null;
let isCongruenceMode = false;
let totalBlocks = bigInt(1007);
let originalInput1 = bigInt(1007);
let totalBase = null, totalExponent = null, totalMultiplication = null, totalAddition = null;
let isBigNumberMode = false;
let rect = {x: 2, y: 2, w: 0, h: 0};
let exactWidth = bigInt(0);
let exactHeight = bigInt(0);
let handles = [];
let xSquare = { x: 2, y: 2, size: 50 };
let yValue = bigInt.zero;
let ySquareSize = 0;
let xSquareHandle = { x: 0, y: 0 };
let activeTool = null;
let activeHandleName = null;
let lastTouchDist = 0;
const logarithmicThreshold = 75;
let fireworks = [];
let isSuccessState = false;
let currentMode = 'rectangle';
let aValue = bigInt.zero;
let aSquareHandle = { x: 0, y: 0 };
let sValue1 = bigInt.zero;
let sLineHandle1 = { x: 0, y: 0};
let mValue1 = bigInt.zero;
let mLineHandle1 = null;

// Comparison mode variables
let isCompareMode = false;
let originalInput2 = bigInt(1007);
let sValue2 = bigInt.zero;
let sLineHandle2 = { x: 0, y: 0 };
let mValue2 = bigInt.zero;
let mLineHandle2 = null;


// --- Lightweight prime check (cached, only when value changes) ---
const PRIME_CHECK_LIMIT = bigInt("1000000000000"); // 1e12
const SMALL_PRIMES = [2,3,5,7,11,13,17,19,23,29,31];
const MR_BASES = [2,3,5,7,11];
const primeCache = new Map();
let lastWidthStr  = "";
let lastHeightStr = "";

function isTooLargeForPrimeCheck(n) { return n.greater(PRIME_CHECK_LIMIT); }
function trialDivisionSmall(n) { for (const p of SMALL_PRIMES) { const bp = bigInt(p); if (n.equals(bp)) return true; if (n.mod(bp).isZero()) return false; } return null; }
function millerRabin(n) { if (n.lesser(2)) return false; if (n.equals(2)) return true; if (n.isEven()) return false; let d = n.minus(1); let s = 0; while (d.isEven()) { d = d.divide(2); s++; } for (const a of MR_BASES) { const A = bigInt(a); if (A.greaterOrEquals(n)) continue; let x = A.modPow(d, n); if (x.equals(1) || x.equals(n.minus(1))) continue; let cont = false; for (let r = 1; r < s; r++) { x = x.multiply(x).mod(n); if (x.equals(n.minus(1))) { cont = true; break; } } if (!cont) return false; } return true;}
function primeStatus(n) { const key = n.toString(); if (primeCache.has(key)) return primeCache.get(key); if (n.lesser(2)) { primeCache.set(key, "composite"); return "composite"; } if (isTooLargeForPrimeCheck(n)) { primeCache.set(key, "too-large"); return "too-large"; } const td = trialDivisionSmall(n); let res; if (td === true) res = "prime"; else if (td === false) res = "composite"; else res = millerRabin(n) ? "prime" : "composite"; primeCache.set(key, res); return res;}
function setPrimeBadge(el, status) { if (!el) return; if (status === "prime")   { el.textContent = "Prime";      el.className = "badge green-text"; } else if (status === "composite") { el.textContent = "Composite";  el.className = "badge red-text"; } else { el.textContent = "Too large"; el.className = "badge gray-text"; }}


// --- Main App Logic ---
function parseInput(inputString) {
    const sanitizedInput = inputString.replace(/\s/g, '');
    const prothPattern = /^(\d+)\*2\^(\d+)\+1$/;
    const mersennePattern = /^2\^(\d+)-1$/;
    const powerPattern = /^(\d+)\^(.+?)(?:\+(\d+))?$/;
    const scientificPattern = /^(\d*\.?\d*)e(\d+)(?:\+(\d+))?$/i;
    let match;
    match = sanitizedInput.match(scientificPattern); if (match) { const multiplication = match[1] && match[1] !== '' ? bigInt(match[1]) : bigInt(1); const exponent = bigInt(match[2]); const addition = match[3] ? bigInt(match[3]) : bigInt(0); if (exponent.greaterOrEquals(logarithmicThreshold)) { return { type: 'bigNumber', base: bigInt(10), exponent: exponent, multiplication: multiplication, addition: addition }; } else { const total = multiplication.multiply(bigInt(10).pow(exponent)).plus(addition); return { type: 'number', total: total }; } }
    match = sanitizedInput.match(prothPattern); if (match) { const k = bigInt(match[1]), n = bigInt(match[2]); return n.greaterOrEquals(logarithmicThreshold) ? { type: 'bigNumber', base: bigInt(2), exponent: n, multiplication: k, addition: bigInt(1) } : { type: 'number', total: k.multiply(bigInt(2).pow(n)).plus(1) }; }
    match = sanitizedInput.match(mersennePattern); if (match) { const exponent = bigInt(match[1]); return exponent.greaterOrEquals(logarithmicThreshold) ? { type: 'bigNumber', base: bigInt(2), exponent: exponent, multiplication: bigInt(1), addition: bigInt(-1) } : { type: 'number', total: bigInt(2).pow(exponent).minus(1) }; }
    match = sanitizedInput.match(powerPattern); if (match) { const base = bigInt(match[1]), exponentStr = match[2], addition = match[3] ? bigInt(match[3]) : bigInt(0); const exponent = exponentStr.toLowerCase().includes('e') ? bigInt(Number(exponentStr)) : bigInt(exponentStr); return exponent.greaterOrEquals(logarithmicThreshold) ? { type: 'bigNumber', base, exponent, multiplication: bigInt(1), addition } : { type: 'number', total: base.pow(exponent).plus(addition) }; }
    if (sanitizedInput === '') return { type: 'number', total: bigInt(0) };
    return { type: 'number', total: bigInt(sanitizedInput) };
}


function performCalculation() {
 statusDiv.innerText = "Calculating...";
 try {
   const result = parseInput(valueInput1.value);
   isBigNumberMode = (result.type === 'bigNumber');

   if (isBigNumberMode) {
     originalInput1 = bigInt(0); totalBase = result.base; totalExponent = result.exponent; totalMultiplication = result.multiplication; totalAddition = result.addition; totalBlocks = null; const side = totalExponent; exactWidth = side; exactHeight = side; rect.w = side.toJSNumber(); rect.h = side.toJSNumber();
   } else {
     originalInput1 = result.total; totalBase = null; totalExponent = null; totalMultiplication = null; totalAddition = null; totalBlocks = result.total; if (totalBlocks.isNegative()) { statusDiv.innerText = "Error: Input must be non-negative."; return; } const side = customSqrt(totalBlocks); exactWidth = side; exactHeight = side; rect.w = side.toJSNumber(); rect.h = side.toJSNumber();
   }

   if (currentMode === 'factorTriangle') {
        let sMin = customSqrt(originalInput1); if(!sMin.square().equals(originalInput1)) sMin = sMin.plus(1);
        document.getElementById('aValueInput').value = sMin.toString(); aValue = sMin; updateFactorTriangle(); zoomToFit({x: 2, y: 2, w: aValue.toJSNumber() * 1.8, h: aValue.toJSNumber()});
   } else if (currentMode === 'hyperbola') {
        let sMin = customSqrt(originalInput1.multiply(4)); if(!sMin.square().equals(originalInput1.multiply(4))) sMin = sMin.plus(1);
        document.getElementById('sValueInput1').value = sMin.toString(); sValue1 = sMin; updateHyperbolaSearch(); zoomToFit({x:0, y:0, w: sValue1.toJSNumber() * 1.2, h: sValue1.toJSNumber() * 1.2});
   } else if (currentMode === 'm_search') {
        document.getElementById('mValueInput1').value = "72"; mValue1 = bigInt(72); updateMSearch();
        const sqrtN_approx = customSqrt(originalInput1).toJSNumber();
        const viewWidth = sqrtN_approx * 2.5;
        const viewHeight = viewWidth;
        zoomToFit({x: -viewWidth / 2, y: -viewHeight / 2, w: viewWidth, h: viewHeight});
   } else {
        document.getElementById('xValueInput').value = customSqrt(originalInput1).plus(1).toString(); updateCongruence(); zoomToFit(isCongruenceMode ? xSquare : rect);
   }

   if(isCompareMode) {
       performCalculation2();
   }

   updateHandles();
   statusDiv.innerText = "Ready.";
 } catch (error) { console.error("Calculation Error:", error); statusDiv.innerText = "Error: Invalid input format."; }
}

function performCalculation2() {
 try {
   const result = parseInput(valueInput2.value);
   if (result.type === 'bigNumber') {
     originalInput2 = bigInt(0); // Comparison mode doesn't support big numbers
   } else {
     originalInput2 = result.total;
     if (originalInput2.isNegative()) { return; }
   }
   if (currentMode === 'hyperbola') {
        let sMin = customSqrt(originalInput2.multiply(4)); if(!sMin.square().equals(originalInput2.multiply(4))) sMin = sMin.plus(1);
        document.getElementById('sValueInput2').value = sMin.toString(); sValue2 = sMin; updateHyperbolaSearch2();
   } else if (currentMode === 'm_search') {
        document.getElementById('mValueInput2').value = "1"; mValue2 = bigInt(1); updateMSearch2();
   }
 } catch (error) { console.error("Calculation Error N2:", error); }
}

function updateMSearch() {
    if (originalInput1.isZero() || isBigNumberMode) return;
    const N = originalInput1;
    const M = mValue1;
    const discriminant = M.square().plus(N.multiply(4));

    let sqrtStr = "Not a perfect square";
    let f1Str = "N/A", f2Str = "N/A";
    let f1Class = '', f2Class = '';

    document.getElementById('m_discriminant').innerText = formatNumberWithCommas(discriminant);

    const root = customSqrt(discriminant);
    if (root.square().equals(discriminant)) {
        sqrtStr = formatNumberWithCommas(root);
        const f1 = M.plus(root).divide(2);
        const f2 = f1.minus(M);
        f1Str = formatNumberWithCommas(f1); f2Str = formatNumberWithCommas(f2);
        if (f1.times(f2).equals(N)) {
            f1Class = 'green-text'; f2Class = 'green-text';
            if (!isSuccessState) { createFireworks(); isSuccessState = true; } canvas.style.backgroundColor = "lime";
        } else { isSuccessState = false; canvas.style.backgroundColor = "#fff"; }
    } else { isSuccessState = false; canvas.style.backgroundColor = "#fff"; }
    document.getElementById('m_discriminant_sqrt').innerText = sqrtStr;
    document.getElementById('m_factor1').innerText = f1Str; document.getElementById('m_factor2').innerText = f2Str;
    document.getElementById('m_factor1').className = f1Class; document.getElementById('m_factor2').className = f2Class;

    document.getElementById('f_N3').textContent = N.toString();
    document.getElementById('f_M1_val').textContent = M.toString();
    document.getElementById('f_k2_val_m').textContent = root.square().equals(discriminant) ? root.toString() : 'k';
    document.getElementById('f_M2_val').textContent = M.toString();
    document.getElementById('f_N4').textContent = N.toString();

    updateHandles();
}

function updateMSearch2() {
    if (originalInput2.isZero()) return;
    const N = originalInput2; const M = mValue2; const discriminant = M.square().plus(N.multiply(4));
    let sqrtStr = "Not a perfect square"; let f1Str = "N/A", f2Str = "N/A"; let f1Class = '', f2Class = '';
    document.getElementById('m_discriminant_2').innerText = formatNumberWithCommas(discriminant);
    const root = customSqrt(discriminant);
    if (root.square().equals(discriminant)) {
        sqrtStr = formatNumberWithCommas(root); const f1 = M.plus(root).divide(2); const f2 = f1.minus(M); f1Str = formatNumberWithCommas(f1); f2Str = formatNumberWithCommas(f2); if (f1.times(f2).equals(N)) { f1Class = 'green-text'; f2Class = 'green-text'; }
    }
    document.getElementById('m_discriminant_sqrt_2').innerText = sqrtStr; document.getElementById('m_factor1_2').innerText = f1Str; document.getElementById('m_factor2_2').innerText = f2Str; document.getElementById('m_factor1_2').className = f1Class; document.getElementById('m_factor2_2').className = f2Class;
    updateHandles();
}

function updateHyperbolaSearch() {
    if (originalInput1.isZero() || isBigNumberMode) return;
    const N = originalInput1; const S = sValue1; const s2_4N = S.square().minus(N.multiply(4));
    let sqrtStr = "Not a perfect square"; let f1Str = "N/A", f2Str = "N/A"; let f1Class = '', f2Class = '';
    document.getElementById('s2Minus4N').innerText = formatNumberWithCommas(s2_4N);
    let root = bigInt(-1);
    if (s2_4N.isPositive()) {
        root = customSqrt(s2_4N);
    }

    if (root.square().equals(s2_4N)) {
        sqrtStr = formatNumberWithCommas(root); const f1 = S.plus(root).divide(2); const f2 = S.minus(root).divide(2);
        f1Str = formatNumberWithCommas(f1); f2Str = formatNumberWithCommas(f2);
        if (f1.times(f2).equals(N)) { f1Class = 'green-text'; f2Class = 'green-text'; if (!isSuccessState) { createFireworks(); isSuccessState = true; } canvas.style.backgroundColor = "lime";
        } else { isSuccessState = false; canvas.style.backgroundColor = "#fff"; }
    } else { sqrtStr = "Not a perfect square"; isSuccessState = false; canvas.style.backgroundColor = "#fff"; }

    document.getElementById('s2Minus4N_sqrt').innerText = sqrtStr; document.getElementById('hyperbolaFactor1').innerText = f1Str; document.getElementById('hyperbolaFactor2').innerText = f2Str; document.getElementById('hyperbolaFactor1').className = f1Class; document.getElementById('hyperbolaFactor2').className = f2Class;

    document.getElementById('f_k2_val_s').textContent = root.square().equals(s2_4N) ? root.toString() : 'k';
    document.getElementById('f_S2_val').textContent = S.toString();
    document.getElementById('f_N2').textContent = N.toString();
    updateHandles();
}

function updateHyperbolaSearch2() {
    if (originalInput2.isZero()) return;
    const N = originalInput2; const S = sValue2; const s2_4N = S.square().minus(N.multiply(4));
    let sqrtStr = "Not a perfect square"; let f1Str = "N/A", f2Str = "N/A"; let f1Class = '', f2Class = '';
    document.getElementById('s2Minus4N_2').innerText = formatNumberWithCommas(s2_4N);
    let root = bigInt(-1); if (s2_4N.isPositive()) { root = customSqrt(s2_4N); }
    if (root.square().equals(s2_4N)) {
        sqrtStr = formatNumberWithCommas(root); const f1 = S.plus(root).divide(2); const f2 = S.minus(root).divide(2);
        f1Str = formatNumberWithCommas(f1); f2Str = formatNumberWithCommas(f2); if (f1.times(f2).equals(N)) { f1Class = 'green-text'; f2Class = 'green-text'; }
    }
    document.getElementById('s2Minus4N_sqrt_2').innerText = sqrtStr; document.getElementById('hyperbolaFactor1_2').innerText = f1Str; document.getElementById('hyperbolaFactor2_2').innerText = f2Str; document.getElementById('hyperbolaFactor1_2').className = f1Class; document.getElementById('hyperbolaFactor2_2').className = f2Class;
    updateHandles();
}


function updateFactorTriangle() {
    if (originalInput1.isZero() || isBigNumberMode) return;
    const N = originalInput1; const A = aValue; const a2 = A.square(); const b2 = a2.minus(N);
    let bValueStr = "Not a perfect square"; let f1Str = "N/A", f2Str = "N/A"; let f1Class = '', f2Class = '';
    document.getElementById('a2MinusN').innerText = formatNumberWithCommas(b2);
    let B = bigInt(-1);
    if (b2.isPositive()) {
        B = customSqrt(b2);
    }

    if (B.square().equals(b2)) {
        bValueStr = formatNumberWithCommas(B); const f1 = A.plus(B); const f2 = A.minus(B); f1Str = formatNumberWithCommas(f1); f2Str = formatNumberWithCommas(f2);
        if (f1.times(f2).equals(N) && !f2.isUnit()) { f1Class = 'green-text'; f2Class = 'green-text'; if (!isSuccessState) { createFireworks(); isSuccessState = true; } canvas.style.backgroundColor = "lime";
        } else { isSuccessState = false; canvas.style.backgroundColor = "#fff"; }
    } else { isSuccessState = false; canvas.style.backgroundColor = "#fff"; }

    document.getElementById('bValue').innerText = bValueStr; document.getElementById('triangleFactor1').innerText = f1Str; document.getElementById('triangleFactor2').innerText = f2Str; document.getElementById('triangleFactor1').className = f1Class; document.getElementById('triangleFactor2').className = f2Class;

    document.getElementById('f_N1').textContent = N.toString();
    document.getElementById('f_A1_val').textContent = A.toString();
    document.getElementById('f_B1_val').textContent = B.square().equals(b2) ? B.toString() : 'B';
    updateHandles();
}

function updateCongruence() {
    if (isBigNumberMode || originalInput1.isZero() || originalInput1.isUnit()) { document.getElementById('congruenceControls').style.color = '#aaa'; return; }
    document.getElementById('congruenceControls').style.color = 'inherit';
    const N = originalInput1; let x; try { x = bigInt(document.getElementById('xValueInput').value); if(x.isZero()) return; } catch (e) { return; }
    if (!isCongruenceMode) { xSquare.size = x.toJSNumber(); }
    const x2 = x.square(); const x2ModN = x2.mod(N); yValue = customSqrt(x2ModN);
    let factor1Str = "N/A", factor2Str = "N/A", yStr = "Not a perfect square"; let factor1Class = '', factor2Class = ''; ySquareSize = 0;
    if (yValue.square().equals(x2ModN)) {
        ySquareSize = yValue.toJSNumber(); yStr = formatNumberWithCommas(yValue);
        const xMinusY = x.minus(yValue); const xPlusY = x.plus(yValue);
        if (x.equals(yValue) || x.mod(N).equals(yValue) || x.plus(yValue).mod(N).isZero()) { factor1Str = "Trivial"; factor2Str = "Trivial";
        } else { const f1 = bigInt.gcd(xMinusY, N); const f2 = bigInt.gcd(xPlusY, N); factor1Str = formatNumberWithCommas(f1); factor2Str = formatNumberWithCommas(f2); if (!f1.isUnit() && !f1.equals(N)) { factor1Class = 'green-text'; } if (!f2.isUnit() && !f2.equals(N)) { factor2Class = 'green-text'; } }
    }
    document.getElementById('congruenceN').innerText = formatNumberWithCommas(N); document.getElementById('x2ModN').innerText = formatNumberWithCommas(x2ModN); document.getElementById('yValue').innerText = yStr; document.getElementById('factor1').innerText = factor1Str; document.getElementById('factor2').innerText = factor2Str; document.getElementById('factor1').className = factor1Class; document.getElementById('factor2').className = factor2Class;
}

// --- Drawing & Visualization ---
function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawFireworks();
    ctx.save();

    const isCartesian = currentMode === 'hyperbola' || currentMode === 'm_search';

    if (isCartesian) {
        ctx.translate(canvas.width / 2, canvas.height / 2);
        ctx.translate(offsetX, offsetY); // Apply pan
        ctx.scale(1, -1); // THEN Flip Y-axis for textbook grid
    } else {
        ctx.translate(offsetX, offsetY);
    }

    ctx.scale(scale, scale);

    switch(currentMode) {
        case 'm_search': drawMSearchVisualization(); break;
        case 'hyperbola': drawHyperbolaVisualization(); break;
        case 'factorTriangle': drawFactorTriangleVisualization(); break;
        case 'rectangle': default: drawGridLines(); if (isCongruenceMode) { drawCongruenceVisualization(); } else { drawFactorizationVisualization(); } break;
    }
    ctx.restore();
    updateInfoPanel();
    requestAnimationFrame(draw);
}

function drawGridLines(isSpecialMode = false) {
    const isCartesian = currentMode === 'hyperbola' || currentMode === 'm_search';
    let minX, maxX, minY, maxY;

    if (isCartesian) {
        minX = (-canvas.width / 2 - offsetX) / scale / gridSize;
        maxX = (canvas.width / 2 - offsetX) / scale / gridSize;
        minY = (canvas.height / 2 + offsetY) / scale / gridSize;
        maxY = (-canvas.height / 2 + offsetY) / scale / gridSize;
    } else {
        minX = -offsetX / scale / gridSize;
        maxX = (canvas.width - offsetX) / scale / gridSize;
        minY = -offsetY / scale / gridSize;
        maxY = (canvas.height - offsetY) / scale / gridSize;
    }

    ctx.strokeStyle = "#ddd";
    ctx.lineWidth = 1 / scale;
    ctx.font = `${10/scale}px Arial`;
    ctx.fillStyle = '#aaa';

    const numTicks = 20;
    const xTicks = d3.scaleLinear().domain([minX, maxX]).ticks(numTicks);
    const yTicks = d3.scaleLinear().domain([minY, maxY]).ticks(numTicks);

    const drawText = (text, x, y) => {
        if (isCartesian) {
            ctx.save();
            ctx.scale(1, -1);
            ctx.fillText(text, x, -y);
            ctx.restore();
        } else {
            ctx.fillText(text, x, y);
        }
    };

    ctx.textAlign = 'center';
    xTicks.forEach(tick => {
        const yPos = isCartesian ? maxY : minY;
        const yLimit = isCartesian ? minY : maxY;
        ctx.beginPath();
        ctx.moveTo(tick * gridSize, yPos * gridSize);
        ctx.lineTo(tick * gridSize, yLimit * gridSize);
        ctx.stroke();
        if (Math.abs(tick) > 0.1) {
            ctx.textBaseline = isCartesian ? 'bottom' : 'top';
            drawText(tick, tick * gridSize, (isCartesian ? 10 : -10) / scale);
        }
    });

    ctx.textAlign = 'left';
    ctx.textBaseline = 'middle';
    yTicks.forEach(tick => {
        ctx.beginPath();
        ctx.moveTo(minX * gridSize, tick * gridSize);
        ctx.lineTo(maxX * gridSize, tick * gridSize);
        ctx.stroke();
        if (Math.abs(tick) > 0.1) {
             drawText(tick, 10 / scale, tick * gridSize);
        }
    });

    if(isSpecialMode) {
        ctx.strokeStyle = "#000"; ctx.lineWidth = 1.5/scale;
        ctx.beginPath(); ctx.moveTo(minX*gridSize, 0); ctx.lineTo(maxX*gridSize, 0); ctx.stroke(); // X-axis
        ctx.beginPath(); ctx.moveTo(0, minY*gridSize); ctx.lineTo(0, maxY*gridSize); ctx.stroke(); // Y-axis
    }
}
function drawMSearchLayer(N, M, parabolaColor, lineColor, handle, handleColor, showDetails) {
    const N_num = N.toJSNumber(); if (N_num <= 0) return;
    const m_num = M.toJSNumber();
    const minX = (-canvas.width / 2 - offsetX) / scale / gridSize;
    const maxX = (canvas.width / 2 - offsetX) / scale / gridSize;

    // Draw Parabola y = x^2 - N
    ctx.strokeStyle = parabolaColor; ctx.lineWidth = 2 / scale; ctx.beginPath();
    let firstPoint = true;
    for (let x = minX; x < maxX; x += 1 / scale) {
        const y = x * x - N_num;
        if (firstPoint) { ctx.moveTo(x * gridSize, y * gridSize); firstPoint = false; } else { ctx.lineTo(x * gridSize, y * gridSize); }
    }
    ctx.stroke();

    // Draw Line y = M*x
    ctx.strokeStyle = lineColor; ctx.lineWidth = 2 / scale; ctx.beginPath();
    ctx.moveTo(minX * gridSize, minX * m_num * gridSize); ctx.lineTo(maxX * gridSize, maxX * m_num * gridSize); ctx.stroke();

    // Check for solution and draw intersections
    const discriminant = M.square().plus(N.multiply(4));
    const root = customSqrt(discriminant);
    if (root.square().equals(discriminant)) {
        const f1 = M.plus(root).divide(2); const f2 = root.minus(M).divide(2);
        const x1 = f1.toJSNumber(); const y1 = x1 * x1 - N_num;
        const x2 = -f2.toJSNumber(); const y2 = x2 * x2 - N_num;
        ctx.fillStyle = 'green';
        ctx.beginPath(); ctx.arc(x1 * gridSize, y1 * gridSize, 5 / scale, 0, 2 * Math.PI); ctx.fill();
        ctx.beginPath(); ctx.arc(x2 * gridSize, y2 * gridSize, 5 / scale, 0, 2 * Math.PI); ctx.fill();

        if (showDetails) {
            ctx.save();
            ctx.scale(1,-1);
            ctx.fillStyle = 'black'; ctx.font = `${14/scale}px Arial`; ctx.textAlign = 'left';
            ctx.fillText(`(F₁, y) = (${x1.toFixed(0)}, ${y1.toFixed(0)})`, x1 * gridSize + 10/scale, -y1 * gridSize);
            ctx.textAlign = 'right';
            ctx.fillText(`(-F₂, y) = (${x2.toFixed(0)}, ${y2.toFixed(0)})`, x2 * gridSize - 10/scale, -y2 * gridSize);
            ctx.restore();
        }
    }

    if (showDetails) {
        const sqrtN_num = customSqrt(N).toJSNumber();
        ctx.fillStyle = 'purple';
        ctx.beginPath(); ctx.arc(sqrtN_num * gridSize, 0, 5 / scale, 0, 2 * Math.PI); ctx.fill();
        ctx.beginPath(); ctx.arc(-sqrtN_num * gridSize, 0, 5 / scale, 0, 2 * Math.PI); ctx.fill();

        ctx.save();
        ctx.scale(1, -1);
        ctx.fillStyle = 'black'; ctx.font = `${12/scale}px Arial`; ctx.textAlign = 'center'; ctx.textBaseline = 'top';
        ctx.fillText(`(√N, 0)`, sqrtN_num * gridSize, 10/scale);
        ctx.fillText(`(-√N, 0)`, -sqrtN_num * gridSize, 10/scale);
        ctx.restore();
    }

    if (handle) {
        const handleSize = Math.max(10, 10 / scale);
        ctx.fillStyle = handleColor;
        ctx.beginPath(); ctx.arc(handle.p1.x * gridSize, handle.p1.y * gridSize, handleSize / 2, 0, 2 * Math.PI); ctx.fill();
        ctx.beginPath(); ctx.arc(handle.p2.x * gridSize, handle.p2.y * gridSize, handleSize / 2, 0, 2 * Math.PI); ctx.fill();
    }
}

function drawMSearchVisualization() {
    drawGridLines(true);
    drawMSearchLayer(originalInput1, mValue1, 'purple', 'orange', mLineHandle1, (activeTool === 'mHandle1') ? 'blue' : 'orange', true);
    if(isCompareMode && originalInput2.greater(0)) {
        drawMSearchLayer(originalInput2, mValue2, '#4169E1', '#00BFFF', mLineHandle2, (activeTool === 'mHandle2') ? '#00FFFF' : '#00BFFF', false);
    }
}

function drawHyperbolaLayer(N, S, hyperbolaColor, lineColor, handle, handleColor, showDetails, showLabels, shapeStyles) {
    const N_num = N.toJSNumber(); if(N_num <= 0) return;
    const minX = (-canvas.width/2 - offsetX) / scale / gridSize, maxX = (canvas.width/2 - offsetX) / scale / gridSize;
    const s_num = S.toJSNumber();
    const s2_4N = S.square().minus(N.multiply(4));
    const solutionFound = s2_4N.geq(0) && customSqrt(s2_4N).square().equals(s2_4N);

    const drawText = (text, x, y, align='center', baseline='middle') => {
        ctx.save();
        ctx.scale(1,-1);
        ctx.textAlign = align;
        ctx.textBaseline = baseline;
        ctx.fillText(text, x, -y);
        ctx.restore();
    };

    // Draw hyperbola
    ctx.strokeStyle = hyperbolaColor; ctx.lineWidth = 2 / scale; ctx.beginPath();
    let firstPoint = true;
    for(let x = minX; x < maxX; x += 1/scale) { if (x > 0.01) { const y = N_num / x; if (firstPoint) { ctx.moveTo(x * gridSize, y * gridSize); firstPoint = false; } else { ctx.lineTo(x * gridSize, y * gridSize); } } }
    ctx.stroke();

    // Draw line
    ctx.strokeStyle = lineColor; ctx.lineWidth = 2 / scale; ctx.beginPath(); ctx.moveTo(minX * gridSize, (s_num - minX) * gridSize); ctx.lineTo(maxX * gridSize, (s_num - maxX) * gridSize); ctx.stroke();

    if(solutionFound) {
        const root = customSqrt(s2_4N);
        const f1 = S.plus(root).divide(2); const f2 = S.minus(root).divide(2);
        const f1_num = f1.toJSNumber(); const f2_num = f2.toJSNumber();

        if (showDetails) {
            ctx.fillStyle = shapeStyles.fill.sTriangle; ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(s_num * gridSize, 0); ctx.lineTo(0, s_num * gridSize); ctx.closePath(); ctx.fill();
            if (showLabels) {
                ctx.fillStyle = 'rgba(0,0,0,0.7)';
                drawText(`Area = S²/2 = ${formatNumberWithCommas(S.square().divide(2))}`, s_num*gridSize/3, s_num*gridSize/3);
                ctx.beginPath(); ctx.arc(s_num*gridSize/2, s_num*gridSize/2, 4/scale, 0, 2*Math.PI); ctx.fill();
                drawText(`Midpoint (S/2, S/2)`, s_num*gridSize/2, s_num*gridSize/2 + 10/scale, 'center', 'bottom');
            }

            [[f1_num, f2_num], [f2_num, f1_num]].forEach(([x,y], index) => {
                ctx.fillStyle = shapeStyles.fill.nRect; ctx.fillRect(0, 0, x * gridSize, y * gridSize); ctx.strokeStyle = shapeStyles.stroke.nRect; ctx.strokeRect(0, 0, x * gridSize, y * gridSize);
                if (index === 0 && showLabels) { ctx.fillStyle = 'green'; drawText(`Area = N = ${formatNumberWithCommas(N)}`, x * gridSize / 2, y * gridSize / 2 - 15/scale); }
                const f_min = Math.min(x,y); ctx.fillStyle = shapeStyles.fill.f2Square; ctx.fillRect(0, 0, f_min * gridSize, f_min * gridSize); ctx.strokeStyle = shapeStyles.stroke.f2Square; ctx.strokeRect(0, 0, f_min * gridSize, f_min * gridSize);
                if (index === 0 && showLabels) { ctx.fillStyle = 'blue'; drawText(`Area = F₂²`, f_min * gridSize / 2, f_min * gridSize / 2); }
            });
        }

        ctx.fillStyle = 'green'; ctx.beginPath(); ctx.arc(f1_num * gridSize, f2_num * gridSize, 5/scale, 0, 2*Math.PI); ctx.fill(); ctx.beginPath(); ctx.arc(f2_num * gridSize, f1_num * gridSize, 5/scale, 0, 2*Math.PI); ctx.fill();
        if(showLabels) {
            ctx.fillStyle = 'black';
            drawText(`(${formatNumberWithCommas(f1)}, ${formatNumberWithCommas(f2)})`, f1_num * gridSize + 10/scale, f2_num * gridSize, 'left');
            drawText(`(${formatNumberWithCommas(f2)}, ${formatNumberWithCommas(f1)})`, f2_num * gridSize - 10/scale, f1_num * gridSize, 'right');
        }
    }
     if(handle) {
        const handleSize = Math.max(10, 10/scale);
        ctx.fillStyle = handleColor; ctx.beginPath(); ctx.arc(handle.x * gridSize, handle.y * gridSize, handleSize/2, 0, 2*Math.PI); ctx.fill();
     }
}

function drawHyperbolaVisualization() {
    drawGridLines(true);
    const styles1 = {
        fill: { sTriangle: 'rgba(255, 165, 0, 0.1)', nRect: 'rgba(0, 128, 0, 0.2)', f2Square: 'rgba(0, 0, 255, 0.2)' },
        stroke: { nRect: 'green', f2Square: 'blue' }
    };
    drawHyperbolaLayer(originalInput1, sValue1, 'purple', 'orange', sLineHandle1, (activeTool === 'sHandle1') ? 'blue' : 'orange', true, true, styles1);

     if(isCompareMode && originalInput2.greater(0)) {
        const styles2 = {
            fill: { sTriangle: 'rgba(64, 224, 208, 0.15)', nRect: 'rgba(0, 163, 108, 0.25)', f2Square: 'rgba(0, 128, 128, 0.25)' },
            stroke: { nRect: '#00A36C', f2Square: '#40E0D0' }
        };
        drawHyperbolaLayer(originalInput2, sValue2, '#00A36C', '#40E0D0', sLineHandle2, (activeTool === 'sHandle2') ? '#66DDAA' : '#40E0D0', true, false, styles2);
    }
}


function drawFactorTriangleVisualization() {
    const A_num = aValue.toJSNumber(); if (A_num === 0 || !Number.isFinite(A_num)) return;
    drawGridLines(); const N = originalInput1; const b2 = aValue.square().minus(N); const startX = 2, startY = 2; const handleSize = Math.max(10, 10/scale);
    ctx.fillStyle = "rgba(2, 117, 216, 0.3)"; ctx.strokeStyle = "blue"; ctx.lineWidth = 2 / scale;
    ctx.fillRect(startX * gridSize, startY * gridSize, A_num * gridSize, A_num * gridSize); ctx.strokeRect(startX * gridSize, startY * gridSize, A_num * gridSize, A_num * gridSize);
    ctx.fillStyle = "blue"; ctx.font = `${14 / scale}px Arial`; ctx.textAlign = "center"; ctx.textBaseline = "bottom";
    ctx.fillText(`A = ${formatNumberWithCommas(aValue)}`, (startX + A_num / 2) * gridSize, startY * gridSize - 5/scale); ctx.textBaseline = "middle"; ctx.textAlign = "right"; ctx.fillText("A²", (startX + A_num / 2) * gridSize, (startY + A_num / 2) * gridSize);
    if (b2.isPositive()) {
        const B = customSqrt(b2);
        if (B.square().equals(b2)) {
            const B_num = B.toJSNumber();
            ctx.fillStyle = "rgba(217, 83, 79, 0.3)"; ctx.strokeStyle = "red";
            ctx.fillRect(startX * gridSize, startY * gridSize, B_num * gridSize, B_num * gridSize); ctx.strokeRect(startX * gridSize, startY * gridSize, B_num * gridSize, B_num * gridSize);
            ctx.fillStyle = "red"; ctx.textAlign = "left"; ctx.textBaseline = "middle";
            ctx.fillText(`B = ${formatNumberWithCommas(B)}`, (startX + B_num) * gridSize + 5/scale, (startY + B_num / 2) * gridSize); ctx.fillText("B²", (startX + B_num / 2) * gridSize, (startY + B_num / 2) * gridSize);
            ctx.fillStyle = "rgba(92, 184, 92, 0.5)"; ctx.beginPath(); ctx.moveTo((startX + B_num) * gridSize, startY * gridSize); ctx.lineTo((startX + A_num) * gridSize, startY * gridSize); ctx.lineTo((startX + A_num) * gridSize, (startY + A_num) * gridSize); ctx.lineTo(startX * gridSize, (startY + A_num) * gridSize); ctx.lineTo(startX * gridSize, (startY + B_num) * gridSize); ctx.lineTo((startX + B_num) * gridSize, (startY + B_num) * gridSize); ctx.closePath(); ctx.fill();
            ctx.fillStyle = "green"; ctx.textAlign = "center"; ctx.fillText("N", (startX + A_num) * gridSize, (startY + A_num) * gridSize);
            const triX = startX + A_num + 5; const triY = startY; const triHeight = B_num; const triWidth = Math.sqrt(N.toJSNumber()); const hyp = A_num; const maxDim = Math.max(triWidth, triHeight); const triScale = (A_num / 2) / maxDim;
            ctx.strokeStyle = "black"; ctx.lineWidth = 2 / scale; ctx.beginPath(); ctx.moveTo(triX * gridSize, (triY + triHeight * triScale) * gridSize); ctx.lineTo((triX + triWidth * triScale) * gridSize, (triY + triHeight * triScale) * gridSize); ctx.lineTo(triX * gridSize, triY * gridSize); ctx.closePath(); ctx.stroke();
            ctx.fillStyle = "black"; ctx.font = `${12 / scale}px Arial`; ctx.textAlign = "right"; ctx.fillText(`B = ${formatNumberWithCommas(B)}`, triX * gridSize - 5/scale, (triY + triHeight * triScale / 2) * gridSize); ctx.textAlign = "center"; ctx.textBaseline = "top"; ctx.fillText(`√N ≈ ${triWidth.toFixed(2)}`, (triX + triWidth*triScale/2) * gridSize, (triY + triHeight * triScale) * gridSize + 5/scale);
            ctx.save(); ctx.translate((triX + triWidth * triScale / 2) * gridSize, (triY + triHeight*triScale/2)*gridSize); ctx.rotate(Math.atan2(-triHeight, triWidth)); ctx.textBaseline = "bottom"; ctx.fillText(`A = ${formatNumberWithCommas(aValue)}`, 0, -5/scale); ctx.restore();
        }
    }
    ctx.fillStyle = (activeTool === 'aHandle') ? "blue" : "orange"; ctx.fillRect(aSquareHandle.x * gridSize - handleSize/2, aSquareHandle.y * gridSize - handleSize/2, handleSize, handleSize);
}


function drawFactorizationVisualization() {
    ctx.strokeStyle = "blue"; ctx.lineWidth = 2/scale; ctx.strokeRect(rect.x * gridSize, rect.y * gridSize, rect.w * gridSize, rect.h * gridSize); ctx.strokeStyle = "red"; ctx.beginPath(); ctx.moveTo(rect.x * gridSize, rect.y * gridSize); ctx.lineTo((rect.x + rect.w) * gridSize, (rect.y + rect.h) * gridSize); ctx.stroke(); ctx.strokeStyle = "green"; ctx.beginPath(); ctx.moveTo((rect.x + rect.w) * gridSize, rect.y * gridSize); ctx.lineTo(rect.x * gridSize, (rect.y + rect.h) * gridSize); ctx.stroke();
    if ((!isBigNumberMode && totalBlocks && totalBlocks.greater(0)) || (isBigNumberMode && totalExponent)) { let side; if (isBigNumberMode) { side = totalExponent.divide(2).toJSNumber(); } else { side = customSqrt(totalBlocks).toJSNumber(); } ctx.strokeStyle = "yellow"; ctx.lineWidth = 2 / scale; ctx.setLineDash([10 / scale, 10 / scale]); ctx.strokeRect(rect.x * gridSize, rect.y * gridSize, side * gridSize, side * gridSize); ctx.setLineDash([]); }
    let handleSize = Math.max(10, 10/scale); for (let h of handles) { ctx.fillStyle = (activeTool === 'handle' && activeHandleName === h.name) ? "blue" : "orange"; ctx.fillRect(h.x * gridSize - handleSize/2, h.y * gridSize - handleSize/2, handleSize, handleSize); }
}

function drawCongruenceVisualization() {
    if (ySquareSize > 0) { ctx.fillStyle = "rgba(92, 184, 92, 0.5)"; ctx.strokeStyle = "green"; ctx.lineWidth = 2/scale; ctx.fillRect(xSquare.x * gridSize, xSquare.y * gridSize, ySquareSize * gridSize, ySquareSize * gridSize); ctx.strokeRect(xSquare.x * gridSize, xSquare.y * gridSize, ySquareSize * gridSize, ySquareSize * gridSize); ctx.fillStyle = "green"; ctx.font = `${14 / scale}px Arial`; ctx.fillText(`y = ${formatNumberWithCommas(yValue)}`, (xSquare.x + ySquareSize) * gridSize + 5/scale, xSquare.y * gridSize + 15/scale); }
    ctx.fillStyle = "rgba(2, 117, 216, 0.3)"; ctx.strokeStyle = "blue"; ctx.lineWidth = 2/scale; ctx.fillRect(xSquare.x * gridSize, xSquare.y * gridSize, xSquare.size * gridSize, xSquare.size * gridSize); ctx.strokeRect(xSquare.x * gridSize, xSquare.y * gridSize, xSquare.size * gridSize, xSquare.size * gridSize); ctx.fillStyle = "blue"; ctx.font = `${14 / scale}px Arial`; ctx.fillText(`x = ${document.getElementById('xValueInput').value}`, (xSquare.x + xSquare.size) * gridSize + 5/scale, xSquare.y * gridSize + 15/scale); let handleSize = Math.max(10, 10/scale); ctx.fillStyle = (activeTool === 'xHandle') ? "blue" : "orange"; ctx.fillRect(xSquareHandle.x * gridSize - handleSize/2, xSquareHandle.y * gridSize - handleSize/2, handleSize, handleSize);
}


// --- Event Handlers & Controls ---
function getMousePos(e, isTouch = false) {
    const input = isTouch ? e.touches[0] : e;
    const isCartesian = currentMode === 'hyperbola' || currentMode === 'm_search';
    let mx, my;

    if (isCartesian) {
        mx = (input.clientX - canvas.width / 2 - offsetX) / scale / gridSize;
        my = -(input.clientY - canvas.height / 2 - offsetY) / scale / gridSize;
    } else {
        mx = (input.clientX - offsetX) / scale / gridSize;
        my = (input.clientY - offsetY) / scale / gridSize;
    }
    return { mx, my };
}

function mousedown(e) {
    const { mx, my } = getMousePos(e);
    const handleRadius = Math.max(15, 15/scale) / gridSize;

    if (currentMode === 'm_search') {
        if (mLineHandle1 && (dist(mx, my, mLineHandle1.p1.x, mLineHandle1.p1.y) < handleRadius || dist(mx, my, mLineHandle1.p2.x, mLineHandle1.p2.y) < handleRadius)) { activeTool = 'mHandle1'; return; }
        if (isCompareMode && mLineHandle2 && (dist(mx, my, mLineHandle2.p1.x, mLineHandle2.p1.y) < handleRadius || dist(mx, my, mLineHandle2.p2.x, mLineHandle2.p2.y) < handleRadius)) { activeTool = 'mHandle2'; return; }
    } else if (currentMode === 'hyperbola') {
        if (sLineHandle1 && dist(mx, my, sLineHandle1.x, sLineHandle1.y) < handleRadius) { activeTool = 'sHandle1'; return; }
        if (isCompareMode && sLineHandle2 && dist(mx, my, sLineHandle2.x, sLineHandle2.y) < handleRadius) { activeTool = 'sHandle2'; return; }
    } else if (currentMode === 'factorTriangle') {
        if (dist(mx, my, aSquareHandle.x, aSquareHandle.y) < handleRadius) { activeTool = 'aHandle'; return; }
    } else if (isCongruenceMode) {
        if (dist(mx, my, xSquareHandle.x, xSquareHandle.y) < handleRadius) { activeTool = 'xHandle'; return; }
    } else if (currentMode === 'rectangle') {
        for (let h of handles) { if (dist(mx, my, h.x, h.y) < handleRadius) { activeTool = 'handle'; activeHandleName = h.name; return; } }
    }

    activeTool = 'pan';
    lastPan = { x: e.clientX, y: e.clientY };
}

function mousemove(e) {
 if (!activeTool) return;
 const { mx, my } = getMousePos(e);

 if (activeTool === 'mHandle1' || activeTool === 'mHandle2') {
    if (Math.abs(mx) > 0.01) {
        const angle = Math.atan2(my, mx);
        const newM = bigInt(Math.round(Math.tan(angle)));
        if(activeTool === 'mHandle1' && !mValue1.equals(newM)) { mValue1 = newM; document.getElementById('mValueInput1').value = mValue1.toString(); updateMSearch(); }
        if(activeTool === 'mHandle2' && !mValue2.equals(newM)) { mValue2 = newM; document.getElementById('mValueInput2').value = mValue2.toString(); updateMSearch2(); }
    }
    autoPanOnEdgeDrag(e.clientX, e.clientY);
 } else if (activeTool === 'sHandle1' || activeTool === 'sHandle2') {
    const newS = bigInt(Math.round(my + mx));
    if(activeTool === 'sHandle1' && !sValue1.equals(newS)){ sValue1 = newS; document.getElementById('sValueInput1').value = sValue1.toString(); updateHyperbolaSearch();}
    if(activeTool === 'sHandle2' && !sValue2.equals(newS)){ sValue2 = newS; document.getElementById('sValueInput2').value = sValue2.toString(); updateHyperbolaSearch2();}
    autoPanOnEdgeDrag(e.clientX, e.clientY);
 } else if (activeTool === 'aHandle') { const newA = bigInt(Math.max(1, Math.round(mx - 2))); if (!aValue.equals(newA)) { aValue = newA; document.getElementById('aValueInput').value = aValue.toString(); updateFactorTriangle(); } autoPanOnEdgeDrag(e.clientX, e.clientY);
 } else if (activeTool === 'handle') { handleResize(mx, my); autoPanOnEdgeDrag(e.clientX, e.clientY);
 } else if (activeTool === 'xHandle') { const newSize = Math.max(1, Math.round(mx - xSquare.x)); xSquare.size = newSize; document.getElementById('xValueInput').value = newSize; updateCongruence(); updateHandles(); autoPanOnEdgeDrag(e.clientX, e.clientY);
 } else if (activeTool === 'pan' && lastPan) {
    const deltaX = e.clientX - lastPan.x;
    let deltaY = e.clientY - lastPan.y;
    offsetX += deltaX;
    offsetY += deltaY;
    lastPan = {x: e.clientX, y: e.clientY};
 }
}

canvas.addEventListener("mousedown", mousedown); canvas.addEventListener("mousemove", mousemove); canvas.addEventListener("mouseup", () => { activeTool = null; activeHandleName = null; lastPan = null; }); canvas.addEventListener("mouseleave", () => { activeTool = null; activeHandleName = null; lastPan = null; });
canvas.addEventListener('wheel', e => { e.preventDefault(); const factor = Math.pow(1.001, -e.deltaY);
    const isCartesian = currentMode === 'hyperbola' || currentMode === 'm_search';
    let mouseX = e.offsetX;
    let mouseY = e.offsetY;

    if(isCartesian){
      offsetX = mouseX - canvas.width/2 - (mouseX - canvas.width/2 - offsetX) * factor;
      offsetY = mouseY - canvas.height/2 - (mouseY - canvas.height/2 - offsetY) * factor;
    } else {
       offsetX = mouseX - (mouseX - offsetX) * factor;
       offsetY = mouseY - (mouseY - offsetY) * factor;
    }
    scale *= factor;
}, { passive: false });


// TOUCH CONTROLS
function getTouchPos(e, isTouch = false) { // Duplicated for touch context
    const input = isTouch ? e.touches[0] : e;
    const isCartesian = currentMode === 'hyperbola' || currentMode === 'm_search';
    let mx, my;

    if (isCartesian) {
        mx = (input.clientX - canvas.width / 2 - offsetX) / scale / gridSize;
        my = -(input.clientY - canvas.height / 2 - offsetY) / scale / gridSize;
    } else {
        mx = (input.clientX - offsetX) / scale / gridSize;
        my = (input.clientY - offsetY) / scale / gridSize;
    }
    return { mx, my };
}

function touchstart(e) {
    e.preventDefault(); const touches = e.touches;
    if (touches.length === 1) {
        const { mx, my } = getTouchPos(e, true);
        const handleRadius = Math.max(25, 25/scale) / gridSize;

        if (currentMode === 'm_search') {
            if (mLineHandle1 && (dist(mx, my, mLineHandle1.p1.x, mLineHandle1.p1.y) < handleRadius || dist(mx, my, mLineHandle1.p2.x, mLineHandle1.p2.y) < handleRadius)) { activeTool = 'mHandle1'; return; }
            if (isCompareMode && mLineHandle2 && (dist(mx, my, mLineHandle2.p1.x, mLineHandle2.p1.y) < handleRadius || dist(mx, my, mLineHandle2.p2.x, mLineHandle2.p2.y) < handleRadius)) { activeTool = 'mHandle2'; return; }
        } else if (currentMode === 'hyperbola') {
            if (sLineHandle1 && dist(mx, my, sLineHandle1.x, sLineHandle1.y) < handleRadius) { activeTool = 'sHandle1'; return; }
            if (isCompareMode && sLineHandle2 && dist(mx, my, sLineHandle2.x, sLineHandle2.y) < handleRadius) { activeTool = 'sHandle2'; return; }
        } else if (currentMode === 'factorTriangle') {
            if (dist(mx, my, aSquareHandle.x, aSquareHandle.y) < handleRadius) { activeTool = 'aHandle'; return; }
        } else if (isCongruenceMode) {
            if (dist(mx, my, xSquareHandle.x, xSquareHandle.y) < handleRadius) { activeTool = 'xHandle'; return; }
        } else if (currentMode === 'rectangle') {
            for (let h of handles) { if (dist(mx, my, h.x, h.y) < handleRadius) { activeTool = 'handle'; activeHandleName = h.name; return; } }
        }

        activeTool = 'pan'; lastPan = { x: touches[0].clientX, y: touches[0].clientY };
    } else if (touches.length === 2) { activeTool = 'zoom'; lastTouchDist = dist(touches[0].clientX, touches[0].clientY, touches[1].clientX, touches[1].clientY); lastPan = { x: (touches[0].clientX + touches[1].clientX) / 2, y: (touches[0].clientY + touches[1].clientY) / 2 }; }
}

function touchmove(e) {
    e.preventDefault(); if (!activeTool) return; const touches = e.touches;
    if (touches.length === 1) {
        const touch = touches[0];
        const { mx, my } = getTouchPos(e, true);

        if (activeTool === 'pan') {
            const deltaX = touch.clientX - lastPan.x;
            const deltaY = touch.clientY - lastPan.y;
            offsetX += deltaX;
            offsetY += deltaY;
            lastPan = { x: touch.clientX, y: touch.clientY };
        } else if (activeTool === 'mHandle1' || activeTool === 'mHandle2') {
            if (Math.abs(mx) > 0.1) {
                const angle = Math.atan2(my, mx);
                const newM = bigInt(Math.round(Math.tan(angle)));
                if(activeTool === 'mHandle1' && !mValue1.equals(newM)){ mValue1 = newM; document.getElementById('mValueInput1').value = mValue1.toString(); updateMSearch(); }
                if(activeTool === 'mHandle2' && !mValue2.equals(newM)){ mValue2 = newM; document.getElementById('mValueInput2').value = mValue2.toString(); updateMSearch2(); }
            }
        } else if (activeTool === 'sHandle1' || activeTool === 'sHandle2') {
            const newS = bigInt(Math.round(my + mx));
            if(activeTool === 'sHandle1' && !sValue1.equals(newS)){ sValue1 = newS; document.getElementById('sValueInput1').value = sValue1.toString(); updateHyperbolaSearch();}
            if(activeTool === 'sHandle2' && !sValue2.equals(newS)){ sValue2 = newS; document.getElementById('sValueInput2').value = sValue2.toString(); updateHyperbolaSearch2();}
        } else if (activeTool === 'aHandle') { const newA = bigInt(Math.max(1, Math.round(mx - 2))); if (!aValue.equals(newA)) { aValue = newA; document.getElementById('aValueInput').value = aValue.toString(); updateFactorTriangle(); }
        } else if (activeTool === 'handle' || activeTool === 'xHandle') { if (activeTool === 'handle') { handleResize(mx, my); } else { const newSize = Math.max(1, Math.round(mx - xSquare.x)); xSquare.size = newSize; document.getElementById('xValueInput').value = newSize; updateCongruence(); updateHandles(); } autoPanOnEdgeDrag(touch.clientX, touch.clientY); }
    } else if (activeTool === 'zoom' && touches.length === 2) { let newDist = dist(touches[0].clientX, touches[0].clientY, touches[1].clientX, touches[1].clientY); let factor = newDist / lastTouchDist; let mid = { x: (touches[0].clientX + touches[1].clientX) / 2, y: (touches[0].clientY + touches[1].clientY) / 2 }; offsetX += mid.x - lastPan.x; offsetY += mid.y - lastPan.y; offsetX = mid.x - ((mid.x - offsetX) * factor); offsetY = mid.y - ((mid.y - offsetY) * factor); scale *= factor; lastTouchDist = newDist; lastPan = mid; }
}

function touchend(e) { e.preventDefault(); if (e.touches.length < 2) lastTouchDist = 0; if (e.touches.length === 0) { activeTool = null; activeHandleName = null; } }
canvas.addEventListener("touchstart", touchstart, { passive: false }); canvas.addEventListener("touchmove", touchmove, { passive: false }); canvas.addEventListener("touchend", touchend, { passive: false }); canvas.addEventListener("touchcancel", touchend, { passive: false });

// --- UI Event Listeners ---
document.querySelectorAll('input[name="visMode"]').forEach(radio => {
    radio.addEventListener('change', (e) => {
        currentMode = e.target.value;
        const isGraphMode = currentMode === 'hyperbola' || currentMode === 'm_search' || currentMode === 'factorTriangle';
        document.getElementById('formulaContainer').style.display = isGraphMode ? 'block' : 'none';
        document.getElementById('gnomonFormulas').style.display = (currentMode === 'factorTriangle') ? 'block' : 'none';
        document.getElementById('hyperbolaFormulas').style.display = (currentMode === 'hyperbola') ? 'block' : 'none';
        document.getElementById('msearchFormulas').style.display = (currentMode === 'm_search') ? 'block' : 'none';

        document.getElementById('mSearchControls').style.display = (currentMode === 'm_search') ? 'block' : 'none';
        document.getElementById('factorTriangleControls').style.display = (currentMode === 'factorTriangle') ? 'block' : 'none';
        document.getElementById('hyperbolaControls').style.display = (currentMode === 'hyperbola') ? 'block' : 'none';
        document.getElementById('factorizationControls').style.display = (currentMode === 'rectangle') ? 'block' : 'none';
        document.getElementById('congruenceToggleContainer').style.display = (currentMode === 'rectangle') ? 'block' : 'none';
        document.getElementById('congruenceControls').style.display = 'none'; document.getElementById('congruenceToggle').checked = false; isCongruenceMode = false; isSuccessState = false; canvas.style.backgroundColor = "#fff";

        const isCompareModeChecked = document.getElementById('compareToggle').checked;
        const showS2 = isCompareModeChecked && currentMode === 'hyperbola';
        document.getElementById('s2Controls').style.display = showS2 ? 'block' : 'none';
        document.getElementById('hyperbolaResults2').style.display = showS2 ? 'block' : 'none';
        const showM2 = isCompareModeChecked && currentMode === 'm_search';
        document.getElementById('m2Controls').style.display = showM2 ? 'block' : 'none';
        document.getElementById('mSearchResults2').style.display = showM2 ? 'block' : 'none';

        performCalculation();
    });
});

document.getElementById('compareToggle').addEventListener('change', (e) => {
    isCompareMode = e.target.checked;
    document.getElementById('compareControls').style.display = isCompareMode ? 'block' : 'none';
    const showS2 = isCompareMode && currentMode === 'hyperbola';
    document.getElementById('s2Controls').style.display = showS2 ? 'block' : 'none';
    document.getElementById('hyperbolaResults2').style.display = showS2 ? 'block' : 'none';
    const showM2 = isCompareMode && currentMode === 'm_search';
    document.getElementById('m2Controls').style.display = showM2 ? 'block' : 'none';
    document.getElementById('mSearchResults2').style.display = showM2 ? 'block' : 'none';
    if (isCompareMode) {
        performCalculation2();
    }
    updateHandles();
});


document.getElementById('mValueInput1').addEventListener('input', () => { try { const val = bigInt(document.getElementById('mValueInput1').value); mValue1 = val; updateMSearch(); } catch(e){} });
document.getElementById('mValueInput2').addEventListener('input', () => { try { const val = bigInt(document.getElementById('mValueInput2').value); mValue2 = val; updateMSearch2(); } catch(e){} });
document.getElementById('sValueInput1').addEventListener('input', () => { try { const val = bigInt(document.getElementById('sValueInput1').value); if(val.geq(0)) { sValue1 = val; updateHyperbolaSearch(); } } catch(e){} });
document.getElementById('sValueInput2').addEventListener('input', () => { try { const val = bigInt(document.getElementById('sValueInput2').value); if(val.geq(0)) { sValue2 = val; updateHyperbolaSearch2(); } } catch(e){} });
document.getElementById('aValueInput').addEventListener('input', () => { try { const val = bigInt(document.getElementById('aValueInput').value); if (val.geq(0)) { aValue = val; updateFactorTriangle(); } } catch(e) {} });


// --- UTILITY FUNCTIONS ---
function autoPanOnEdgeDrag(clientX, clientY) { const panThreshold = canvas.width * 0.10; const panSpeedFactor = 1.5; if (clientX < panThreshold) { offsetX += (panThreshold - clientX) * panSpeedFactor; } else if (clientX > canvas.width - panThreshold) { offsetX -= (clientX - (canvas.width - panThreshold)) * panSpeedFactor; } if (clientY < panThreshold) { offsetY += (panThreshold - clientY) * panSpeedFactor; } else if (clientY > canvas.height - panThreshold) { offsetY -= (clientY - (canvas.height - panThreshold)) * panSpeedFactor; } }
function handleResize(mx, my) { const right = rect.x + rect.w, bottom = rect.y + rect.h; switch (activeHandleName) { case "tl": rect.x = mx; rect.y = my; rect.w = right - rect.x; rect.h = bottom - rect.y; break; case "tr": rect.y = my; rect.w = mx - rect.x; rect.h = bottom - rect.y; break; case "bl": rect.x = mx; rect.w = right - rect.x; rect.h = my - rect.y; break; case "br": rect.w = mx - rect.x; rect.h = my - rect.y; break; } let swappedX = false, swappedY = false; if (rect.w < 0) { rect.x += rect.w; rect.w *= -1; swappedX = true; } if (rect.h < 0) { rect.y += rect.h; rect.h *= -1; swappedY = true; } if (swappedX) activeHandleName = activeHandleName.includes('l') ? activeHandleName.replace('l', 'r') : activeHandleName.replace('r', 'l'); if (swappedY) activeHandleName = activeHandleName.includes('t') ? activeHandleName.replace('t', 'b') : activeHandleName.replace('b', 't'); rect.w = Math.max(1, Math.round(rect.w)); rect.h = Math.max(1, Math.round(rect.h)); rect.x = Math.round(rect.x); rect.y = Math.round(rect.y); exactWidth = bigInt(rect.w); exactHeight = bigInt(rect.h); updateHandles(); }
window.addEventListener('resize', () => { canvas.width = window.innerWidth; canvas.height = window.innerHeight; });
valueInput1.addEventListener('keyup', e => { if (e.key === 'Enter') performCalculation(); });
valueInput2.addEventListener('keyup', e => { if (e.key === 'Enter') performCalculation2(); });
document.getElementById('xValueInput').addEventListener('input', () => { try { const val = bigInt(document.getElementById('xValueInput').value); if (val.geq(0)) { xSquare.size = val.toJSNumber(); updateCongruence(); } } catch(e) {} });
document.getElementById('congruenceToggle').addEventListener('change', (e) => { isCongruenceMode = e.target.checked; document.getElementById('congruenceControls').style.display = isCongruenceMode ? 'block' : 'none'; document.getElementById('factorizationControls').style.display = isCongruenceMode ? 'none' : 'block'; if (isCongruenceMode) { try { const xVal = bigInt(document.getElementById('xValueInput').value); if (xVal.geq(0)) { xSquare.size = xVal.toJSNumber(); } } catch(err) {} updateCongruence(); updateHandles(); zoomToFit(xSquare); } else { updateHandles(); zoomToFit(rect); } });

function zoomToFit(target) {
    if (!target) return;
    const padding = 1.5;
    let targetW, targetH, targetX, targetY;
    if ('size' in target) {
        targetW = target.size; targetH = target.size; targetX = target.x; targetY = target.y;
    } else {
        targetW = target.w; targetH = target.h; targetX = target.x; targetY = target.y;
    }
    if(!Number.isFinite(targetW) || !Number.isFinite(targetH) || targetW === 0 || targetH === 0) return;

    const scaleX = canvas.width / (targetW * gridSize * padding);
    const scaleY = canvas.height / (targetH * gridSize * padding);
    scale = Math.min(scaleX, scaleY);

    const cX = targetX + targetW / 2;
    const cY = targetY + targetH / 2;

    const isCartesian = currentMode === 'hyperbola' || currentMode === 'm_search';
    if(isCartesian){
        offsetX = -cX * gridSize * scale;
        offsetY = cY * gridSize * scale; // Invert Y offset for cartesian
    } else {
        offsetX = (canvas.width / 2) - (cX * gridSize * scale);
        offsetY = (canvas.height / 2) - (cY * gridSize * scale);
    }
}


function updateHandles() {
 const startX = 2, startY = 2;
 if (currentMode === 'm_search') {
    const m_num1 = mValue1.toJSNumber();
    const handleRadius = 30; // pixels on the grid
    if (Number.isFinite(m_num1)) {
        const norm = Math.sqrt(1 + m_num1*m_num1);
        mLineHandle1 = { p1: { x: handleRadius / norm, y: handleRadius * m_num1 / norm }, p2: { x: -handleRadius / norm, y: -handleRadius * m_num1 / norm } };
    } else { mLineHandle1 = null; }

    if (isCompareMode) {
        const m_num2 = mValue2.toJSNumber();
        if (Number.isFinite(m_num2)) {
            const norm = Math.sqrt(1 + m_num2 * m_num2);
            mLineHandle2 = { p1: { x: handleRadius / norm, y: handleRadius * m_num2 / norm }, p2: { x: -handleRadius / norm, y: -handleRadius * m_num2 / norm } };
        } else { mLineHandle2 = null; }
    }

 } else if (currentMode === 'hyperbola') {
    const s_num1 = sValue1.toJSNumber();
    if (Number.isFinite(s_num1)) sLineHandle1 = { x: s_num1/2, y: s_num1/2 };
    if(isCompareMode) {
        const s_num2 = sValue2.toJSNumber();
        if (Number.isFinite(s_num2)) sLineHandle2 = { x: s_num2/2, y: s_num2/2 };
    }
 } else if (currentMode === 'factorTriangle') {
    const A_num = aValue.toJSNumber(); if(Number.isFinite(A_num)) { aSquareHandle = { x: startX + A_num, y: startY + A_num }; }
 } else if (isCongruenceMode) {
    xSquareHandle = { x: xSquare.x + xSquare.size, y: xSquare.y + xSquare.size };
 } else {
    handles = [ {x: rect.x, y: rect.y, name: "tl"}, {x: rect.x + rect.w, y: rect.y, name: "tr"}, {x: rect.x, y: rect.y + rect.h, name: "bl"}, {x: rect.x + rect.w, y: rect.y + rect.h, name: "br"} ];
 }
}

function updateInfoPanel() {
    if (currentMode !== 'rectangle' || isCongruenceMode) return;
    const blocksUsed = exactWidth.times(exactHeight); let isWDiv = false, isHDiv = false;
    if (!isBigNumberMode) { isWDiv = exactWidth.greater(0) && originalInput1.mod(exactWidth).isZero(); isHDiv = exactHeight.greater(0) && originalInput1.mod(exactHeight).isZero();
    } else { if (totalBase && totalExponent && totalMultiplication && totalAddition) { if (exactWidth.greater(0)) { let term1 = totalMultiplication.mod(exactWidth); let term2 = totalBase.modPow(totalExponent, exactWidth); let rem = term1.multiply(term2).plus(totalAddition).mod(exactWidth); if (rem.isNegative()) rem = rem.add(exactWidth); isWDiv = rem.isZero(); } if (exactHeight.greater(0)) { let term1 = totalMultiplication.mod(exactHeight); let term2 = totalBase.modPow(totalExponent, exactHeight); let rem = term1.multiply(term2).plus(totalAddition).mod(exactHeight); if (rem.isNegative()) rem = rem.add(exactHeight); isHDiv = rem.isZero(); } } }
    infoWidth.className = isWDiv ? "green-text" : "red-text"; infoHeight.className = isHDiv ? "green-text" : "red-text";
    if (isBigNumberMode) {
        widthLabel.innerText = "Width (log):"; heightLabel.innerText = "Height (log):"; labelTotalBlocks.style.display = 'inline'; labelBlocksRemaining.style.display = 'none'; labelModRemainder.style.display = 'inline'; infoBlocks.style.display = 'none'; infoModRemainder.style.display = 'inline';
        let baseStr = totalBase.toString(); let multStr = totalMultiplication.toString(); let addStr = totalAddition.isNegative() ? ` - ${totalAddition.abs()}` : totalAddition.isZero() ? "" : ` + ${totalAddition}`;
        if (multStr === "1") { totalBlocksDisplay.innerText = `${baseStr}^${formatNumberWithCommas(totalExponent)}${addStr}`; } else { totalBlocksDisplay.innerText = `${multStr} * ${baseStr}^${formatNumberWithCommas(totalExponent)}${addStr}`; }
        if (blocksUsed.isZero()) { infoModRemainder.innerText = "N/A"; infoModRemainder.className = ""; } else { const term1 = totalMultiplication.mod(blocksUsed); const term2 = totalBase.modPow(totalExponent, blocksUsed); let totalRemainder = term1.multiply(term2).plus(totalAddition).mod(blocksUsed); if (totalRemainder.isNegative()) { totalRemainder = totalRemainder.add(blocksUsed); } infoModRemainder.innerText = formatNumberWithCommas(totalRemainder); infoModRemainder.className = totalRemainder.isZero() ? "green-text" : "red-text"; }
    } else {
        widthLabel.innerText = "Width (A):"; heightLabel.innerText = "Height (B):"; labelModRemainder.style.display='none'; infoModRemainder.style.display='none'; labelBlocksRemaining.style.display='inline'; infoBlocks.style.display='inline'; totalBlocksDisplay.innerText = formatNumberWithCommas(totalBlocks); const rem = totalBlocks.minus(blocksUsed); infoBlocks.innerText = formatNumberWithCommas(rem); infoBlocks.className = rem.isZero() ? "green-text" : "red-text";
    }
    infoWidth.innerText = formatNumberWithCommas(exactWidth); infoHeight.innerText = formatNumberWithCommas(exactHeight); infoSlope.innerText = rect.w === 0 ? 'inf' : (rect.h / rect.w).toFixed(2); infoAngle.innerText = (Math.atan2(rect.h, rect.w) * 180 / Math.PI).toFixed(1); infoCenterPoint.innerText = `(${(rect.w / 2).toFixed(1)}, ${(rect.h / 2).toFixed(1)})`;
    if (primeToggleEl.checked) { const wStr = exactWidth.toString(); const hStr = exactHeight.toString(); const widthPrimeEl = document.getElementById('widthPrime'); const heightPrimeEl = document.getElementById('heightPrime'); if (wStr !== lastWidthStr) { lastWidthStr = wStr; setPrimeBadge(widthPrimeEl, primeStatus(exactWidth)); } if (hStr !== lastHeightStr) { lastHeightStr = hStr; setPrimeBadge(heightPrimeEl, primeStatus(exactHeight)); }
    } else { setPrimeBadge(document.getElementById('widthPrime'), "too-large"); setPrimeBadge(document.getElementById('heightPrime'), "too-large"); }
    const blocksMatch = isBigNumberMode ? (infoModRemainder.className === 'green-text') : blocksUsed.equals(originalInput1);
    const bothFactors = isWDiv && isHDiv && blocksMatch;
    if (bothFactors) { canvas.style.backgroundColor = "lime"; if (!isSuccessState) { createFireworks(); isSuccessState = true; } } else if (isWDiv || isHDiv) { canvas.style.backgroundColor = "yellow"; isSuccessState = false; } else { canvas.style.backgroundColor = "#fff"; isSuccessState = false; }
}

function customSqrt(n) { if (n.isNegative()) return bigInt(-1); if (n.lesserOrEquals(1)) return n; let x = n.shiftRight(1), y; while (true) { y = x.add(n.divide(x)).shiftRight(1); if (y.geq(x)) return x; x = y; }}
function dist(x1, y1, x2, y2) { return Math.hypot(x2 - x1, y2 - y1); }
function formatNumberWithCommas(n) { return !n ? "" : n.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ","); }
const FIREWORK_COUNT = 200, FIREWORK_LIFETIME = 200;
function createFireworks() { fireworks = []; const maxVel = Math.max(canvas.width, canvas.height) * 0.02; for (let i = 0; i < FIREWORK_COUNT; i++) { fireworks.push({ x: canvas.width / 2, y: canvas.height / 2, vx: (Math.random() - 0.5) * maxVel, vy: (Math.random() - 0.5) * maxVel, radius: 3 + Math.random() * 2, color: `hsl(${Math.random() * 360}, 100%, 50%)`, alpha: 1, life: FIREWORK_LIFETIME }); } }
function drawFireworks() { for (let i = fireworks.length - 1; i >= 0; i--) { let p = fireworks[i]; p.x += p.vx; p.y += p.vy; p.vy += 0.05; p.alpha = p.life / FIREWORK_LIFETIME; p.life--; if (p.life <= 0) { fireworks.splice(i, 1); continue; } ctx.fillStyle = p.color; ctx.globalAlpha = p.alpha; ctx.beginPath(); ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2); ctx.fill(); } ctx.globalAlpha = 1; }

window.onload = function() { performCalculation(); requestAnimationFrame(draw); };
</script>
</body>
</html>

