<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Enhanced Interactive Prime Grid</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body {
      background-color: #1a1a1a;
      color: #e5e7eb;
      font-family: 'Inter', sans-serif;
      user-select: none;
    }

    .grid-container {
      display: grid;
      border: 1px solid #333;
      background-color: #222;
      cursor: grab;
      grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
      gap: 1px;
      transform-origin: 0 0;
      touch-action: none;
      min-height: 200px;
    }

    .grid-cell {
      width: 60px;
      height: 60px;
      background-color: #2c2c2c;
      border: 1px solid #333;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      font-weight: bold;
      transition: background-color 0.5s ease-in-out;
      word-break: break-all;
      overflow: hidden;
    }

    .grid-cell.prime { background-color: var(--prime-color, #34d399); }
    .grid-cell.composite { background-color: var(--composite-color, #ef4444); }
    .grid-cell.multiple-of-6 { background-color: var(--multiple-of-6-color, #a855f7); }
    .grid-cell.selected-prime { box-shadow: 0 0 0 3px #1e90ff inset; }

    .grid-cell.is-factor { background-color: #facc15; } /* Yellow background for factors */

    .grid-cell.sieve-marked { background-color: #4b5563; } /* Sieve animation color */
    .grid-cell.sieve-prime { background-color: #4ade80; animation: bounce-in 0.5s ease-out; }
    .grid-cell.highlighted-pair { box-shadow: 0 0 0 3px yellow inset; }

    @keyframes bounce-in {
      0% { transform: scale(0.5); opacity: 0; }
      100% { transform: scale(1); opacity: 1; }
    }

    /* Bottom sheet modal */
    .bottom-sheet {
      position: fixed;
      bottom: -100%;
      left: 0;
      right: 0;
      background: #1f2937;
      border-top-left-radius: 1rem;
      border-top-right-radius: 1rem;
      box-shadow: 0 -4px 12px rgba(0,0,0,0.5);
      transition: bottom 0.3s ease-in-out;
      max-height: 60%;
      overflow-y: auto;
      padding: 1rem;
      z-index: 50;
    }
    .bottom-sheet.active {
      bottom: 0;
    }

    /* Message box */
    .message-box {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #2c3e50;
      color: white;
      padding: 2rem;
      border-radius: 1rem;
      box-shadow: 0 4px 12px rgba(0,0,0,0.5);
      z-index: 100;
      display: none;
    }
    .message-box.active {
      display: block;
    }
  </style>
</head>
<body class="p-4">
  <div class="max-w-7xl mx-auto space-y-6">
    <header class="text-center">
      <h1 class="text-2xl font-bold">Number Grid Visualizer</h1>
      <p id="gridRangeDisplay" class="text-gray-400">Explore prime numbers and their patterns</p>
    </header>

    <section class="bg-gray-800 p-4 rounded-lg shadow space-y-4">
      <div class="flex flex-wrap items-center gap-4">
        <div>
          <label for="startInput" class="block text-sm text-gray-400">Start</label>
          <input type="text" id="startInput" value="100000" class="mt-1 w-28 px-2 py-1 bg-gray-700 border border-gray-600 rounded-md text-gray-300">
        </div>
        <div>
          <label for="endInput" class="block text-sm text-gray-400">End</label>
          <input type="text" id="endInput" value="100200" class="mt-1 w-28 px-2 py-1 bg-gray-700 border border-gray-600 rounded-md text-gray-300">
        </div>
        <div>
          <label for="columns" class="block text-sm text-gray-400">Columns</label>
          <select id="columns" class="mt-1 w-28 px-2 py-1 bg-gray-700 border border-gray-600 rounded-md text-gray-300">
            <option value="auto">Auto</option>
            <option value="6">6</option>
            <option value="12">12</option>
            <option value="24">24</option>
            <option value="48">48</option>
          </select>
        </div>
        <div>
          <label for="primeColor" class="block text-sm text-gray-400">Prime Color</label>
          <input type="color" id="primeColor" value="#34d399" class="mt-1 w-24 h-8 bg-gray-700 rounded-md">
        </div>
        <div>
          <label for="compositeColor" class="block text-sm text-gray-400">Composite Color</label>
          <input type="color" id="compositeColor" value="#ef4444" class="mt-1 w-24 h-8 bg-gray-700 rounded-md">
        </div>
      </div>
      <div class="flex flex-wrap gap-2">
        <button id="drawButton" class="px-3 py-1 bg-blue-600 hover:bg-blue-700 text-white font-bold rounded">Draw</button>
        <button id="sieveButton" class="px-3 py-1 bg-teal-600 hover:bg-teal-700 text-white font-bold rounded" disabled>Sieve</button>
        <button id="clearButton" class="px-3 py-1 bg-gray-600 hover:bg-gray-700 text-white font-bold rounded">Clear</button>
      </div>
      <div class="mt-4 flex flex-wrap items-center gap-4">
        <div>
          <label for="primePairDifference" class="block text-sm text-gray-400">Highlight Prime Pairs with difference of</label>
          <input type="text" id="primePairDifference" value="2" class="mt-1 w-24 px-2 py-1 bg-gray-700 border border-gray-600 rounded-md text-gray-300">
        </div>
        <button id="highlightPairsButton" class="px-3 py-1 bg-yellow-500 hover:bg-yellow-600 text-gray-900 font-bold rounded">Highlight Pairs</button>
      </div>
      <!-- Updated div with Square Root input field -->
      <div class="mt-4 flex flex-wrap items-center gap-4">
        <div>
          <label for="targetNumberInput" class="block text-sm text-gray-400">Target Number (for P * Q)</label>
          <input type="text" id="targetNumberInput" class="mt-1 w-48 px-2 py-1 bg-gray-700 border border-gray-600 rounded-md text-gray-300" placeholder="e.g., 100201">
        </div>
        <!-- New input field for the square root -->
        <div>
          <label for="sqrtInput" class="block text-sm text-gray-400">Integer Sqrt</label>
          <input type="text" id="sqrtInput" class="mt-1 w-24 px-2 py-1 bg-gray-700 border border-gray-600 rounded-md text-gray-300" disabled>
        </div>
        <div class="flex items-center gap-2">
          <input type="checkbox" id="isFactorCheck" class="form-checkbox h-4 w-4 text-yellow-500 rounded border-gray-600 bg-gray-700">
          <label for="isFactorCheck" class="text-sm text-gray-400">isFactor?</label>
        </div>
        <button id="checkMatchButton" class="px-3 py-1 bg-orange-500 hover:bg-orange-600 text-white font-bold rounded" disabled>Check Match</button>
      </div>
      <div id="statusMessage" class="text-gray-400 text-sm">Enter a range and click "Draw".</div>
    </section>

    <section class="relative overflow-hidden">
      <div id="grid-container" class="grid-container"></div>
      <div class="absolute bottom-4 left-1/2 -translate-x-1/2 bg-gray-800 rounded-full px-3 py-1 text-xs text-white shadow flex gap-3">
        <span class="flex items-center gap-1"><div class="w-3 h-3 rounded-full bg-red-500"></div> Composite</span>
        <span class="flex items-center gap-1"><div class="w-3 h-3 rounded-full bg-green-500"></div> Prime</span>
        <span class="flex items-center gap-1"><div class="w-3 h-3 rounded-full bg-purple-500"></div> Multiple of 6</span>
        <span class="flex items-center gap-1"><div class="w-3 h-3 rounded-full bg-yellow-400"></div> Factor</span>
      </div>
    </section>
  </div>

  <!-- Bottom sheet modal -->
  <div id="bottomSheet" class="bottom-sheet">
    <button id="closeSheet" class="text-gray-400 float-right">âœ•</button>
    <h2 class="text-xl font-bold mb-2">Number Details</h2>
    <div id="sheetContent" class="text-gray-300 text-sm"></div>
  </div>

  <!-- Message box for results -->
  <div id="messageBox" class="message-box">
    <div id="messageText" class="text-center font-bold text-lg mb-4"></div>
    <button id="closeMessageBox" class="block mx-auto px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded">Close</button>
  </div>

  <script>
    const gridContainer = document.getElementById('grid-container');
    const drawButton = document.getElementById('drawButton');
    const sieveButton = document.getElementById('sieveButton');
    const clearButton = document.getElementById('clearButton');
    const highlightPairsButton = document.getElementById('highlightPairsButton');
    const statusMessage = document.getElementById('statusMessage');
    const columnsSelect = document.getElementById('columns');
    const startInput = document.getElementById('startInput');
    const endInput = document.getElementById('endInput');
    const primeColorInput = document.getElementById('primeColor');
    const compositeColorInput = document.getElementById('compositeColor');
    const primePairDifferenceInput = document.getElementById('primePairDifference');
    const targetNumberInput = document.getElementById('targetNumberInput');
    const sqrtInput = document.getElementById('sqrtInput'); // New input field
    const checkMatchButton = document.getElementById('checkMatchButton');
    const isFactorCheck = document.getElementById('isFactorCheck');
    const bottomSheet = document.getElementById('bottomSheet');
    const sheetContent = document.getElementById('sheetContent');
    const closeSheet = document.getElementById('closeSheet');
    const gridRangeDisplay = document.getElementById('gridRangeDisplay');
    const messageBox = document.getElementById('messageBox');
    const messageText = document.getElementById('messageText');
    const closeMessageBox = document.getElementById('closeMessageBox');

    let isDragging = false, startX, startY, transformX = 0, transformY = 0, scale = 1;
    let allNumbers = [];
    let selectedPrimes = [];

    /**
     * Parses a string that may contain scientific notation or addition,
     * returning a BigInt.
     * @param {string} str
     * @returns {BigInt}
     */
    function parseBigInt(str) {
      if (!str) return 0n;
      str = str.replace(/\s/g, '');
      if (str.includes('+')) {
        const terms = str.split('+');
        return terms.reduce((sum, term) => sum + parseBigInt(term), 0n);
      }
      if (str.includes('e') || str.includes('E')) {
        const parts = str.toLowerCase().split('e');
        return BigInt(parts[0]) * 10n ** BigInt(parts[1]);
      }
      return BigInt(str);
    }

    /**
     * Calculates (base^exp) % mod for BigInts.
     * @param {BigInt} base
     * @param {BigInt} exp
     * @param {BigInt} mod
     * @returns {BigInt}
     */
    function powMod(base, exp, mod) {
      let result = 1n;
      base %= mod;
      while (exp > 0n) {
        if ((exp & 1n) === 1n) result = (result * base) % mod;
        exp >>= 1n;
        base = (base * base) % mod;
      }
      return result;
    }

    /**
     * Generates a random BigInt within a range.
     * @param {BigInt} low
     * @param {BigInt} high
     * @returns {BigInt}
     */
    function randomBigInt(low, high) {
      const diff = high - low;
      const bitLength = diff.toString(2).length;
      const byteLength = Math.ceil(bitLength / 8);
      const buf = new Uint8Array(byteLength);
      crypto.getRandomValues(buf);
      let rand = 0n;
      for (let i = 0; i < byteLength; i++) {
        rand = (rand << 8n) | BigInt(buf[i]);
      }
      return low + (rand % diff);
    }

    /**
     * Probabilistic Miller-Rabin primality test for BigInts.
     * @param {BigInt} n
     * @param {number} k Number of iterations (witnesses) for the test.
     * @returns {boolean}
     */
    function millerRabinTest(n, k = 20) {
      if (n <= 1n) return false;
      if (n <= 3n) return true;
      if ((n & 1n) === 0n) return false;

      let d = n - 1n;
      let s = 0n;
      while ((d & 1n) === 0n) {
        d >>= 1n;
        s++;
      }

      const witnesses = (n < 3825123056546413051n) ? [2n, 3n, 5n, 7n, 11n, 13n, 23n] : null;
      if (witnesses && k > witnesses.length) k = witnesses.length;

      for (let i = 0; i < k; i++) {
        const a = witnesses ? witnesses[i] : randomBigInt(2n, n - 2n);
        if (a >= n - 1n) continue;

        let x = powMod(a, d, n);
        if (x === 1n || x === n - 1n) continue;

        let composite = true;
        for (let j = 1n; j < s; j++) {
          x = powMod(x, 2n, n);
          if (x === n - 1n) {
            composite = false;
            break;
          }
          if (x === 1n) break;
        }
        if (composite) return false;
      }
      return true;
    }

    // Function to get prime factors
    function getPrimeFactors(n) {
      const factors = [];
      let tempN = n;
      // Handle factor 2
      while (tempN % 2n === 0n) {
        factors.push(2n);
        tempN /= 2n;
      }
      // Handle odd factors
      for (let i = 3n; i * i <= tempN; i += 2n) {
        while (tempN % i === 0n) {
          factors.push(i);
          tempN /= i;
        }
      }
      if (tempN > 2n) {
        factors.push(tempN);
      }
      return factors;
    }

    // Main function to create and draw the grid
    function createGrid(colorize = true) {
      try {
        const start = parseBigInt(startInput.value);
        const end = parseBigInt(endInput.value);
        const columns = columnsSelect.value === 'auto' ? calculateAutoColumns() : parseInt(columnsSelect.value, 10);

        if (start > end) {
          statusMessage.textContent = "Invalid range: Start number is greater than End number.";
          return;
        }

        const total = Number(end - start) + 1;
        if (total > 5000) {
          statusMessage.textContent = "Too many numbers (max 5000). Please select a smaller range.";
          return;
        }

        const isLargeRange = start > 1000000n;
        const startString = start.toString();

        gridRangeDisplay.textContent = `Showing numbers from ${startString} to ${end.toString()}.`;

        if (isLargeRange) {
          sieveButton.disabled = true;
          sieveButton.classList.add('opacity-50', 'cursor-not-allowed');
          highlightPairsButton.disabled = true;
          highlightPairsButton.classList.add('opacity-50', 'cursor-not-allowed');
          statusMessage.textContent = "Sieve and Prime Pairs are disabled for large numbers.";
        } else {
          sieveButton.disabled = false;
          sieveButton.classList.remove('opacity-50', 'cursor-not-allowed');
          highlightPairsButton.disabled = false;
          highlightPairsButton.classList.remove('opacity-50', 'cursor-not-allowed');
        }

        gridContainer.innerHTML = '';
        gridContainer.style.gridTemplateColumns = `repeat(${columns}, 1fr)`;
        allNumbers = [];

        const isFactorChecked = isFactorCheck.checked;
        let targetNumber = 0n;
        if (isFactorChecked) {
          try {
            targetNumber = parseBigInt(targetNumberInput.value);
          } catch (e) {
            statusMessage.textContent = "Invalid target number for isFactor? check.";
            isFactorCheck.checked = false;
            return;
          }
        }

        for (let i = 0; i < total; i++) {
          const number = start + BigInt(i);
          const cell = document.createElement('div');
          cell.className = 'grid-cell';

          if (isLargeRange) {
            const shortString = startString.slice(0, 5) + '...';
            cell.textContent = i === 0 ? shortString : `+${i}`;
            if (i === 0) {
              cell.title = startString;
            }
          } else {
            cell.textContent = number;
          }

          cell.dataset.number = number;
          allNumbers.push(number);

          if (isFactorChecked && targetNumber > 0n && number > 0n && targetNumber % number === 0n) {
            cell.classList.add('is-factor');
          } else if (colorize) {
            if (millerRabinTest(number)) cell.classList.add('prime');
            else cell.classList.add('composite');
            if (number > 1n && number % 6n === 0n) cell.classList.add('multiple-of-6');
          }

          cell.addEventListener('click', () => handleCellClick(cell, number));
          gridContainer.appendChild(cell);
        }
        statusMessage.textContent = `Grid drawn for ${start.toLocaleString()} to ${end.toLocaleString()}.`;
      } catch (e) {
        statusMessage.textContent = "Invalid number format. Please use standard numbers or scientific notation (e.g., 1e308).";
        console.error(e);
      }
    }

    function handleCellClick(cell, number) {
      if (!cell.classList.contains('prime')) {
        showDetails(number);
        return;
      }

      const isSelected = selectedPrimes.includes(number);
      if (isSelected) {
        selectedPrimes = selectedPrimes.filter(p => p !== number);
        cell.classList.remove('selected-prime');
      } else {
        selectedPrimes.push(number);
        cell.classList.add('selected-prime');
        if (selectedPrimes.length > 2) {
          const deselected = selectedPrimes.shift();
          const oldCell = document.querySelector(`[data-number="${deselected}"]`);
          if (oldCell) {
            oldCell.classList.remove('selected-prime');
          }
        }
      }

      if (selectedPrimes.length === 2) {
        checkMatchButton.disabled = false;
      } else {
        checkMatchButton.disabled = true;
      }
    }

    function checkMatch() {
      const targetNumber = parseBigInt(targetNumberInput.value);
      if (selectedPrimes.length !== 2) {
        showMessage('Please select exactly two prime numbers from the grid.');
        return;
      }

      const p = selectedPrimes[0];
      const q = selectedPrimes[1];
      const product = p * q;

      let message = '';
      if (product === targetNumber) {
        message = `Success! ðŸŽ‰\n\n${p.toLocaleString()} * ${q.toLocaleString()} = ${targetNumber.toLocaleString()}`;
        console.log(`Match found: ${p} * ${q} = ${targetNumber}`);
      } else {
        message = `No match. ðŸ˜ž\n\n${p.toLocaleString()} * ${q.toLocaleString()} = ${product.toLocaleString()}\n\nDoes not equal ${targetNumber.toLocaleString()}`;
        console.log(`No match: ${p} * ${q} = ${product} (Target: ${targetNumber})`);
      }
      showMessage(message);
    }

    function showMessage(text) {
      messageText.textContent = text;
      messageBox.classList.add('active');
    }

    function closeMessage() {
      messageBox.classList.remove('active');
    }

    function calculateAutoColumns() {
      const screenWidth = window.innerWidth;
      const cellWidth = 62; // Cell width + border
      let cols = Math.floor((screenWidth * 0.9) / cellWidth);
      cols = Math.min(cols, 60);
      return Math.max(cols, 6);
    }

    // Function to run the Sieve animation
    async function runSieve() {
      const start = parseBigInt(startInput.value);
      if (start > 1000n) {
        statusMessage.textContent = "Sieve is not supported for large numbers.";
        return;
      }

      statusMessage.textContent = "Running Sieve of Eratosthenes...";
      await new Promise(resolve => setTimeout(resolve, 500));

      createGrid(false); // Draw grid with no colors
      const cells = gridContainer.querySelectorAll('.grid-cell');
      const end = parseBigInt(endInput.value);
      const limit = BigInt(Math.sqrt(Number(end)));

      for (let i = start; i <= end; i++) {
        if (i <= 1n) continue;
        const cell = document.querySelector(`[data-number="${i}"]`);
        if (!cell) continue;

        if (!cell.classList.contains('sieve-marked')) {
          cell.classList.add('sieve-prime');
          cell.style.setProperty('--prime-color', primeColorInput.value);

          if (i <= limit) {
            for (let j = i * i; j <= end; j += i) {
              const multipleCell = document.querySelector(`[data-number="${j}"]`);
              if (multipleCell) {
                multipleCell.classList.add('sieve-marked');
                multipleCell.style.setProperty('--composite-color', compositeColorInput.value);
              }
              await new Promise(resolve => setTimeout(resolve, 50));
            }
          }
        }
      }
      statusMessage.textContent = "Sieve complete!";
    }

    function highlightPrimePairs() {
      const difference = parseBigInt(primePairDifferenceInput.value);
      const start = parseBigInt(startInput.value);
      const end = parseBigInt(endInput.value);

      if (difference <= 0n) {
        statusMessage.textContent = "Please enter a positive difference for prime pairs.";
        return;
      }

      document.querySelectorAll('.highlighted-pair').forEach(el => {
        el.classList.remove('highlighted-pair');
      });

      let foundPairs = false;
      for (let i = start; i <= end; i++) {
        const num1 = i;
        const num2 = i + difference;

        if (num2 <= end && millerRabinTest(num1) && millerRabinTest(num2)) {
          const cell1 = document.querySelector(`[data-number="${num1}"]`);
          const cell2 = document.querySelector(`[data-number="${num2}"]`);
          if (cell1 && cell2) {
            cell1.classList.add('highlighted-pair');
            cell2.classList.add('highlighted-pair');
            foundPairs = true;
          }
        }
      }

      if (foundPairs) {
        statusMessage.textContent = `Highlighted all prime pairs with a difference of ${difference}.`;
      } else {
        statusMessage.textContent = `No prime pairs with a difference of ${difference} found in this range.`;
      }
    }

    function showDetails(number) {
      let info = `<strong>Number:</strong> ${number.toLocaleString()}<br>`;
      if (millerRabinTest(number)) {
        info += `<strong>Status:</strong> Prime<br>`;
      } else {
        info += `<strong>Status:</strong> Composite<br>`;
        if (number <= 1000000n) { // Set a reasonable limit for factorization
          info += `<button id="getFactorsButton" class="px-2 py-1 bg-gray-600 hover:bg-gray-700 text-white rounded mt-2">Get Prime Factors</button>`;
        } else {
          info += `<strong>Prime Factors:</strong> Too large to compute.<br>`;
        }
      }
      sheetContent.innerHTML = info;
      bottomSheet.classList.add('active');

      if (number <= 1000000n && !millerRabinTest(number)) {
        document.getElementById('getFactorsButton').addEventListener('click', () => {
          const factors = getPrimeFactors(number);
          const factorString = factors.join(' Ã— ');
          const factorDisplay = document.createElement('div');
          factorDisplay.innerHTML = `<strong>Prime Factors:</strong> ${factorString}<br>`;
          sheetContent.insertBefore(factorDisplay, document.getElementById('getFactorsButton').nextSibling);
          document.getElementById('getFactorsButton').remove();
        });
      }
    }

    // Function to get prime factors (optimized trial division)
    function getPrimeFactors(n) {
      const factors = [];
      let tempN = n;
      // Handle factor 2
      while (tempN % 2n === 0n) {
        factors.push(2n);
        tempN /= 2n;
      }
      // Handle odd factors
      for (let i = 3n; i * i <= tempN; i += 2n) {
        while (tempN % i === 0n) {
          factors.push(i);
          tempN /= i;
        }
      }
      if (tempN > 2n) {
        factors.push(tempN);
      }
      return factors;
    }

    // Function to calculate integer square root for BigInt (Corrected Logic)
    function integerSqrt(n) {
      if (n < 0n) throw new Error("Square root of negative numbers is not defined.");
      if (n < 2n) return n;

      // Use a more robust iterative method (Babylonian method variant)
      let x = n;
      let y = (x + 1n) / 2n;
      while (y < x) {
        x = y;
        y = (x + n / x) / 2n;
      }
      return x;
    }

    function updateSqrt() {
      const targetValue = targetNumberInput.value;
      try {
        const num = parseBigInt(targetValue);
        if (num >= 0n) {
          const sqrt = integerSqrt(num);
          sqrtInput.value = sqrt.toLocaleString();
        } else {
          sqrtInput.value = '';
        }
      } catch (e) {
        sqrtInput.value = '';
      }
    }

    function clearGrid() {
      gridContainer.innerHTML = '';
      statusMessage.textContent = "Cleared.";
      gridRangeDisplay.textContent = 'Explore prime numbers and their patterns';
      resetTransform();
      selectedPrimes = [];
      document.querySelectorAll('.selected-prime').forEach(el => el.classList.remove('selected-prime'));
      checkMatchButton.disabled = true;
    }

    function resetTransform() {
      transformX = 0; transformY = 0; scale = 1;
      gridContainer.style.transform = '';
    }

    // Event Listeners
    closeSheet.addEventListener('click', () => bottomSheet.classList.remove('active'));
    drawButton.addEventListener('click', () => createGrid());
    sieveButton.addEventListener('click', runSieve);
    clearButton.addEventListener('click', clearGrid);
    highlightPairsButton.addEventListener('click', highlightPrimePairs);
    checkMatchButton.addEventListener('click', checkMatch);
    closeMessageBox.addEventListener('click', closeMessage);

    primeColorInput.addEventListener('input', (e) => {
      document.documentElement.style.setProperty('--prime-color', e.target.value);
    });
    compositeColorInput.addEventListener('input', (e) => {
      document.documentElement.style.setProperty('--composite-color', e.target.value);
    });

    // Event listener for the new square root functionality
    targetNumberInput.addEventListener('input', updateSqrt);

    // Mouse Controls
    gridContainer.addEventListener('mousedown', (e) => {
      isDragging = true;
      startX = e.clientX;
      startY = e.clientY;
      gridContainer.style.cursor = 'grabbing';
    });

    window.addEventListener('mouseup', () => {
      isDragging = false;
      gridContainer.style.cursor = 'grab';
    });

    window.addEventListener('mousemove', (e) => {
      if (!isDragging) return;
      transformX += e.clientX - startX;
      transformY += e.clientY - startY;
      gridContainer.style.transform = `translate(${transformX}px, ${transformY}px) scale(${scale})`;
      startX = e.clientX;
      startY = e.clientY;
    });

    gridContainer.addEventListener('wheel', (e) => {
      e.preventDefault();
      const delta = Math.sign(e.deltaY);
      const zoomFactor = 1.1;
      if (delta > 0) {
        scale /= zoomFactor;
      } else {
        scale *= zoomFactor;
      }
      scale = Math.max(0.1, Math.min(scale, 3));
      gridContainer.style.transform = `translate(${transformX}px, ${transformY}px) scale(${scale})`;
    });

    // Touch Controls
    let lastDist = null;
    gridContainer.addEventListener('touchstart', (e) => {
      if (e.touches.length === 1) {
        startX = e.touches[0].clientX;
        startY = e.touches[0].clientY;
      } else if (e.touches.length === 2) {
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        lastDist = Math.sqrt(dx * dx + dy * dy);
      }
    });

    gridContainer.addEventListener('touchmove', (e) => {
      if (e.touches.length === 1) {
        transformX += e.touches[0].clientX - (startX);
        transformY += e.touches[0].clientY - (startY);
        startX = e.touches[0].clientX;
        startY = e.touches[0].clientY;
        gridContainer.style.transform = `translate(${transformX}px, ${transformY}px) scale(${scale})`;
      } else if (e.touches.length === 2) {
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (lastDist !== null) {
          const diff = dist - lastDist;
          scale += diff * 0.005;
          scale = Math.max(0.1, Math.min(scale, 3));
          gridContainer.style.transform = `translate(${transformX}px, ${transformY}px) scale(${scale})`;
        }
        lastDist = dist;
      }
      e.preventDefault();
    });

    gridContainer.addEventListener('touchend', () => {
      lastDist = null;
    });

    document.addEventListener('DOMContentLoaded', () => {
      createGrid();
      // Also update the square root input on initial load
      updateSqrt();
    });
  </script>
</body>
</html>
