<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
<title>Hyper-Streamliner v7 (BigInt Precision)</title>
<script src="https://cdn.tailwindcss.com"></script>
<style>
  body { background-color: #000; color: #e2e8f0; font-family: 'Courier New', monospace; padding: 15px; overflow-x: hidden; }
  .card { background: #111; border: 1px solid #333; border-radius: 16px; padding: 20px; box-shadow: 0 0 20px rgba(59, 130, 246, 0.2); }
  
  .input-group { margin-bottom: 15px; }
  label { display: block; font-weight: bold; margin-bottom: 5px; color: #60a5fa; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.05em; }
  input { width: 100%; background: #222; border: 1px solid #444; color: #fff; padding: 12px; border-radius: 8px; font-size: 1.1rem; }
  input:focus { outline: none; border-color: #3b82f6; }
  
  .btn { width: 100%; padding: 18px; border: none; border-radius: 10px; font-weight: 900; cursor: pointer; font-size: 1.1rem; text-transform: uppercase; margin-top: 10px; }
  .btn-start { background: #3b82f6; color: #fff; }
  .btn-stop { background: #4b5563; color: #fff; }
  
  .log-box { background: #050505; border: 1px solid #333; padding: 15px; height: 200px; overflow-y: auto; margin-top: 20px; border-radius: 10px; font-size: 0.75rem; color: #93c5fd; white-space: pre-wrap; }
  .status-bar { height: 10px; background: #333; margin-top: 20px; border-radius: 5px; overflow: hidden; }
  .progress { height: 100%; background: #3b82f6; width: 0%; transition: width 0.2s; }
  
  .file-area { text-align: center; margin-top: 20px; }
  #downloadLink { display: none; color: #60a5fa; text-decoration: underline; font-weight: bold; padding: 10px; border: 1px dashed #333; border-radius: 8px; }
</style>
</head>
<body>

<div class="card">
  <h1 class="text-2xl font-black text-center text-blue-500 mb-2">HYPER v7: BigInt</h1>
  <p class="text-center text-xs text-gray-500 mb-6">Overflow-Proof Math â€¢ High Precision</p>

  <div class="grid grid-cols-3 gap-3 mb-2">
    <div class="input-group">
      <label>Base</label>
      <input id="inpBase" value="10">
    </div>
    <div class="input-group">
      <label>Exp</label>
      <input id="inpExp" value="1000000000"> 
    </div>
    <div class="input-group">
      <label>Add</label>
      <input id="inpAdd" value="61">
    </div>
  </div>

  <button id="btnRun" class="btn btn-start" onclick="startProof()">Run BigInt Proof</button>
  <button id="btnStop" class="btn btn-stop hidden" onclick="stopProof()">STOP</button>

  <div class="status-bar"><div id="progressBar" class="progress"></div></div>
  <div id="logBox" class="log-box">System Ready.
v7 uses BigInts inside the NTT transform.
This prevents overflow errors but runs slower.</div>

  <div class="file-area">
    <a id="downloadLink"></a>
  </div>
</div>

<script>
const workerCode = `
// --- VIRTUAL MEMORY MANAGER (BigInt Support) ---
const PAGE_ELEMENTS = 16 * 1024 * 1024; // Smaller pages (16M BigInts) to be safe

class VirtualBigIntArray {
    constructor(totalSize) {
        this.totalSize = totalSize;
        this.pages = [];
        this.numPages = Math.ceil(totalSize / PAGE_ELEMENTS);
        
        postMessage({type:'log', msg: \`Allocating BigInt RAM: \${this.numPages} pages...\`});

        for(let i=0; i<this.numPages; i++) {
            const size = (i === this.numPages-1) ? (totalSize % PAGE_ELEMENTS) || PAGE_ELEMENTS : PAGE_ELEMENTS;
            try {
                // BigUint64Array is efficient for 64-bit ints. 
                // Q=998244353 fits in 64 bits easily.
                this.pages.push(new BigUint64Array(size));
            } catch(e) {
                throw new Error(\`Page \${i} Alloc Failed.\`);
            }
        }
        postMessage({type:'log', msg: 'BigInt RAM Allocated.'});
    }
    
    get(index) {
        const pageIdx = (index / PAGE_ELEMENTS) | 0;
        const offset = index % PAGE_ELEMENTS;
        return this.pages[pageIdx][offset];
    }
    
    set(index, value) {
        const pageIdx = (index / PAGE_ELEMENTS) | 0;
        const offset = index % PAGE_ELEMENTS;
        this.pages[pageIdx][offset] = value;
    }
}

// --- CONSTANTS ---
// We use a larger Prime Q that fits in 64-bit to allow larger intermediate values
// However, for compatibility with v6 logic, we stick to the standard NTT prime but use BigInt ops.
const Q = 998244353n; 
const G = 3n;
const BASE_BI = 10000n;
const CHUNK_SIZE = 4;

// --- NTT MATH (BigInt) ---
function power(base, exp) {
    let res = 1n; base %= Q;
    while (exp > 0n) {
        if (exp % 2n === 1n) res = (res * base) % Q;
        base = (base * base) % Q;
        exp /= 2n;
    }
    return res;
}

function modInverse(n) { return power(n, Q - 2n); }

function bitReverseCopy(arr, n) {
    postMessage({type:'stage', msg:'Bit Reversal'});
    for (let i = 0, j = 0; i < n; i++) {
        if (i < j) {
            const i_page = (i / PAGE_ELEMENTS) | 0; const i_off = i % PAGE_ELEMENTS;
            const j_page = (j / PAGE_ELEMENTS) | 0; const j_off = j % PAGE_ELEMENTS;
            const ai = arr.pages[i_page][i_off];
            const aj = arr.pages[j_page][j_off];
            arr.pages[i_page][i_off] = aj;
            arr.pages[j_page][j_off] = ai;
        }
        let bit = n >> 1;
        while (j & bit) { j ^= bit; bit >>= 1; }
        j ^= bit;
        if (i % 500000 === 0) postMessage({type:'progress', val: (i/n)*20});
    }
}

function ntt(arr, n, invert) {
    bitReverseCopy(arr, n);
    
    postMessage({type:'stage', msg: invert ? 'Inverse NTT' : 'Forward NTT'});
    
    let stages = 0;
    let maxStages = Math.log2(n);
    
    for (let len = 2; len <= n; len <<= 1) {
        let wlen = power(G, (Q - 1n) / BigInt(len));
        if (invert) wlen = modInverse(wlen);
        
        stages++;
        const progressBase = invert ? 60 : 20;
        postMessage({type:'progress', val: progressBase + (stages/maxStages)*40});

        for (let i = 0; i < n; i += len) {
            let w = 1n;
            for (let j = 0; j < len / 2; j++) {
                const idxU = i + j;
                const idxV = i + j + len / 2;
                
                const u_page = (idxU / PAGE_ELEMENTS) | 0; const u_off = idxU % PAGE_ELEMENTS;
                const v_page = (idxV / PAGE_ELEMENTS) | 0; const v_off = idxV % PAGE_ELEMENTS;
                
                // Read directly as BigInt (BigUint64Array returns BigInt)
                const uVal = arr.pages[u_page][u_off];
                const vVal = arr.pages[v_page][v_off];
                
                const vMod = (vVal * w) % Q;
                const uNew = (uVal + vMod) % Q;
                const vNew = (uVal - vMod + Q) % Q;
                
                arr.pages[u_page][u_off] = uNew;
                arr.pages[v_page][v_off] = vNew;
                
                w = (w * wlen) % Q;
            }
        }
    }
    
    if (invert) {
        const n_inv = modInverse(BigInt(n));
        for (let i = 0; i < n; i++) {
            const page = (i / PAGE_ELEMENTS) | 0; const off = i % PAGE_ELEMENTS;
            const val = arr.pages[page][off];
            arr.pages[page][off] = (val * n_inv) % Q;
        }
    }
}

self.onmessage = function(e) {
    const { mode, bStr, cStr } = e.data;
    
    if(mode === 'prove') {
        try {
            const digits = parseInt(bStr);
            const chunksNeeded = Math.ceil(digits / CHUNK_SIZE);
            let n = 1;
            while(n < chunksNeeded * 2) n <<= 1;
            
            postMessage({type:'log', msg: \`Math Size: \${n.toLocaleString()} BigInts.\`});
            
            const ram = new VirtualBigIntArray(n);
            
            // Construct Index (I)
            const topPos = digits - 1;
            const topIdx = Math.floor(topPos / CHUNK_SIZE);
            const topVal = 5 * Math.pow(10, topPos % CHUNK_SIZE);
            
            ram.set(topIdx, BigInt(topVal));
            ram.set(0, ram.get(0) + 31n); 
            
            postMessage({type:'log', msg: 'Index Constructed. Starting BigInt NTT...'});
            
            const start = performance.now();
            
            ntt(ram, n, false); // Forward
            
            // Pointwise Square (In-Place)
            for(let i=0; i<n; i++) {
                const page = (i / PAGE_ELEMENTS) | 0; const off = i % PAGE_ELEMENTS;
                let val = ram.pages[page][off];
                ram.pages[page][off] = (val * val) % Q;
            }
            
            ntt(ram, n, true); // Inverse
            
            // Carry Propagation
            postMessage({type:'stage', msg:'Carries'});
            let carry = 0n;
            for(let i=0; i<n; i++) {
                const page = (i / PAGE_ELEMENTS) | 0; const off = i % PAGE_ELEMENTS;
                let val = ram.pages[page][off] + carry;
                ram.pages[page][off] = val % BASE_BI;
                carry = val / BASE_BI;
            }
            
            // Tail Extraction
            const tailArr = [];
            for(let i=0; i<20; i++) tailArr.push(ram.get(i));
            
            let tailString = tailArr.map(n => n.toString().padStart(4,'0')).reverse().join('').replace(/^0+/,'');
            if(!tailString) tailString = "0";
            
            let tailBig = BigInt(tailString.slice(-15));
            let resultTail = tailBig - 61n;
            
            const end = performance.now();
            
            postMessage({
                type: 'result',
                tail: resultTail.toString(),
                fullTail: tailString,
                time: ((end-start)/1000).toFixed(1)
            });
            
        } catch(e) {
            postMessage({type:'error', msg: e.message});
        }
    }
};
`;

let worker = null;
let wakeLock = null;

function log(msg, type='') {
    const el = document.getElementById('logBox');
    el.textContent += `> ${msg}\n`;
    el.scrollTop = el.scrollHeight;
}

async function startProof() {
    try { wakeLock = await navigator.wakeLock.request('screen'); } catch(e){}
    
    document.getElementById('btnRun').classList.add('hidden');
    document.getElementById('btnStop').classList.remove('hidden');
    document.getElementById('logBox').textContent = '';
    document.getElementById('downloadLink').style.display = 'none';
    
    const bVal = document.getElementById('inpExp').value;
    const cVal = document.getElementById('inpAdd').value;

    const blob = new Blob([workerCode], {type: 'application/javascript'});
    worker = new Worker(URL.createObjectURL(blob));
    
    worker.onmessage = function(e) {
        const d = e.data;
        if(d.type === 'log') log(d.msg);
        if(d.type === 'stage') log(`[STAGE] ${d.msg}`);
        if(d.type === 'progress') document.getElementById('progressBar').style.width = d.val + '%';
        if(d.type === 'error') { log("ERROR: " + d.msg); stopProof(); }
        if(d.type === 'result') {
            log("----------------");
            log("BIGINT MATH COMPLETE");
            log("Rim^2 Tail: ..." + d.tail);
            log(`Time: ${d.time}s`);
            
            const blob = new Blob([`BigInt Proof Result\nTime: ${d.time}s\nTail: ${d.tail}\nFull Block: ${d.fullTail}`], {type: "text/plain"});
            const url = URL.createObjectURL(blob);
            const link = document.getElementById('downloadLink');
            link.href = url;
            link.download = `bigint_proof.txt`;
            link.textContent = "ðŸ’¾ Download Result";
            link.style.display = "inline-block";
            
            stopProof();
        }
    };
    
    worker.postMessage({ mode: 'prove', bStr: bVal, cStr: cVal });
}

function stopProof() {
    if(worker) worker.terminate();
    worker = null;
    if(wakeLock) wakeLock.release();
    document.getElementById('btnRun').classList.remove('hidden');
    document.getElementById('btnStop').classList.add('hidden');
}
</script>
</body>
</html>

