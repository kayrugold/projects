<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prime Boundaries Visualizer</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        body { background-color: #0f172a; color: #e2e8f0; font-family: 'Courier New', Courier, monospace; overflow: hidden; }
        /* Diagonal Line Animation */
        .line-draw { stroke-dasharray: 1000; stroke-dashoffset: 1000; animation: dash 2s linear forwards; }
        @keyframes dash { to { stroke-dashoffset: 0; } }
        
        .grid-cell { transition: all 0.3s ease; }
        .grid-cell:hover { transform: scale(1.1); z-index: 10; box-shadow: 0 0 10px white; }
    </style>
</head>
<body>

<div id="root"></div>

<script type="text/babel">

const App = () => {
    const [gridSize, setGridSize] = React.useState(9); // Start small to match user image
    const [showLines, setShowLines] = React.useState(true);
    const [highlightPrimes, setHighlightPrimes] = React.useState(true);

    // --- Math Logic ---
    const isPrime = (num) => {
        if (num <= 1) return false;
        if (num <= 3) return true;
        if (num % 2 === 0 || num % 3 === 0) return false;
        for (let i = 5; i * i <= num; i += 6) {
            if (num % i === 0 || num % (i + 2) === 0) return false;
        }
        return true;
    };

    const layerData = React.useMemo(() => {
        const layers = [];
        for (let i = 1; i <= gridSize; i++) {
            const blocks = (2 * i) - 1;
            layers.push({
                index: i,
                blocks: blocks,
                isPrime: isPrime(blocks),
                sqValue: i*i
            });
        }
        return layers;
    }, [gridSize]);

    // --- SVG Line Overlay Renderer ---
    const renderLines = () => {
        if (!showLines) return null;
        
        // We need to draw diagonal lines cutting through the grid
        // Based on the user's image, the lines connect the outer corners of the squares
        // Coordinates logic: 
        // Line 1 connects (0,1) to (1,0) in a continuous coordinate space?
        // Actually, looking at the image, the lines act as barriers for the L-shapes.
        // They run parallel.
        
        // Let's draw lines relative to the grid layout.
        // Assuming each cell is 1 unit.
        
        const lines = [];
        // The grid is rendered with CSS grid, so precise SVG overlay is tricky but doable with percentages
        // Or we just draw them as borders on the cells (Simpler and more robust)
        return null; 
    };

    const renderGrid = () => {
        let cells = [];
        // Render grid logic similar to previous, but strictly matching the "Layer" concept
        // Rows and Cols
        
        for (let r = 0; r < gridSize; r++) {
            for (let c = 0; c < gridSize; c++) {
                
                // Which layer is this cell in?
                // Layer is defined by the max coordinate
                const layerIndex = Math.max(r, c) + 1;
                const layerInfo = layerData[layerIndex - 1];
                
                // Is this cell part of the "Diagonal Boundary"?
                // The visual "Line" the user drew connects the inner corners.
                // It's effectively the boundary between layer N and N+1.
                
                // Visual styles
                let bg = "bg-slate-800";
                let border = "border-slate-900";
                let content = "";
                
                // Highlight the actual "Gnomon" (the current strip)
                if (highlightPrimes) {
                    if (layerInfo.isPrime) {
                        bg = "bg-blue-600/90"; // Prime Layer
                        border = "border-blue-400";
                    } else {
                        bg = "bg-slate-700/50"; // Composite Layer
                        border = "border-slate-600";
                    }
                }

                // Add the "Blue Line" effect
                // The user drew lines separating the layers.
                // We can simulate this by adding a heavy border to the Top and Left of the FIRST cell of a layer?
                // Or simpler: The "Line" is the boundary between Layer N and Layer N-1
                
                const isLayerEdge = (r === layerIndex - 1 || c === layerIndex - 1);
                
                // Special styling for the "Line" visual
                // If showLines is on, we emphasize the separation
                const lineStyle = showLines ? "border-l-[1px] border-t-[1px] border-white/20" : "";

                cells.push(
                    <div 
                        key={`${r}-${c}`}
                        className={`
                            relative ${bg} border ${border} ${lineStyle}
                            flex items-center justify-center text-[8px] text-white/0 hover:text-white/100
                            grid-cell
                        `}
                        style={{
                            // If it's a composite layer, maybe pattern it?
                            backgroundImage: !layerInfo.isPrime && highlightPrimes ? 'radial-gradient(circle, rgba(0,0,0,0.2) 1px, transparent 1px)' : 'none',
                            backgroundSize: '4px 4px'
                        }}
                    >
                        {/* Number the diagonals to match user image logic? */}
                        {/* {r+c} */}
                    </div>
                );
            }
        }
        return cells;
    };

    // SVG Overlay for the exact lines user drew
    // The lines appear to connect (0, k) to (k, 0) roughly? 
    // Actually in the image, they are diagonals connecting the inner corners of the L-shapes.
    // Let's render SVG lines on top.
    const renderSVGLines = () => {
        if (!showLines) return null;
        
        const lines = [];
        const gap = 100 / gridSize; // percentage
        
        for (let i = 1; i < gridSize; i++) {
            // Draw line separating layer i from i+1
            // The line goes from (i, 0) to (0, i) ? 
            // No, the L-shapes are squares. The line connects (i,0) to (i,i) to (0,i) basically?
            // The user drew diagonals. Let's draw the diagonal that separates the layers.
            // That would be a line from (i, 0) to (0, i) shifted?
            
            // Let's simulate the user's blue lines exactly.
            // They connect the inner corners.
            // Start at (i*gap, 0) -> End at (0, i*gap) would be diagonal.
            // But the user's lines are parallel diagonals.
            
            // Let's draw lines from (i*gap, 0) to (0, i*gap) is visually confusing for L-shapes.
            // The user's lines connect the *corners* of the L-shapes. 
            // Let's draw lines from (i, 0) to (i, i) is vertical...
            
            // Visual approximation of user's "Blue Lines":
            // They are diagonals starting from the diagonal of the grid outwards.
            
            // Let's just draw the "Square Boundaries" which is what they mathematically represent.
            lines.push(
                <polyline 
                    key={i}
                    points={`${i*gap},0 ${i*gap},${i*gap} 0,${i*gap}`}
                    fill="none"
                    stroke="#3b82f6"
                    strokeWidth="0.5"
                    className="line-draw"
                    style={{animationDelay: `${i * 0.1}s`}}
                />
            );
        }
        return (
            <svg className="absolute inset-0 w-full h-full pointer-events-none overflow-visible" style={{zIndex: 20}}>
                {lines}
            </svg>
        );
    };

    return (
        <div className="min-h-screen bg-slate-950 flex flex-col items-center justify-center p-4">
            
            {/* Header */}
            <div className="mb-6 text-center space-y-2">
                <h1 className="text-3xl font-bold text-white tracking-tight">PRIME <span className="text-blue-500">BOUNDARIES</span></h1>
                <p className="text-xs text-slate-400 uppercase tracking-widest">Visualizing the Space Between Squares</p>
            </div>

            {/* Main Viz */}
            <div className="relative bg-slate-900/50 p-8 rounded-xl border border-slate-800 shadow-2xl">
                
                {/* The Grid */}
                <div 
                    className="grid relative"
                    style={{
                        gridTemplateColumns: `repeat(${gridSize}, 1fr)`,
                        width: 'min(85vw, 400px)',
                        height: 'min(85vw, 400px)'
                    }}
                >
                    {renderGrid()}
                    {renderSVGLines()}
                </div>

                {/* Legend / Info */}
                <div className="mt-6 flex justify-between text-xs font-mono text-slate-400 border-t border-slate-800 pt-4">
                    <div className="flex items-center gap-2">
                        <div className="w-3 h-3 bg-blue-600 rounded-sm"></div>
                        <span>Prime Gap</span>
                    </div>
                    <div className="flex items-center gap-2">
                        <div className="w-3 h-3 bg-slate-700 rounded-sm opacity-50" style={{backgroundImage: 'radial-gradient(circle, white 1px, transparent 1px)', backgroundSize: '3px 3px'}}></div>
                        <span>Composite Gap</span>
                    </div>
                    <div className="flex items-center gap-2">
                        <div className="w-4 h-1 bg-blue-500"></div>
                        <span>Perfect Square Line</span>
                    </div>
                </div>
            </div>

            {/* Controls */}
            <div className="mt-8 w-full max-w-md space-y-4">
                
                {/* Sliders */}
                <div className="bg-slate-900 p-4 rounded-lg border border-slate-800">
                    <div className="flex justify-between text-sm text-white mb-2">
                        <span>Grid Size</span>
                        <span className="font-mono text-blue-400">{gridSize}x{gridSize}</span>
                    </div>
                    <input 
                        type="range" min="3" max="20" value={gridSize} 
                        onChange={(e) => setGridSize(parseInt(e.target.value))}
                        className="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer accent-blue-500"
                    />
                </div>

                {/* Toggles */}
                <div className="flex gap-4">
                    <button 
                        onClick={() => setShowLines(!showLines)}
                        className={`flex-1 py-3 rounded-lg text-sm font-bold transition-all ${showLines ? 'bg-blue-600 text-white' : 'bg-slate-800 text-slate-400 hover:bg-slate-700'}`}
                    >
                        {showLines ? 'HIDE LINES' : 'SHOW LINES'}
                    </button>
                    <button 
                        onClick={() => setHighlightPrimes(!highlightPrimes)}
                        className={`flex-1 py-3 rounded-lg text-sm font-bold transition-all ${highlightPrimes ? 'bg-indigo-600 text-white' : 'bg-slate-800 text-slate-400 hover:bg-slate-700'}`}
                    >
                        {highlightPrimes ? 'HIDE PRIMES' : 'SHOW PRIMES'}
                    </button>
                </div>

                {/* Deep Dive Text */}
                <div className="text-[10px] text-slate-500 text-center px-4 leading-relaxed">
                    <p>The blue lines represent Perfect Squares (1, 4, 9, 16...)</p>
                    <p>The highlighted areas are the "Spacing" between them.</p>
                    <p>Primes hide in these spaces because <span className="text-blue-400 font-mono">Prime = Square A - Square B</span></p>
                </div>
            </div>
        </div>
    );
};

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App />);

</script>
</body>
</html>

