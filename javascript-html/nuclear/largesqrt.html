<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Factor Hunter with Streaming Sqrt (v3 Fixed)</title>
<style>
:root {
  --bg-color: #f3f4f6;
  --text-color: #1f2937;
  --card-bg: #fff;
  --card-text: #374151;
  --input-bg: #f9fafb;
  --input-border: #d1d5db;
  --button-bg: #2563eb;
  --button-hover: #1d4ed8;
  --s-search-bg: #16a34a;
  --s-search-hover: #15803d;
  --log-bg: #e2e8f0;
  --progress-bg: #4caf50;
  --header-color: #1d4ed8;
}
body { font-family: system-ui, sans-serif; background: var(--bg-color); color: var(--text-color); display:flex; justify-content:center; align-items:center; min-height:100vh; flex-direction:column; padding:1rem; }
.container { max-width: 900px; width: 100%; background: var(--card-bg); border-radius: .5rem; box-shadow: 0 10px 15px rgba(0,0,0,.1); padding: 2rem; }
h2 { text-align:center; color: var(--header-color); margin-bottom: 2rem; font-size:1.8rem; font-weight:700; }
h3 { margin-top:1.5rem; margin-bottom:1rem; color:var(--card-text); border-bottom:2px solid var(--input-border); padding-bottom:.5rem; }
.grid { display:grid; grid-template-columns: repeat(auto-fit, minmax(200px,1fr)); gap: 1.5rem; }
.input-group { display:flex; flex-direction:column; }
label { margin-bottom:.5rem; font-weight:600; }
input[type="text"] { padding:.75rem; border:1px solid var(--input-border); border-radius:.25rem; background:var(--input-bg); color:var(--card-text); font-size:1rem; }
input:focus { outline:none; border-color:var(--button-bg); }
.button-group { display:flex; flex-wrap:wrap; gap:.75rem; margin-top:1.5rem; }
button { padding:.75rem 1.25rem; border:none; border-radius:.25rem; background:var(--button-bg); color:#fff; font-weight:600; cursor:pointer; font-size: 0.9rem; }
button:hover:not(:disabled){ background: var(--button-hover); }
button:disabled { background:#9ca3af; cursor:not-allowed; }
#sSearchButton { background: var(--s-search-bg); }
#sSearchButton:hover:not(:disabled) { background: var(--s-search-hover); }
#progressBarContainer { width:100%; background:#e0e0e0; border-radius:.25rem; margin-top:1.5rem; overflow:hidden; }
#progressBar { height:25px; width:0%; background:var(--progress-bg); text-align:center; line-height:25px; color:white; font-weight:bold; transition: width .2s ease; }
#results { margin-top:1.5rem; font-weight:700; color:var(--header-color); font-size:1.1rem; text-align: center; }
#logOutput { width:100%; height:200px; overflow-y:auto; border:1px solid var(--input-border); background:var(--log-bg); padding:1rem; font-family: monospace; white-space:pre-wrap; margin-top:1rem; border-radius:.25rem; }
</style>
</head>
<body>
<div class="container">
<h2>Factor Hunter: Streaming S-Search</h2>
<h3>Number to Factor (N)</h3>
<div class="grid">
  <div class="input-group">
    <label for="baseInput">Base (a)</label>
    <input type="text" id="baseInput" value="10">
  </div>
  <div class="input-group">
    <label for="exponentInput">Exponent (b)</label>
    <input type="text" id="exponentInput" value="100000">
  </div>
  <div class="input-group">
    <label for="addendInput">Addend (c)</label>
    <input type="text" id="addendInput" value="19">
  </div>
</div>
<div class="button-group">
  <button id="sSearchButton">Start S-Search (Streaming Sqrt)</button>
  <button id="stopButton" disabled>Stop</button>
</div>
<div id="progressBarContainer">
  <div id="progressBar">0%</div>
</div>
<div id="results">Status: Idle</div>
<h3>Log</h3>
<pre id="logOutput">Log: Ready to begin. Using smaller default exponent (100,000) for faster testing.</pre>
</div>

<script>
// --- UI Element References ---
const baseInput = document.getElementById('baseInput');
const exponentInput = document.getElementById('exponentInput');
const addendInput = document.getElementById('addendInput');
const sSearchButton = document.getElementById('sSearchButton');
const stopButton = document.getElementById('stopButton');
const progressBar = document.getElementById('progressBar');
const resultsDiv = document.getElementById('results');
const logOutput = document.getElementById('logOutput');

// --- Global State ---
let sqrtWorker = null;
let isCalculating = false;

// --- Utility Functions ---
function log(msg) {
  logOutput.textContent += msg + '\n';
  logOutput.scrollTop = logOutput.scrollHeight;
}

function setStatus(t) { resultsDiv.textContent = 'Status: ' + t; }

function setProgress(p) {
  const percent = Math.min(100, p).toFixed(2);
  progressBar.style.width = percent + '%';
  progressBar.textContent = percent + '%';
}

// --- Web Worker for Streaming Sqrt ---
const workerCode = `
    const chunk_size = 9;
    const BASE = 10 ** chunk_size;

    // --- Chunked Arithmetic Functions (MSB-first) ---
    function trim(c) {
        let i = 0;
        while (i < c.length - 1 && c[i] === 0) i++;
        return c.slice(i);
    }
    function cmp(a, b) {
        a = trim(a); b = trim(b);
        if (a.length !== b.length) return a.length > b.length ? 1 : -1;
        for (let i = 0; i < a.length; i++) {
            if (a[i] !== b[i]) return a[i] > b[i] ? 1 : -1;
        }
        return 0;
    }
    function add(a, b) {
        let a_rev = a.slice().reverse(); let b_rev = b.slice().reverse();
        let n = Math.max(a_rev.length, b_rev.length), carry = 0, out = [];
        for (let i = 0; i < n; i++) {
            let s = (a_rev[i] || 0) + (b_rev[i] || 0) + carry;
            out.push(s % BASE);
            carry = Math.floor(s / BASE);
        }
        if (carry) out.push(carry);
        return out.reverse();
    }
    function sub(a, b) { // a - b, assumes a >= b
        let a_rev = a.slice().reverse(); let b_rev = b.slice().reverse();
        let n = a_rev.length, borrow = 0, out = [];
        for (let i = 0; i < n; i++) {
            let v = a_rev[i] - (b_rev[i] || 0) - borrow;
            if (v < 0) { v += BASE; borrow = 1; } else { borrow = 0; }
            out.push(v);
        }
        return trim(out.reverse());
    }
    function mulSmall(a, s) {
        if (s === 0) return [0];
        let a_rev = a.slice().reverse(), carry = 0, out = [];
        for (const d of a_rev) {
            let p = d * s + carry;
            out.push(p % BASE);
            carry = Math.floor(p / BASE);
        }
        while (carry > 0) {
            out.push(carry % BASE);
            carry = Math.floor(carry / BASE);
        }
        return out.reverse();
    }
    function chunksToString(chunks) {
        if (!chunks || chunks.length === 0) return "0";
        let s = chunks[0].toString();
        for (let i = 1; i < chunks.length; i++) {
            s += chunks[i].toString().padStart(chunk_size, '0');
        }
        return s;
    }

    // --- N String Generation (moved to worker) ---
    function generateNString(aStr, bStr, cStr) {
        if (aStr !== '10') {
            throw new Error('Streaming string generation currently only supports base 10.');
        }
        const b = BigInt(bStr);
        const c = BigInt(cStr);
        const cLen = c.toString().length;

        if (b < cLen) {
            return (BigInt(10)**b + c).toString();
        }

        const numZeros = b - BigInt(cLen);
        let nStr = '1';

        const practicalZeroLimit = 2000000;
        if (numZeros > practicalZeroLimit) {
            self.postMessage({ type: 'log', message: 'WARNING: Exponent is too large for full string generation in JS. Simulating with a capped number of zeros.' });
        }

        const zerosToRepeat = numZeros < BigInt(practicalZeroLimit) ? numZeros : BigInt(practicalZeroLimit);
        if (zerosToRepeat > 0) {
            nStr += '0'.repeat(Number(zerosToRepeat));
        }
        nStr += c.toString().padStart(cLen, '0');

        return nStr;
    }


    // --- Main Streaming Sqrt Function ---
    self.onmessage = function(e) {
        const { a, b, c } = e.data;

        let nStr;
        try {
             self.postMessage({ type: 'log', message: 'Generating string representation of N...' });
             nStr = generateNString(a, b, c);
             self.postMessage({ type: 'log', message: \`N has \${nStr.length} digits. Starting streaming square root calculation...\` });
        } catch (err) {
            self.postMessage({ type: 'error', message: 'Failed to generate N string: ' + err.message });
            return;
        }

        const groupDigits = 2 * chunk_size;

        // ** THE FIX IS HERE **
        // Correctly calculate the padding required to make the string length a multiple of groupDigits.
        let padLength = nStr.length % groupDigits;
        if (padLength !== 0) {
            padLength = groupDigits - padLength;
        }
        const paddedNStr = '0'.repeat(padLength) + nStr;

        const groups = [];
        for (let i = 0; i < paddedNStr.length; i += groupDigits) {
            groups.push(paddedNStr.substring(i, i + groupDigits));
        }

        let root = [0];
        let remainder = [0];
        const totalGroups = groups.length;

        groups.forEach((group, index) => {
            remainder.push(0, 0);
            const groupChunks = [parseInt(group.substring(0, chunk_size), 10), parseInt(group.substring(chunk_size), 10)];
            remainder = add(remainder, groupChunks);

            let prefix = mulSmall(root, 2);
            prefix.push(0);

            let lo = 0, hi = BASE - 1, chosen = 0;
            while (lo <= hi) {
                let mid = Math.floor((lo + hi) / 2);
                let t = add(prefix, [mid]);
                let trial = mulSmall(t, mid);
                if (cmp(trial, remainder) <= 0) {
                    chosen = mid;
                    lo = mid + 1;
                } else {
                    hi = mid - 1;
                }
            }

            let t_chosen = add(prefix, [chosen]);
            let trial_chosen = mulSmall(t_chosen, chosen);
            remainder = sub(remainder, trial_chosen);

            root.push(chosen);
            root = trim(root);

            self.postMessage({ type: 'progress', value: ((index + 1) / totalGroups) * 100 });
        });

        self.postMessage({ type: 'result', root: chunksToString(root), remainder: chunksToString(remainder) });
    };
`;

// --- Event Handlers ---
function startSSearch() {
    if (isCalculating) return;

    logOutput.textContent = 'Log:\n';
    log('--- Starting Streaming Sqrt S-Search ---');
    setStatus('Initializing worker...');
    setProgress(0);

    const aStr = baseInput.value;
    const bStr = exponentInput.value;
    const cStr = addendInput.value;

    isCalculating = true;
    sSearchButton.disabled = true;
    stopButton.disabled = false;

    sqrtWorker = new Worker(URL.createObjectURL(new Blob([workerCode], { type: 'application/javascript' })));

    sqrtWorker.onmessage = (e) => {
        if (e.data.type === 'progress') {
            setStatus(`Calculating sqrt(N)... ${e.data.value.toFixed(2)}%`);
            setProgress(e.data.value);
        } else if (e.data.type === 'log') {
            log(e.data.message);
        } else if (e.data.type === 'result') {
            const { root, remainder } = e.data;
            log(`Streaming sqrt complete.`);
            log(`Floor(sqrt(N)) has ${root.length} digits.`);

            const floor_sqrt = BigInt(root);
            const rem = BigInt(remainder);

            let s_min = floor_sqrt * 2n;
            if (rem > 0n) {
                s_min += 1n;
            }

            log(`Calculated S_min = ${s_min.toString().substring(0, 40)}...`);
            log(`S_min has ${s_min.toString().length} digits.`);
            log(`\nNow, the S-Search loop would begin at S_min, using file-based chunked arithmetic to check S^2 - 4N = k^2.`);
            log(`This prototype proves the starting point can be found without crashing.`);
            setStatus('Ready for S-Search loop (conceptual)');
            stopCalculation();
        } else if (e.data.type === 'error') {
            log(`Worker Error: ${e.data.message}`);
            setStatus('Error in streaming calculation.');
            stopCalculation();
        }
    };

    sqrtWorker.onerror = (e) => {
        log(`Worker Error: ${e.message}`);
        setStatus('Error in streaming calculation.');
        stopCalculation();
    };

    // Post the components, not the full number
    sqrtWorker.postMessage({ a: aStr, b: bStr, c: cStr });
}

function stopCalculation() {
    if (sqrtWorker) {
        sqrtWorker.terminate();
        sqrtWorker = null;
    }
    isCalculating = false;
    sSearchButton.disabled = false;
    stopButton.disabled = true;
    if (resultsDiv.textContent.includes('...')) {
        setStatus('Stopped by user.');
    }
}

sSearchButton.addEventListener('click', startSSearch);
stopButton.addEventListener('click', stopCalculation);

</script>
</body>
</html>

