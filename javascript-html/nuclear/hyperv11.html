<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
<title>Factor Hunter v9.0 (Parallel)</title>
<script src="https://cdn.tailwindcss.com"></script>
<style>
  body { background-color: #000; color: #e2e8f0; font-family: 'Courier New', monospace; padding: 10px; }
  .card { background: #111; border: 1px solid #333; border-radius: 12px; padding: 15px; }
  input { width: 100%; background: #222; border: 1px solid #444; color: #fff; padding: 10px; border-radius: 6px; font-weight:bold; }
  .btn { width: 100%; padding: 15px; border-radius: 8px; font-weight: 900; cursor: pointer; text-transform: uppercase; margin-top: 10px; }
  .btn-go { background: #d97706; color: #fff; } /* Amber for "Construction" feel */
  .stat-grid { display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap: 5px; margin-top: 15px; }
  .stat-box { background: #222; padding: 5px; border-radius: 4px; text-align: center; }
  .stat-val { font-size: 0.8rem; font-weight: bold; color: #fbbf24; }
  .stat-lbl { font-size: 0.6rem; color: #666; }
  .progress-container { margin-top: 10px; }
  .p-bar { height: 4px; background: #333; margin-bottom: 4px; width: 100%; position:relative; }
  .p-fill { height: 100%; background: #d97706; width: 0%; transition: width 0.2s; }
</style>
</head>
<body>

<div class="card">
  <h2 class="text-xl font-black text-center text-amber-500 mb-4">FACTOR HUNTER v9.0</h2>
  
  <div class="grid grid-cols-2 gap-2 mb-2">
    <div><label class="text-xs text-gray-500">EXPONENT (INDEX)</label><input id="inpExp" value="1000000"></div>
    <div><label class="text-xs text-gray-500">ADD CONST</label><input id="inpAdd" value="61"></div>
  </div>

  <button id="btnRun" class="btn btn-go" onclick="launchCluster()">INITIATE PARALLEL RUN</button>
  
  <div class="stat-grid">
    <div class="stat-box"><div id="tTotal" class="stat-val">0.0s</div><div class="stat-lbl">TIME</div></div>
    <div class="stat-box"><div id="sCore0" class="stat-val">IDLE</div><div class="stat-lbl">CORE 1</div></div>
    <div class="stat-box"><div id="sCore1" class="stat-val">IDLE</div><div class="stat-lbl">CORE 2</div></div>
    <div class="stat-box"><div id="sCore2" class="stat-val">IDLE</div><div class="stat-lbl">CORE 3</div></div>
  </div>

  <div class="progress-container">
    <div class="p-bar"><div id="p0" class="p-fill" style="background:#ef4444"></div></div> <div class="p-bar"><div id="p1" class="p-fill" style="background:#22c55e"></div></div> <div class="p-bar"><div id="p2" class="p-fill" style="background:#3b82f6"></div></div> </div>

  <div id="log" class="mt-4 text-xs text-gray-400 font-mono h-32 overflow-y-auto border border-gray-800 p-2">
    System Ready. Note 20 Detected.<br>Waiting for orders.
  </div>
</div>

<script>
// --- WORKER SOURCE ---
const workerBlob = new Blob([`
// REDUCED MEMORY FOOTPRINT FOR MOBILE
const PAGE_ELEMENTS = 16 * 1024 * 1024; // 64MB Pages (Smaller chunks for stability)

class VirtualArray {
    constructor(totalSize) {
        this.totalSize = totalSize;
        this.pages = [];
        this.numPages = Math.ceil(totalSize / PAGE_ELEMENTS);
    }
    async allocate() {
        for(let i=0; i<this.numPages; i++) {
            const size = (i === this.numPages-1) ? (this.totalSize % PAGE_ELEMENTS) || PAGE_ELEMENTS : PAGE_ELEMENTS;
            this.pages.push(new Int32Array(size));
            if(i % 5 === 0) await new Promise(r => setTimeout(r, 0)); // Anti-freeze
        }
    }
    // Inline access is manually done in loops for speed, these are helpers
    get(i) { return this.pages[(i / PAGE_ELEMENTS) | 0][i % PAGE_ELEMENTS]; }
    set(i, v) { this.pages[(i / PAGE_ELEMENTS) | 0][i % PAGE_ELEMENTS] = v; }
}

// MATH CORE
function power(base, exp, mod) {
    let res = 1n; base %= mod;
    while (exp > 0n) {
        if (exp & 1n) res = (res * base) % mod;
        base = (base * base) % mod;
        exp >>= 1n;
    }
    return res;
}
function modInverse(n, mod) { return power(n, mod - 2n, mod); }

async function ntt(arr, n, invert, modObj) {
    const Q = modObj.P; const G = modObj.G;
    
    // Bit Reverse
    for (let i = 0, j = 0; i < n; i++) {
        if (i < j) {
            const i_p = (i/PAGE_ELEMENTS)|0; const i_o = i%PAGE_ELEMENTS;
            const j_p = (j/PAGE_ELEMENTS)|0; const j_o = j%PAGE_ELEMENTS;
            const t = arr.pages[i_p][i_o];
            arr.pages[i_p][i_o] = arr.pages[j_p][j_o];
            arr.pages[j_p][j_o] = t;
        }
        let bit = n >> 1;
        while (j & bit) { j ^= bit; bit >>= 1; }
        j ^= bit;
    }

    let stages = 0;
    const maxStages = Math.log2(n);
    
    for (let len = 2; len <= n; len <<= 1) {
        let wlen = power(G, (Q - 1n) / BigInt(len), Q);
        if (invert) wlen = modInverse(wlen, Q);
        
        stages++;
        if(stages % 2 === 0) postMessage({type:'prog', val: (stages/maxStages)});

        const halfLen = len >> 1;
        for (let i = 0; i < n; i += len) {
            let w = 1n;
            for (let j = 0; j < halfLen; j++) {
                const uIdx = i + j;
                const vIdx = i + j + halfLen;
                
                // Manual Inline Access
                const u_p = (uIdx/PAGE_ELEMENTS)|0; const u_o = uIdx%PAGE_ELEMENTS;
                const v_p = (vIdx/PAGE_ELEMENTS)|0; const v_o = vIdx%PAGE_ELEMENTS;
                
                const uVal = BigInt(arr.pages[u_p][u_o]);
                const vVal = BigInt(arr.pages[v_p][v_o]);
                
                const vMod = (vVal * w) % Q;
                const uNew = Number((uVal + vMod) % Q);
                const vNew = Number((uVal - vMod + Q) % Q); // +Q handles negative result
                
                arr.pages[u_p][u_o] = uNew;
                arr.pages[v_p][v_o] = vNew;
                
                w = (w * wlen) % Q;
            }
        }
        if(n > 1000000) await new Promise(r => setTimeout(r, 0)); // Yield on huge arrays
    }
    
    if (invert) {
        const n_inv = modInverse(BigInt(n), Q);
        for (let i = 0; i < n; i++) {
            const p = (i/PAGE_ELEMENTS)|0; const o = i%PAGE_ELEMENTS;
            arr.pages[p][o] = Number((BigInt(arr.pages[p][o]) * n_inv) % Q);
        }
    }
}

self.onmessage = async function(e) {
    const { modObj, expStr, cStr, chunk } = e.data;
    const Q = modObj.P;
    
    try {
        const digits = parseInt(expStr);
        let n = 1; 
        const chunksNeeded = Math.ceil(digits / chunk);
        while(n < chunksNeeded * 2) n <<= 1;
        
        // 1. Allocate
        const ram = new VirtualArray(n);
        await ram.allocate();
        
        // 2. Build Index (5 * 10^Idx + 31)
        const topPos = digits - 1;
        const topIdx = Math.floor(topPos / chunk);
        const topVal = 5 * Math.pow(10, topPos % chunk);
        ram.set(topIdx, topVal);
        ram.set(0, ram.get(0) + 31);
        
        // 3. Forward NTT
        await ntt(ram, n, false, modObj);
        
        // 4. Square
        for(let i=0; i<n; i++) {
            const p = (i/PAGE_ELEMENTS)|0; const o = i%PAGE_ELEMENTS;
            const val = BigInt(ram.pages[p][o]);
            ram.pages[p][o] = Number((val * val) % Q);
        }
        
        // 5. Inverse NTT
        await ntt(ram, n, true, modObj);
        
        // 6. Extract Tail
        const tail = [];
        for(let i=0; i<30; i++) tail.push(ram.get(i)); // Grab first 30 chunks
        
        postMessage({type:'done', result: tail});
        
    } catch(err) {
        postMessage({type:'err', msg: err.message});
    }
};
`], {type: 'application/javascript'});

// --- MAIN THREAD ---
const MODS = [
    { P: 998244353n, G: 3n },
    { P: 1004535809n, G: 3n },
    { P: 985661441n, G: 3n }
];
const BASE_BI = 10000n;
const CHUNK_SIZE = 4;

let workers = [];
let startTime = 0;

function log(m) { 
    const l = document.getElementById('log');
    l.innerHTML += `> ${m}<br>`;
    l.scrollTop = l.scrollHeight;
}

function launchCluster() {
    // Reset
    workers.forEach(w => w.terminate());
    workers = [];
    document.getElementById('log').innerHTML = '';
    
    const exp = document.getElementById('inpExp').value;
    const add = document.getElementById('inpAdd').value;
    
    startTime = Date.now();
    
    log(`Initializing Cluster... Target: 10^${exp}`);
    
    // Spawn 3 Workers
    const promises = MODS.map((mod, i) => {
        return new Promise((resolve, reject) => {
            const w = new Worker(URL.createObjectURL(workerBlob));
            workers.push(w);
            
            w.onmessage = function(e) {
                if(e.data.type === 'prog') {
                    // Update specific progress bar
                    document.getElementById(`p${i}`).style.width = (e.data.val * 100) + '%';
                }
                if(e.data.type === 'done') {
                    document.getElementById(`sCore${i}`).textContent = "DONE";
                    document.getElementById(`sCore${i}`).style.color = "#4ade80"; // Bright green
                    resolve(e.data.result);
                }
                if(e.data.type === 'err') reject(e.data.msg);
            };
            
            document.getElementById(`sCore${i}`).textContent = "RUNNING";
            w.postMessage({ 
                modObj: mod, 
                expStr: exp, 
                cStr: add, 
                chunk: CHUNK_SIZE 
            });
        });
    });
    
    // Timer
    const timer = setInterval(() => {
        document.getElementById('tTotal').textContent = ((Date.now() - startTime)/1000).toFixed(1) + 's';
    }, 100);
    
    Promise.all(promises).then(results => {
        clearInterval(timer);
        log("All Cores Reported In.");
        performCRT(results[0], results[1], results[2]);
    }).catch(e => {
        clearInterval(timer);
        log("CRITICAL ERROR: " + e);
    });
}

function performCRT(r1, r2, r3) {
    const m1 = MODS[0].P, m2 = MODS[1].P, m3 = MODS[2].P;
    const M = m1 * m2 * m3;
    const M1 = M/m1, M2 = M/m2, M3 = M/m3;
    
    // Precompute inverses
    const power = (b,e,m) => { let r=1n; b%=m; while(e>0n){if(e&1n)r=(r*b)%m; b=(b*b)%m; e>>=1n} return r; };
    const inv = (n,m) => power(n,m-2n,m);
    
    const y1 = inv(M1, m1);
    const y2 = inv(M2, m2);
    const y3 = inv(M3, m3);
    
    log("Reconstructing via CRT...");
    
    let carry = 0n;
    const finalChunks = [];
    
    // CRT Reconstruct loop
    const len = Math.min(r1.length, r2.length, r3.length);
    
    for(let i=0; i<len; i++) {
        let t1 = (BigInt(r1[i]) * M1 * y1) % M;
        let t2 = (BigInt(r2[i]) * M2 * y2) % M;
        let t3 = (BigInt(r3[i]) * M3 * y3) % M;
        
        let sum = (t1 + t2 + t3) % M;
        sum += carry;
        
        finalChunks.push(sum % BASE_BI);
        carry = sum / BASE_BI;
    }
    
    // Format
    let str = finalChunks.map(n => n.toString().padStart(4,'0')).reverse().join('').replace(/^0+/,'');
    if(!str) str = "0";
    
    const finalBig = BigInt(str) - 61n; // The Final Adjustment
    
    log("-------------------------");
    log("PROOF SUCCESSFUL");
    log("Tail: " + finalBig.toString());
    log("-------------------------");
}
</script>
</body>
</html>
