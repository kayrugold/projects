<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>The Architect v2.2 (Deep Field)</title>
<script src="https://cdn.tailwindcss.com"></script>
<style>
    body { background-color: #0f172a; color: #e2e8f0; font-family: 'Courier New', monospace; padding: 15px; }
    
    /* CARD & LAYOUT */
    .card { background: #1e293b; border: 1px solid #334155; border-radius: 12px; padding: 20px; max-width: 800px; margin: 0 auto; box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.6); position: relative; }
    .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px; }
    
    /* CONVERTER BOX */
    .converter-box { background: #0f172a; border: 1px dashed #3b82f6; border-radius: 8px; padding: 15px; margin-bottom: 20px; }
    .conv-label { font-size: 0.7rem; color: #3b82f6; font-weight: bold; margin-bottom: 5px; uppercase; }
    .conv-input { width: 100%; background: #1e293b; border: 1px solid #334155; color: #fff; padding: 8px; font-family: monospace; font-size: 0.9rem; margin-bottom: 10px; }
    .conv-btn { background: #1e293b; border: 1px solid #3b82f6; color: #3b82f6; padding: 5px 10px; font-size: 0.75rem; cursor: pointer; font-weight: bold; width: 100%; }
    .conv-btn:hover { background: #3b82f6; color: white; }

    /* INPUTS */
    label { display: block; font-size: 0.7rem; color: #94a3b8; margin-bottom: 4px; font-weight: bold; uppercase; letter-spacing: 0.05em; }
    input { width: 100%; background: #0f172a; border: 1px solid #334155; color: #fff; padding: 12px; border-radius: 6px; font-family: monospace; text-align: center; font-weight: bold; }
    input:focus { outline: none; border-color: #3b82f6; }
    
    /* BUTTONS */
    .btn { width: 100%; padding: 14px; border-radius: 8px; font-weight: 900; cursor: pointer; text-transform: uppercase; border: none; transition: all 0.2s; color: white; }
    .btn-run { background: #3b82f6; box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3); }
    .btn-run:hover { background: #2563eb; }
    .btn-stop { background: #ef4444; display: none; }
    .btn-dl { background: #10b981; margin-top: 10px; display: none; } 
    .btn-help { background: transparent; border: 1px dashed #475569; color: #94a3b8; font-size: 0.8rem; padding: 8px; margin-top: 15px; }
    .btn-help:hover { border-color: #cbd5e1; color: #fff; }

    /* STATS PANEL */
    .stats-container { background: #0f172a; border: 1px solid #334155; border-radius: 8px; padding: 15px; margin-bottom: 20px; }
    .stat-box { text-align: center; padding: 5px; }
    .stat-label { font-size: 0.7rem; color: #64748b; margin-bottom: 2px; }
    .stat-val { font-size: 1.1rem; font-weight: bold; color: #f1f5f9; }
    .timer { color: #fbbf24; text-shadow: 0 0 5px rgba(251, 191, 36, 0.2); }
    
    .hero-stat { grid-column: span 2; border-top: 1px solid #1e293b; margin-top: 10px; padding-top: 10px; }
    .hero-val { font-size: 2rem; color: #4ade80; text-shadow: 0 0 10px rgba(74, 222, 128, 0.2); }

    /* PROGRESS */
    .progress-track { height: 6px; background: #1e293b; border-radius: 3px; overflow: hidden; margin: 15px 0; border: 1px solid #334155; }
    .progress-fill { height: 100%; background: #3b82f6; width: 0%; transition: width 0.2s; }

    /* LOGS & OUTPUT */
    .log-window { background: #020617; border: 1px solid #334155; height: 150px; overflow-y: auto; padding: 10px; font-size: 0.8rem; color: #cbd5e1; border-radius: 6px; font-family: monospace; }
    .data-preview { background: #020617; border: 1px solid #334155; padding: 10px; margin-top: 10px; border-radius: 6px; color: #4ade80; font-size: 0.8rem; min-height: 60px; display: flex; align-items: center; justify-content: center; text-align: center; }

    /* HELP MODAL */
    .modal-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); z-index: 50; backdrop-filter: blur(4px); }
    .modal-content { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1e293b; border: 1px solid #3b82f6; border-radius: 12px; width: 90%; max-width: 550px; padding: 25px; box-shadow: 0 0 40px rgba(59, 130, 246, 0.2); max-height: 85vh; overflow-y: auto; }
    .modal-close { position: absolute; top: 15px; right: 20px; color: #64748b; font-size: 1.5rem; cursor: pointer; }
    .modal-title { font-size: 1.25rem; font-weight: bold; color: #fff; border-bottom: 1px solid #334155; padding-bottom: 10px; margin-bottom: 15px; }
    .modal-p { color: #cbd5e1; font-size: 0.9rem; margin-bottom: 12px; line-height: 1.5; }
    .modal-ex { background: #0f172a; border-left: 3px solid #3b82f6; padding: 10px; margin: 15px 0; font-size: 0.85rem; color: #93c5fd; font-family: monospace; }

</style>
</head>
<body>

<div class="card">
    <h1 class="text-2xl font-bold text-center text-blue-400 mb-1">THE ARCHITECT v2.2</h1>
    <p class="text-center text-xs text-slate-500 mb-6">Deep Field Index Sieve</p>

    <div class="converter-box">
        <div class="conv-label">Number â†” Index Converter</div>
        <input id="convNum" class="conv-input" placeholder="Enter Number (e.g. 1e100)">
        <button class="conv-btn" onclick="convertNumToIndex()">â–¼ Convert to Index & Set Start â–¼</button>
    </div>

    <div class="grid-2">
        <div>
            <label>START INDEX (Supports 1eN)</label>
            <input id="inpStart" value="1">
        </div>
        <div>
            <label>MAX INDEX (or +Offset)</label>
            <input id="inpMax" value="1000" style="border-color: #fbbf24; color: #fbbf24;">
        </div>
    </div>
    
    <div>
        <label>CHUNK SIZE</label>
        <input id="inpChunk" value="100000">
    </div>

    <div class="progress-track"><div id="pBar" class="progress-fill"></div></div>

    <div class="stats-container grid-2">
        <div class="stat-box">
            <div class="stat-label">ELAPSED TIME</div>
            <div id="sTime" class="stat-val timer">00:00:00</div>
        </div>
        <div class="stat-box">
            <div class="stat-label">WALL DENSITY</div>
            <div id="sDensity" class="stat-val">0%</div>
        </div>
        <div class="stat-box hero-stat">
            <div class="stat-label">CANDIDATES FOUND</div>
            <div id="sCount" class="stat-val hero-val">0</div>
        </div>
    </div>

    <button id="btnStart" class="btn btn-run" onclick="startBuild()">BUILD WALLS</button>
    <button id="btnStop" class="btn btn-stop" onclick="stopBuild()">HALT CONSTRUCTION</button>
    <button id="btnDl" class="btn btn-dl" onclick="downloadData()">ðŸ’¾ DOWNLOAD CANDIDATES</button>

    <div class="data-preview" id="livePreview">
        Live Sample: Waiting to start...
    </div>

    <div class="log-window" id="logBox">System Ready.<br>Use Converter above for large numbers.</div>

    <button class="btn btn-help" onclick="showHelp()">[?] MANUAL</button>
</div>

<div id="helpModal" class="modal-overlay">
    <div class="modal-content">
        <span class="modal-close" onclick="closeHelp()">&times;</span>
        <div class="modal-title">THE ARCHITECT MANUAL</div>
        <div class="modal-p">
            <strong>CONVERTER:</strong><br>
            Type a massive number (e.g., <code>1e1000</code>) in the top box. It will calculate <code>(N+1)/2</code> and set the Start Index for you.
        </div>
        <div class="modal-p">
            <strong>DEEP FIELD SCANNING:</strong><br>
            For numbers > 10^14, the system switches to "Candidate Mode." It builds walls using primes up to 10 Million. Indices that survive are <strong>High-Probability Candidates</strong> (not guaranteed primes, but highly likely to be prime or semi-prime).
        </div>
        <div class="modal-p">
            <strong>RANGE SETTING:</strong><br>
            - <strong>Start:</strong> Where to begin.<br>
            - <strong>Max:</strong> If you enter a number smaller than Start (e.g., <code>200000</code>), it acts as an <strong>Offset</strong> (Start + 200,000).
        </div>
    </div>
</div>

<script>
let isRunning = false;
let startTime = 0;
let timerInterval = null;
let worker = null;
let totalPrimes = 0;
let collectedData = []; 

function showHelp() { document.getElementById('helpModal').style.display = 'block'; }
function closeHelp() { document.getElementById('helpModal').style.display = 'none'; }

// --- BIGINT PARSER ---
function parseBigInput(str) {
    str = str.toLowerCase().replace(/\s/g, '');
    if (str.includes('e')) {
        const parts = str.split('e');
        const base = BigInt(parts[0]);
        const exp = BigInt(parts[1]);
        return base * (10n ** exp);
    }
    return BigInt(str);
}

function convertNumToIndex() {
    try {
        const raw = document.getElementById('convNum').value;
        const num = parseBigInput(raw);
        const idx = (num + 1n) / 2n;
        document.getElementById('inpStart').value = idx.toString();
        
        // Auto-set reasonable chunk/offset
        document.getElementById('inpChunk').value = "100000";
        document.getElementById('inpMax').value = "2000000"; // Default +2M offset
        
        log(`Converted Number 10^${raw.split('e')[1] || raw.length} to Index.`);
    } catch(e) {
        alert("Invalid Number Format. Use 1e9 or integer.");
    }
}

// --- WORKER ---
const workerCode = `
self.onmessage = function(e) {
    const { startStr, chunkStr } = e.data;
    const startIdx = BigInt(startStr);
    const size = Number(chunkStr);

    const ruler = new Uint8Array(size);
    
    // Determine Safe Sieve Limit
    // For massive numbers, we clamp to 10M to prevent OOM
    const MAX_SIEVE = 10000000; 
    let limit = MAX_SIEVE;
    
    // Build Walls (Small Primes)
    let walls = 0;
    
    // Generate Sieve Primes
    const gens = new Uint8Array(limit + 1);
    for(let p=3; p<=limit; p+=2) {
        if(gens[p] === 0) {
            const P = BigInt(p);
            
            // Index Stride Logic
            const globalStart = (P*P + 1n) / 2n;
            
            let localStart = 0;
            if (globalStart >= startIdx) {
                if (globalStart < startIdx + BigInt(size)) {
                    localStart = Number(globalStart - startIdx);
                } else {
                    continue; 
                }
            } else {
                // Bridge gap using Modulo for speed on massive startIdx
                // P-Start = (startIdx - globalStart) % P
                // Wait... standard math: 
                // We need K such that globalStart + K*P >= startIdx
                // K = ceil( (startIdx - globalStart)/P )
                
                const dist = startIdx - globalStart;
                const jumps = (dist + P - 1n) / P;
                const firstHit = globalStart + (jumps * P);
                localStart = Number(firstHit - startIdx);
            }

            for(let i=localStart; i<size; i+=p) {
                if(ruler[i] === 0) {
                    ruler[i] = 1;
                    walls++;
                }
            }

            if(p*p <= limit) {
                for(let j=p*p; j<=limit; j+=2*p) gens[j] = 1;
            }
        }
    }

    const results = [];
    for(let i=0; i<size; i++) {
        if(ruler[i] === 0) {
            const idx = startIdx + BigInt(i);
            if(idx > 1n) {
                const val = (idx * 2n) - 1n;
                results.push({ i: idx.toString(), v: val.toString() });
            }
        }
    }

    self.postMessage({ 
        primes: results, 
        walls: walls, 
        total: size,
        nextStart: (startIdx + BigInt(size)).toString() 
    });
};
`;

function log(msg) {
    const el = document.getElementById('logBox');
    const div = document.createElement('div');
    div.innerText = "> " + msg;
    el.prepend(div);
}

function updateTimer() {
    const now = Date.now();
    const diff = Math.floor((now - startTime) / 1000);
    const h = Math.floor(diff / 3600).toString().padStart(2, '0');
    const m = Math.floor((diff % 3600) / 60).toString().padStart(2, '0');
    const s = (diff % 60).toString().padStart(2, '0');
    document.getElementById('sTime').innerText = `${h}:${m}:${s}`;
}

function startBuild() {
    if(isRunning) return;
    isRunning = true;
    
    totalPrimes = 0;
    collectedData = [];
    document.getElementById('sCount').innerText = "0";
    document.getElementById('pBar').style.width = "0%";
    document.getElementById('logBox').innerText = "";
    document.getElementById('btnStart').style.display = "none";
    document.getElementById('btnStop').style.display = "inline-block";
    document.getElementById('btnDl').style.display = "none";

    let start = parseBigInput(document.getElementById('inpStart').value);
    let chunk = document.getElementById('inpChunk').value;
    let maxInput = parseBigInput(document.getElementById('inpMax').value);
    
    // Logic: If Max is small (< Start), treat it as Offset
    let max = maxInput;
    if (maxInput < start) {
        max = start + maxInput;
        log(`Max interpreted as Offset. Scanning to ${max}`);
    }

    log(`Initializing Deep Field Scan...`);
    
    startTime = Date.now();
    timerInterval = setInterval(updateTimer, 1000);

    const blob = new Blob([workerCode], {type: "application/javascript"});
    worker = new Worker(URL.createObjectURL(blob));

    worker.postMessage({ startStr: start.toString(), chunkStr: chunk });

    worker.onmessage = function(e) {
        const { primes, walls, total, nextStart } = e.data;
        
        collectedData = collectedData.concat(primes);
        totalPrimes += primes.length;
        
        document.getElementById('sCount').innerText = totalPrimes.toLocaleString();
        
        const density = ((walls / total) * 100).toFixed(1);
        document.getElementById('sDensity').innerText = density + "%";

        const currentIdx = BigInt(nextStart);
        const maxIdx = max;
        const startIdx = start;
        
        // Progress Math
        let progress = 0;
        if (maxIdx > startIdx) {
            progress = Number((currentIdx - startIdx) * 10000n / (maxIdx - startIdx)) / 100;
        }
        document.getElementById('pBar').style.width = Math.min(progress, 100) + "%";

        if(primes.length > 0) {
            const last = primes[primes.length-1];
            // Truncate massive numbers for display
            let dispV = last.v;
            if(dispV.length > 20) dispV = dispV.substring(0, 10) + "..." + dispV.slice(-5);
            
            document.getElementById('livePreview').innerHTML = 
                `LATEST CANDIDATE<br>Index <span style="color:#fbbf24">${last.i}</span> = Num <span style="color:#fff">${dispV}</span>`;
        }
        
        if (isRunning) {
            if (currentIdx < maxIdx) {
                let nextChunk = BigInt(chunk);
                if (currentIdx + nextChunk > maxIdx) {
                    nextChunk = maxIdx - currentIdx; 
                }
                if (nextChunk > 0n) {
                    setTimeout(() => {
                        worker.postMessage({ startStr: nextStart, chunkStr: nextChunk.toString() });
                    }, 0);
                } else {
                    finishBuild();
                }
            } else {
                finishBuild();
            }
        }
    };
}

function stopBuild() {
    log("Manual Abort triggered.");
    finishBuild();
}

function finishBuild() {
    if(worker) worker.terminate();
    worker = null;
    isRunning = false;
    clearInterval(timerInterval);
    document.getElementById('btnStart').style.display = "inline-block";
    document.getElementById('btnStop').style.display = "none";
    document.getElementById('btnDl').style.display = "block";
    document.getElementById('pBar').style.width = "100%";
    log("Scan Complete. Candidates ready for download.");
}

function downloadData() {
    let content = "INDEX, NUMBER, STATUS\n";
    collectedData.forEach(p => {
        content += `${p.i}, ${p.v}, CANDIDATE\n`;
    });
    
    const blob = new Blob([content], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `architect_candidates_${totalPrimes}.txt`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
}
</script>
</body>
</html>
