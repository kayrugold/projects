<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Holographic Command Center v2</title>
<style>
    body { margin: 0; background: #0f172a; overflow: hidden; font-family: 'Courier New', monospace; touch-action: none; color: #94a3b8; }

    /* TICKER */
    .hud-top {
        position: absolute; top: 0; left: 0; right: 0; height: 85px;
        background: rgba(15, 23, 42, 0.95);
        border-bottom: 1px solid #334155;
        display: flex; justify-content: space-between; align-items: center;
        padding: 0 15px;
        backdrop-filter: blur(5px);
        z-index: 50;
    }
    .metric { display: flex; flex-direction: column; }
    .label { font-size: 9px; color: #64748b; letter-spacing: 1px; text-transform: uppercase; margin-bottom: 2px; }
    .value-lg { font-size: 24px; color: #f43f5e; font-weight: 900; letter-spacing: -1px; }
    .value-sm { font-size: 14px; color: #e2e8f0; font-weight: bold; }

    /* INSPECTOR PANEL (Hidden by default) */
    .inspector {
        position: absolute; bottom: 70px; left: 10px; right: 10px;
        background: rgba(30, 41, 59, 0.95);
        border: 1px solid #475569; border-radius: 8px;
        padding: 15px;
        display: none; /* Hidden until click */
        flex-direction: column; gap: 8px;
        box-shadow: 0 -4px 20px rgba(0,0,0,0.5);
        z-index: 60;
        pointer-events: none; /* Let clicks pass through to canvas if needed, but text is selectable */
    }
    .insp-title { color: #f43f5e; font-size: 14px; font-weight: bold; text-transform: uppercase; border-bottom: 1px solid #334155; padding-bottom: 5px; margin-bottom: 5px; }
    .insp-row { display: flex; justify-content: space-between; font-size: 12px; color: #cbd5e1; }
    .insp-val { font-weight: bold; color: white; }
    .hits-box { margin-top: 5px; font-size: 11px; color: #94a3b8; line-height: 1.4; }
    .hit-tag { color: #f43f5e; font-weight: bold; }

    /* CONTROLS */
    .hud-bot {
        position: absolute; bottom: 0; left: 0; right: 0; height: 70px;
        background: rgba(15, 23, 42, 0.95);
        border-top: 1px solid #334155;
        display: flex; align-items: center; justify-content: space-around;
        padding: 0 10px;
        z-index: 100;
    }
    .btn {
        background: #1e293b; border: 1px solid #334155; color: #cbd5e1;
        padding: 10px 16px; border-radius: 6px; font-weight: bold; font-size: 12px;
        text-transform: uppercase; cursor: pointer; flex-grow: 1; margin: 0 5px; text-align: center;
    }
    .btn:active { background: #334155; color: white; border-color: #f43f5e; }
    .btn-alert { color: #f43f5e; border-color: #9f1239; }

    canvas { display: block; width: 100vw; height: 100vh; }
</style>
</head>
<body>

<div class="hud-top">
    <div class="metric">
        <span class="label">Center Index</span>
        <span id="dispIndex" class="value-lg">0</span>
    </div>
    <div class="metric" style="text-align: right;">
        <span class="label">Rim Value</span>
        <span id="dispRim" class="value-sm">0</span>
    </div>
</div>

<div id="inspector" class="inspector">
    <div class="insp-title">INSPECTOR DATA</div>
    <div class="insp-row"><span>Index (I):</span> <span id="inspIdx" class="insp-val">--</span></div>
    <div class="insp-row"><span>Rim (Odd):</span> <span id="inspRim" class="insp-val">--</span></div>
    <div class="insp-row"><span>Status:</span> <span id="inspStatus" class="insp-val">--</span></div>
    <div class="hits-box" id="inspHits"></div>
</div>

<div class="hud-bot">
    <button class="btn" onclick="jumpTo('1000000000')">10⁹</button>
    <button class="btn btn-alert" onclick="jumpTo('10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001')">10¹⁰⁰</button>
    <button class="btn" onclick="resetView()">Home</button>
</div>

<canvas id="c"></canvas>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d', { alpha: false });

// CONFIG
const LAYOUT = { topPad: 100, railStart: 110, railSpace: 28, keyH: 30, keyYOffset: 80 };
const COLORS = ['#f43f5e', '#3b82f6', '#22c55e', '#eab308', '#a855f7', '#ec4899', '#06b6d4'];
const PRIMES = [3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71];

// STATE
let viewOffset = 0n;
let pxPerUnit = 40; 
let isDragging = false;
let selectedIndex = null; // BigInt of selected column
let lastX = 0;

// EVENTS
function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    draw();
}
window.addEventListener('resize', resize);

// Touch Logic
let lastTouchX = 0;
let lastDist = 0;
let touchStartTime = 0;

canvas.addEventListener('touchstart', e => {
    if(e.touches.length === 1) {
        lastTouchX = e.touches[0].clientX;
        isDragging = true;
        touchStartTime = Date.now();
    } else if(e.touches.length === 2) {
        isDragging = false;
        lastDist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
    }
}, {passive: false});

canvas.addEventListener('touchmove', e => {
    e.preventDefault();
    if(e.touches.length === 1 && isDragging) {
        const dx = e.touches[0].clientX - lastTouchX;
        lastTouchX = e.touches[0].clientX;
        pan(dx);
    } else if(e.touches.length === 2) {
        const dist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
        zoom((dist - lastDist) * 2, (e.touches[0].clientX + e.touches[1].clientX)/2);
        lastDist = dist;
    }
}, {passive: false});

canvas.addEventListener('touchend', e => {
    isDragging = false;
    // Detect Tap (short duration, no move)
    if(e.changedTouches.length === 1) {
        const dur = Date.now() - touchStartTime;
        if(dur < 250) handleTap(e.changedTouches[0].clientX, e.changedTouches[0].clientY);
    }
});

// Mouse Logic
canvas.addEventListener('mousedown', e => { isDragging = true; lastX = e.clientX; touchStartTime = Date.now(); });
window.addEventListener('mouseup', e => { 
    isDragging = false; 
    if(Date.now() - touchStartTime < 200) handleTap(e.clientX, e.clientY);
});
window.addEventListener('mousemove', e => {
    if(!isDragging) return;
    const dx = e.clientX - lastX;
    lastX = e.clientX;
    pan(dx);
});
canvas.addEventListener('wheel', e => {
    e.preventDefault();
    zoom(-e.deltaY, e.clientX);
}, {passive: false});

// CORE LOGIC
function pan(dx) {
    const units = dx / pxPerUnit;
    const shift = BigInt(Math.round(-units));
    if(shift !== 0n) {
        viewOffset += shift;
        if(viewOffset < 0n) viewOffset = 0n;
        draw();
    }
}

function zoom(delta, centerX) {
    const oldScale = pxPerUnit;
    let newScale = oldScale + (delta * 0.1);
    if(newScale < 5) newScale = 5;
    if(newScale > 150) newScale = 150;
    
    const mouseUnits = centerX / oldScale;
    const shift = mouseUnits - (centerX / newScale);
    viewOffset += BigInt(Math.floor(shift));
    if(viewOffset < 0n) viewOffset = 0n;
    pxPerUnit = newScale;
    draw();
}

function handleTap(x, y) {
    // Convert Screen X to Index
    const unitOffset = Math.floor(x / pxPerUnit);
    const clickedI = viewOffset + BigInt(unitOffset);
    
    selectedIndex = clickedI;
    updateInspector(clickedI);
    draw();
}

function updateInspector(idx) {
    const el = document.getElementById('inspector');
    el.style.display = 'flex';
    
    document.getElementById('inspIdx').innerText = idx.toString();
    const rim = idx * 2n - 1n;
    document.getElementById('inspRim').innerText = rim.toString();
    
    // Calculate Hits locally for visualizer
    const hits = [];
    PRIMES.forEach(p => {
        const pBI = BigInt(p);
        // Stride Check: I = inv2 mod p?
        // Actually: Start = (p^2+1)/2. 
        // Hit if (I - Start) % p == 0
        const start = (pBI*pBI + 1n)/2n;
        
        // We need to check if idx >= start AND (idx - start) % p == 0
        if (idx >= start) {
            const diff = idx - start;
            if (diff % pBI === 0n) hits.push(p);
        }
    });
    
    const statEl = document.getElementById('inspStatus');
    const hitsEl = document.getElementById('inspHits');
    
    if (hits.length > 0) {
        statEl.innerText = "COMPOSITE";
        statEl.style.color = "#ef4444"; // Red
        hitsEl.innerHTML = "INTERFERENCE DETECTED:<br>" + hits.map(h => `<span class="hit-tag">Family ${h}</span>`).join(", ");
    } else {
        // Warning: This is only "Prime relative to displayed families"
        statEl.innerText = "PRIME CANDIDATE*";
        statEl.style.color = "#22c55e"; // Green
        hitsEl.innerHTML = "*No interference from top 20 families.";
    }
}

function jumpTo(val) { viewOffset = BigInt(val); draw(); }
function resetView() { viewOffset = 0n; pxPerUnit = 40; selectedIndex = null; document.getElementById('inspector').style.display='none'; draw(); }

// RENDER
function draw() {
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    const unitsOnScreen = Math.ceil(canvas.width / pxPerUnit) + 1;
    const startI = viewOffset;
    const keyY = canvas.height - LAYOUT.keyYOffset;
    
    ctx.textAlign = 'center';
    
    // 1. GRID & LABELS
    let labelSkip = 1;
    if(pxPerUnit < 30) labelSkip = 2;
    if(pxPerUnit < 15) labelSkip = 5;
    if(pxPerUnit < 8) labelSkip = 10;

    for(let i=0; i<unitsOnScreen; i++) {
        const idxVal = startI + BigInt(i);
        const x = i * pxPerUnit;
        
        // Highlight Selected
        if(selectedIndex === idxVal) {
            ctx.fillStyle = 'rgba(244, 63, 94, 0.15)';
            ctx.fillRect(x, LAYOUT.topPad, pxPerUnit, keyY - LAYOUT.topPad + LAYOUT.keyH);
            ctx.strokeStyle = '#f43f5e';
            ctx.lineWidth = 1;
            ctx.strokeRect(x, LAYOUT.topPad, pxPerUnit, keyY - LAYOUT.topPad + LAYOUT.keyH);
        }
        
        // Grid Line
        ctx.strokeStyle = '#1e293b';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(x + pxPerUnit/2, LAYOUT.topPad); // Center line
        ctx.lineTo(x + pxPerUnit/2, keyY);
        ctx.stroke();
        
        // Label
        if(Number(idxVal % BigInt(labelSkip)) === 0) {
            ctx.fillStyle = '#475569';
            ctx.font = '10px Courier New';
            ctx.fillText(idxVal.toString(), x + pxPerUnit/2, LAYOUT.topPad - 10);
        }
    }
    
    // 2. PRIME RAILS
    const compositeHits = new Set();
    const visibleRailCount = Math.floor((keyY - LAYOUT.railStart) / LAYOUT.railSpace);
    
    for(let pIdx=0; pIdx < Math.min(PRIMES.length, visibleRailCount); pIdx++) {
        const p = PRIMES[pIdx];
        const pBI = BigInt(p);
        const color = COLORS[pIdx % COLORS.length];
        const y = LAYOUT.railStart + (pIdx * LAYOUT.railSpace);
        
        // Line
        ctx.strokeStyle = color;
        ctx.globalAlpha = 0.2;
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
        ctx.globalAlpha = 1.0;
        
        // Hits
        const startIdxAbs = (pBI * pBI + 1n) / 2n;
        let k = 0n;
        if(viewOffset > startIdxAbs) {
            const diff = viewOffset - startIdxAbs;
            k = diff / pBI;
            if(diff % pBI !== 0n) k += 1n;
        }
        
        let currIdx = startIdxAbs + k * pBI;
        const endI = startI + BigInt(unitsOnScreen);
        
        while(currIdx < endI) {
            const localOffset = Number(currIdx - viewOffset);
            const screenX = localOffset * pxPerUnit + pxPerUnit/2;
            
            // Dot
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(screenX, y, 4, 0, Math.PI*2);
            ctx.fill();
            
            // Collision Logic
            compositeHits.add(localOffset);
            
            // If Selected, highlight the specific dot
            if(currIdx === selectedIndex) {
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(screenX, y, 7, 0, Math.PI*2);
                ctx.stroke();
            }
            
            currIdx += pBI;
        }
    }
    
    // 3. PIANO KEYS
    for(let i=0; i<unitsOnScreen; i++) {
        const x = i * pxPerUnit;
        const w = Math.max(pxPerUnit - 2, 1);
        const isHit = compositeHits.has(i);
        const kx = x + 1;
        
        if(isHit) {
            // Black Key
            ctx.fillStyle = '#020617';
            ctx.fillRect(kx, keyY, w, LAYOUT.keyH);
            ctx.strokeStyle = '#334155';
            ctx.strokeRect(kx, keyY, w, LAYOUT.keyH);
        } else {
            // White Key
            ctx.fillStyle = '#e2e8f0';
            ctx.shadowBlur = 10;
            ctx.shadowColor = 'white';
            ctx.fillRect(kx, keyY, w, LAYOUT.keyH);
            ctx.shadowBlur = 0;
            ctx.fillStyle = '#22c55e';
            ctx.fillRect(kx, keyY + LAYOUT.keyH, w, 2);
        }
    }

    // UPDATE TOP TICKER (Center of Screen)
    const centerUnit = Math.floor(unitsOnScreen / 2);
    const centerI = startI + BigInt(centerUnit);
    document.getElementById('dispIndex').innerText = centerI.toString();
    const rim = centerI * 2n - 1n;
    let rStr = rim.toString();
    if(rStr.length > 20) rStr = ".." + rStr.slice(-15);
    document.getElementById('dispRim').innerText = rStr;
}

resize();
</script>
</body>
</html>
