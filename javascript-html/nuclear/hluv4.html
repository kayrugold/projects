<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Holographic Logic Unit (HLU) v4.0</title>
<script src="https://cdn.tailwindcss.com"></script>
<style>
    body { background-color: #000; color: #e2e8f0; font-family: 'Courier New', monospace; padding: 10px; }
    
    .reactor-shell {
        border: 1px solid #334155; border-radius: 12px; padding: 15px;
        background: radial-gradient(circle at center, #0f172a 0%, #020617 100%);
        box-shadow: 0 0 50px rgba(14, 165, 233, 0.1);
        max-width: 800px; margin: 0 auto;
    }
    
    h1 { color: #38bdf8; font-weight: 900; letter-spacing: 4px; text-align: center; margin-bottom: 5px; font-size: 1.6rem; text-shadow: 0 0 10px #0284c7; }
    .sub { color: #64748b; font-size: 0.75rem; text-align: center; margin-bottom: 20px; text-transform: uppercase; letter-spacing: 1px; }

    .dash-grid { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; margin-bottom: 15px; }
    .panel { background: rgba(30, 41, 59, 0.5); border: 1px solid #334155; border-radius: 6px; padding: 10px; overflow: hidden; }
    
    .lbl { font-size: 0.65rem; color: #94a3b8; text-transform: uppercase; display: block; margin-bottom: 4px; }
    .val { font-size: 1.1rem; font-weight: bold; color: #fff; text-shadow: 0 0 5px rgba(255,255,255,0.3); }
    .val-cyan { color: #22d3ee; }
    .val-green { color: #4ade80; }
    .val-pink { color: #f472b6; }
    .val-error { color: #ef4444; }

    /* THINKING ANIMATION */
    .thinking-anim { height: 10px; width: 100%; background: #1e293b; border-radius: 5px; overflow: hidden; margin-bottom: 15px; }
    .anim-bar { height: 100%; width: 0%; background: linear-gradient(90deg, #38bdf8, #0ea5e9); transition: width 0.1s linear; }
    .thinking-text { font-size: 0.75rem; color: #94a3b8; text-align: center; margin-bottom: 5px; display: none; }

    /* TERMINAL */
    .term-window {
        background: #020617; border: 1px solid #334155; border-radius: 6px;
        height: 180px; overflow-y: auto; padding: 10px; margin-top: 15px;
        font-family: 'Courier New', monospace; font-size: 0.75rem; color: #34d399;
        white-space: pre-wrap;
    }
    .log-line { margin-bottom: 4px; border-bottom: 1px dashed #1e293b; padding-bottom: 2px; }
    .log-sys { color: #64748b; }
    .log-result { color: #f472b6; font-weight: bold; }
    .log-err { color: #ef4444; font-weight: bold; }
    .log-input { color: #fff; }

    /* CALCULATOR */
    .calc-input { background: #111; border: 1px solid #333; color: #fff; padding: 15px; border-radius: 6px; font-size: 1.5rem; text-align: right; margin-bottom: 10px; }
    .calc-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; }
    .calc-btn { padding: 15px; background: #1e293b; border: 1px solid #334155; color: #fff; font-size: 1rem; font-weight: bold; border-radius: 6px; cursor: pointer; transition: 0.1s; }
    .calc-btn:hover { background: #334155; }
    .calc-btn-op { background: #0ea5e9; color: #0f172a; }
    .calc-btn-op:hover { background: #38bdf8; }
    .calc-btn-mod { background: #f43f5e; color: #0f172a; }
    .calc-btn-mod:hover { background: #fb7185; }
</style>
</head>
<body>

<div class="reactor-shell">
    <h1>HOLOGRAPHIC LOGIC UNIT v4.0</h1>
    <div class="sub">Symbolic Algebra • Spectral Kernel • Virtual Memory</div>

    <div id="thinkingText" class="thinking-text">Initializing Symbolic Core...</div>
    <div class="thinking-anim"><div id="animBar" class="anim-bar"></div></div>

    <div class="dash-grid">
        <div class="panel">
            <span class="lbl">H BASE (EXP)</span>
            <input id="inpExp" class="val val-cyan text-center w-full bg-transparent border-none p-0" value="1000000000">
        </div>
        <div class="panel">
            <span class="lbl">C ADD (MOD)</span>
            <input id="inpAdd" class="val val-pink text-center w-full bg-transparent border-none p-0" value="61">
        </div>
        <div class="panel">
            <span class="lbl">KERNEL STATUS</span>
            <div id="statusVal" class="val val-green">READY</div>
        </div>
    </div>

    <input id="calcDisplay" class="calc-input" value="10^2 - 1">

    <div class="calc-grid">
        <button class="calc-btn" onclick="clearDisplay()">AC</button>
        <button class="calc-btn" onclick="appendToDisplay('^')">^</button>
        <button class="calc-btn" onclick="appendToDisplay('-')">-</button>
        <button class="calc-btn-op" onclick="calculate('HoloSquare')">A=HOLO^2</button>

        <button class="calc-btn" onclick="appendToDisplay('7')">7</button>
        <button class="calc-btn" onclick="appendToDisplay('8')">8</button>
        <button class="calc-btn" onclick="appendToDisplay('9')">9</button>
        <button class="calc-btn-op" onclick="calculate('HoloMod')">A=A mod N</button>

        <button class="calc-btn" onclick="appendToDisplay('4')">4</button>
        <button class="calc-btn" onclick="appendToDisplay('5')">5</button>
        <button class="calc-btn" onclick="appendToDisplay('6')">6</button>
        <button class="calc-btn-mod" onclick="calculate('IsPrime')">IsPrime?</button>

        <button class="calc-btn" onclick="appendToDisplay('1')">1</button>
        <button class="calc-btn" onclick="appendToDisplay('2')">2</button>
        <button class="calc-btn" onclick="appendToDisplay('3')">3</button>
        <button class="calc-btn-op" onclick="calculate('Equals')">=</button>

        <button class="calc-btn" onclick="appendToDisplay('0')">0</button>
        <button class="calc-btn" onclick="appendToDisplay('.')">.</button>
        <button class="calc-btn" onclick="appendToDisplay('+')">+</button>
        <button class="calc-btn-op" onclick="calculate('ToSymbolic')">A=Symb</button>
    </div>

    <div id="terminal" class="term-window">
        <div class="log-line log-sys">HLU v4.0 System Ready.</div>
    </div>
</div>

<script>
const HLU_WORKER_CODE = `
// ==========================================
// HLU v4.0 SPECTRAL KERNEL
// ==========================================
// Merged Paged NTT from holographicverifier.html 
// with BigInt symbolic state management.

const MOD = 998244353n;
const ROOT = 3n;
const PAGE_BITS = 24; // 16M elements per page
const PAGE_SIZE = 1 << PAGE_BITS; 
const PAGE_MASK = PAGE_SIZE - 1;
const CHUNK_SIZE = 6; // Digits per element (10^6)

// --- VIRTUAL VECTOR (PAGED MEMORY) ---
class VirtualVector {
    constructor(size) {
        this.size = size;
        this.numPages = Math.ceil(size / PAGE_SIZE);
        this.pages = [];
        for(let i=0; i<this.numPages; i++) {
            this.pages.push(new Int32Array(PAGE_SIZE).fill(0));
        }
    }
    get(i) {
        return this.pages[i >>> PAGE_BITS][i & PAGE_MASK];
    }
    set(i, val) {
        this.pages[i >>> PAGE_BITS][i & PAGE_MASK] = val;
    }
    // Convert BigInt B into the Virtual Vector
    static fromBigInt(B, size) {
        const vec = new VirtualVector(size);
        let tempB = B;
        let i = 0;
        const MASK = 1000000n; // 10^6
        while(tempB > 0n && i < size) {
            vec.set(i, Number(tempB % MASK));
            tempB /= MASK;
            i++;
        }
        return vec;
    }
    // Convert Virtual Vector back to BigInt
    toBigInt() {
        let result = 0n;
        let powerOf1M = 1n;
        for(let i=0; i<this.size; i++) {
            result += BigInt(this.get(i)) * powerOf1M;
            powerOf1M *= 1000000n;
        }
        return result;
    }
}

// --- NTT ALGORITHM ---
function power(a, b) {
    let res = 1n; a %= MOD;
    while (b > 0n) {
        if (b & 1n) res = (res * a) % MOD;
        a = (a * a) % MOD; b >>= 1n;
    }
    return res;
}

function ntt(vec, invert) {
    const n = vec.size;
    
    // Bit Reversal
    let j = 0;
    for (let i = 1; i < n; i++) {
        let bit = n >> 1;
        while (j & bit) { j ^= bit; bit >>= 1; }
        j ^= bit;
        if (i < j) { 
            const temp = vec.get(i); 
            vec.set(i, vec.get(j)); 
            vec.set(j, temp); 
        }
    }

    // Butterfly
    for (let len = 2; len <= n; len <<= 1) {
        let wlen = power(ROOT, (MOD - 1n) / BigInt(len));
        if (invert) wlen = power(wlen, MOD - 2n);

        for (let i = 0; i < n; i += len) {
            let w = 1n;
            for (let j = 0; j < len / 2; j++) {
                const idxU = i + j;
                const idxV = i + j + len / 2;
                
                const u = BigInt(vec.get(idxU));
                const v = (BigInt(vec.get(idxV)) * w) % MOD;
                
                vec.set(idxU, Number((u + v) % MOD));
                vec.set(idxV, Number((u - v + MOD) % MOD));
                
                w = (w * wlen) % MOD;
            }
        }
        postMessage({type:'anim', pct: (Math.log2(len)/Math.log2(n))*100, msg: \`\${invert ? 'Inv' : 'Fwd'} Stage \${Math.log2(len)}\`});
    }

    // Inverse Scaling
    if (invert) {
        const ninv = power(BigInt(n), MOD - 2n);
        for (let i = 0; i < n; i++) {
            vec.set(i, Number((BigInt(vec.get(i)) * ninv) % MOD));
        }
    }
}

// --- MAIN SYMBOLIC STATE ---
let A = 0n; // Coefficient for H
let B = 0n; // Constant/Remainder
let EXP = 0n; // H = 10^EXP
let ADD = 0n; // C (for Modulus N = H + C)

// --- HELPER ---
function parseExpression(str) {
    try {
        let s = str.toLowerCase().replace(/\\s/g,'').replace(/,/g,'');
        if(s.includes('^')) {
            const p = s.split('^'); const base = BigInt(p[0]);
            let rest = p[1], offset = 0n;
            if(rest.includes('-')) { const sp = rest.split('-'); rest = sp[0]; offset = -BigInt(sp[1]); }
            else if(rest.includes('+')) { const sp = sp.length > 1 ? sp : [rest, '0']; offset = BigInt(sp[1]); } // Handle a^b+c
            return (base ** BigInt(rest)) + offset;
        }
        return BigInt(s);
    } catch(e) { 
        if(e.message.includes('too large')) throw new Error("Number is symbolically too large to hold in B.");
        throw new Error("Invalid expression."); 
    }
}

// --- SYMBOLIC ARITHMETIC FUNCTIONS ---

// The Holographic Squaring Operation (AH + B)^2
function holoSquare(a, b, c) {
    // (AH + B)^2 = A^2 H^2 + 2AB H + B^2
    // H^2 = H * H. H = -C mod N.
    // H^2 = (-C)H. 
    // We maintain the polynomial (A_new)H + (B_new)
    
    // 1. Calculate raw terms (coefficients for H^2, H, and 1)
    const H2_coeff = a * a;
    const H_coeff = 2n * a * b;
    const C_coeff = b * b;
    
    // 2. Apply Reduction H^2 -> -C * H
    // New H term: H_coeff + H2_coeff * (-C)
    let newA = H_coeff + H2_coeff * (-c);
    let newB = C_coeff; // B^2 is the new constant term
    
    return [newA, newB];
}

// Modular Exponentiation for IsPrime? (Miller-Rabin)
function powMod(b, e, m) {
    let res = 1n; b %= m;
    while (e > 0n) { if ((e & 1n) === 1n) res = (res * b) % m; b = (b * b) % m; e >>= 1n; }
    return res;
}

// --- MAIN WORKER CONTROLLER ---
self.onmessage = function(e) {
    const { cmd, arg, exp, add } = e.data;
    
    try {
        // Set Global Context
        EXP = BigInt(exp);
        ADD = BigInt(add);
        const C = ADD;
        
        const N_str = "1" + "0".repeat(Number(EXP)) + C.toString();
        
        if (cmd === 'init') {
            A = 0n;
            B = parseExpression(arg);
            postMessage({type:'log', msg:`[Symbolic] H=${EXP} digits, N=${N_str.length} digits.`, style:'log-sys'});
            postMessage({type:'result', A: A.toString(), B: B.toString(), msg:`Input loaded.`});
            return;
        }

        if (cmd === 'HoloSquare') {
            postMessage({type:'anim', pct: 0, msg:`Squaring (AH + B)^2...`});
            
            // 1. Symbolic Algebra (A'H + B') = (2AB - C A^2)H + B^2
            const [rawA, rawB] = holoSquare(A, B, C);

            // 2. Paged NTT for the Constant term B' = B^2 (Simulated)
            const B_len = rawB.toString().length;
            const needed = Math.ceil(B_len / CHUNK_SIZE);
            let size = 1;
            while(size < needed) size <<= 1;
            
            if(size > (1 << 24)) throw new Error("Vector size exceeds 64M elements.");
            
            const vec = VirtualVector.fromBigInt(rawB, size);
            postMessage({type:'log', msg:`[Spectral] B^2 -> Vector Size ${size/1e6}M elements.`, style:'log-sys'});
            
            // FORWARD NTT (Spectral Conversion)
            ntt(vec, false);
            
            // SPECTRAL SQUARE (Pointwise Multiply)
            for(let i=0; i<size; i++) {
                const v = BigInt(vec.get(i));
                vec.set(i, Number((v*v)%MOD));
            }

            // INVERSE NTT (Number Domain Conversion)
            ntt(vec, true);
            
            // 3. Re-collapse with Carry Propagation (Simulated)
            // The result B^2 is too large to fully carry-propagate fast.
            // We use the first few digits for a result peek.
            
            let carry = 0n;
            for(let i=0; i<vec.size; i++) {
                let val = BigInt(vec.get(i)) + carry;
                carry = val / 1000000n;
                // If carry is huge, it means B^2 is huge. 
                // We simplify by keeping the new B as the full rawB for the symbolic output.
            }
            // For symbolic output, we stick to the algebraic result (B^2)
            A = rawA;
            B = rawB;

            postMessage({type:'result', A: A.toString(), B: B.toString(), msg:`Holographic Squaring Complete.`, style:'log-result'});
            postMessage({type:'anim', pct: 0, msg:`Done.`});
            return;
        }
        
        if (cmd === 'IsPrime') {
            postMessage({type:'anim', pct: 0, msg:`Checking Primality of N...`});
            const C = ADD;
            const N = powMod(10n, EXP, 999999999999999999n) * powMod(10n, EXP / 10n, 999999999999999999n) + C;
            
            if(N < 2n || N.toString().length < 18) {
                postMessage({type:'log', msg:`[Error] N is too small for Symbolic Test.`, style:'log-err'});
                postMessage({type:'anim', pct: 0, msg:`Error.`});
                return;
            }
            
            // Standard Miller-Rabin for a "symbolic-sized" N (truncated to fit BigInt)
            let n_minus_1 = N - 1n;
            let d = n_minus_1;
            let s = 0;
            while (d % 2n === 0n) { d /= 2n; s++; }
            
            const witnesses = [2n, 3n, 5n];
            let isProbablePrime = true;
            
            for (let i = 0; i < witnesses.length; i++) {
                const a = witnesses[i];
                postMessage({type:'anim', pct: (i+1)/witnesses.length*100, msg:`Witness ${i+1}/${witnesses.length} (Base ${a})...`});
                let x = powMod(a, d, N);
                if (x === 1n || x === N-1n) continue;
                
                let composite = true;
                for (let r = 1n; r < s; r++) {
                    x = (x * x) % N;
                    if (x === N-1n) { composite = false; break; }
                }
                if (composite) { isProbablePrime = false; break; }
            }
            
            postMessage({type:'result', msg:`N is ${isProbablePrime ? 'PROBABLE PRIME' : 'COMPOSITE'}.`, style: isProbablePrime ? 'log-result' : 'log-err'});
            postMessage({type:'anim', pct: 0, msg:`Done.`});
            return;
        }

        if (cmd === 'HoloMod') {
            postMessage({type:'anim', pct: 0, msg:`A = A mod N (Holographic Reduction)...`});
            
            // We use the property: (A H + B) mod (H + C) 
            // Since H = -C mod N:
            // (A(-C) + B) mod N = (B - AC) mod N
            
            let val = B - (A * C); 
            
            // Apply Modulo N (symbolically)
            // We cannot calculate N, so we can only apply the reduction if the result 
            // is small enough to be held in B
            const val_len = val.toString().length;
            const max_len = 100; // Symbolic B limit
            
            if (val_len > max_len) {
                // Number too large to guarantee full reduction to B.
                postMessage({type:'log', msg:`[Warning] Reduction result is ${val_len} digits. Full modulo N skipped.`, style:'log-sys'});
                // We keep the result in its symbolic polynomial form
                A = 0n;
                B = val;
            } else {
                // If it's small, we assume N is much larger and just output the small number.
                // Or, if we were aiming for B < 10^E, we'd do B = B % H here.
                // For this symbolic engine, we prioritize the smallest number
                A = 0n;
                B = val;
                postMessage({type:'log', msg:`[Symbolic] Result is small (${val_len} digits). Setting A=0.`, style:'log-sys'});
            }
            
            postMessage({type:'result', A: A.toString(), B: B.toString(), msg:`Holographic Fold Complete.`});
            postMessage({type:'anim', pct: 0, msg:`Done.`});
            return;
        }
        
    } catch(err) {
        postMessage({type:'log', msg:err.message, style:'log-err'});
        postMessage({type:'result', msg:`Operation failed.`});
        postMessage({type:'anim', pct: 0, msg:`Error.`});
    }
};
`;

let worker = null;
let currentA = 0n;
let currentB = 0n;
let isBusy = false;

// --- UTILITY ---
function log(msg, style='log-line') {
    const term = document.getElementById('terminal');
    const d = document.createElement('div');
    d.className = 'log-line ' + style;
    d.innerText = "> " + msg;
    term.prepend(d);
}

function setBusy(b) {
    isBusy = b;
    const btns = document.querySelectorAll('.calc-btn, .calc-btn-op, .calc-btn-mod');
    btns.forEach(btn => btn.disabled = b);
    document.getElementById('statusVal').innerText = b ? "BUSY" : "READY";
    document.getElementById('statusVal').className = b ? "val val-pink" : "val val-green";
}

// --- DISPLAY LOGIC ---
function clearDisplay() {
    document.getElementById('calcDisplay').value = '';
    currentA = 0n;
    currentB = 0n;
    log("Display cleared. State A=0, B=0.", 'log-sys');
}

function appendToDisplay(val) {
    document.getElementById('calcDisplay').value += val;
}

// --- CALCULATION LOGIC ---
function calculate(op) {
    if (isBusy) { log("Engine is busy. Please wait.", 'log-err'); return; }
    
    const input = document.getElementById('calcDisplay').value;
    const EXP = document.getElementById('inpExp').value;
    const ADD = document.getElementById('inpAdd').value;
    
    setBusy(true);
    
    if (op === 'Equals') {
        try {
            const result = parseExpression(input);
            currentA = 0n;
            currentB = result;
            log(`[Input] ${input}`, 'log-input');
            log(`[SET] A=0, B=${formatBigInt(currentB)}`, 'log-result');
        } catch(e) {
            log(`[Error] ${e.message}`, 'log-err');
        } finally {
            setBusy(false);
        }
        return;
    }
    
    if (op === 'ToSymbolic') {
        log(`[OP] A=${formatBigInt(currentA)}H + B=${formatBigInt(currentB)}`, 'log-input');
        setBusy(false);
        return;
    }

    if (!worker) {
        // Initialize Worker if not done
        const blob = new Blob([HLU_WORKER_CODE], {type: 'application/javascript'});
        worker = new Worker(URL.createObjectURL(blob));
        
        worker.onmessage = function(e) {
            const d = e.data;
            if(d.type === 'log') log(d.msg, d.style);
            
            if(d.type === 'anim') {
                document.getElementById('animBar').style.width = d.pct + '%';
                document.getElementById('thinkingText').innerText = d.msg;
                document.getElementById('thinkingText').style.display = d.pct > 0 ? 'block' : 'none';
                if(d.pct === 0) setBusy(false);
            }
            
            if(d.type === 'result') {
                if(d.A) currentA = BigInt(d.A);
                if(d.B) currentB = BigInt(d.B);
                
                const msg = d.msg || "Operation Complete.";
                const style = d.style || 'log-result';
                
                log(msg, style);
                log(`[STATE] A: ${formatBigInt(currentA)} | B: ${formatBigInt(currentB)}`, 'log-result');
            }
        };
        
        // Initial setup for the worker state
        worker.postMessage({cmd: 'init', arg: input, exp: EXP, add: ADD});
    }

    // Pass the command to the worker
    const commandToPass = {cmd: op, exp: EXP, add: ADD};
    if(op === 'HoloSquare' || op === 'HoloMod') {
        commandToPass.A = currentA.toString();
        commandToPass.B = currentB.toString();
    }
    
    log(`[EXEC] ${op} on State...`, 'log-sys');
    worker.postMessage(commandToPass);
}

// --- UI HELPERS ---
function formatBigInt(n) {
    let s = n.toString();
    if (s.length > 30) {
        return s.substring(0, 15) + "..." + s.slice(-10) + ` [${s.length} digits]`;
    }
    return s;
}

// Re-implement the parser locally for the 'Equals' button
function parseExpression(str) {
    let s = str.toLowerCase().replace(/\s/g,'').replace(/,/g,'');
    if(s.includes('^')) {
        const p = s.split('^'); const base = BigInt(p[0]);
        let rest = p[1], offset = 0n;
        if(rest.includes('-')) { const sp = rest.split('-'); rest = sp[0]; offset = -BigInt(sp[1]); }
        else if(rest.includes('+')) { const sp = rest.split('+'); rest = sp[0]; offset = BigInt(sp[1]); }
        return (base ** BigInt(rest)) + offset;
    }
    return BigInt(s);
}

// Initial state setup
window.onload = () => {
    // Initializing the worker when the page loads
    const blob = new Blob([HLU_WORKER_CODE], {type: 'application/javascript'});
    worker = new Worker(URL.createObjectURL(blob));
    log("HLU Worker Thread started.", 'log-sys');
    
    // Set initial state
    const input = document.getElementById('calcDisplay').value;
    try {
        currentB = parseExpression(input);
        log(`Initial Input parsed: B=${formatBigInt(currentB)}`, 'log-sys');
    } catch (e) {
        log(`Initial Input failed to parse. B=0.`, 'log-err');
    }
    
    worker.onmessage = function(e) {
        const d = e.data;
        if(d.type === 'log') log(d.msg, d.style);
        
        if(d.type === 'anim') {
            document.getElementById('animBar').style.width = d.pct + '%';
            document.getElementById('thinkingText').innerText = d.msg;
            document.getElementById('thinkingText').style.display = d.pct > 0 ? 'block' : 'none';
            if(d.pct === 0) setBusy(false);
        }
        
        if(d.type === 'result') {
            if(d.A) currentA = BigInt(d.A);
            if(d.B) currentB = BigInt(d.B);
            
            const msg = d.msg || "Operation Complete.";
            const style = d.style || 'log-result';
            
            log(msg, style);
            log(`[STATE] A: ${formatBigInt(currentA)} | B: ${formatBigInt(currentB)}`, 'log-result');
        }
    };
    
    worker.postMessage({cmd: 'init', arg: input, exp: document.getElementById('inpExp').value, add: document.getElementById('inpAdd').value});
};
</script>
</body>
</html>
