<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>The Hyper-Streamliner: NTT Rim Proof</title>
<script src="https://cdn.tailwindcss.com"></script>
<style>
  body { background-color: #0f172a; color: #e2e8f0; font-family: 'Courier New', monospace; padding: 20px; }
  .card { max-width: 900px; margin: 0 auto; background: #1e293b; border-radius: 12px; padding: 24px; border: 1px solid #334155; box-shadow: 0 10px 30px rgba(0,0,0,0.5); }
  .input-group { margin-bottom: 16px; }
  label { display: block; font-weight: bold; margin-bottom: 8px; color: #94a3b8; font-size: 0.85rem; text-transform: uppercase; letter-spacing: 0.05em; }
  input { width: 100%; background: #020617; border: 1px solid #475569; color: #fff; padding: 12px; border-radius: 6px; font-family: inherit; font-size: 1rem; transition: border-color 0.2s; }
  input:focus { outline: none; border-color: #3b82f6; }
  .btn { width: 100%; padding: 14px; border: none; border-radius: 8px; font-weight: bold; cursor: pointer; font-size: 1.1rem; transition: transform 0.1s, background-color 0.2s; text-transform: uppercase; letter-spacing: 0.05em; margin-top: 10px; }
  .btn-start { background: #8b5cf6; color: #fff; } /* Purple for Hyper */
  .btn-start:hover { background: #7c3aed; }
  .btn-stop { background: #ef4444; color: #fff; }
  .btn-stop:hover { background: #dc2626; }
  .log-box { background: #020617; border: 1px solid #334155; padding: 16px; height: 300px; overflow-y: auto; margin-top: 24px; border-radius: 8px; font-size: 0.9rem; color: #a78bfa; line-height: 1.5; white-space: pre-wrap; }
  .status-bar { height: 4px; width: 100%; background: #334155; margin-top: 20px; border-radius: 2px; overflow: hidden; }
  .progress { height: 100%; background: #8b5cf6; width: 0%; transition: width 0.3s ease; }
  .highlight { color: #facc15; font-weight: bold; }
  .error { color: #f87171; font-weight: bold; }
</style>
</head>
<body>

<div class="card">
  <h1 class="text-2xl font-bold text-center text-purple-400 mb-2">THE HYPER-STREAMLINER</h1>
  <p class="text-center text-xs text-gray-500 mb-6">Giga-Scale NTT Rim Proof (10^9 Digits)</p>

  <div class="grid grid-cols-3 gap-4 mb-4">
    <div class="input-group">
      <label>Base (a)</label>
      <input id="inpBase" value="10">
    </div>
    <div class="input-group">
      <label>Exponent (b)</label>
      <input id="inpExp" value="1000000000"> 
    </div>
    <div class="input-group">
      <label>Add (c)</label>
      <input id="inpAdd" value="61">
    </div>
  </div>

  <button id="btnRun" class="btn btn-start" onclick="startProof()">INITIATE HYPER-PROOF</button>
  <button id="btnStop" class="btn btn-stop hidden" onclick="stopProof()">ABORT</button>

  <div class="status-bar"><div id="progressBar" class="progress"></div></div>
  <div id="logBox" class="log-box">System Ready.
This tool uses the NTT Engine (O(N log N)) to square the 500-million-digit Index.
If successful, it calculates Rim^2 = I^2 - N.</div>
</div>

<script>
/* THE CORE ENGINE: NTT WORKER 
   (Embedded directly from your ntt_worker.js logic)
*/
const workerCode = `
// --- CONFIGURATION ---
const BASE = 10000; // Chunk base 10^4
const BASE_BI = 10000n;
const CHUNK_SIZE = 4;

// NTT Params (Q must be prime, Q-1 divisible by maxN)
// Standard NTT Prime: 998244353 = 119 * 2^23 + 1. Root = 3.
const Q = 998244353n;
const G = 3n;

// --- UTILS ---
function trim(arr) {
    let i = 0;
    while (i < arr.length - 1 && arr[i] === 0) i++;
    return arr.slice(i);
}

function stringToChunks(str) {
    if (!str) return [0];
    str = str.trim();
    const pad = (CHUNK_SIZE - (str.length % CHUNK_SIZE)) % CHUNK_SIZE;
    str = '0'.repeat(pad) + str;
    const out = [];
    for(let i=0; i<str.length; i+=CHUNK_SIZE) {
        out.push(parseInt(str.substring(i, i+CHUNK_SIZE), 10));
    }
    // Convert to LSB-first for math
    return trim(out).reverse(); 
}

function chunksToString(chunks) {
    // chunks is LSB-first
    if(!chunks || chunks.length === 0) return "0";
    let c = Array.from(chunks).slice().reverse(); // Convert TypedArray to normal array for reverse
    c = trim(c);
    let s = c[0].toString();
    for(let i=1; i<c.length; i++) {
        s += c[i].toString().padStart(CHUNK_SIZE, '0');
    }
    return s;
}

// --- NTT CORE ---
function power(base, exp) {
    let res = 1n;
    base %= Q;
    while (exp > 0n) {
        if (exp % 2n === 1n) res = (res * base) % Q;
        base = (base * base) % Q;
        exp /= 2n;
    }
    return res;
}

function modInverse(n) {
    return power(n, Q - 2n);
}

function ntt(a, invert) {
    const n = a.length;
    for (let i = 1, j = 0; i < n; i++) {
        let bit = n >> 1;
        for (; j & bit; bit >>= 1) j ^= bit;
        j ^= bit;
        if (i < j) {
            const temp = a[i];
            a[i] = a[j];
            a[j] = temp;
        }
    }
    
    for (let len = 2; len <= n; len <<= 1) {
        let wlen = power(G, (Q - 1n) / BigInt(len));
        if (invert) wlen = modInverse(wlen);
        
        for (let i = 0; i < n; i += len) {
            let w = 1n;
            for (let j = 0; j < len / 2; j++) {
                let u = a[i + j];
                let v = (a[i + j + len / 2] * w) % Q;
                a[i + j] = (u + v) % Q;
                a[i + j + len / 2] = (u - v + Q) % Q;
                w = (w * wlen) % Q;
            }
        }
    }
    
    if (invert) {
        const n_inv = modInverse(BigInt(n));
        for (let i = 0; i < n; i++) a[i] = (a[i] * n_inv) % Q;
    }
}

// --- MULTIPLICATION (SQUARING) ---
function multiply(a, b) {
    // LSB-first chunks input
    let n = 1;
    while (n < a.length + b.length) n <<= 1;
    
    // Prepare arrays (padded with 0)
    // WARNING: For 1B digits, n will be ~536 million. 
    // We use BigUint64Array to save memory (8 bytes per element vs ~pointer size)
    
    let fa, fb;
    try {
        fa = new BigUint64Array(n);
        fb = new BigUint64Array(n);
    } catch(e) {
        throw new Error("NTT Array Allocation Failed: " + e.message);
    }
    
    for(let i=0; i<a.length; i++) fa[i] = BigInt(a[i]);
    for(let i=0; i<b.length; i++) fb[i] = BigInt(b[i]);
    
    ntt(fa, false);
    if(a === b || (a.length === b.length && a.every((val, index) => val === b[index]))) { // Optimization for squaring
        for(let i=0; i<n; i++) fa[i] = (fa[i] * fa[i]) % Q;
    } else {
        ntt(fb, false);
        for(let i=0; i<n; i++) fa[i] = (fa[i] * fb[i]) % Q;
    }
    
    ntt(fa, true);
    
    // Carry propagation
    // We convert back to Int32Array for result
    const res = new Int32Array(n);
    
    let carry = 0n;
    for(let i=0; i<n; i++) {
        let val = fa[i] + carry;
        res[i] = Number(val % BASE_BI);
        carry = val / BASE_BI;
    }
    // Handle remaining carry (rarely exceeds buffer if padded correctly)
    
    return res;
}

// --- SUBTRACTION (TypedArray Compatible) ---
function subtract(a, b) {
    // a - b. Assumes a >= b. LSB-first. 
    // a and b are TypedArrays or Arrays.
    const len = a.length;
    const res = new Int32Array(len);
    
    let borrow = 0;
    for(let i=0; i<len; i++) {
        let val = a[i] - (b[i] || 0) - borrow;
        if(val < 0) {
            val += BASE;
            borrow = 1;
        } else {
            borrow = 0;
        }
        res[i] = val;
    }
    return res;
}

// --- WORKER LOGIC ---
self.onmessage = function(e) {
    const { mode, aStr, bStr, cStr } = e.data;
    
    if(mode === 'prove') {
        try {
            self.postMessage({type:'log', msg:'Calculating Index...'});
            
            const bVal = parseInt(bStr);
            const cVal = parseInt(cStr);
            
            // MEMORY CHECK
            // 4 digits per chunk. 10^9 digits = 250M chunks.
            const estimatedChunks = Math.ceil(bVal / CHUNK_SIZE);
            
            // Safety Warning in Log
            if(estimatedChunks > 150000000) {
                self.postMessage({type:'log', msg: 'WARNING: Index construction requires > 150M chunks. Using TypedArrays to survive.'});
            }

            self.postMessage({type:'log', msg: \`Generating Index for 10^\${bVal} + \${cVal}...\`});
            
            // Constructing Index I in chunks (LSB-first)
            // Low part: (C+1)/2.
            const lowVal = Math.floor((cVal + 1) / 2); 
            const lowStr = lowVal.toString();
            const lowChunks = stringToChunks(lowStr); 
            
            // Allocate TypedArray for Index (Int32 to hold 0-9999)
            const I_chunks = new Int32Array(estimatedChunks + 1);
            
            // Fill low part
            for(let k=0; k<lowChunks.length; k++) I_chunks[k] = lowChunks[k];
            
            // Fill high part (Top digit is 5)
            const topPos = bVal - 1;
            const topChunkIdx = Math.floor(topPos / CHUNK_SIZE);
            const topChunkShift = topPos % CHUNK_SIZE;
            const topVal = 5 * Math.pow(10, topChunkShift);
            
            I_chunks[topChunkIdx] += topVal;
            
            self.postMessage({type:'log', msg: \`Index constructed. Size: \${I_chunks.length} chunks.\`});
            self.postMessage({type:'log', msg: 'Starting NTT Squaring (I^2)... This is the heavy lifting.'});
            
            // 2. Calculate I^2 via NTT
            const startTime = performance.now();
            const I_sq_chunks = multiply(I_chunks, I_chunks); // Returns Int32Array
            const endTime = performance.now();
            
            self.postMessage({type:'log', msg: \`Squaring Complete! Time: \${((endTime-startTime)/1000).toFixed(2)}s\`});
            
            // 3. Calculate Target N
            // N = 10^B + C
            self.postMessage({type:'log', msg: 'Constructing N...'});
            const N_chunks = new Int32Array(I_sq_chunks.length); // Match size for subtraction
            
            const cChunks = stringToChunks(cStr);
            for(let k=0; k<cChunks.length; k++) N_chunks[k] = cChunks[k];
            
            const nTopPos = bVal;
            const nTopChunkIdx = Math.floor(nTopPos / CHUNK_SIZE);
            const nTopShift = nTopPos % CHUNK_SIZE;
            const nTopVal = 1 * Math.pow(10, nTopShift);
            N_chunks[nTopChunkIdx] = nTopVal;
            
            // 4. Calculate Rim^2 = I^2 - N
            self.postMessage({type:'log', msg: 'Calculating Rim^2 = I^2 - N...'});
            const R_sq_chunks = subtract(I_sq_chunks, N_chunks);
            
            // 5. Result
            // Show the tail of R^2
            // Extract first 10 chunks for display
            let tailArr = [];
            for(let i=0; i<10 && i<R_sq_chunks.length; i++) tailArr.push(R_sq_chunks[i]);
            // Convert back to standard array for util
            const tail = chunksToString(tailArr); 
            
            self.postMessage({
                type: 'result',
                rimSqTail: tail,
                isZero: (R_sq_chunks.length === 1 && R_sq_chunks[0] === 0)
            });
            
        } catch(e) {
            self.postMessage({type:'error', msg: e.message});
        }
    }
};
`;

// --- UI LOGIC ---
let worker = null;

function log(msg, type='') {
    const el = document.getElementById('logBox');
    const line = document.createElement('div');
    line.textContent = `> ${msg}`;
    if(type === 'error') line.className = 'error';
    if(type === 'success') line.className = 'highlight';
    el.appendChild(line);
    el.scrollTop = el.scrollHeight;
}

function startProof() {
    const base = document.getElementById('inpBase').value;
    const exp = document.getElementById('inpExp').value;
    const add = document.getElementById('inpAdd').value;
    
    if(base !== '10') {
        log("Prototype only supports Base 10 for Index Construction optimization.", "error");
        return;
    }

    document.getElementById('btnRun').classList.add('hidden');
    document.getElementById('btnStop').classList.remove('hidden');
    document.getElementById('progressBar').style.width = '10%';
    log("Initializing Worker...");

    const blob = new Blob([workerCode], {type: 'application/javascript'});
    worker = new Worker(URL.createObjectURL(blob));
    
    worker.onmessage = function(e) {
        const d = e.data;
        if(d.type === 'log') {
            log(d.msg);
        } else if(d.type === 'error') {
            log(`ERROR: ${d.msg}`, 'error');
            stopProof();
        } else if(d.type === 'result') {
            document.getElementById('progressBar').style.width = '100%';
            log("-----------------------------");
            log("PROOF COMPLETE", "success");
            log(`Rim^2 (Tail): ...${d.rimSqTail}`);
            
            if(d.isZero) {
                log("Rim^2 is ZERO. N is a perfect square.", "error");
            } else {
                log("Rim^2 calculated successfully.");
                log("To finalize proof: Check if Rim^2 is a perfect integer square.");
                log("If Rim^2 is NOT a perfect square, N is PRIME.", "success");
            }
            stopProof();
        }
    };
    
    worker.postMessage({ mode: 'prove', aStr: base, bStr: exp, cStr: add });
}

function stopProof() {
    if(worker) worker.terminate();
    worker = null;
    document.getElementById('btnRun').classList.remove('hidden');
    document.getElementById('btnStop').classList.add('hidden');
    document.getElementById('progressBar').style.width = '0%';
    log("Process Halted.");
}
</script>
</body>
</html>


