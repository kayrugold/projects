<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zoomable Grid Drawer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for full-screen layout and touch handling */
        body {
            margin: 0;
            padding: 0;
            overflow: hidden; /* Prevent body scrolling */
            font-family: 'Inter', sans-serif;
            touch-action: none; /* Disable browser swipe actions on the canvas */
        }
        #app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        #canvas-container {
            flex-grow: 1;
            overflow: hidden;
            position: relative;
        }
        canvas {
            background-color: #f7f7f7; /* Light gray background */
            display: block;
        }
    </style>
</head>
<body>

<div id="app-container">
    <!-- Fixed Header for Controls -->
    <header class="p-3 bg-gray-800 text-white shadow-lg flex justify-between items-center z-10">
        <h1 class="text-xl font-bold">Grid Sketchpad</h1>
        <div class="space-x-2 flex items-center">
            <button id="mode-button" class="px-3 py-1 text-sm rounded-full font-semibold transition bg-blue-500 hover:bg-blue-600 active:scale-95">
                Current Mode: FILL
            </button>
            <button id="clear-button" class="px-3 py-1 text-sm rounded-full font-semibold transition bg-red-500 hover:bg-red-600 active:scale-95">
                Clear All
            </button>
        </div>
    </header>

    <!-- Canvas Container for Panning and Zooming -->
    <div id="canvas-container">
        <canvas id="drawing-canvas"></canvas>
    </div>
</div>

<script>
    // --- Configuration ---
    const GRID_SIZE = 50;
    const CELL_SIZE = 40; // Base size of a cell in pixels (before scaling)
    const GRID_COLOR = '#ccc';
    const LINE_COLOR = '#3b82f6'; // Tailwind blue-500
    const FILL_COLOR = '#111827'; // Tailwind gray-900
    
    // --- State Variables ---
    let canvas, ctx;
    let container;
    let modeButton, clearButton;

    let currentMode = 'FILL'; // 'FILL' or 'LINE'
    
    // Grid data structure: Maps cell coordinates (e.g., "10,5") to color (for filling)
    const filledCells = new Map();
    // Line data structure: Array of objects {start: {x, y}, end: {x, y}}
    const drawnLines = [];
    
    // Line mode state
    let lineStartPoint = null;
    
    // Panning & Zooming State
    let scale = 1.0;
    let offset = { x: 0, y: 0 };
    let isDragging = false;
    let dragStart = { x: 0, y: 0 };
    let lastTouchDistance = null; // For pinch zoom
    let gestureActive = false; // Flag to ignore taps during drag/zoom

    // --- Initialization ---

    document.addEventListener('DOMContentLoaded', () => {
        canvas = document.getElementById('drawing-canvas');
        ctx = canvas.getContext('2d');
        container = document.getElementById('canvas-container');
        modeButton = document.getElementById('mode-button');
        clearButton = document.getElementById('clear-button');

        // Set up event listeners
        window.addEventListener('resize', resizeCanvas);
        modeButton.addEventListener('click', toggleMode);
        clearButton.addEventListener('click', clearAll);

        // Touch/Mouse Listeners for interaction
        canvas.addEventListener('mousedown', handleMouseDown);
        canvas.addEventListener('mouseup', handleMouseUp);
        canvas.addEventListener('mousemove', handleMouseMove);
        
        canvas.addEventListener('touchstart', handleTouchStart);
        canvas.addEventListener('touchend', handleTouchEnd);
        canvas.addEventListener('touchmove', handleTouchMove);
        
        // Initial setup
        resizeCanvas();
        drawCanvas();
    });

    // --- Canvas Setup Functions ---
    
    function resizeCanvas() {
        // Set canvas dimensions to container size
        canvas.width = container.clientWidth;
        canvas.height = container.clientHeight;
        
        // Adjust initial scale to fit the entire grid width on screen
        scale = canvas.width / (GRID_SIZE * CELL_SIZE);
        // Ensure the initial offset centers the grid
        offset.x = (canvas.width - GRID_SIZE * CELL_SIZE * scale) / 2;
        offset.y = (canvas.height - GRID_SIZE * CELL_SIZE * scale) / 2;
        
        drawCanvas();
    }

    // --- Drawing Functions ---

    function drawCanvas() {
        // 1. Clear the entire canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // 2. Apply transformation for pan and zoom
        ctx.save();
        ctx.translate(offset.x, offset.y);
        ctx.scale(scale, scale);

        const scaledCellSize = CELL_SIZE; // Note: scale is already applied via ctx.scale

        // 3. Draw filled cells (fills first, so grid lines are on top)
        for (const [key, color] of filledCells) {
            const [x, y] = key.split(',').map(Number);
            ctx.fillStyle = color;
            ctx.fillRect(
                x * scaledCellSize,
                y * scaledCellSize,
                scaledCellSize,
                scaledCellSize
            );
        }

        // 4. Draw grid lines
        ctx.strokeStyle = GRID_COLOR;
        ctx.lineWidth = 1 / scale; // Make line width constant visually
        
        const totalSize = GRID_SIZE * scaledCellSize;

        // Draw vertical lines
        for (let x = 0; x <= GRID_SIZE; x++) {
            const lineX = x * scaledCellSize;
            ctx.beginPath();
            ctx.moveTo(lineX, 0);
            ctx.lineTo(lineX, totalSize);
            ctx.stroke();
        }

        // Draw horizontal lines
        for (let y = 0; y <= GRID_SIZE; y++) {
            const lineY = y * scaledCellSize;
            ctx.beginPath();
            ctx.moveTo(0, lineY);
            ctx.lineTo(totalSize, lineY);
            ctx.stroke();
        }

        // 5. Draw lines
        ctx.strokeStyle = LINE_COLOR;
        ctx.lineWidth = 3 / scale; 
        ctx.lineCap = 'round';

        ctx.beginPath();
        drawnLines.forEach(line => {
            ctx.moveTo(line.start.x * scaledCellSize, line.start.y * scaledCellSize);
            ctx.lineTo(line.end.x * scaledCellSize, line.end.y * scaledCellSize);
        });
        ctx.stroke();

        // 6. Draw line start point marker if in LINE mode
        if (currentMode === 'LINE' && lineStartPoint) {
            ctx.fillStyle = LINE_COLOR;
            ctx.beginPath();
            ctx.arc(
                lineStartPoint.x * scaledCellSize, 
                lineStartPoint.y * scaledCellSize, 
                6 / scale, // radius size constant visually
                0, 
                Math.PI * 2
            );
            ctx.fill();
        }

        // 7. Restore context (remove transformations)
        ctx.restore();
    }
    
    // --- Interaction Helpers ---

    function getGridCoords(canvasX, canvasY) {
        // Reverse the transformations to get coordinates within the 0..GRID_SIZE range
        const gridX = (canvasX - offset.x) / scale;
        const gridY = (canvasY - offset.y) / scale;
        
        // Calculate cell indices (for FILL mode)
        const cellCol = Math.floor(gridX / CELL_SIZE);
        const cellRow = Math.floor(gridY / CELL_SIZE);
        
        // Calculate corner indices (for LINE mode)
        const cornerCol = Math.round(gridX / CELL_SIZE);
        const cornerRow = Math.round(gridY / CELL_SIZE);

        return {
            cell: { x: cellCol, y: cellRow },
            corner: { x: cornerCol, y: cornerRow },
            raw: { x: gridX, y: gridY }
        };
    }
    
    function toggleMode() {
        currentMode = (currentMode === 'FILL') ? 'LINE' : 'FILL';
        modeButton.textContent = `Current Mode: ${currentMode}`;
        modeButton.classList.toggle('bg-blue-500');
        modeButton.classList.toggle('hover:bg-blue-600');
        modeButton.classList.toggle('bg-green-500');
        modeButton.classList.toggle('hover:bg-green-600');
        lineStartPoint = null; // Reset line state on mode change
        drawCanvas();
    }

    function clearAll() {
        filledCells.clear();
        drawnLines.length = 0;
        lineStartPoint = null;
        drawCanvas();
    }
    
    // --- Drawing Logic ---

    function handleDraw(coords) {
        // If a drag/zoom gesture was just active, ignore the tap
        if (gestureActive) {
            gestureActive = false;
            return;
        }

        const { cell, corner } = coords;

        if (currentMode === 'FILL') {
            // Check bounds for fill mode
            if (cell.x >= 0 && cell.x < GRID_SIZE && cell.y >= 0 && cell.y < GRID_SIZE) {
                const key = `${cell.x},${cell.y}`;
                if (filledCells.has(key)) {
                    filledCells.delete(key); // Clear cell
                } else {
                    filledCells.set(key, FILL_COLOR); // Fill cell
                }
            }
        } else if (currentMode === 'LINE') {
            // Check bounds for line mode corners (0 to GRID_SIZE)
            if (corner.x >= 0 && corner.x <= GRID_SIZE && corner.y >= 0 && corner.y <= GRID_SIZE) {
                if (lineStartPoint === null) {
                    // Start of a new line segment
                    lineStartPoint = corner;
                } else {
                    // End of a line segment, draw it
                    drawnLines.push({ 
                        start: lineStartPoint, 
                        end: corner 
                    });
                    lineStartPoint = corner; // Continue line from the new point
                }
            }
        }
        drawCanvas();
    }
    
    // --- Mouse Handlers (for desktop testing) ---

    function handleMouseDown(e) {
        if (e.button === 0) { // Left click
            isDragging = true;
            dragStart.x = e.clientX;
            dragStart.y = e.clientY;
            gestureActive = false;
        }
    }

    function handleMouseMove(e) {
        if (!isDragging) return;
        
        // Calculate movement
        const dx = e.clientX - dragStart.x;
        const dy = e.clientY - dragStart.y;

        // Update offset
        offset.x += dx;
        offset.y += dy;
        
        // Reset start position
        dragStart.x = e.clientX;
        dragStart.y = e.clientY;
        
        gestureActive = true; // Indicate that dragging is happening
        drawCanvas();
    }

    function handleMouseUp(e) {
        if (isDragging) {
            isDragging = false;
            // Check if it was a quick click vs a drag
            if (!gestureActive) {
                const rect = canvas.getBoundingClientRect();
                const coords = getGridCoords(e.clientX - rect.left, e.clientY - rect.top);
                handleDraw(coords);
            }
            setTimeout(() => { gestureActive = false; }, 100); // Debounce
        } else if (e.button === 0) {
            const rect = canvas.getBoundingClientRect();
            const coords = getGridCoords(e.clientX - rect.left, e.clientY - rect.top);
            handleDraw(coords);
        }
    }

    // --- Touch Handlers (Mobile) ---

    function handleTouchStart(e) {
        const touches = e.touches;
        e.preventDefault(); 
        gestureActive = false;
        
        if (touches.length === 1) {
            // Start of a drag/pan
            isDragging = true;
            dragStart.x = touches[0].clientX;
            dragStart.y = touches[0].clientY;
            lastTouchDistance = null;
        } else if (touches.length >= 2) {
            // Start of a pinch/zoom
            isDragging = false;
            lastTouchDistance = getDistance(touches[0], touches[1]);
        }
    }

    function handleTouchMove(e) {
        const touches = e.touches;
        e.preventDefault();

        if (touches.length === 1 && isDragging) {
            // Panning (Dragging)
            const dx = touches[0].clientX - dragStart.x;
            const dy = touches[0].clientY - dragStart.y;

            offset.x += dx;
            offset.y += dy;

            dragStart.x = touches[0].clientX;
            dragStart.y = touches[0].clientY;
            
            // Mark gesture as active if movement is significant
            if (Math.abs(dx) > 1 || Math.abs(dy) > 1) {
                gestureActive = true;
            }
            drawCanvas();

        } else if (touches.length >= 2 && lastTouchDistance !== null) {
            // Pinch Zooming
            const currentDistance = getDistance(touches[0], touches[1]);
            const delta = currentDistance - lastTouchDistance;
            
            // Calculate zoom center (midpoint of the two touches)
            const center = {
                x: (touches[0].clientX + touches[1].clientX) / 2,
                y: (touches[0].clientY + touches[1].clientY) / 2
            };

            const zoomFactor = 1 + delta / 400; // Sensitivity
            
            // Clamp scale between 0.1x and 10x
            const newScale = Math.max(0.1, Math.min(10, scale * zoomFactor));

            // Adjust offset to keep the zoom center fixed
            offset.x = center.x - (center.x - offset.x) * (newScale / scale);
            offset.y = center.y - (center.y - offset.y) * (newScale / scale);
            
            scale = newScale;
            lastTouchDistance = currentDistance;
            gestureActive = true;
            drawCanvas();
        }
    }

    function handleTouchEnd(e) {
        isDragging = false;
        lastTouchDistance = null;
        
        // If no significant movement occurred (a true tap)
        if (!gestureActive) {
            // Check if there was exactly one touch end (a single tap)
            const changedTouch = e.changedTouches[0];
            const rect = canvas.getBoundingClientRect();
            
            // Get coordinates relative to the canvas
            const canvasX = changedTouch.clientX - rect.left;
            const canvasY = changedTouch.clientY - rect.top;
            
            const coords = getGridCoords(canvasX, canvasY);
            handleDraw(coords);
        }
        
        // Reset gesture flag after a short delay to prevent race conditions
        setTimeout(() => { gestureActive = false; }, 100);
    }
    
    function getDistance(t1, t2) {
        return Math.sqrt(Math.pow(t2.clientX - t1.clientX, 2) + Math.pow(t2.clientY - t1.clientY, 2));
    }

</script>

</body>
</html>

