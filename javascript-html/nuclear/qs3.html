<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, interactive-widget=resizes-content">
<title>Architect v19 (Hybrid)</title>
<script src="https://cdn.tailwindcss.com"></script>
<style>
    body { background-color: #000; color: #e2e8f0; font-family: 'Courier New', monospace; padding: 10px; display: flex; flex-direction: column; height: 100vh; overflow: hidden; }
    
    /* HUD */
    .hud-panel { background: #0a0a0a; border-bottom: 1px solid #333; padding: 10px; flex-shrink: 0; z-index: 50; }
    .row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px; }
    .lbl { font-size: 0.65rem; color: #9ca3af; text-transform: uppercase; font-weight: bold; letter-spacing: 1px; }
    .val { font-size: 1rem; color: #fff; font-weight: bold; text-shadow: 0 0 5px rgba(255,255,255,0.2); }
    .val-sec { color: #fb923c; }
    .val-time { color: #22d3ee; font-family: monospace; font-size: 1.1rem; }

    /* TRACKS */
    .track-container { margin-bottom: 8px; }
    .track { height: 6px; background: #1f1f1f; border-radius: 3px; overflow: hidden; border: 1px solid #333; }
    .fill-mine { height: 100%; background: #dc2626; width: 0%; transition: width 0.1s linear; }
    .fill-solve { height: 100%; background: #ea580c; width: 0%; transition: width 0.1s linear; }

    /* CORE GRID */
    .core-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 4px; margin-bottom: 10px; }
    .core-card { background: #1a0505; border: 1px solid #2b0a0a; padding: 4px; border-radius: 4px; text-align: center; }
    .core-lbl { font-size: 0.55rem; color: #7f1d1d; font-weight: bold; display: block; }
    .core-stat { font-size: 0.7rem; color: #fca5a5; font-weight: bold; }
    .core-active { border-color: #ef4444; background: #450a0a; }
    
    /* LOG */
    .log-area { flex-grow: 1; overflow-y: auto; background: #050505; padding: 10px; font-size: 0.75rem; color: #a3a3a3; font-family: monospace; border-top: 1px solid #222; }
    .log-row { margin-bottom: 3px; border-bottom: 1px solid #111; padding-bottom: 2px; }
    .l-sys { color: #38bdf8; }
    .l-hit { color: #facc15; }
    .l-win { color: #4ade80; font-weight: bold; background: rgba(74, 222, 128, 0.1); padding: 8px; text-align: center; border: 1px solid #4ade80; margin: 10px 0; font-size: 1rem; }
    .l-warn { color: #fb923c; }

    /* INPUTS */
    .input-area { padding: 10px; background: #0a0a0a; border-top: 1px solid #333; display: flex; flex-direction: column; gap: 8px; flex-shrink: 0; }
    .input-row { display: flex; gap: 8px; }
    input { background: #111; border: 1px solid #333; color: #fff; padding: 12px; border-radius: 6px; flex-grow: 1; font-family: monospace; font-weight: bold; font-size: 0.9rem; outline: none; }
    input:focus { border-color: #ef4444; }
    .btn { background: #1f1f1f; color: #fff; border: 1px solid #333; border-radius: 6px; font-weight: 900; cursor: pointer; text-transform: uppercase; font-size: 1rem; display: flex; align-items: center; justify-content: center; height: 48px; }
    .btn-ignite { background: #991b1b; border-color: #b91c1c; width: 100%; box-shadow: 0 0 15px rgba(220, 38, 38, 0.4); }
    .btn-stop { background: #333; border-color: #555; width: 30%; font-size: 0.8rem; }
</style>
</head>
<body>

<div class="hud-panel">
    <div class="row">
        <div><span class="lbl">TARGET (N)</span><div id="dispN" class="val" style="word-break:break-all; font-size:0.85rem;">WAITING</div></div>
        <div style="text-align:right;">
            <span class="lbl">RUNTIME</span>
            <div id="timerDisplay" class="val val-time">00:00.00</div>
        </div>
    </div>
    
    <div class="track-container">
        <div class="row" style="margin-bottom:2px;">
            <span class="lbl">MINING <span id="fbSizeTxt" class="text-gray-500 ml-2">(FB: 0)</span></span>
            <span id="relTxt" class="lbl text-red-400">0 / 0</span>
        </div>
        <div class="track"><div id="relBar" class="fill-mine"></div></div>
    </div>

    <div class="track-container">
        <div class="row" style="margin-bottom:2px;"><span class="lbl">SOLVER</span><span id="solTxt" class="lbl text-orange-400">IDLE</span></div>
        <div class="track"><div id="solBar" class="fill-solve"></div></div>
    </div>

    <div class="core-grid" id="coreGrid"></div>
</div>

<div id="log" class="log-area">
    <div class="log-row l-sys">Architect v19 Online.</div>
    <div class="log-row l-sys">v15 Logic Restored. v18 UI Active.</div>
</div>

<div class="input-area">
    <div class="input-row">
        <input id="inpN" value="1099515822059" placeholder="e.g. 10^15+7">
        <button id="btnStop" class="btn btn-stop" onclick="abort()">STOP</button>
    </div>
    <button id="btnRun" class="btn btn-ignite" onclick="ignite()">IGNITE ENGINE</button>
    <select id="coreSelect" style="display:none;"><option value="8" selected>8</option></select>
</div>

<script>
// ==========================================
// WORKER 1: MINER (v15 Logic)
// ==========================================
const minerScript = `
self.onmessage = function(e) {
    const { cmd, N_str, startX, range, fb, primes, threshold } = e.data;
    
    if(cmd === 'mine') {
        const N = BigInt(N_str);
        const sieve = new Float32Array(range);
        const rootN = BigInt(Math.floor(Math.sqrt(Number(N))));
        
        let currentX = BigInt(startX);
        let Q_val = (rootN + currentX)*(rootN + currentX) - N;
        let Slope = 2n * (rootN + currentX) + 1n;
        
        // Initialize Sieve with approx log2(Q)
        for(let i=0; i<range; i++) {
            let absQ = Q_val < 0n ? -Q_val : Q_val;
            sieve[i] = absQ.toString(2).length; 
            Q_val += Slope;
            Slope += 2n;
        }
        
        // Sieve with Primes
        for(let i=0; i<primes.length; i++) {
            const p = primes[i];
            const logP = Math.log2(p);
            const roots = fb[i];
            for(let r of roots) {
                let offset = Number((BigInt(r) - rootN - BigInt(startX)) % BigInt(p));
                if (offset < 0) offset += p;
                for(let j=offset; j<range; j+=p) sieve[j] -= logP;
            }
        }
        
        // Collect Relations
        const relations = [];
        for(let j=0; j<range; j++) {
            if(sieve[j] < threshold) {
                const xVal = BigInt(startX + j);
                let Q = (rootN + xVal)*(rootN + xVal) - N;
                if(Q < 0n) Q = -Q;
                
                const vector = new Uint8Array(primes.length);
                const exps = new Uint32Array(primes.length);
                
                for(let k=0; k<primes.length; k++) {
                    const p = BigInt(primes[k]);
                    while(Q % p === 0n) { Q /= p; vector[k] ^= 1; exps[k]++; }
                }
                if(Q === 1n) {
                    relations.push({ x: xVal.toString(), vec: vector.buffer, exps: exps.buffer });
                }
            }
        }
        // v15 Transferable Logic
        self.postMessage({ type: 'results', rels: relations }, relations.map(r => r.vec).concat(relations.map(r => r.exps)));
    }
};
`;

// ==========================================
// WORKER 2: SOLVER (v15 Logic)
// ==========================================
const solverScript = `
let targetN = 0n;
let rootN = 0n;
let factorBase = [];
let matrix = [];
let relations = [];

function gcd(a, b) { if(a<0n) a=-a; while(b>0n){let t=b;b=a%b;a=t;} return a; }

function solveMatrix() {
    self.postMessage({type:'status', msg:'ELIMINATING PIVOTS'});
    const pivots = new Map(); 
    let dependencies = []; 
    
    const matrixSize = matrix.length;
    const fbSize = factorBase.length;

    for(let i=0; i<matrixSize; i++) {
        let row = matrix[i];
        let mask = row.mask;
        let history = row.history;
        
        for(let col=0; col<fbSize; col++) {
            if ( (mask & (1n << BigInt(col))) !== 0n ) {
                if (pivots.has(col)) {
                    const piv = pivots.get(col);
                    mask ^= piv.mask;
                    history = history.concat(piv.history);
                } else {
                    pivots.set(col, { mask: mask, history: history });
                    mask = 0n; break; 
                }
            }
        }
        
        if (mask === 0n && history.length > 0) {
            dependencies.push(history);
            if(dependencies.length > 5) break; 
        }
        if(i % 100 === 0) self.postMessage({type:'prog', val: i, total: matrixSize});
    }
    
    if(dependencies.length === 0) { self.postMessage({type:'fail'}); return; }

    self.postMessage({type:'status', msg:'CRACKING ROOTS'});
    
    for(let dep of dependencies) {
        let X = 1n;
        const totalExps = new Array(fbSize).fill(0);
        
        for(let idx of dep) {
            const r = relations[idx];
            const x_val = BigInt(r.x) + rootN;
            X = (X * x_val) % targetN;
            for(let k=0; k<r.exps.length; k++) totalExps[k] += r.exps[k];
        }
        
        let Y = 1n;
        for(let k=0; k<fbSize; k++) {
            const p = BigInt(factorBase[k]);
            const exp = BigInt(totalExps[k] >> 1); 
            
            let base = p, e = exp, res = 1n;
            while(e>0n){ if(e&1n) res=(res*base)%targetN; base=(base*base)%targetN; e>>=1n; }
            Y = (Y * res) % targetN;
        }
        
        const f1 = gcd(X - Y, targetN);
        const f2 = targetN / f1;
        
        if(f1 > 1n && f1 < targetN) {
            self.postMessage({type:'success', f1:f1.toString(), f2:f2.toString()});
            return;
        }
    }
    self.postMessage({type:'trivial'});
}

self.onmessage = function(e) {
    const d = e.data;
    if(d.cmd === 'init') {
        targetN = BigInt(d.targetN_str);
        rootN = BigInt(Math.floor(Math.sqrt(Number(targetN))));
        factorBase = d.factorBase;
        matrix = [];
        relations = []; 
        self.postMessage({type:'status', msg:'MATRIX READY'});
    }
    if(d.cmd === 'add_chunk') {
        const chunk = d.chunk;
        for(let rel of chunk) {
            const vector = new Uint8Array(rel.vec);
            const exponents = new Uint32Array(rel.exps);
            let mask = 0n;
            for(let i=0; i<vector.length; i++) if(vector[i]) mask |= (1n << BigInt(i));
            matrix.push({ mask: mask, history: [relations.length] });
            relations.push({ x: rel.x, exps: exponents });
        }
        self.postMessage({type:'status', msg:'ROWS: ' + matrix.length});
    }
    if(d.cmd === 'solve') {
        solveMatrix();
    }
};
`;

const minerBlob = new Blob([minerScript], {type:'application/javascript'});
const solverBlob = new Blob([solverScript], {type:'application/javascript'});
const minerUrl = URL.createObjectURL(minerBlob);
const solverUrl = URL.createObjectURL(solverBlob);

let miners = [], solver = null;
let factorBase = [], rootsFB = [];
let targetN = 0n, relations = [], neededRels = 0;
let isRunning = false, globalOffset = 0;
const BLOCK_SIZE = 50000;
const BATCH_SIZE = 50; 

// TIMER VARS
let startTime = 0;
let timerInterval = null;

function updateEl(id, text) {
    const el = document.getElementById(id);
    if(el) el.innerText = text;
}
function updateStyle(id, prop, val) {
    const el = document.getElementById(id);
    if(el) el.style[prop] = val;
}

document.addEventListener('DOMContentLoaded', () => {
    // Note 20 Optimization
    const sel = document.getElementById('coreSelect');
    sel.value = "8";
    initGrid();
});

function startTimer() {
    startTime = Date.now();
    if(timerInterval) clearInterval(timerInterval);
    timerInterval = setInterval(() => {
        const diff = Date.now() - startTime;
        const min = Math.floor(diff / 60000).toString().padStart(2,'0');
        const sec = Math.floor((diff % 60000) / 1000).toString().padStart(2,'0');
        const ms = Math.floor((diff % 1000) / 10).toString().padStart(2,'0');
        updateEl('timerDisplay', `${min}:${sec}.${ms}`);
    }, 50);
}

function stopTimer() {
    if(timerInterval) clearInterval(timerInterval);
}

function parseInput() {
    const raw = document.getElementById('inpN').value.toLowerCase().replace(/\s/g, '');
    try {
        if (raw.includes('e')) {
            const [base, exp] = raw.split('e');
            const [p, add] = exp.includes('+') ? exp.split('+') : [exp, '0'];
            return (BigInt(Math.floor(Number(base))) * (10n ** BigInt(p))) + BigInt(add);
        }
        if (raw.includes('^')) {
            let [base, rest] = raw.split('^');
            let exp = rest;
            let add = 0n;
            if (rest.includes('+')) { [exp, add] = rest.split('+'); add = BigInt(add); }
            else if (rest.includes('-')) { [exp, add] = rest.split('-'); add = -BigInt(add); }
            return (BigInt(base) ** BigInt(exp)) + add;
        }
        return BigInt(raw);
    } catch(e) {
        log("Input Error: " + e.message, 'l-warn');
        return null;
    }
}

function log(msg, type='') {
    const box = document.getElementById('log');
    if(!box) return;
    const d = document.createElement('div');
    d.className = `log-row l-${type||'sys'}`;
    d.innerText = `> ${msg}`;
    box.prepend(d);
}

function initGrid() {
    const n = document.getElementById('coreSelect').value;
    const g = document.getElementById('coreGrid');
    if(!g) return;
    g.innerHTML = '';
    g.style.gridTemplateColumns = `repeat(${Math.min(n,4)}, 1fr)`;
    for(let i=0; i<n; i++) {
        g.innerHTML += `<div class="core-card" id="card${i}"><span class="core-lbl">CORE ${i+1}</span><span class="core-stat" id="c${i}">IDLE</span></div>`;
    }
}

// RESTORED V15 LOGIC WITH SAFETY NET
function buildFB(n) {
    // v15 used a hard 3000 limit. v18 tried to be smart and failed.
    // We are reverting to robust limits.
    const bits = n.toString(2).length;
    let limit = 3000; 
    
    // Only increase for massive numbers, never decrease for small ones
    if(bits > 50) limit = 5000;
    if(bits > 60) limit = 10000;
    
    const fb=[], roots=[], sieve=new Uint8Array(limit).fill(1);
    for(let p=2; p<limit; p++) {
        if(sieve[p]) {
            for(let j=p*p; j<limit; j+=p) sieve[j]=0;
            const bigP = BigInt(p);
            const target = n % bigP;
            let r_sol = [];
            for(let r=0n; r<bigP; r++) { if((r*r)%bigP===target) r_sol.push(Number(r)); }
            if(r_sol.length>0) { fb.push(p); roots.push(r_sol); }
        }
    }
    return {p:fb, r:roots};
}

function ignite() {
    targetN = parseInput();
    if(!targetN) return;
    
    isRunning = true; relations = []; globalOffset = 0;
    document.getElementById('btnRun').style.display = 'none';
    document.getElementById('btnStop').style.display = 'flex';
    document.getElementById('log').innerHTML = '';
    
    // Display N formatted
    let nDis = targetN.toString();
    if(nDis.length > 20) nDis = nDis.substring(0,20) + "...";
    updateEl('dispN', nDis);
    
    updateStyle('relBar', 'width', '0%');
    updateStyle('solBar', 'width', '0%');
    updateEl('solTxt', 'IDLE');
    updateStyle('solBar', 'backgroundColor', '#ea580c');
    
    startTimer();
    log(`Target Locked: ${targetN.toString().substring(0,30)}...`, 'sys');
    
    const data = buildFB(targetN);
    factorBase = data.p; rootsFB = data.r;
    neededRels = factorBase.length + 20; // v15 Padding
    
    updateEl('dispFB', factorBase.length);
    updateEl('fbSizeTxt', `(FB: ${factorBase.length})`);
    updateEl('relTxt', `0 / ${neededRels}`);
    
    log(`Factor Base Configured: ${factorBase.length} Primes`, 'sys');
    
    miners.forEach(w=>w.terminate()); miners=[];
    const count = parseInt(document.getElementById('coreSelect').value);
    for(let i=0; i<count; i++) {
        const w = new Worker(minerUrl);
        w.onmessage = e => handleMiner(e, i);
        miners.push(w);
    }
    dispatch();
}

function dispatch() {
    if(!isRunning) return;
    if(relations.length >= neededRels) { launchSolver(); return; }
    miners.forEach((w, i) => {
        w.postMessage({
            cmd:'mine', N_str:targetN.toString(), startX:globalOffset, range:BLOCK_SIZE,
            fb:rootsFB, primes:factorBase, threshold: 5.0
        });
        updateEl(`c${i}`, `${Math.round(globalOffset/1000)}k`);
        const card = document.getElementById(`card${i}`);
        if(card) card.classList.add('core-active');
        globalOffset += BLOCK_SIZE;
    });
}

function handleMiner(e, id) {
    if(e.data.type === 'results') {
        const hits = e.data.rels;
        if(hits.length > 0) {
            relations.push(...hits);
            // Throttle DOM updates slightly for performance
            const pct = Math.min(100, (relations.length/neededRels)*100);
            updateStyle('relBar', 'width', pct+'%');
            updateEl('relTxt', `${relations.length} / ${neededRels}`);
            log(`Core ${id+1} found ${hits.length} relations`, 'l-hit');
        }
        
        const card = document.getElementById(`card${id}`);
        if(card) setTimeout(()=>card.classList.remove('core-active'), 50);
        
        if(relations.length < neededRels && isRunning) {
            const chunk = globalOffset; globalOffset += BLOCK_SIZE;
            miners[id].postMessage({
                cmd:'mine', N_str:targetN.toString(), startX:chunk, range:BLOCK_SIZE,
                fb:rootsFB, primes:factorBase, threshold: 5.0
            });
            updateEl(`c${id}`, `${Math.round(chunk/1000)}k`);
            if(card) card.classList.add('core-active');
        } else if (isRunning && relations.length >= neededRels) {
            launchSolver();
        }
    }
}

function launchSolver() {
    if(solver) return;
    isRunning = false;
    miners.forEach(w=>w.terminate()); miners=[];
    document.querySelectorAll('.core-active').forEach(e=>e.classList.remove('core-active'));
    
    log("Mining Complete. Initiating Solver...", 'sys');
    
    solver = new Worker(solverUrl);
    solver.onmessage = handleSolverMsg;
    
    solver.postMessage({
        cmd: 'init',
        targetN_str: targetN.toString(),
        factorBase: factorBase
    });

    log(`Streaming ${relations.length} relations...`, 'l-sys');
    
    const chunker = () => {
        const sendRels = [];
        const buffers = [];
        
        while(relations.length > 0 && sendRels.length < BATCH_SIZE) {
            const rel = relations.shift();
            sendRels.push(rel);
            buffers.push(rel.vec, rel.exps);
        }
        
        if(sendRels.length > 0) {
            solver.postMessage({ cmd: "add_chunk", chunk: sendRels }, buffers);
            setTimeout(chunker, 10);
        } else {
            log("Matrix populated. Solving...", 'l-sys');
            solver.postMessage({ cmd: "solve" });
        }
    };
    
    chunker();
}

function handleSolverMsg(e) {
    if(e.data.type === 'status') updateEl('solTxt', e.data.msg);
    if(e.data.type === 'prog') {
        const pct = (e.data.val / e.data.total)*100;
        updateStyle('solBar', 'width', pct+'%');
    }
    if(e.data.type === 'success') {
        stopTimer();
        log(`FACTOR: ${e.data.f1}`, 'l-win');
        log(`FACTOR: ${e.data.f2}`, 'l-win');
        updateStyle('solBar', 'width', '100%');
        updateStyle('solBar', 'backgroundColor', '#4ade80');
        updateEl('solTxt', "CRACKED");
        resetUI();
    }
    if(e.data.type === 'fail' || e.data.type === 'trivial') {
        log(e.data.type === 'fail' ? "Matrix Singular." : "Trivial Solution.", 'l-warn');
        log("Resuming Mining...", 'sys');
        solver.terminate(); solver=null;
        neededRels += 50; 
        isRunning = true;
        
        // Re-ignite miners
        const count = parseInt(document.getElementById('coreSelect').value);
        for(let i=0; i<count; i++) {
            const w = new Worker(minerUrl);
            w.onmessage = evt => handleMiner(evt, i);
            miners.push(w);
        }
        dispatch();
    }
}

function abort() {
    stopTimer();
    isRunning = false;
    if(miners.length) miners.forEach(w=>w.terminate());
    if(solver) solver.terminate();
    resetUI();
    log("System Halted.", 'l-warn');
}

function resetUI() {
    document.getElementById('btnRun').style.display = 'flex';
    document.getElementById('btnStop').style.display = 'none';
    solver = null; miners = [];
}
</script>
</body>
</html>
