<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Factor Hunter: Rotated Phase View</title>
    <style>
        body {
            background-color: #050505;
            color: #ccc;
            font-family: 'Segoe UI', monospace;
            margin: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }
        header {
            padding: 10px 20px;
            background: #111;
            border-bottom: 1px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 10;
        }
        h1 { margin: 0; font-size: 1.1rem; color: #4CAF50; letter-spacing: 1px; }
        
        #controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        input[type="number"] {
            background: #222;
            border: 1px solid #444;
            color: white;
            padding: 5px;
            border-radius: 3px;
            width: 50px;
            text-align: center;
        }
        
        button {
            background: #333;
            color: white;
            border: 1px solid #555;
            padding: 5px 15px;
            cursor: pointer;
            transition: 0.2s;
        }
        button:hover { background: #555; }

        #canvas-wrapper {
            flex-grow: 1;
            position: relative;
            overflow: hidden;
            cursor: move; /* Indicates panning */
        }
        
        /* The Canvas is the viewport */
        canvas { display: block; }

        .overlay-info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            padding: 10px;
            border-left: 3px solid #4CAF50;
            pointer-events: none;
        }
    </style>
</head>
<body>

<header>
    <h1>PHASE INTERFERENCE VIEW</h1>
    <div id="controls">
        <label style="color:#ff69b4">Pink(3)</label>
        <input type="number" id="modA" value="3">
        
        <label style="color:#ffeb3b">Yell(5)</label>
        <input type="number" id="modB" value="5">
        
        <label>Zoom</label>
        <input type="number" id="scale" value="6" min="1" max="50">
        
        <button id="btnReset">Center</button>
    </div>
</header>

<div id="canvas-wrapper">
    <canvas id="viewCanvas"></canvas>
    <div class="overlay-info">
        <div><strong>Vertical Axis:</strong> The Number Sum (N)</div>
        <div><strong>Horizontal Axis:</strong> The Offset (Difference)</div>
        <div id="debug-coords" style="color: #888; margin-top:5px;">Pan to explore...</div>
    </div>
</div>

<script id="worker-script" type="javascript/worker">
    self.onmessage = function(e) {
        const { width, height, modA, modB, scale, panY, panX } = e.data;
        const buffer = new Uint32Array(width * height);

        // Colors (ABGR)
        const C_VOID   = 0xFF000000; // Black space
        const C_PINK   = 0xFFB469FF; // Pink Line
        const C_YELL   = 0xFF00E5FF; // Yellow Line
        const C_BOTH   = 0xFFFFFFFF; // Intersection
        const C_AXIS   = 0xFF4CAF50; // The Central "Number Line" (Green)
        const C_BAR    = 0xFF225522; // The Horizontal Bar (Green faint)

        // Center of the screen is (width/2, height/2)
        const centerX = width / 2;
        const centerY = height / 2;

        for (let py = 0; py < height; py++) {
            // Screen Y maps to the "Sum Index" (The Number N)
            // We invert logic so UP is higher numbers (or down, user preference)
            // Let's make DOWN = Higher Numbers (like reading a list)
            const screenYvals = (py - centerY) + panY; 
            const indexN = Math.floor(screenYvals / scale);

            for (let px = 0; px < width; px++) {
                // Screen X maps to the "Difference" (Offset)
                // Center screen = Offset 0
                const screenXvals = (px - centerX) + panX;
                const offsetK = Math.floor(screenXvals / scale);

                // --- THE COORDINATE TRANSFORM ---
                // We are converting from (N, K) back to (a, b)
                // Where N = a + b  and  K = a - b
                // Therefore: a = (N + K)/2,  b = (N - K)/2
                
                // We only care if (N + K) and (N - K) are valid integers (parity check)
                // For visualized grid continuity, we just treat a and b as float coordinates
                // and check the divisibility of the SUM (N).
                
                let color = C_VOID;

                // 1. Structural Logic
                // In your rotated drawing, the Pink/Yellow lines follow the grid of 'a' and 'b'.
                // Even though we rotated, the "Structure" is still based on the Sum.
                
                // Check if we are inside a "Cell"
                const inCell = (screenYvals % scale < scale-1) && (screenXvals % scale < scale-1);

                if (inCell) {
                    // Logic for the pattern:
                    // If this row (Index N) is divisible by ModA...
                    const isModA = (indexN % modA === 0);
                    const isModB = (indexN % modB === 0);

                    // BUT, to look like your drawing, we need to see the *components*.
                    // Your drawing shows lines connecting specific (a,b) coords.
                    // Let's reconstruct the 'a' and 'b' values:
                    const a = (indexN + offsetK) / 2;
                    const b = (indexN - offsetK) / 2;

                    // This pixel is part of the structure if a,b are integers?
                    // Actually, simpler: Your drawing colors the bar based on the Sum.
                    
                    if (offsetK === 0) {
                        // The Central Axis (The Number Itself)
                        color = C_AXIS; 
                    } else if (Math.abs(offsetK) < indexN) { 
                        // We are "inside" the cone of the number (a > 0, b > 0)
                        
                        // Let's visualize the "Interference"
                        if (isModA && isModB) color = C_BOTH;
                        else if (isModA) color = C_PINK;
                        else if (isModB) color = C_YELL;
                        else color = C_BAR; // Just the green bar
                    }
                }

                buffer[py * width + px] = color;
            }
        }
        self.postMessage({ buffer: buffer }, [buffer.buffer]);
    };
</script>

<script>
    const canvas = document.getElementById('viewCanvas');
    const ctx = canvas.getContext('2d');
    const wrapper = document.getElementById('canvas-wrapper');
    const debug = document.getElementById('debug-coords');

    // State
    let state = {
        panY: 100, // Start a bit down the number line
        panX: 0,
        scale: 10,
        modA: 3,
        modB: 5
    };

    // Worker Setup
    const blob = new Blob([document.getElementById('worker-script').textContent], {type: 'text/javascript'});
    const worker = new Worker(URL.createObjectURL(blob));

    worker.onmessage = (e) => {
        const imgData = new ImageData(new Uint8ClampedArray(e.data.buffer.buffer), canvas.width, canvas.height);
        ctx.putImageData(imgData, 0, 0);
    };

    function render() {
        canvas.width = wrapper.clientWidth;
        canvas.height = wrapper.clientHeight;
        
        worker.postMessage({
            width: canvas.width,
            height: canvas.height,
            modA: state.modA,
            modB: state.modB,
            scale: state.scale,
            panY: state.panY,
            panX: state.panX
        });
        
        // Update debug text
        const centerNum = Math.floor(state.panY / state.scale);
        debug.innerText = `Center Number (Approx): ${centerNum}`;
    }

    // Controls
    document.getElementById('modA').addEventListener('input', (e) => { state.modA = parseInt(e.target.value); render(); });
    document.getElementById('modB').addEventListener('input', (e) => { state.modB = parseInt(e.target.value); render(); });
    document.getElementById('scale').addEventListener('input', (e) => { state.scale = parseInt(e.target.value); render(); });
    document.getElementById('btnReset').addEventListener('click', () => { state.panX = 0; state.panY = 100; render(); });

    // Drag Logic
    let isDown = false;
    let lastX, lastY;

    canvas.addEventListener('mousedown', e => { isDown = true; lastX = e.clientX; lastY = e.clientY; });
    window.addEventListener('mouseup', () => isDown = false);
    canvas.addEventListener('mousemove', e => {
        if (!isDown) return;
        const dx = e.clientX - lastX;
        const dy = e.clientY - lastY;
        lastX = e.clientX; lastY = e.clientY;
        
        state.panX -= dx;
        state.panY -= dy; // Invert if you want natural scrolling
        requestAnimationFrame(render);
    });

    // Init
    window.addEventListener('resize', render);
    render();

</script>
</body>
</html>
