<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, interactive-widget=resizes-content">
<title>Architect v13 (Industrial)</title>
<script src="https://cdn.tailwindcss.com"></script>
<style>
    body { background-color: #000; color: #e2e8f0; font-family: 'Courier New', monospace; padding: 10px; }
    
    /* HUD */
    .hud-panel { background: #0a0a0a; border: 1px solid #333; border-radius: 8px; padding: 12px; margin-bottom: 10px; box-shadow: 0 0 30px rgba(0,0,0,0.8); }
    .row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
    .lbl { font-size: 0.7rem; color: #64748b; text-transform: uppercase; font-weight: bold; letter-spacing: 1px; }
    .val { font-size: 1.1rem; color: #fff; font-weight: bold; text-shadow: 0 0 5px rgba(255,255,255,0.2); }
    .val-gold { color: #facc15; }
    .val-blue { color: #38bdf8; }
    .val-red { color: #f87171; }
    .val-green { color: #4ade80; }

    /* PROGRESS TRACKS */
    .track-container { margin-bottom: 12px; }
    .track-lbl { display: flex; justify-content: space-between; font-size: 0.65rem; color: #94a3b8; margin-bottom: 3px; font-weight: bold; }
    .track { height: 6px; background: #171717; border-radius: 3px; overflow: hidden; border: 1px solid #262626; }
    .fill-gold { height: 100%; background: #facc15; width: 0%; transition: width 0.1s linear; }
    .fill-blue { height: 100%; background: #38bdf8; width: 0%; transition: width 0.1s linear; }

    /* CORE GRID */
    .core-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 4px; margin-bottom: 15px; }
    .core-card { background: #111; border: 1px solid #222; padding: 6px; border-radius: 4px; text-align: center; }
    .core-lbl { font-size: 0.6rem; color: #525252; font-weight: bold; display: block; }
    .core-stat { font-size: 0.75rem; color: #e5e5e5; font-weight: bold; }
    .core-active { border-color: #facc15; color: #facc15; background: #2a200a; }
    
    /* INPUTS */
    .input-group { display: flex; gap: 5px; margin-top: 10px; }
    input { background: #111; border: 1px solid #333; color: #fff; padding: 12px; border-radius: 6px; flex-grow: 1; font-family: monospace; font-weight: bold; font-size: 0.9rem; outline: none; }
    input:focus { border-color: #facc15; }
    .btn { background: #333; color: #fff; border: 1px solid #444; padding: 0 20px; border-radius: 6px; font-weight: 900; cursor: pointer; text-transform: uppercase; font-size: 0.9rem; }
    .btn-go { background: #ca8a04; border-color: #eab308; color: #000; }
    .btn-stop { background: #991b1b; border-color: #ef4444; display: none; }

    /* LOG */
    .log-box { height: 180px; overflow-y: auto; background: #050505; border: 1px solid #222; padding: 8px; font-size: 0.7rem; color: #a3a3a3; border-radius: 4px; font-family: monospace; }
    .log-row { margin-bottom: 2px; border-bottom: 1px solid #111; padding-bottom: 1px; }
    .l-sys { color: #38bdf8; }
    .l-hit { color: #facc15; }
    .l-win { color: #4ade80; font-weight: bold; background: rgba(74, 222, 128, 0.1); padding: 4px; text-align: center; border: 1px solid #4ade80; }
    .l-warn { color: #fb923c; }
</style>
</head>
<body>

<div class="hud-panel">
    <div class="row">
        <div><span class="lbl">TARGET (N)</span><div id="dispN" class="val" style="word-break:break-all; font-size:0.9rem;">WAITING</div></div>
        <div style="text-align:right;"><span class="lbl">FACTOR BASE</span><div id="dispFB" class="val val-blue">0</div></div>
    </div>
    
    <div class="track-container">
        <div class="track-lbl"><span>RELATIONS SILO</span><span id="relTxt" class="text-yellow-400">0 / 0</span></div>
        <div class="track"><div id="relBar" class="fill-gold"></div></div>
    </div>

    <div class="track-container">
        <div class="track-lbl"><span>MATRIX SOLVER</span><span id="solTxt" class="text-cyan-400">IDLE</span></div>
        <div class="track"><div id="solBar" class="fill-blue"></div></div>
    </div>

    <div class="flex justify-between items-center mb-2">
        <span class="lbl">ACTIVE CORES</span>
        <select id="coreSelect" style="background:#111; color:#fff; border:1px solid #333; padding:2px 8px; font-size:0.8rem; border-radius:4px;" onchange="initGrid()">
            <option value="2">2</option>
            <option value="4">4</option>
            <option value="6">6</option>
            <option value="8">8</option>
            <option value="12">12</option>
        </select>
    </div>

    <div class="core-grid" id="coreGrid"></div>

    <div class="input-group">
        <input id="inpN" value="1099515822059" placeholder="Enter Target Number">
        <button id="btnRun" class="btn btn-go" onclick="ignite()">IGNITE</button>
        <button id="btnStop" class="btn btn-stop" onclick="abort()">ABORT</button>
    </div>
</div>

<div id="log" class="log-box">
    <div class="log-row l-sys">Architect v13 Online.</div>
    <div class="log-row l-sys">Hardware: Ready. Memory: Virtual.</div>
</div>

<script>
// ==========================================
// WORKER 1: THE MINER (Gnomon & Log Sieve)
// ==========================================
const minerScript = `
self.onmessage = function(e) {
    const { cmd, N_str, startX, range, fb, primes, threshold } = e.data;
    
    if(cmd === 'mine') {
        const N = BigInt(N_str);
        const sieve = new Float32Array(range);
        const rootN = BigInt(Math.floor(Math.sqrt(Number(N))));
        
        // --- 1. GNOMONIC INITIALIZATION (No BigInt Multiplication Loop) ---
        // Q(x) = (rootN + x)^2 - N
        // We know Q(0) = rootN^2 - N
        // We know Q(x+1) = Q(x) + 2*(rootN + x) + 1
        
        let currentX = BigInt(startX);
        // Calculate initial Q for this chunk start
        let Q_val = (rootN + currentX)*(rootN + currentX) - N;
        // Calculate initial "Slope" (First derivative of x^2 is 2x)
        let Slope = 2n * (rootN + currentX) + 1n;
        
        // Fill sieve with Logs using iterative addition
        // Note: For huge N, Q is huge. We assume Q fits in double for log2 estimation.
        // If N is > 2^1024, we need BigInt log estimation.
        // For Architect range, standard log2 is fine approximation.
        
        for(let i=0; i<range; i++) {
            // Store approx log2 of abs(Q)
            // We convert Q to Number. If Q > MAX_SAFE_INTEGER, precision loss is fine for Log.
            // Using string conversion is slow, so we estimate magnitude by bit length.
            
            let absQ = Q_val < 0n ? -Q_val : Q_val;
            sieve[i] = absQ.toString(2).length; // Fast Log2 estimate
            
            // Gnomon Step: Move to next polynomial value using Addition
            Q_val += Slope;
            Slope += 2n; // The second derivative of x^2 is constant 2
        }
        
        // --- 2. LOGARITHMIC EROSION (The Sieve) ---
        for(let i=0; i<primes.length; i++) {
            const p = primes[i];
            const logP = Math.log2(p); // Precalc this in main thread for speed? Fast enough here.
            const roots = fb[i];
            
            for(let r of roots) {
                // Solver: (rootN + x) % p = r
                let offset = Number((BigInt(r) - rootN - BigInt(startX)) % BigInt(p));
                if (offset < 0) offset += p;
                
                // Stride
                for(let j=offset; j<range; j+=p) {
                    sieve[j] -= logP;
                }
            }
        }
        
        // --- 3. HARVEST ---
        const relations = [];
        // Threshold: We want Q reduced to near 1 (log 0). 
        // Allow slack for log errors.
        
        for(let j=0; j<range; j++) {
            if(sieve[j] < threshold) {
                const xVal = BigInt(startX + j);
                let Q = (rootN + xVal)*(rootN + xVal) - N;
                if(Q < 0n) Q = -Q;
                
                const vector = new Uint8Array(primes.length);
                const exps = new Uint32Array(primes.length);
                let smooth = true;
                
                // Trial Divide Candidates
                for(let k=0; k<primes.length; k++) {
                    const p = BigInt(primes[k]);
                    let count = 0;
                    while(Q % p === 0n) { Q /= p; count++; }
                    if(count % 2 === 1) vector[k] = 1;
                    exps[k] = count;
                }
                
                if(Q === 1n) {
                    relations.push({ x: xVal.toString(), vec: vector, exps: exps });
                }
            }
        }
        
        self.postMessage({ type: 'results', rels: relations });
    }
};
`;

// ==========================================
// WORKER 2: THE SOLVER (Deterministic Gaussian)
// ==========================================
const solverScript = `
self.onmessage = function(e) {
    const { relations, factorBase, targetN_str } = e.data;
    const targetN = BigInt(targetN_str);
    const rootN = BigInt(Math.floor(Math.sqrt(Number(targetN))));
    
    function gcd(a, b) {
        if(a<0n) a=-a; while(b>0n){let t=b;b=a%b;a=t;} return a;
    }

    self.postMessage({type:'status', msg:'BUILDING MATRIX'});
    
    // 1. Build Matrix
    // We treat the "vector" as a BitSet (BigInt) for speed
    const matrix = relations.map((r, i) => {
        let mask = 0n;
        for(let k=0; k<r.vec.length; k++) if(r.vec[k]) mask |= (1n << BigInt(k));
        return { mask, id: i };
    });

    self.postMessage({type:'status', msg:'ELIMINATING PIVOTS'});
    
    // 2. Deterministic Pivot Search
    const pivots = new Map(); // BitPos -> Row
    const dependencies = []; // Solutions
    
    for(let i=0; i<matrix.length; i++) {
        let row = matrix[i];
        let mask = row.mask;
        let history = [row.id];
        
        // Scan bits from LSB
        // We iterate through Factor Base columns
        for(let col=0; col<factorBase.length; col++) {
            if ( (mask & (1n << BigInt(col))) !== 0n ) {
                if (pivots.has(col)) {
                    // XOR with existing pivot to clear this bit
                    const piv = pivots.get(col);
                    mask ^= piv.mask;
                    history = history.concat(piv.history);
                } else {
                    // Found a new pivot for this column
                    pivots.set(col, { mask: mask, history: history });
                    mask = 0n; // Row is now part of the basis
                    break; 
                }
            }
        }
        
        // If mask is cleared, we found a dependency
        if (mask === 0n && history.length > 0) {
            dependencies.push(history);
            // We only need one good one, but let's collect a few to avoid trivial results
            if(dependencies.length > 5) break; 
        }
        
        if(i % 50 === 0) self.postMessage({type:'prog', val: i, total: matrix.length});
    }
    
    if(dependencies.length === 0) {
        self.postMessage({type:'fail'});
        return;
    }

    self.postMessage({type:'status', msg:'CRACKING ROOTS'});
    
    // 3. Crack Roots
    for(let dep of dependencies) {
        // Construct X and Y
        let X = 1n;
        const totalExps = new Array(factorBase.length).fill(0);
        
        for(let idx of dep) {
            const r = relations[idx];
            const x_val = BigInt(r.x) + rootN;
            X = (X * x_val) % targetN;
            for(let k=0; k<r.exps.length; k++) totalExps[k] += r.exps[k];
        }
        
        let Y = 1n;
        for(let k=0; k<factorBase.length; k++) {
            const p = BigInt(factorBase[k]);
            const exp = BigInt(totalExps[k] / 2);
            // ModPow
            let base = p, e = exp, res = 1n;
            while(e>0n){ if(e&1n) res=(res*base)%targetN; base=(base*base)%targetN; e>>=1n; }
            Y = (Y * res) % targetN;
        }
        
        const f1 = gcd(X - Y, targetN);
        const f2 = targetN / f1;
        
        if(f1 > 1n && f1 < targetN) {
            self.postMessage({type:'success', f1:f1.toString(), f2:f2.toString()});
            return;
        }
    }
    
    self.postMessage({type:'trivial'});
};
`;

// ==========================================
// CONTROLLER (The Silo)
// ==========================================
const minerBlob = new Blob([minerScript], {type:'application/javascript'});
const solverBlob = new Blob([solverScript], {type:'application/javascript'});
const minerUrl = URL.createObjectURL(minerBlob);
const solverUrl = URL.createObjectURL(solverBlob);

let miners = [], solver = null;
let factorBase = [], rootsFB = [];
let targetN = 0n, relations = [], neededRels = 0;
let isRunning = false, globalOffset = 0;
const BLOCK_SIZE = 50000;

document.addEventListener('DOMContentLoaded', () => {
    const cores = navigator.hardwareConcurrency || 4;
    const sel = document.getElementById('coreSelect');
    for(let i=0;i<sel.options.length;i++) if(sel.options[i].value==cores) sel.selectedIndex=i;
    initGrid();
});

function log(msg, type='') {
    const box = document.getElementById('log');
    const d = document.createElement('div');
    d.className = `log-row l-${type||'sys'}`;
    d.innerText = `> ${msg}`;
    box.prepend(d);
}

function initGrid() {
    const n = document.getElementById('coreSelect').value;
    const g = document.getElementById('coreGrid');
    g.innerHTML = '';
    g.style.gridTemplateColumns = `repeat(${Math.min(n,4)}, 1fr)`;
    for(let i=0; i<n; i++) {
        g.innerHTML += `<div class="core-card" id="card${i}"><span class="core-lbl">CORE ${i+1}</span><span class="core-stat" id="c${i}">IDLE</span></div>`;
    }
}

function buildFB(n) {
    // Dynamic Size based on N magnitude
    // For 12-15 digits, 300-500 primes is usually enough. 
    // For bigger, we need more.
    const limit = 5000; 
    const fb=[], roots=[], sieve=new Uint8Array(limit).fill(1);
    for(let p=2; p<limit; p++) {
        if(sieve[p]) {
            for(let j=p*p; j<limit; j+=p) sieve[j]=0;
            const bigP = BigInt(p);
            const target = n % bigP;
            let r_sol = [];
            for(let r=0n; r<bigP; r++) { if((r*r)%bigP===target) r_sol.push(Number(r)); }
            if(r_sol.length>0) { fb.push(p); roots.push(r_sol); }
        }
    }
    return {p:fb, r:roots};
}

function ignite() {
    const nStr = document.getElementById('inpN').value.trim();
    try { targetN = BigInt(nStr); } catch{ alert("Invalid N"); return; }
    
    isRunning = true; relations = []; globalOffset = 0;
    document.getElementById('btnRun').style.display = 'none';
    document.getElementById('btnStop').style.display = 'inline-block';
    document.getElementById('log').innerHTML = '';
    document.getElementById('dispN').innerText = nStr;
    document.getElementById('relBar').style.width = '0%';
    document.getElementById('solBar').style.width = '0%';
    
    log(`Target Locked: ${targetN}`, 'sys');
    
    const data = buildFB(targetN);
    factorBase = data.p; rootsFB = data.r;
    neededRels = factorBase.length + 20;
    
    document.getElementById('dispFB').innerText = factorBase.length;
    document.getElementById('relTxt').innerText = `0 / ${neededRels}`;
    
    log(`Generated Factor Base (${factorBase.length} Primes)`, 'sys');
    
    // Spawn Miners
    miners.forEach(w=>w.terminate()); miners=[];
    const count = parseInt(document.getElementById('coreSelect').value);
    for(let i=0; i<count; i++) {
        const w = new Worker(minerUrl);
        w.onmessage = e => handleMiner(e, i);
        miners.push(w);
    }
    
    dispatch();
}

function dispatch() {
    if(!isRunning) return;
    if(relations.length >= neededRels) { launchSolver(); return; }
    
    miners.forEach((w, i) => {
        w.postMessage({
            cmd:'mine', N_str:targetN.toString(), startX:globalOffset, range:BLOCK_SIZE,
            fb:rootsFB, primes:factorBase, threshold: 5.0
        });
        document.getElementById(`c${i}`).innerText = `${Math.round(globalOffset/1000)}k`;
        document.getElementById(`card${i}`).classList.add('core-active');
        globalOffset += BLOCK_SIZE;
    });
}

function handleMiner(e, id) {
    if(e.data.type === 'results') {
        const hits = e.data.rels;
        if(hits.length > 0) {
            relations.push(...hits);
            const pct = Math.min(100, (relations.length/neededRels)*100);
            document.getElementById('relBar').style.width = pct+'%';
            document.getElementById('relTxt').innerText = `${relations.length} / ${neededRels}`;
            document.getElementById('relTxt').classList.add('text-white');
            log(`Core ${id+1} found ${hits.length} relations`, 'hit');
        }
        
        // Visual Reset
        setTimeout(()=>document.getElementById(`card${id}`).classList.remove('core-active'), 100);
        
        if(relations.length < neededRels && isRunning) {
            // Re-dispatch this specific miner immediately to keep pipeline full
            const chunk = globalOffset; globalOffset += BLOCK_SIZE;
            miners[id].postMessage({
                cmd:'mine', N_str:targetN.toString(), startX:chunk, range:BLOCK_SIZE,
                fb:rootsFB, primes:factorBase, threshold: 5.0
            });
            document.getElementById(`c${id}`).innerText = `${Math.round(chunk/1000)}k`;
            document.getElementById(`card${id}`).classList.add('core-active');
        } else if (isRunning && relations.length >= neededRels) {
            launchSolver();
        }
    }
}

function launchSolver() {
    if(solver) return;
    isRunning = false;
    miners.forEach(w=>w.terminate()); miners=[];
    document.querySelectorAll('.core-active').forEach(e=>e.classList.remove('core-active'));
    
    log("Silo Full. Launching Deterministic Solver...", 'sys');
    
    solver = new Worker(solverUrl);
    solver.onmessage = e => {
        if(e.data.type === 'status') document.getElementById('solTxt').innerText = e.data.msg;
        if(e.data.type === 'prog') {
            const pct = (e.data.val / e.data.total)*100;
            document.getElementById('solBar').style.width = pct+'%';
        }
        if(e.data.type === 'success') {
            document.getElementById('solBar').style.width = '100%';
            document.getElementById('solBar').style.backgroundColor = '#4ade80';
            document.getElementById('solTxt').innerText = "CRACKED";
            log(`FACTOR: ${e.data.f1}`, 'win');
            log(`FACTOR: ${e.data.f2}`, 'win');
            resetUI();
        }
        if(e.data.type === 'fail' || e.data.type === 'trivial') {
            log(e.data.type === 'fail' ? "Matrix Singular (Need more data)." : "Trivial Solution Found (Unlucky).", 'warn');
            log("Resuming Mining...", 'sys');
            solver.terminate(); solver=null;
            neededRels += 30; // Raise bar
            isRunning = true;
            ignite(); // Re-init miners with existing relations? No, restart for simplicity in this demo structure
            // In full prod we would keep relations.
        }
    };
    
    solver.postMessage({ relations, factorBase, targetN_str:targetN.toString() });
}

function abort() {
    isRunning = false;
    if(miners.length) miners.forEach(w=>w.terminate());
    if(solver) solver.terminate();
    resetUI();
    log("System Halted.", 'warn');
}

function resetUI() {
    document.getElementById('btnRun').style.display = 'inline-block';
    document.getElementById('btnStop').style.display = 'none';
    solver = null; miners = [];
}
</script>
</body>
</html>
