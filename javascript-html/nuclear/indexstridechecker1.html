<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Index Stride Visualizer — Workers + Blob</title>
<style>
  :root { --bg:#0b1220; --card:#0f1724; --muted:#94a3b8; --accent:#3b82f6; --good:#16a34a; --bad:#ef4444; }
  body { background: linear-gradient(180deg,#071026 0%, #031024 100%); color:#e6eefc; font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; padding:18px; }
  .wrap { max-width:1100px; margin:0 auto; }
  .card { background: linear-gradient(180deg,#07122788,#00122666); border:1px solid rgba(99,102,241,0.06); padding:16px; border-radius:12px; box-shadow:0 8px 40px rgba(2,6,23,0.7); }
  h1 { margin:0 0 8px 0; font-size:20px; letter-spacing:0.4px; }
  label { display:block; font-size:12px; color:var(--muted); margin-top:12px; }
  input, select { width:100%; padding:8px 10px; font-size:14px; border-radius:8px; border:1px solid rgba(255,255,255,0.04); background: rgba(255,255,255,0.02); color:#dbeafe; box-sizing:border-box; }
  .grid2 { display:grid; grid-template-columns: 1fr 1fr; gap:12px; }
  .row { display:flex; gap:10px; margin-top:12px; }
  button { padding:10px 14px; font-weight:700; border-radius:8px; cursor:pointer; border:none; background:var(--accent); color:white; }
  button.stop { background:var(--bad); }
  .stats { display:flex; gap:12px; margin-top:12px; align-items:center; flex-wrap:wrap; }
  .stat { font-size:13px; color:var(--muted); }
  .stat b { color:#fff; margin-left:6px; }
  #log { background:#041124; border:1px solid rgba(255,255,255,0.03); padding:10px; margin-top:12px; height:200px; overflow:auto; border-radius:8px; font-family: monospace; font-size:13px; color:#cbd5e1;}
  .workers { display:grid; grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); gap:10px; margin-top:12px; }
  .worker { background: rgba(255,255,255,0.02); border:1px solid rgba(255,255,255,0.03); padding:8px; border-radius:8px; font-size:13px; color:#e6eefc; }
  .index-list { margin-top:12px; display:flex; flex-direction:column; gap:6px; max-height:220px; overflow:auto; }
  .index-item { display:flex; gap:8px; align-items:center; padding:6px; border-radius:6px; background: rgba(255,255,255,0.01); }
  .dot { width:12px; height:12px; border-radius:6px; background:var(--muted); flex:0 0 12px; }
  .bar { height:10px; width:260px; background:rgba(255,255,255,0.03); border-radius:6px; overflow:hidden; position:relative; }
  .bar > .pos { height:100%; background:var(--accent); width:0%; transition:width .18s linear; }
  .mid { position:absolute; top:-6px; left:50%; transform:translateX(-50%); font-size:11px; color:var(--muted); }
  .hit { color:var(--bad); font-weight:800; }
  .found { color:var(--good); font-weight:800; }
  footer { margin-top:14px; color:var(--muted); font-size:13px; }
  small.note { color:var(--muted); display:block; margin-top:6px; }
</style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <h1>Index Stride Visualizer — Workers + Blob</h1>
    <div>
      <label>Target form: <code>10^exp + add</code> — enter exponent as a plain integer (e.g. <code>1000000000</code>)</label>
      <div class="grid2">
        <div>
          <input id="inpExp" placeholder="exp (digits only)" value="1000000000"/>
        </div>
        <div>
          <input id="inpAdd" placeholder="add (e.g. 61)" value="61"/>
        </div>
      </div>

      <label>Max prime to test (sieve limit, e.g. 2,000,000)</label>
      <div class="grid2">
        <div><input id="inpMaxP" value="2000000"/></div>
        <div>
          <select id="inpCores">
            <option>1</option><option>2</option><option selected>4</option><option>6</option><option>8</option>
          </select>
        </div>
      </div>

      <div class="row">
        <button id="btnStart">Start Visual Check</button>
        <button id="btnStop" class="stop" style="display:none">Stop</button>
        <button id="btnClear">Clear Log</button>
      </div>

      <div class="stats">
        <div class="stat">Elapsed <b id="lblTime">00:00:00</b></div>
        <div class="stat">Primes <b id="lblPrimes">0</b></div>
        <div class="stat">Tested <b id="lblTested">0</b></div>
        <div class="stat">Workers <b id="lblWorkers">0</b></div>
      </div>

      <small class="note">Index metaphor: each prime p defines a multiplicative cycle of length <code>p−1</code>. We show
        <code>eMod = exp mod (p−1)</code> (the index inside that cycle) and place it on a bar where midpoint = (p−1)/2.
        If <code>(10^exp + add) mod p = 0</code> we report a factor. This visualizes the standing wave / index idea.</small>
    </div>

    <div class="workers" id="workers"></div>

    <label style="margin-top:12px">Recent Index Positions (per-prime visual)</label>
    <div class="index-list" id="indexList"></div>

    <label style="margin-top:10px">Log</label>
    <div id="log">Ready.</div>

    <footer>
      Tip: Use moderate maxP (a few million) on a phone. Exponent must be a digits-only integer. This runs entirely client-side.
    </footer>
  </div>
</div>

<script>
(() => {
  const inpExp = document.getElementById('inpExp');
  const inpAdd = document.getElementById('inpAdd');
  const inpMaxP = document.getElementById('inpMaxP');
  const inpCores = document.getElementById('inpCores');
  const btnStart = document.getElementById('btnStart');
  const btnStop = document.getElementById('btnStop');
  const btnClear = document.getElementById('btnClear');
  const lblTime = document.getElementById('lblTime');
  const lblPrimes = document.getElementById('lblPrimes');
  const lblTested = document.getElementById('lblTested');
  const lblWorkers = document.getElementById('lblWorkers');
  const workersDiv = document.getElementById('workers');
  const indexList = document.getElementById('indexList');
  const logBox = document.getElementById('log');

  let workers = [];
  let primes = [];
  let totalPrimes = 0;
  let testedCount = 0;
  let startTime = 0;
  let timerInt = null;
  let aborted = false;

  function log(msg, cls='') {
    const t = new Date().toISOString().slice(11,19);
    logBox.textContent = `[${t}] ${msg}\n` + logBox.textContent;
  }

  function formatTime(s) {
    const h = Math.floor(s/3600).toString().padStart(2,'0');
    const m = Math.floor((s%3600)/60).toString().padStart(2,'0');
    const ss = Math.floor(s%60).toString().padStart(2,'0');
    return `${h}:${m}:${ss}`;
  }

  function updateTimer() {
    lblTime.textContent = formatTime(Math.floor((Date.now()-startTime)/1000));
  }

  // simple sieve
  function sievePrimes(n) {
    const N = Number(n);
    const sieve = new Uint8Array(N+1);
    const out = [];
    for (let i=2; i*i<=N; i++) {
      if (!sieve[i]) {
        for (let j=i*i; j<=N; j+=i) sieve[j]=1;
      }
    }
    for (let i=2;i<=N;i++) if(!sieve[i]) out.push(i);
    return out;
  }

  // Worker source (Blob). Worker reduces exponent modulo (p-1) and computes pow10 mod p using reduced exponent.
  const workerSrc = `
    self.onmessage = function(ev) {
      const data = ev.data;
      const primes = data.primes;
      const expStr = data.expStr;   // decimal digits string
      const addStr = data.addStr;
      const id = data.workerId;

      function powMod(base, exp, mod) {
        base = BigInt(base) % BigInt(mod);
        let e = BigInt(exp);
        let res = 1n;
        while (e > 0n) {
          if ((e & 1n) === 1n) res = (res * base) % BigInt(mod);
          base = (base * base) % BigInt(mod);
          e = e >> 1n;
        }
        return res;
      }

      try {
        let tested = 0;
        for (let i=0;i<primes.length;i++) {
          const p = primes[i];
          const pBI = BigInt(p);

          // compute eMod = exp % (p-1) (as BigInt)
          let eModBI;
          if (p === 2 || p === 5) {
            // special small-handling: no reduction needed for p=2 or p=5
            eModBI = BigInt(0);
          } else {
            const cycle = BigInt(p-1);
            eModBI = BigInt(expStr) % cycle;
          }
          // send index info (converted to Number if safe)
          const cycleLen = (p === 2) ? 1 : (p-1);
          const eModNum = Number(eModBI); // safe because p-1 <= maxP which should be reasonable
          self.postMessage({ type:'index', p, eMod: eModNum, cycle: cycleLen, workerId: id });

          // compute remainder efficiently:
          let rem;
          if (p === 2) {
            // 10^exp mod 2 == 0
            rem = (BigInt(0) + BigInt(addStr)) % pBI;
          } else if (p === 5) {
            // 10^exp mod 5 == 0
            rem = (BigInt(0) + BigInt(addStr)) % pBI;
          } else {
            const pow10 = powMod(10n, eModBI, pBI);
            rem = (pow10 + BigInt(addStr)) % pBI;
          }

          tested++;
          if (rem === 0n) {
            self.postMessage({ type:'hit', p, workerId: id });
            return;
          }
          // periodic progress update
          if ((tested & 127) === 0) {
            self.postMessage({ type:'progress', tested, workerId: id });
          }
        }
        self.postMessage({ type:'done', tested, workerId: id });
      } catch (err) {
        self.postMessage({ type:'error', msg: String(err) });
      }
    };
  `;

  function createWorkerFromString(src) {
    const blob = new Blob([src], { type: 'application/javascript' });
    const url = URL.createObjectURL(blob);
    return new Worker(url);
  }

  btnClear.addEventListener('click', () => { logBox.textContent = ''; });

  btnStop.addEventListener('click', () => {
    aborted = true;
    workers.forEach(w => w.terminate());
    workers = [];
    clearInterval(timerInt);
    lblWorkers.textContent = '0';
    btnStart.style.display = 'inline-block';
    btnStop.style.display = 'none';
    log('User stopped scan.');
  });

  btnStart.addEventListener('click', async () => {
    // clear
    aborted = false;
    indexList.innerHTML = '';
    workersDiv.innerHTML = '';
    logBox.textContent = '';
    testedCount = 0;
    lblTested.textContent = '0';
    lblPrimes.textContent = '0';

    const expStr = inpExp.value.trim();
    const addStr = inpAdd.value.trim();
    const maxP = parseInt(inpMaxP.value.replace(/,/g,''), 10) || 2000000;
    const cores = Math.max(1, Math.min(12, parseInt(inpCores.value,10) || 4));

    // validation
    if (!/^[0-9]+$/.test(expStr)) { log('Invalid exponent. Enter digits-only integer (e.g. 1000000000).'); return; }
    if (!/^-?[0-9]+$/.test(addStr)) { log('Invalid add. Enter integer (e.g. 61 or -1).'); return; }
    if (maxP < 1000) { log('maxP should be at least 1000.'); return; }

    btnStart.style.display = 'none';
    btnStop.style.display = 'inline-block';
    log('Sieve primes up to ' + maxP.toLocaleString() + ' ...');

    // generate primes (blocking-ish for big maxP; keep moderate)
    await new Promise(r => setTimeout(r,10));
    primes = sievePrimes(maxP);
    totalPrimes = primes.length;
    lblPrimes.textContent = totalPrimes.toLocaleString();
    log('Generated ' + totalPrimes.toLocaleString() + ' primes.');

    // split into chunks
    const chunk = Math.ceil(primes.length / cores);
    startTime = Date.now();
    timerInt = setInterval(updateTimer, 1000);

    // create worker UI blocks and spawn workers
    workers = [];
    for (let i=0;i<cores;i++) {
      const start = i*chunk;
      const end = Math.min(start+chunk, primes.length);
      if (start >= end) break;
      const chunkPrimes = primes.slice(start, end);

      // worker UI
      const wdiv = document.createElement('div'); wdiv.className='worker';
      wdiv.innerHTML = `<div><b>Worker ${i+1}</b></div><div id="w${i}-stat">Primes ${start.toLocaleString()}–${(end-1).toLocaleString()}</div><div id="w${i}-last" style="margin-top:6px;color:var(--muted)">idle</div>`;
      workersDiv.appendChild(wdiv);

      const w = createWorkerFromString(workerSrc);
      w.onmessage = function(evt) {
        const d = evt.data;
        if (d.type === 'index') {
          // show index visual
          const p = d.p;
          const eMod = d.eMod;
          const cycle = d.cycle;
          showIndexVisual(p, eMod, cycle);
          document.getElementById(`w${i}-last`).textContent = `p=${p} eMod=${eMod} / ${cycle}`;
        } else if (d.type === 'progress') {
          testedCount += d.tested;
          lblTested.textContent = testedCount.toLocaleString();
        } else if (d.type === 'hit') {
          log('FOUND FACTOR p=' + d.p + ' (worker ' + (d.workerId+1) + ')', 'hit');
          // stop all
          workers.forEach(wk => wk.terminate());
          workers = [];
          clearInterval(timerInt);
          btnStart.style.display = 'inline-block';
          btnStop.style.display = 'none';
          lblWorkers.textContent = '0';
          log('Target is composite (divisible by p=' + d.p + ').');
        } else if (d.type === 'done') {
          // worker finished chunk
          testedCount += d.tested;
          lblTested.textContent = testedCount.toLocaleString();
          document.getElementById(`w${i}-stat`).textContent = `Finished chunk (${d.tested} tested)`;
        } else if (d.type === 'error') {
          log('Worker error: ' + d.msg);
        }
      };

      // post chunk
      w.postMessage({ primes: chunkPrimes, expStr: expStr, addStr: addStr, workerId: i });
      workers.push(w);
    } // end spawn

    lblWorkers.textContent = workers.length.toString();
    log('Dispatched ' + workers.length + ' workers across ' + totalPrimes.toLocaleString() + ' primes.');
  });

  // show index visual; keep list trimmed
  function showIndexVisual(p, eMod, cycle) {
    const item = document.createElement('div'); item.className = 'index-item';
    const dot = document.createElement('div'); dot.className='dot';
    const meta = document.createElement('div'); meta.style.minWidth='110px'; meta.innerHTML = `<b>p=${p}</b> eMod=${eMod}/${cycle}`;
    const barWrap = document.createElement('div'); barWrap.className='bar';
    const pos = document.createElement('div'); pos.className='pos';
    // compute percent position (eMod relative to cycle)
    const pct = cycle > 0 ? Math.round((eMod / cycle) * 100) : 0;
    pos.style.width = pct + '%';
    // choose color based on being near midpoint
    const midpoint = cycle/2;
    const dist = Math.abs(eMod - midpoint);
    if (dist === 0) { pos.style.background = 'var(--bad)'; dot.style.background = 'var(--bad)'; }
    else if (dist <= Math.max(1, cycle*0.05)) { pos.style.background = '#f59e0b'; dot.style.background = '#f59e0b'; }
    else { pos.style.background = 'var(--accent)'; dot.style.background = 'var(--muted)'; }

    const midLabel = document.createElement('div'); midLabel.className='mid'; midLabel.textContent = 'mid';
    barWrap.appendChild(pos);
    barWrap.appendChild(midLabel);

    item.appendChild(dot);
    item.appendChild(meta);
    item.appendChild(barWrap);

    indexList.insertBefore(item, indexList.firstChild);
    // trim list to 200
    while (indexList.children.length > 200) indexList.removeChild(indexList.lastChild);
  }

})();
</script>
</body>
</html>