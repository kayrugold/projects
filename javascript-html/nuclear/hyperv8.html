<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
<title>Hyper-Streamliner v6 (Real Math)</title>
<script src="https://cdn.tailwindcss.com"></script>
<style>
  body { background-color: #000; color: #e2e8f0; font-family: 'Courier New', monospace; padding: 15px; overflow-x: hidden; }
  .card { background: #111; border: 1px solid #333; border-radius: 16px; padding: 20px; box-shadow: 0 0 20px rgba(220, 38, 38, 0.2); }
  
  .input-group { margin-bottom: 15px; }
  label { display: block; font-weight: bold; margin-bottom: 5px; color: #f87171; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.05em; }
  input { width: 100%; background: #222; border: 1px solid #444; color: #fff; padding: 12px; border-radius: 8px; font-size: 1.1rem; }
  input:focus { outline: none; border-color: #ef4444; }
  
  .btn { width: 100%; padding: 18px; border: none; border-radius: 10px; font-weight: 900; cursor: pointer; font-size: 1.1rem; text-transform: uppercase; margin-top: 10px; }
  .btn-start { background: #ef4444; color: #fff; }
  .btn-stop { background: #4b5563; color: #fff; }
  
  .log-box { background: #050505; border: 1px solid #333; padding: 15px; height: 200px; overflow-y: auto; margin-top: 20px; border-radius: 10px; font-size: 0.75rem; color: #fca5a5; white-space: pre-wrap; }
  .status-bar { height: 10px; background: #333; margin-top: 20px; border-radius: 5px; overflow: hidden; }
  .progress { height: 100%; background: #ef4444; width: 0%; transition: width 0.2s; }
  
  .stat-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 15px; }
  .stat-box { background: #222; padding: 10px; border-radius: 8px; text-align: center; }
  .stat-val { font-weight: bold; color: #fff; font-size: 1.1rem; }
  .stat-lbl { font-size: 0.7rem; color: #888; text-transform: uppercase; }
  
  /* File Download Link */
  .file-area { text-align: center; margin-top: 20px; }
  #downloadLink { display: none; color: #f87171; text-decoration: underline; font-weight: bold; padding: 10px; border: 1px dashed #333; border-radius: 8px; }
</style>
</head>
<body>

<div class="card">
  <h1 class="text-2xl font-black text-center text-red-500 mb-2">HYPER v6: REAL MATH</h1>
  <p class="text-center text-xs text-gray-500 mb-6">Virtual Memory NTT â€¢ True Calculation</p>

  <div class="grid grid-cols-3 gap-3 mb-2">
    <div class="input-group">
      <label>Base</label>
      <input id="inpBase" value="10">
    </div>
    <div class="input-group">
      <label>Exp</label>
      <input id="inpExp" value="1000000000"> 
    </div>
    <div class="input-group">
      <label>Add</label>
      <input id="inpAdd" value="61">
    </div>
  </div>

  <div class="stat-grid">
    <div class="stat-box">
      <div id="statStage" class="stat-val">IDLE</div>
      <div class="stat-lbl">Current Stage</div>
    </div>
    <div class="stat-box">
      <div id="statTime" class="stat-val">0s</div>
      <div class="stat-lbl">Elapsed Time</div>
    </div>
  </div>

  <button id="btnRun" class="btn btn-start" onclick="startProof()">Initiate Computation</button>
  <button id="btnStop" class="btn btn-stop hidden" onclick="stopProof()">STOP</button>

  <div class="status-bar"><div id="progressBar" class="progress"></div></div>
  <div id="logBox" class="log-box">System Ready.
This will perform the ACTUAL mathematical squaring of the Index.
Warning: For 10^9, this process will take a long time. Plug in phone.</div>

  <div class="file-area">
    <a id="downloadLink"></a>
  </div>
</div>

<script>
const workerCode = `
// --- VIRTUAL MEMORY MANAGER ---
// Allows allocating 1GB+ by splitting into 256MB pages
// This bypasses the browser's "contiguous memory" limit.
const PAGE_ELEMENTS = 64 * 1024 * 1024; // 64 Million Ints (256MB)

class VirtualArray {
    constructor(totalSize) {
        this.totalSize = totalSize;
        this.pages = [];
        this.numPages = Math.ceil(totalSize / PAGE_ELEMENTS);
        
        // Log allocation attempt
        postMessage({type:'log', msg: \`Allocating Virtual RAM: \${this.numPages} pages of 256MB...\`});

        for(let i=0; i<this.numPages; i++) {
            const size = (i === this.numPages-1) ? (totalSize % PAGE_ELEMENTS) || PAGE_ELEMENTS : PAGE_ELEMENTS;
            try {
                this.pages.push(new Int32Array(size));
            } catch(e) {
                throw new Error(\`Memory Allocation Failed at Page \${i}. Device RAM exhausted.\`);
            }
        }
        postMessage({type:'log', msg: 'Virtual RAM Allocation Successful.'});
    }
    
    // Optimized Accessors
    // We inline these logic in critical loops for speed, but keep methods for clarity
    get(index) {
        const pageIdx = (index / PAGE_ELEMENTS) | 0; 
        const offset = index % PAGE_ELEMENTS;
        return this.pages[pageIdx][offset];
    }
    
    set(index, value) {
        const pageIdx = (index / PAGE_ELEMENTS) | 0;
        const offset = index % PAGE_ELEMENTS;
        this.pages[pageIdx][offset] = value;
    }
}

// --- MATH CONSTANTS ---
const Q = 998244353n; // NTT Prime
const G = 3n; // Primitive Root
const BASE_BI = 10000n;
const CHUNK_SIZE = 4;

// --- NTT MATH ENGINE ---
function power(base, exp) {
    let res = 1n; base %= Q;
    while (exp > 0n) {
        if (exp % 2n === 1n) res = (res * base) % Q;
        base = (base * base) % Q;
        exp /= 2n;
    }
    return res;
}

function modInverse(n) { return power(n, Q - 2n); }

// VIRTUAL-AWARE BIT REVERSAL
function bitReverseCopy(arr, n) {
    postMessage({type:'stage', msg:'Bit Reversal (Sorting)'});
    
    let lastLog = 0;
    for (let i = 0, j = 0; i < n; i++) {
        if (i < j) {
            // Manual inline get/set for speed
            const i_page = (i / PAGE_ELEMENTS) | 0; const i_off = i % PAGE_ELEMENTS;
            const j_page = (j / PAGE_ELEMENTS) | 0; const j_off = j % PAGE_ELEMENTS;
            
            const ai = arr.pages[i_page][i_off];
            const aj = arr.pages[j_page][j_off];
            
            arr.pages[i_page][i_off] = aj;
            arr.pages[j_page][j_off] = ai;
        }
        let bit = n >> 1;
        while (j & bit) { j ^= bit; bit >>= 1; }
        j ^= bit;
        
        if (i % 1000000 === 0) {
            const prog = (i/n)*10; // Allocation 10% of total progress bar
            postMessage({type:'progress', val: prog});
        }
    }
}

// VIRTUAL-AWARE NTT TRANSFORM
function ntt(arr, n, invert) {
    bitReverseCopy(arr, n);
    
    postMessage({type:'stage', msg: invert ? 'Inverse NTT (Reconstructing)' : 'Forward NTT (Transforming)'});
    
    let stages = 0;
    let maxStages = Math.log2(n);
    let progressBase = invert ? 55 : 10;
    let progressScale = 45; // 45% for forward, 45% for inverse
    
    for (let len = 2; len <= n; len <<= 1) {
        let wlen = power(G, (Q - 1n) / BigInt(len));
        if (invert) wlen = modInverse(wlen);
        
        stages++;
        // Update UI every stage
        postMessage({type:'progress', val: progressBase + (stages/maxStages)*progressScale});

        for (let i = 0; i < n; i += len) {
            let w = 1n;
            for (let j = 0; j < len / 2; j++) {
                const idxU = i + j;
                const idxV = i + j + len / 2;
                
                // Virtual Access
                const u_page = (idxU / PAGE_ELEMENTS) | 0; const u_off = idxU % PAGE_ELEMENTS;
                const v_page = (idxV / PAGE_ELEMENTS) | 0; const v_off = idxV % PAGE_ELEMENTS;
                
                const uVal = BigInt(arr.pages[u_page][u_off]);
                const vVal = BigInt(arr.pages[v_page][v_off]);
                
                // Butterfly Operation
                const vMod = (vVal * w) % Q;
                const uNew = Number((uVal + vMod) % Q);
                const vNew = Number((uVal - vMod + Q) % Q);
                
                arr.pages[u_page][u_off] = uNew;
                arr.pages[v_page][v_off] = vNew;
                
                w = (w * wlen) % Q;
            }
        }
    }
    
    if (invert) {
        postMessage({type:'stage', msg:'Normalizing'});
        const n_inv = modInverse(BigInt(n));
        for (let i = 0; i < n; i++) {
            const page = (i / PAGE_ELEMENTS) | 0; const off = i % PAGE_ELEMENTS;
            const val = BigInt(arr.pages[page][off]);
            arr.pages[page][off] = Number((val * n_inv) % Q);
        }
    }
}

self.onmessage = function(e) {
    const { mode, bStr, cStr } = e.data;
    
    if(mode === 'prove') {
        try {
            const digits = parseInt(bStr);
            const chunksNeeded = Math.ceil(digits / CHUNK_SIZE);
            
            // Pad to Power of 2 for NTT
            let n = 1;
            while(n < chunksNeeded * 2) n <<= 1;
            
            postMessage({type:'log', msg: \`Target: 10^\${bStr}. Math Size: \${n.toLocaleString()} chunks.\`});
            
            // 1. ALLOCATE VIRTUAL RAM
            const ram = new VirtualArray(n);
            
            // 2. CONSTRUCT INDEX (I)
            const topPos = digits - 1;
            const topIdx = Math.floor(topPos / CHUNK_SIZE);
            const topVal = 5 * Math.pow(10, topPos % CHUNK_SIZE);
            
            ram.set(topIdx, topVal);
            ram.set(0, ram.get(0) + 31); // Low part (61+1)/2
            
            postMessage({type:'log', msg: 'Index Constructed. Starting Real NTT...'});
            
            // 3. FORWARD NTT (Real Math)
            ntt(ram, n, false);
            
            // 4. POINTWISE SQUARE (Real Math)
            postMessage({type:'stage', msg:'Squaring in Frequency Domain'});
            for(let i=0; i<n; i++) {
                const page = (i / PAGE_ELEMENTS) | 0; const off = i % PAGE_ELEMENTS;
                let val = BigInt(ram.pages[page][off]);
                ram.pages[page][off] = Number((val * val) % Q);
            }
            
            // 5. INVERSE NTT (Real Math)
            ntt(ram, n, true);
            
            // 6. CARRY PROPAGATION
            postMessage({type:'stage', msg:'Propagating Carries'});
            let carry = 0n;
            for(let i=0; i<n; i++) {
                const page = (i / PAGE_ELEMENTS) | 0; const off = i % PAGE_ELEMENTS;
                let val = BigInt(ram.pages[page][off]) + carry;
                ram.pages[page][off] = Number(val % BASE_BI);
                carry = val / BASE_BI;
            }
            
            // 7. SUBTRACT N (Tail extraction)
            // I^2 - ( ...61 )
            const tailArr = [];
            for(let i=0; i<20; i++) tailArr.push(ram.get(i)); // Get last 20 chunks
            
            // Simple tail logic for N = ...61
            // N ends in 61.
            // tailArr is [chunk0, chunk1...]
            // We do bigInt subtraction on the tail string
            
            let tailString = tailArr.map(n => n.toString().padStart(4,'0')).reverse().join('').replace(/^0+/,'');
            if(!tailString) tailString = "0";
            
            // Perform the final subtraction check on the tail
            let tailBig = BigInt(tailString.slice(-15)); // Last 15 digits
            let resultBig = tailBig - 61n;
            
            postMessage({
                type: 'result',
                tail: resultBig.toString(),
                fullTail: tailString
            });
            
        } catch(e) {
            postMessage({type:'error', msg: e.message});
        }
    }
};
`;

let worker = null;
let wakeLock = null;
let startTime = 0;
let timerInterval = null;

function log(msg, type='') {
    const el = document.getElementById('logBox');
    el.textContent += `> ${msg}\n`;
    el.scrollTop = el.scrollHeight;
}

async function startProof() {
    try { wakeLock = await navigator.wakeLock.request('screen'); } catch(e){}
    
    document.getElementById('btnRun').classList.add('hidden');
    document.getElementById('btnStop').classList.remove('hidden');
    document.getElementById('logBox').textContent = '';
    document.getElementById('downloadLink').style.display = 'none';
    
    const bVal = document.getElementById('inpExp').value;
    const cVal = document.getElementById('inpAdd').value;
    
    startTime = Date.now();
    timerInterval = setInterval(() => {
        const s = Math.floor((Date.now() - startTime)/1000);
        const m = Math.floor(s / 60);
        const sec = s % 60;
        document.getElementById('statTime').textContent = `${m}m ${sec}s`;
    }, 1000);

    const blob = new Blob([workerCode], {type: 'application/javascript'});
    worker = new Worker(URL.createObjectURL(blob));
    
    worker.onmessage = function(e) {
        const d = e.data;
        if(d.type === 'log') log(d.msg);
        if(d.type === 'stage') document.getElementById('statStage').textContent = d.msg;
        if(d.type === 'progress') document.getElementById('progressBar').style.width = d.val + '%';
        if(d.type === 'error') { log("ERROR: " + d.msg); stopProof(); }
        if(d.type === 'result') {
            log("----------------");
            log("REAL MATH COMPLETE");
            log("Rim^2 Tail: ..." + d.tail);
            
            // Generate File
            const blob = new Blob([`Proof Result for 10^${bVal}+${cVal}\nTime: ${document.getElementById('statTime').textContent}\nRim^2 Tail: ...${d.tail}\nFull Tail Block: ${d.fullTail}`], {type: "text/plain"});
            const url = URL.createObjectURL(blob);
            const link = document.getElementById('downloadLink');
            link.href = url;
            link.download = `rim_proof_10_${bVal}.txt`;
            link.textContent = "ðŸ’¾ Download Proof Result";
            link.style.display = "inline-block";
            
            stopProof();
        }
    };
    
    worker.postMessage({ mode: 'prove', bStr: bVal, cStr: cVal });
}

function stopProof() {
    if(worker) worker.terminate();
    worker = null;
    if(wakeLock) wakeLock.release();
    clearInterval(timerInterval);
    document.getElementById('btnRun').classList.remove('hidden');
    document.getElementById('btnStop').classList.add('hidden');
}
</script>
</body>
</html>


