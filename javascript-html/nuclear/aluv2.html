<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Holographic ALU v2.0</title>
<script src="https://cdn.tailwindcss.com"></script>
<style>
    body { background-color: #020617; color: #e2e8f0; font-family: 'Courier New', monospace; padding: 20px; }
    .card { background: #0f172a; border: 1px solid #1e293b; border-radius: 12px; padding: 20px; max-width: 800px; margin: 0 auto; box-shadow: 0 0 40px rgba(56, 189, 248, 0.1); }
    h1 { color: #38bdf8; font-weight: 900; letter-spacing: 2px; text-align: center; margin-bottom: 20px; }
    
    .register-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 20px; }
    .reg-box { background: #1e293b; padding: 10px; border-radius: 6px; border: 1px solid #334155; }
    .reg-label { font-size: 0.7rem; color: #94a3b8; display: block; margin-bottom: 4px; font-weight: bold; }
    .reg-input { background: transparent; color: #fff; font-size: 1.1rem; font-weight: bold; width: 100%; outline: none; font-family: monospace; }
    
    .btn-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; margin-bottom: 20px; }
    .btn { padding: 15px; background: #334155; border: 1px solid #475569; border-radius: 6px; color: #fff; font-weight: bold; cursor: pointer; transition: all 0.2s; }
    .btn:hover { background: #475569; border-color: #94a3b8; }
    .btn-prime { background: #0369a1; border-color: #0ea5e9; }
    .btn-prime:hover { background: #0284c7; }

    .console { background: #000; border: 1px solid #334155; height: 250px; overflow-y: auto; padding: 10px; font-size: 0.75rem; color: #34d399; font-family: monospace; border-radius: 6px; margin-bottom: 10px; }
    .log-dim { color: #475569; }
    .log-res { color: #facc15; font-weight: bold; border-top: 1px dashed #334155; padding-top: 4px; margin-top: 4px; }
    
    .res-display { text-align: center; font-size: 1.2rem; color: #38bdf8; font-weight: bold; word-break: break-all; }
</style>
</head>
<body>

<div class="card">
    <h1>HOLOGRAPHIC ALU v2.0</h1>
    
    <div class="register-grid">
        <div class="reg-box">
            <span class="reg-label">REGISTER A (Area / Nomad)</span>
            <input id="regA" class="reg-input" value="1000000000000000000000000">
        </div>
        <div class="reg-box">
            <span class="reg-label">REGISTER B (Operand)</span>
            <input id="regB" class="reg-input" value="314159">
        </div>
    </div>

    <div class="btn-grid">
        <button class="btn btn-prime" onclick="runOp('mul')">MULTIPLY (Geometric)</button>
        <button class="btn btn-prime" onclick="runOp('sq')">SQUARE A (4x Reactor)</button>
        <button class="btn" onclick="runOp('sqrt')">SQRT A (Reverse 4x)</button>
        <button class="btn" onclick="runOp('div')">DIVIDE A / B (Packing)</button>
    </div>

    <div id="console" class="console">
        <div class="log-dim">System Online. Ready for geometric ops.</div>
    </div>
    
    <div id="finalRes" class="res-display">0</div>
</div>

<script>
const logBox = document.getElementById('console');

function log(msg, type='') {
    const d = document.createElement('div');
    d.className = type === 'res' ? 'log-res' : (type === 'dim' ? 'log-dim' : '');
    d.innerText = "> " + msg;
    logBox.prepend(d);
}

// --- GEOMETRIC KERNEL ---

// 1. SQUARING (The 4x Reactor)
function holoSquare(val) {
    const bits = val.toString(2);
    let area = 0n;
    let index = 0n;
    
    log(`Squaring ${val.toString().substr(0,10)}... via Stream`, 'dim');
    
    for(let i=0; i<bits.length; i++) {
        // 4x Scaling (Area x 4, Index x 2)
        area <<= 2n;
        index <<= 1n;
        
        if(bits[i] === '1') {
            // Gnomon Injection: 2*Index + 1
            const gnomon = (index << 1n) + 1n;
            area += gnomon;
            index += 1n;
        }
    }
    return area;
}

// 2. MULTIPLICATION (Difference of Squares)
function holoMul(a, b) {
    const sum = a + b;
    const diff = a > b ? a - b : b - a;
    
    // Check parity for "Nomad Alignment"
    if ((a % 2n) !== (b % 2n)) {
        // If parity mismatch, double both to align, then divide result by 4
        // Logic: (2a * 2b) / 4 = ab
        log("Parity Mismatch. Aligning Grids...", 'dim');
        return holoMul(a << 1n, b << 1n) >> 2n;
    }
    
    const avg = sum >> 1n;
    const rad = diff >> 1n;
    
    log("Calculating Midpoint Square...", 'dim');
    const s1 = holoSquare(avg);
    log("Calculating Difference Square...", 'dim');
    const s2 = holoSquare(rad);
    
    return s1 - s2;
}

// 3. SQUARE ROOT (Reverse 4x Reactor)
function holoSqrt(val) {
    if (val < 0n) throw "Imaginary";
    if (val === 0n) return 0n;
    
    // Align to even bit length for 4x stepping
    let bits = val.toString(2);
    if (bits.length % 2 !== 0) bits = '0' + bits;
    
    let res = 0n;
    let rem = 0n;
    
    log(`Collapsing Square (${bits.length} bits)...`, 'dim');
    
    // Process 2 bits at a time (inverse of 4x scale)
    for (let i = 0; i < bits.length; i += 2) {
        // Bring down next 2 bits of the area
        const chunk = BigInt(parseInt(bits.substr(i, 2), 2));
        rem = (rem << 2n) + chunk;
        
        // The "Inverse Gnomon" Check
        // Can we subtract the next layer?
        // Next potential root: (res << 1) + 1
        // Cost to build that layer: (20 * res) + 1  <-- Decimal view
        // Binary view: (res << 2) | 1
        
        const testGnomon = (res << 2n) | 1n;
        
        if (rem >= testGnomon) {
            rem -= testGnomon;
            res = (res << 1n) | 1n; // Add bit 1
        } else {
            res = (res << 1n);      // Add bit 0
        }
    }
    return res;
}

// 4. DIVISION (Rectangle Packing)
// A / B = How many 'B' widths fit in 'A'?
function holoDiv(a, b) {
    if (b === 0n) return "ERR";
    let quotient = 0n;
    let remainder = 0n;
    
    const bits = a.toString(2);
    log(`Packing Rectangles...`, 'dim');
    
    for (let i = 0; i < bits.length; i++) {
        // Shift remainder (Scaling the container)
        remainder = (remainder << 1n) | BigInt(bits[i]);
        
        // Can we fit a 'B' tile?
        if (remainder >= b) {
            remainder -= b;
            quotient = (quotient << 1n) | 1n;
        } else {
            quotient = (quotient << 1n);
        }
    }
    return quotient;
}

function runOp(op) {
    try {
        const A = BigInt(document.getElementById('regA').value);
        const B = BigInt(document.getElementById('regB').value);
        let res = 0n;
        const start = performance.now();
        
        if(op === 'mul') res = holoMul(A, B);
        if(op === 'sq') res = holoSquare(A);
        if(op === 'sqrt') res = holoSqrt(A);
        if(op === 'div') res = holoDiv(A, B);
        
        const end = performance.now();
        
        log(`${op.toUpperCase()} Result: ${res.toString().substr(0,20)}...`, 'res');
        log(`Time: ${(end-start).toFixed(3)}ms`);
        document.getElementById('finalRes').innerText = res.toString();
        
    } catch(e) {
        log("Error: " + e.message, 'res');
    }
}
</script>
</body>
</html>
