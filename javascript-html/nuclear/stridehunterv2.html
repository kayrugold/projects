<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
<title>Stride Hunter v2.0 (The Extender)</title>
<script src="https://cdn.tailwindcss.com"></script>
<style>
  body { background-color: #050505; color: #e2e8f0; font-family: 'Courier New', monospace; padding: 10px; }
  .card { background: #111; border: 1px solid #333; border-radius: 12px; padding: 15px; box-shadow: 0 0 20px rgba(16, 185, 129, 0.1); }
  
  .input-group { margin-bottom: 12px; }
  label { display: block; color: #64748b; font-size: 0.7rem; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 4px; }
  input { width: 100%; background: #1e1e1e; border: 1px solid #333; color: #4ade80; padding: 12px; border-radius: 6px; font-weight:bold; font-size: 1.1rem; }
  input:focus { outline: none; border-color: #10b981; }

  .btn { width: 100%; padding: 16px; border-radius: 8px; font-weight: 900; cursor: pointer; text-transform: uppercase; margin-top: 10px; transition: all 0.2s; letter-spacing: 1px; }
  .btn-start { background: #059669; color: #fff; border: 1px solid #047857; }
  .btn-start:active { transform: scale(0.98); }
  .btn-stop { background: #ef4444; color: #fff; border: 1px solid #b91c1c; }

  .dashboard { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 20px; }
  .stat-box { background: #0f172a; padding: 12px; border-radius: 8px; border: 1px solid #1e293b; text-align: center; }
  .stat-val { font-size: 1.2rem; font-weight: bold; color: #fff; }
  .stat-label { font-size: 0.6rem; color: #94a3b8; text-transform: uppercase; margin-top: 4px; }

  .progress-container { margin-top: 20px; background: #1e293b; height: 6px; border-radius: 3px; overflow: hidden; position: relative; }
  .scanner-bar { position: absolute; width: 30%; height: 100%; background: #10b981; animation: scan 2s infinite linear; opacity: 0.5; }
  
  @keyframes scan { 
    0% { left: -30%; } 
    100% { left: 130%; } 
  }

  #log { margin-top: 15px; height: 150px; overflow-y: auto; background: #000; border: 1px solid #333; padding: 10px; font-size: 0.75rem; color: #9ca3af; white-space: pre-wrap; border-radius: 6px; }
  .highlight { color: #facc15; font-weight: bold; }
  .safe { color: #4ade80; }
  .danger { color: #ef4444; font-weight: bold; }
</style>
</head>
<body>

<div class="card">
  <h2 class="text-xl font-black text-center text-emerald-500 tracking-tight mb-1">STRIDE HUNTER v2.0</h2>
  <p class="text-center text-xs text-gray-600 mb-6">INDEX EXTENSION ENGINE</p>

  <div class="input-group">
    <label>Target Exponent (10^X)</label>
    <input id="inpExp" value="1000000000" type="number">
  </div>
  <div class="grid grid-cols-2 gap-3 mb-2">
    <div>
      <label>Add Constant (+C)</label>
      <input id="inpAdd" value="61" type="number">
    </div>
    <div>
      <label>Odometer Start</label>
      <input id="inpStart" value="10000000000" type="number">
    </div>
  </div>

  <button id="btnRun" class="btn btn-start" onclick="startEngine()">Start Engine</button>
  <button id="btnStop" class="btn btn-stop hidden" onclick="stopEngine()">Brake</button>

  <div class="progress-container">
    <div id="scanEffect" class="scanner-bar hidden"></div>
  </div>

  <div class="dashboard">
    <div class="stat-box">
      <div id="statCurrent" class="stat-val text-emerald-400">0</div>
      <div class="stat-label">Current Mile (Prime)</div>
    </div>
    <div class="stat-box">
      <div id="statSpeed" class="stat-val text-blue-400">0</div>
      <div class="stat-label">Primes / Sec</div>
    </div>
  </div>

  <div id="log">System Ready.
Parked at: 10,000,000,000
Waiting to extend route...</div>
</div>

<script>
const workerCode = `
self.onmessage = function(e) {
    const { expStr, addStr, startStr } = e.data;
    
    const ONE = 1n;
    const TWO = 2n;
    
    // 1. Build Target Index (The Coordinate)
    // N = 10^Exp + Add
    // Index = (N + 1) / 2
    
    postMessage({type:'log', msg:'Constructing Target Index...'});
    
    try {
        const EXP = BigInt(expStr); // Too big for number, keep as string/BigInt logic
        const ADD = BigInt(addStr);
        
        // We can't actually do 10^1000000000 directly easily, BUT
        // For modulo operations, we don't need the full number.
        // We can compute (10^Exp + Add + 1)/2 MOD P for each prime P.
        // Wait, "Index Stride" logic is: I = (N+1)/2.
        // Check: I % P === (P+1)/2 ?
        
        // Let's refine the "Fast Math":
        // Condition for Composite: N % P === 0
        // Equivalent Index Condition: I % P === (P+1)/2
        // We will calculate (10^Exp + Add) % P directly. It's cleaner.
        // If (10^Exp + Add) % P === 0, then we found a factor.
        
        // SETUP SIEVE FOR GENERATING PRIMES
        // We need to generate primes starting at 'startStr'
        let currentStart = parseInt(startStr);
        const chunkSize = 200000; // Generate primes in chunks
        
        // Helper to perform modular exponentiation for 10^Exp % P
        function modPow10(expStr, m) {
            let res = 1n;
            let base = 10n % m;
            let exp = BigInt(expStr);
            
            // Standard square-and-multiply
            while(exp > 0n) {
                if(exp & 1n) res = (res * base) % m;
                base = (base * base) % m;
                exp >>= 1n;
            }
            return res;
        }

        // Initialize Base Primes for Sieving (up to sqrt(Start+Chunk))
        // Start ~ 10^10, so we need primes up to 10^5 (100,000)
        // Sieve of Eratosthenes for base primes
        const limit = 200000; 
        const sieve = new Uint8Array(limit + 1);
        const basePrimes = [];
        for (let i = 2; i <= limit; i++) {
            if (sieve[i] === 0) {
                basePrimes.push(i);
                for (let j = i * i; j <= limit; j += i) sieve[j] = 1;
            }
        }
        
        postMessage({type:'log', msg:\`Base Sieve Ready. Starting Search at \${currentStart}...\`});

        let totalChecked = 0;
        let t0 = performance.now();

        // MAIN LOOP
        while (true) {
            // 1. Sieve the next chunk
            const chunkEnd = currentStart + chunkSize;
            const rangeSieve = new Uint8Array(chunkSize);
            
            // Mark composites in range
            for (let p of basePrimes) {
                // Find first multiple of p >= currentStart
                let startMultiple = Math.floor((currentStart + p - 1) / p) * p;
                if (startMultiple < p * p) startMultiple = p * p;
                
                let idx = startMultiple - currentStart;
                for (let j = idx; j < chunkSize; j += p) {
                    rangeSieve[j] = 1;
                }
            }
            
            // 2. Scan the chunk for primes
            for (let i = 0; i < chunkSize; i++) {
                if (rangeSieve[i] === 0) {
                    // FOUND A PRIME (P)
                    // "P" is the Stride Length.
                    let P = BigInt(currentStart + i);
                    
                    if (P < 3n) continue; // Skip 2

                    // STRIDE CHECK: Does 10^Exp + Add % P === 0?
                    // We use the "Fast Math" (Modular Exponentiation)
                    
                    // We need 10^Exp % P. 
                    // Since Exp is massive (10^9), we pass Exp as string or BigInt
                    const modP = modPow10(expStr, P);
                    const check = (modP + ADD) % P;
                    
                    if (check === 0n) {
                        // COLLISION!
                        postMessage({type:'found', prime: P.toString()});
                        return; // Stop worker
                    }
                    
                    totalChecked++;
                }
            }
            
            // Report Progress every chunk
            let t1 = performance.now();
            if (t1 - t0 > 1000) {
                postMessage({
                    type: 'prog', 
                    current: chunkEnd, 
                    count: totalChecked
                });
                totalChecked = 0;
                t0 = t1;
            }
            
            currentStart += chunkSize;
        }

    } catch(e) {
        postMessage({type:'error', msg:e.message});
    }
};
`;

let worker = null;

function log(msg, type='') {
    const l = document.getElementById('log');
    let c = type === 'hit' ? 'danger' : (type === 'good' ? 'safe' : '');
    l.innerHTML += `<div class="${c}">> ${msg}</div>`;
    l.scrollTop = l.scrollHeight;
}

function startEngine() {
    const exp = document.getElementById('inpExp').value;
    const add = document.getElementById('inpAdd').value;
    const start = document.getElementById('inpStart').value;

    if(worker) worker.terminate();

    document.getElementById('btnRun').classList.add('hidden');
    document.getElementById('btnStop').classList.remove('hidden');
    document.getElementById('scanEffect').classList.remove('hidden');
    document.getElementById('log').innerHTML = '';
    
    log(`ENGINE START.`);
    log(`Target: 10^${exp} + ${add}`);
    log(`Odometer: ${parseInt(start).toLocaleString()}`);
    log(`Strategy: Extended Stride Check`);

    const blob = new Blob([workerCode], {type: 'application/javascript'});
    worker = new Worker(URL.createObjectURL(blob));

    worker.onmessage = function(e) {
        const d = e.data;
        if(d.type === 'log') log(d.msg);
        if(d.type === 'prog') {
            document.getElementById('statCurrent').textContent = d.current.toLocaleString();
            document.getElementById('statSpeed').textContent = d.count.toLocaleString();
        }
        if(d.type === 'found') {
            document.getElementById('statCurrent').classList.remove('text-emerald-400');
            document.getElementById('statCurrent').classList.add('text-red-500');
            document.getElementById('scanEffect').classList.add('hidden');
            log(`CRITICAL HIT! Factor Found: ${d.prime}`, 'hit');
            log(`The number is COMPOSITE.`, 'hit');
            log(`Stride Logic confirms collision at ${d.prime}.`);
            stopEngine();
        }
        if(d.type === 'error') log("ERROR: " + d.msg, 'hit');
    };

    worker.postMessage({
        expStr: exp, 
        addStr: add, 
        startStr: start
    });
}

function stopEngine() {
    if(worker) worker.terminate();
    worker = null;
    document.getElementById('btnRun').classList.remove('hidden');
    document.getElementById('btnStop').classList.add('hidden');
    document.getElementById('scanEffect').classList.add('hidden');
    log("Engine Stopped.");
}
</script>
</body>
</html>

