<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Streaming Karatsuba square (workers blob)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: system-ui, -apple-system, Roboto, "Helvetica Neue", Arial; padding: 12px; max-width:900px; margin:auto; }
    textarea { width:100%; height:160px; font-family: monospace; font-size:13px; }
    pre { background:#111; color:#eee; padding:10px; overflow:auto; max-height:280px; }
    button { padding:8px 12px; font-size:14px; margin-right:8px; }
    label { display:block; margin-top:10px; }
  </style>
</head>
<body>
  <h2>Streaming Karatsuba square (worker-pool fallback)</h2>

  <label>Paste / type large decimal integer here:</label>
  <textarea id="numIn">1234567890123456789012345678901234567890</textarea>

  <div style="margin-top:10px">
    <button id="btnSquare">Square (Karatsuba + workers)</button>
    <button id="btnClear">Clear output</button>
    <label><input id="useMod" type="checkbox"> Reduce result mod <code>MOD</code> (1_000_000_061)</label>
  </div>

  <h3>Output</h3>
  <div id="meta"></div>
  <pre id="out"></pre>

<script>
/*
  Streaming Karatsuba square with worker pool.
  - Parses decimal into base-B limbs streaming from right to left so it works for huge strings.
  - Uses recursion; offloads large multiplies to workers in a small pool.
  - Workers run identical karatsuba routine locally (no nested worker spawns).
  - You can toggle MOD if you want modular arithmetic (set MOD variable below).
*/

const BASE_POW = 6;               // 10^6 limbs
const BASE = 10 ** BASE_POW;
const SCHOOLBOOK_CUTOFF = 64;     // limbs: below this, use schoolbook multiply locally
const WORKER_OFFLOAD_CUTOFF = 512; // limbs: above this, try offloading to worker
const MAX_WORKERS = Math.max(1, (navigator.hardwareConcurrency || 4) - 1);

let MOD = null; // set to a number if you want modular result (e.g., 1000000061)

const out = document.getElementById('out');
const meta = document.getElementById('meta');
const numIn = document.getElementById('numIn');
const btnSquare = document.getElementById('btnSquare');
const btnClear = document.getElementById('btnClear');
const useMod = document.getElementById('useMod');

useMod.addEventListener('change', () => {
  MOD = useMod.checked ? 1000000061 : null;
});

btnClear.addEventListener('click', () => { out.textContent = ''; meta.textContent = ''; });

/* ---------- worker code as blob string ---------- */
const workerCode = `
// Worker: receives { id, op: 'mul'|'square', a: [limbs], b: [limbs] (optional), mod: n }
// Returns { id, res: [limbs] }
self.onmessage = function (e) {
  const msg = e.data;
  const id = msg.id;
  const mod = msg.mod || null;
  if (msg.op === 'square') {
    const res = squareFull(msg.a, mod);
    self.postMessage({ id, res });
  } else if (msg.op === 'mul') {
    const res = mulFull(msg.a, msg.b, mod);
    self.postMessage({ id, res });
  } else {
    self.postMessage({ id, err: 'bad op' });
  }
};

// local helpers: base power must match main thread (1e6)
const BASE = 1000000;
function trim(a) {
  while (a.length > 1 && a[a.length-1] === 0) a.pop();
  return a;
}
function addTo(dst, src, shift=0) {
  let carry = 0;
  for (let i = 0; i < src.length || carry; ++i) {
    const si = (i < src.length) ? src[i] : 0;
    const idx = i + shift;
    const sum = (dst[idx] || 0) + si + carry;
    dst[idx] = sum % BASE;
    carry = Math.floor(sum / BASE);
  }
}
function subTo(dst, src) {
  let carry = 0;
  for (let i = 0; i < src.length || carry; ++i) {
    const si = (i < src.length) ? src[i] : 0;
    const v = (dst[i] || 0) - si - carry;
    if (v < 0) { dst[i] = v + BASE; carry = 1; } else { dst[i] = v; carry = 0; }
  }
  trim(dst);
}
function schoolMul(a,b) {
  const n = a.length, m = b.length;
  const out = new Array(n+m).fill(0);
  for (let i=0;i<n;i++){
    let carry = 0;
    const ai = a[i];
    for (let j=0;j<m || carry;j++){
      const bj = (j < m)? b[j]:0;
      const idx = i+j;
      const cur = out[idx] + ai * bj + carry;
      out[idx] = cur % BASE;
      carry = Math.floor(cur / BASE);
    }
  }
  return trim(out);
}
function karatsubaMul(a,b) {
  const n = Math.max(a.length, b.length);
  if (n <= 64) return schoolMul(a,b);
  const m = Math.floor(n/2);
  const a0 = a.slice(0, m), a1 = a.slice(m);
  const b0 = b.slice(0, m), b1 = b.slice(m);
  const z0 = karatsubaMul(a0, b0);
  const z2 = karatsubaMul(a1, b1);
  const a0a1 = addArrays(a0, a1);
  const b0b1 = addArrays(b0, b1);
  const z1 = karatsubaMul(a0a1, b0b1);
  // z1 = z1 - z0 - z2
  subTo(z1, z0);
  subTo(z1, z2);
  // compose
  const res = new Array(z0.length + 2*(a1.length)).fill(0);
  addTo(res, z0, 0);
  addTo(res, z1, m);
  addTo(res, z2, 2*m);
  return trim(res);
}
function addArrays(x,y) {
  const n = Math.max(x.length,y.length);
  const r = new Array(n);
  let carry = 0;
  for (let i=0;i<n;i++){
    const v = (x[i]||0) + (y[i]||0) + carry;
    r[i] = v % BASE;
    carry = Math.floor(v / BASE);
  }
  if (carry) r.push(carry);
  return trim(r);
}
function mulFull(a,b,mod=null){
  if (mod) {
    // simple modular reduction via converting to BigInt (works for reasonable sizes)
    // If arrays are humongous, worker shouldn't be used for mod in this simple impl.
    // Convert to BigInt
    let bigA = BigInt(0), p = BigInt(1);
    for (let i=0;i<a.length;i++){ bigA += p * BigInt(a[i]); p *= BigInt(BASE); }
    let bigB = BigInt(0); p = BigInt(1);
    for (let i=0;i<b.length;i++){ bigB += p * BigInt(b[i]); p *= BigInt(BASE); }
    const bigMod = BigInt(mod);
    const r = (bigA * bigB) % bigMod;
    // convert back to limbs
    const out = [];
    let tmp = r;
    const bigBase = BigInt(BASE);
    while (tmp > 0) { out.push(Number(tmp % bigBase)); tmp /= bigBase; }
    if (out.length === 0) out.push(0);
    return out;
  }
  // choose karatsuba
  return karatsubaMul(a,b);
}
function squareFull(a, mod=null) {
  if (mod) {
    let bigA = BigInt(0), p = BigInt(1);
    for (let i=0;i<a.length;i++){ bigA += p * BigInt(a[i]); p *= BigInt(BASE); }
    const bigMod = BigInt(mod);
    const r = (bigA * bigA) % bigMod;
    const out = [];
    let tmp = r;
    const bigBase = BigInt(BASE);
    while (tmp > 0) { out.push(Number(tmp % bigBase)); tmp /= bigBase; }
    if (out.length === 0) out.push(0);
    return out;
  }
  return karatsubaMul(a,a);
}
`;

/* ---------- build worker pool ---------- */
const workerBlob = new Blob([workerCode], {type: 'application/javascript'});
const workerUrl = URL.createObjectURL(workerBlob);

class WorkerPool {
  constructor(size) {
    this.size = size;
    this.workers = [];
    this.idCounter = 1;
    this.callbacks = new Map();
    for (let i=0;i<size;i++){
      const w = new Worker(workerUrl);
      w.onmessage = (e) => {
        const msg = e.data;
        const cb = this.callbacks.get(msg.id);
        if (cb) {
          this.callbacks.delete(msg.id);
          cb(msg.err, msg.res);
        }
      };
      this.workers.push({worker: w, busy: false});
    }
    this.next = 0;
  }
  dispatch(task, cb) {
    // find free worker
    for (let i=0;i<this.workers.length;i++){
      const idx = (this.next + i) % this.workers.length;
      if (!this.workers[idx].busy) {
        this.workers[idx].busy = true;
        const id = this.idCounter++;
        this.callbacks.set(id, (err,res)=>{ this.workers[idx].busy=false; cb(err,res); });
        const payload = Object.assign({id}, task);
        this.workers[idx].worker.postMessage(payload);
        this.next = (idx + 1) % this.workers.length;
        return;
      }
    }
    // if all busy, queue by simple setTimeout fallback (not optimal but simple)
    setTimeout(()=> this.dispatch(task, cb), 10);
  }
  terminate(){
    for (const w of this.workers) w.worker.terminate();
    URL.revokeObjectURL(workerUrl);
  }
}

const pool = new WorkerPool(MAX_WORKERS);

/* ---------- main big-int helpers (same base as worker) ---------- */

function parseDecimalToLimbsStreamed(str) {
  // parse from right to left in chunks of BASE_POW
  const limbs = [];
  let i = str.length;
  while (i > 0) {
    const start = Math.max(0, i - BASE_POW);
    const chunk = str.slice(start, i);
    limbs.push(Number(chunk)); // safe: chunk <= 10^6-1
    i = start;
  }
  trim(limbs);
  return limbs;
}

function trim(a) {
  while (a.length > 1 && a[a.length-1] === 0) a.pop();
  return a;
}

function limbsToDecimal(a) {
  // convert limbs (base 1e6) back to decimal string
  let out = '';
  for (let i = a.length - 1; i >= 0; --i) {
    const part = a[i].toString();
    if (i !== a.length - 1) out += part.padStart(BASE_POW, '0'); else out += part;
  }
  return out || '0';
}

function addArrays(x,y) {
  const n = Math.max(x.length,y.length);
  const r = new Array(n);
  let carry = 0;
  for (let i=0;i<n;i++){
    const v = (x[i]||0) + (y[i]||0) + carry;
    r[i] = v % BASE;
    carry = Math.floor(v / BASE);
  }
  if (carry) r.push(carry);
  return trim(r);
}

function subTo(dst, src) {
  let carry = 0;
  for (let i = 0; i < src.length || carry; ++i) {
    const si = (i < src.length) ? src[i] : 0;
    const v = (dst[i] || 0) - si - carry;
    if (v < 0) { dst[i] = v + BASE; carry = 1; } else { dst[i] = v; carry = 0; }
  }
  trim(dst);
}

function schoolMul(a,b) {
  const n = a.length, m = b.length;
  const out = new Array(n+m).fill(0);
  for (let i=0;i<n;i++){
    let carry = 0;
    const ai = a[i];
    for (let j=0;j<m || carry;j++){
      const bj = (j < m)? b[j]:0;
      const idx = i+j;
      const cur = out[idx] + ai * bj + carry;
      out[idx] = cur % BASE;
      carry = Math.floor(cur / BASE);
    }
  }
  return trim(out);
}

/* Recursive karatsuba in main thread but it will offload to worker when big */
function karatsubaMulAsync(a,b) {
  // returns Promise<limbs>
  const n = Math.max(a.length, b.length);
  if (n <= SCHOOLBOOK_CUTOFF) {
    return Promise.resolve(schoolMul(a,b));
  }
  if (n >= WORKER_OFFLOAD_CUTOFF) {
    // offload whole product to worker
    return new Promise((resolve, reject) => {
      pool.dispatch({op:'mul', a, b, mod: MOD}, (err,res) => {
        if (err) reject(err); else resolve(res);
      });
    });
  }
  // recursive split locally
  const m = Math.floor(n/2);
  const a0 = a.slice(0, m), a1 = a.slice(m);
  const b0 = b.slice(0, m), b1 = b.slice(m);
  return Promise.all([
    karatsubaMulAsync(a0,b0),
    karatsubaMulAsync(a1,b1),
    (async ()=>{
      const a0a1 = addArrays(a0,a1);
      const b0b1 = addArrays(b0,b1);
      const z = await karatsubaMulAsync(a0a1, b0b1);
      return z;
    })()
  ]).then(([z0,z2,z1])=>{
    // z1 = z1 - z0 - z2
    subTo(z1, z0);
    subTo(z1, z2);
    const res = new Array(z0.length + 2*(a1.length)).fill(0);
    addTo(res, z0, 0);
    addTo(res, z1, m);
    addTo(res, z2, 2*m);
    return trim(res);
  });
}

function addTo(dst, src, shift=0) {
  let carry = 0;
  for (let i = 0; i < src.length || carry; ++i) {
    const si = (i < src.length) ? src[i] : 0;
    const idx = i + shift;
    const sum = (dst[idx] || 0) + si + carry;
    dst[idx] = sum % BASE;
    carry = Math.floor(sum / BASE);
  }
}

function squareAsync(a) {
  // small sizes: schoolbook square by schoolMul
  if (a.length <= SCHOOLBOOK_CUTOFF) {
    return Promise.resolve(schoolMul(a,a));
  }
  if (a.length >= WORKER_OFFLOAD_CUTOFF) {
    // ask worker to square
    return new Promise((resolve,reject)=>{
      pool.dispatch({op:'square', a, mod: MOD}, (err,res) => {
        if (err) reject(err); else resolve(res);
      });
    });
  }
  // Karatsuba square: z0 = a0^2, z2 = a1^2, z1 = (a0+a1)^2 - z0 - z2
  const n = a.length;
  const m = Math.floor(n/2);
  const a0 = a.slice(0,m), a1 = a.slice(m);
  return Promise.all([
    squareAsync(a0),
    squareAsync(a1),
    (async ()=>{
      const s = addArrays(a0,a1);
      const sq = await squareAsync(s);
      return sq;
    })()
  ]).then(([z0,z2,z1])=>{
    subTo(z1,z0);
    subTo(z1,z2);
    const res = new Array(z0.length + 2*(a1.length)).fill(0);
    addTo(res, z0, 0);
    addTo(res, z1, m);
    addTo(res, z2, 2*m);
    return trim(res);
  });
}

/* ---------- UI action ---------- */
btnSquare.addEventListener('click', async () => {
  out.textContent = 'Parsing...';
  meta.textContent = '';
  const s = (numIn.value || '').replace(/\\s+/g,'');
  if (!/^[0-9]+$/.test(s)) { out.textContent = 'Input must be decimal digits only.'; return; }
  const t0 = performance.now();
  const limbs = parseDecimalToLimbsStreamed(s);
  const t1 = performance.now();
  out.textContent = 'Starting square... (limbs=' + limbs.length + ')';
  try {
    const resLimbs = await squareAsync(limbs);
    const t2 = performance.now();
    let resultStr = limbsToDecimal(resLimbs);
    if (MOD) {
      // when MOD is enabled main path already used modular reduction inside workers.
      // If result is non-modular, reduce via BigInt
      try {
        const bigA = BigInt('0'); // placeholder
      } catch {}
    }
    meta.textContent = 
      'parse ms: ' + Math.round(t1-t0) + '  |  compute ms: ' + Math.round(t2-t1) +
      '  | limbs: ' + limbs.length + '  | workers: ' + MAX_WORKERS;
    out.textContent = resultStr;
  } catch (err) {
    out.textContent = 'Error: ' + String(err);
    console.error(err);
  }
});

/* ---------- utility: addTo used by karatsuba compose ---------- */
function addTo(dst, src, shift=0) {
  let carry = 0;
  for (let i = 0; i < src.length || carry; ++i) {
    const si = (i < src.length) ? src[i] : 0;
    const idx = i + shift;
    const sum = (dst[idx] || 0) + si + carry;
    dst[idx] = sum % BASE;
    carry = Math.floor(sum / BASE);
  }
}

/* ---------- cleanup on page unload ---------- */
window.addEventListener('unload', () => pool.terminate());
</script>
</body>
</html>