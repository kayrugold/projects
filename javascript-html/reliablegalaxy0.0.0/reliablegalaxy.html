<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Reliable Galaxy — Shader Particles + Worker</title>

<!-- libs -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://unpkg.com/big-integer@1.6.48/BigInteger.min.js"></script>

<style>
:root{
  --bg:#050510; --ui-bg:rgba(18,18,34,0.88); --panel-border:#404060;
  --highlight:#00aaff; --factor:#ffee00; --prime:#ff66ff; --semiprime:#66ffff; --composite:#bfbfbf; --selected:#ff8800;
}
html,body{height:100%;margin:0;background:var(--bg);font-family:system-ui,Segoe UI,Roboto,Arial;color:#e6e6f2;overflow:hidden}
canvas#galaxyCanvas{position:fixed;left:0;top:0;width:100%;height:100%;display:block;outline:none}
.ui-panel{position:fixed;left:10px;right:10px;background:var(--ui-bg);backdrop-filter:blur(6px);border-radius:12px;border:1px solid var(--panel-border);padding:10px;box-sizing:border-box}
#controlsPanel{top:10px}
#infoPanel{bottom:10px;max-height:48%;overflow:hidden;display:none}
#infoHeader{display:flex;align-items:center;justify-content:space-between;padding:6px 8px}
#infoContent{padding:8px}
button{background:var(--highlight);border:none;padding:10px 12px;border-radius:8px;color:white;font-weight:600;cursor:pointer}
button:disabled{opacity:.45;cursor:not-allowed}
.close-btn{background:transparent;border-radius:6px;border:1px solid rgba(255,255,255,0.06);padding:6px 8px;color:#eee;cursor:pointer}
#status{font-size:13px;color:#88a;text-align:center;margin-top:6px}
.tooltip{position:fixed;padding:6px 8px;background:rgba(0,0,0,0.75);color:#fff;border-radius:6px;pointer-events:none;transform:translate(-50%,-120%);display:none;z-index:9999;font-size:13px}
input[type="text"]{width:100%;padding:8px;border-radius:6px;border:1px solid #2b2b44;background:#0f1222;color:#eaf0ff}
.small{font-size:13px;color:#bfc7d8}
</style>
</head>
<body>
<canvas id="galaxyCanvas"></canvas>

<div id="controlsPanel" class="ui-panel">
  <div style="display:flex;gap:12px;align-items:flex-end;">
    <div style="flex:1;">
      <label class="small">Target Number (N)</label>
      <input id="targetInput" type="text" value="1007" placeholder="e.g., 1007 or 2^67-1" />
    </div>
    <div style="width:160px;">
      <button id="illuminateBtn">Illuminate Starfactors</button>
    </div>
    <div style="width:120px;">
      <button id="regenBtn" class="small">Regenerate</button>
    </div>
  </div>
  <div id="status" class="small">Initializing...</div>
</div>

<div id="infoPanel" class="ui-panel">
  <div id="infoHeader">
    <strong id="infoPanelTitle">Star Analysis</strong>
    <div style="display:flex;gap:8px;align-items:center">
      <button id="infoClose" class="close-btn">Close</button>
    </div>
  </div>
  <div id="infoContent"></div>
</div>

<div id="tooltip" class="tooltip"></div>

<script>
/* ========= CONFIG ========= */
const STAR_COUNT = 3000;                 // change to taste
const CANVAS = document.getElementById('galaxyCanvas');
const ui = {
  illuminateBtn: document.getElementById('illuminateBtn'),
  regenBtn: document.getElementById('regenBtn'),
  targetInput: document.getElementById('targetInput'),
  statusDiv: document.getElementById('status'),
  infoPanel: document.getElementById('infoPanel'),
  infoClose: document.getElementById('infoClose'),
  infoPanelTitle: document.getElementById('infoPanelTitle'),
  infoContent: document.getElementById('infoContent'),
  tooltip: document.getElementById('tooltip')
};

/* ========= Parsing (safe, returns bigInt object) ========= */
function parseInputExpression(str) {
  const s = String(str).trim();
  if (!s) return null;
  // common patterns
  const proth = /^(\d+)\*2\^(\d+)\+1$/i;
  const mersenne = /^2\^(\d+)-1$/i;
  const power = /^(\d+)\^(\d+)([+-]\d+)?$/i;
  const sci = /^(\d+(?:\.\d+)?)e(\d+)$/i;
  let m;
  if ((m = s.match(proth))) {
    const k = bigInt(m[1]); const n = bigInt(m[2]);
    return k.multiply(bigInt(2).pow(n)).plus(1);
  }
  if ((m = s.match(mersenne))) {
    return bigInt(2).pow(bigInt(m[1])).minus(1);
  }
  if ((m = s.match(power))) {
    const a = bigInt(m[1]), b = bigInt(m[2]), add = m[3] ? bigInt(m[3]) : bigInt.zero;
    return a.pow(b).add(add);
  }
  if ((m = s.match(sci))) {
    const coeff = Number(m[1]), exp = Number(m[2]);
    if (coeff === 1) return bigInt(10).pow(bigInt(exp));
    // otherwise fallback to numeric when safe
    return bigInt(Math.round(coeff * Math.pow(10, exp)));
  }
  try { return bigInt(s); } catch (e) { return null; }
}

/* ========= THREE.js + Shader Particle Setup ========= */
let scene, camera, renderer, controls;
let particleSystem, geometry;
let positionArray, colorArray, sizeArray;
let starsData = new Array(STAR_COUNT);
let hitTargets = []; // raycastable meshes
let raycaster = new THREE.Raycaster();
let lastSelectedIndex = null;
let targetBig = bigInt.zero;

// Colors from CSS variables
function cssColorToThree(varName, fallback='#ffffff'){
  const v = getComputedStyle(document.body).getPropertyValue(varName) || fallback;
  return new THREE.Color(v.trim() || fallback);
}
const PRIME_COLOR = cssColorToThree('--prime-color','#ff66ff');
const SEMI_COLOR = cssColorToThree('--semiprime-color','#66ffff');
const COMP_COLOR = cssColorToThree('--composite-color','#bfbfbf');
const FACTOR_COLOR = cssColorToThree('--factor-color','#ffee00');
const SELECTED_COLOR = cssColorToThree('--selected-color','#ff8800');
const HIGHLIGHT = cssColorToThree('--highlight','#00aaff');

function initThree() {
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 1, 5000);
  camera.position.set(0, 220, 700);

  renderer = new THREE.WebGLRenderer({ canvas: CANVAS, antialias: true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));
  renderer.setSize(window.innerWidth, window.innerHeight);

  // geometry attributes
  geometry = new THREE.BufferGeometry();
  positionArray = new Float32Array(STAR_COUNT * 3);
  colorArray = new Float32Array(STAR_COUNT * 3);
  sizeArray = new Float32Array(STAR_COUNT);

  geometry.setAttribute('position', new THREE.BufferAttribute(positionArray, 3));
  geometry.setAttribute('aColor', new THREE.BufferAttribute(colorArray, 3));
  geometry.setAttribute('aSize', new THREE.BufferAttribute(sizeArray, 1));

  // shader material (soft sprite / glow)
  const vertexShader = `
    attribute vec3 aColor;
    attribute float aSize;
    varying vec3 vColor;
    varying float vSize;
    void main(){
      vColor = aColor;
      vSize = aSize;
      vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
      // scale point size by camera distance for nicer look
      float size = aSize * (300.0 / -mvPosition.z);
      gl_PointSize = clamp(size, 2.0, 180.0);
      gl_Position = projectionMatrix * mvPosition;
    }
  `;
  const fragmentShader = `
    varying vec3 vColor;
    varying float vSize;
    void main(){
      // radial gradient in point coord
      vec2 uv = gl_PointCoord.xy - vec2(0.5);
      float dist = length(uv);
      // soft circular falloff
      float alpha = smoothstep(0.5, 0.0, dist);
      // rim for glow
      float rim = smoothstep(0.6, 0.4, dist);
      vec3 col = vColor;
      // make center brighter
      col += 0.6 * vColor * (1.0 - dist);
      // output with additive blending (set in material)
      gl_FragColor = vec4(col, alpha * 0.9);
      // small softening
      gl_FragColor.rgb *= gl_FragColor.a;
    }
  `;

  const mat = new THREE.ShaderMaterial({
    vertexShader, fragmentShader,
    transparent: true,
    depthTest: true,
    blending: THREE.AdditiveBlending,
    vertexColors: true
  });

  particleSystem = new THREE.Points(geometry, mat);
  scene.add(particleSystem);

  // orbit controls
  controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.08;
  controls.screenSpacePanning = true;
  controls.minDistance = 40;
  controls.maxDistance = 4000;

  window.addEventListener('resize', onResize, { passive: true });
}

/* ========= Generate starfield (progressive chunks) ========= */
function generateStarfield() {
  ui.statusDiv.textContent = 'Generating starfield...';
  ui.illuminateBtn.disabled = true;
  ui.regenBtn.disabled = true;

  // Clear existing hitTargets if re-gen
  for (const m of hitTargets) if (m.parent) scene.remove(m);
  hitTargets = [];

  // We'll place stars in a nice spiral/archimedean pattern
  let idx = 0;
  const CHUNK = 200;

  // hit material - visible true but fully transparent so raycaster works
  const hitMat = new THREE.MeshBasicMaterial({ visible: true, transparent: true, opacity: 0.0 });

  function genChunk(){
    const end = Math.min(idx + CHUNK, STAR_COUNT);
    for (; idx < end; idx++){
      const nNum = idx + 1;
      // spiral coordinates
      const t = idx + 5;
      const angle = 0.12 * Math.sqrt(t) * Math.PI;
      const radius = 6 * Math.sqrt(t);
      const x = Math.cos(angle) * radius;
      const z = Math.sin(angle) * radius;
      const y = 0; // will be updated by factor-count

      positionArray[idx*3] = x;
      positionArray[idx*3 + 1] = y;
      positionArray[idx*3 + 2] = z;

      // base size and color placeholder
      sizeArray[idx] = 6 + (Math.random() * 6);

      colorArray[idx*3] = COMP_COLOR.r;
      colorArray[idx*3+1] = COMP_COLOR.g;
      colorArray[idx*3+2] = COMP_COLOR.b;

      starsData[idx] = { number: String(nNum), factorCount: -1 };

      // add hit sphere for robust picking (generous radius)
      const sphereGeo = new THREE.SphereGeometry(14, 8, 8);
      const m = new THREE.Mesh(sphereGeo, hitMat);
      m.position.set(x, y, z);
      m.userData = { index: idx, number: String(nNum) };
      scene.add(m);
      hitTargets.push(m);
    }

    geometry.attributes.position.needsUpdate = true;
    geometry.attributes.aColor.needsUpdate = true;
    geometry.attributes.aSize.needsUpdate = true;

    ui.statusDiv.textContent = `Generating starfield... ${Math.round((end/STAR_COUNT)*100)}%`;

    if (idx < STAR_COUNT) setTimeout(genChunk, 12);
    else {
      ui.statusDiv.textContent = 'Starfield ready. Computing factor counts in worker...';
      ui.illuminateBtn.disabled = false;
      ui.regenBtn.disabled = false;
      // start worker factoring after generation
      startWorkerFactorCounting();
    }
  }
  genChunk();
}

/* ========= Web Worker for factor counts =========
   Uses native BigInt inside worker. We send batches of indices (numbers as strings)
   and worker returns array of { index, factorCount }.
*/
let numberWorker = null;
function makeWorker() {
  const workerSrc = `
    self.onmessage = function(e){
      const { batch } = e.data;
      // factor function using BigInt
      function factorCount(nStr){
        try {
          let n = BigInt(nStr);
          if (n <= 1n) return 0;
          let count = 0n;
          let d = 2n;
          const LIMIT = 200000n; // tune for speed vs thoroughness
          while (d*d <= n && d <= LIMIT) {
            while (n % d === 0n) { count++; n /= d; }
            d++;
          }
          if (n > 1n) count++;
          return Number(count);
        } catch(err) { return -1; }
      }
      const out = [];
      for (let i=0;i<batch.length;i++){
        const { idx, nStr } = batch[i];
        const c = factorCount(nStr);
        out.push({ idx, c });
      }
      postMessage({ results: out });
    };
  `;
  const blob = new Blob([workerSrc], { type: 'application/javascript' });
  return new Worker(URL.createObjectURL(blob));
}

function startWorkerFactorCounting(){
  if (numberWorker) numberWorker.terminate();
  numberWorker = makeWorker();

  const BATCH = 300;
  let nextIndex = 0;

  numberWorker.onmessage = function(e){
    const { results } = e.data;
    for (const r of results){
      const i = r.idx;
      const fcount = r.c;
      if (!starsData[i]) continue;
      starsData[i].factorCount = fcount;
      // Y positions scale
      positionArray[i*3 + 1] = fcount * 6 - 30;
      // update hit target Y
      if (hitTargets[i]) hitTargets[i].position.y = positionArray[i*3+1];
      // color by complexity
      let c = COMP_COLOR;
      if (fcount === 1) c = PRIME_COLOR;
      else if (fcount === 2) c = SEMI_COLOR;
      colorArray[i*3] = c.r; colorArray[i*3+1] = c.g; colorArray[i*3+2] = c.b;
      // slight size tweak for primes / important items
      sizeArray[i] = (fcount === 1 ? 18 : (fcount === 2 ? 14 : (6 + Math.random()*6)));
    }

    geometry.attributes.position.needsUpdate = true;
    geometry.attributes.aColor.needsUpdate = true;
    geometry.attributes.aSize.needsUpdate = true;

    ui.statusDiv.textContent = `Factor counts processed: ${Math.min(nextIndex, STAR_COUNT)}/${STAR_COUNT}`;

    // schedule next batch
    if (nextIndex < STAR_COUNT) sendNextBatch();
    else ui.statusDiv.textContent = 'Factorization complete. Ready.';
  };

  function sendNextBatch() {
    const batch = [];
    for (let k=0; k<BATCH && nextIndex < STAR_COUNT; k++, nextIndex++){
      batch.push({ idx: nextIndex, nStr: starsData[nextIndex].number });
    }
    if (batch.length) numberWorker.postMessage({ batch });
  }
  sendNextBatch();
}

/* ========= Illumination: highlight divisors of target ========= */
function illuminateFactors() {
  ui.illuminateBtn.disabled = true;
  ui.statusDiv.textContent = 'Illuminating factors...';

  setTimeout(() => {
    const parsed = parseInputExpression(ui.targetInput.value);
    if (!parsed) {
      ui.statusDiv.textContent = 'Invalid number expression.';
      ui.illuminateBtn.disabled = false;
      return;
    }
    targetBig = parsed;

    // update colors/sizes
    for (let i=0;i<STAR_COUNT;i++){
      const st = starsData[i];
      if (!st) continue;
      let starN;
      try { starN = bigInt(st.number); } catch(e) { starN = bigInt.zero; }
      let isFactor = false;
      try {
        if (!targetBig.isZero() && targetBig.mod(starN).isZero()) isFactor = true;
      } catch(e) { isFactor = false; }
      if (isFactor) {
        colorArray[i*3] = FACTOR_COLOR.r; colorArray[i*3+1] = FACTOR_COLOR.g; colorArray[i*3+2] = FACTOR_COLOR.b;
        sizeArray[i] = 34; // make factors pop
        // also enlarge hit-sphere
        if (hitTargets[i]) hitTargets[i].scale.setScalar(1.6);
      } else {
        // restore base color from factorCount
        const fc = st.factorCount;
        const c = (fc === 1 ? PRIME_COLOR : (fc === 2 ? SEMI_COLOR : COMP_COLOR));
        colorArray[i*3] = c.r; colorArray[i*3+1] = c.g; colorArray[i*3+2] = c.b;
        sizeArray[i] = (fc === 1 ? 18 : (fc === 2 ? 14 : 6 + Math.random()*6));
        if (hitTargets[i]) hitTargets[i].scale.setScalar(1.0);
      }
    }
    geometry.attributes.aColor.needsUpdate = true;
    geometry.attributes.aSize.needsUpdate = true;

    ui.statusDiv.textContent = `Done. Factors of ${targetBig.toString()} are yellow.`;
    ui.illuminateBtn.disabled = false;
  }, 10);
}

/* ========= Picking (raycast) and info panel ========= */
function showInfoForIndex(i) {
  const st = starsData[i];
  if (!st) return;
  const number = st.number;
  const fcount = st.factorCount >= 0 ? st.factorCount : 'unknown';
  const isFactor = (!targetBig.isZero && !targetBig.isZero()) ? targetBig.mod(bigInt(number)).isZero() : false;

  ui.infoPanel.style.display = 'block';
  ui.infoPanelTitle.textContent = `Star Analysis: ${number}`;

  function smallFactors(nStr) {
    let n = bigInt(nStr);
    if (n.leq(1)) return "None";
    let fs = [];
    let d = bigInt(2);
    const limit = bigInt(1000);
    while (d.multiply(d).leq(n) && d.leq(limit)) {
      if (n.mod(d).isZero()) {
        fs.push(d.toString());
        while (n.mod(d).isZero()) n = n.divide(d);
      }
      d = d.next();
    }
    if (n.gt(1) && n.leq(limit)) fs.push(n.toString());
    return fs.length ? fs.join(', ') : 'None under 1000';
  }

  ui.infoContent.innerHTML = `
    <div><strong>Complexity (Ω):</strong> ${fcount}</div>
    <div><strong>Type:</strong> ${fcount === 1 ? 'Prime' : (fcount === 2 ? 'Semi-prime' : 'Composite')}</div>
    <div><strong>Small factors:</strong> ${smallFactors(number)}</div>
    <div><strong>Factor of ${targetBig.toString()}?</strong> <span style="color:${isFactor ? 'var(--factor-color)' : '#ddd'}">${isFactor ? 'Yes' : 'No'}</span></div>
    <div style="margin-top:6px;font-size:13px;color:#bfc7d8">Click close or click outside to hide.</div>
  `;
}

function handlePointerTap(clientX, clientY) {
  const rect = renderer.domElement.getBoundingClientRect();
  const ndcX = ((clientX - rect.left) / rect.width) * 2 - 1;
  const ndcY = -((clientY - rect.top) / rect.height) * 2 + 1;
  raycaster.setFromCamera({ x: ndcX, y: ndcY }, camera);

  const intersects = raycaster.intersectObjects(hitTargets, false);

  // restore previous selection if exists
  if (lastSelectedIndex !== null) {
    const prev = lastSelectedIndex;
    const st = starsData[prev];
    if (st) {
      // restore color from factorCount (unless it's a factor highlight)
      const fc = st.factorCount;
      let c = (fc === 1 ? PRIME_COLOR : (fc === 2 ? SEMI_COLOR : COMP_COLOR));
      // if currently global illumination highlighted this as factor, keep factor color
      try {
        if (!targetBig.isZero() && targetBig.mod(bigInt(st.number)).isZero()) c = FACTOR_COLOR;
      } catch(e){}
      colorArray[prev*3] = c.r; colorArray[prev*3+1] = c.g; colorArray[prev*3+2] = c.b;
      geometry.attributes.aColor.needsUpdate = true;
      if (hitTargets[prev]) hitTargets[prev].scale.setScalar(1.0);
    }
    lastSelectedIndex = null;
  }

  if (intersects.length > 0) {
    const idx = intersects[0].object.userData.index;
    lastSelectedIndex = idx;
    // mark selected visually
    colorArray[idx*3] = SELECTED_COLOR.r; colorArray[idx*3+1] = SELECTED_COLOR.g; colorArray[idx*3+2] = SELECTED_COLOR.b;
    geometry.attributes.aColor.needsUpdate = true;
    if (hitTargets[idx]) hitTargets[idx].scale.setScalar(1.6);
    showInfoForIndex(idx);
  } else {
    ui.infoPanel.style.display = 'none';
  }
}

/* pointer to tap detection */
CANVAS.addEventListener('pointerdown', (ev) => {
  CANVAS._ptrStart = { x: ev.clientX, y: ev.clientY, t: Date.now() };
});
CANVAS.addEventListener('pointerup', (ev) => {
  const s = CANVAS._ptrStart;
  if (!s) return;
  const dt = Date.now() - s.t;
  const dist = Math.hypot(ev.clientX - s.x, ev.clientY - s.y);
  if (dt < 300 && dist < 16) handlePointerTap(ev.clientX, ev.clientY);
  CANVAS._ptrStart = null;
});

/* hover tooltip */
CANVAS.addEventListener('pointermove', (ev) => {
  const rect = renderer.domElement.getBoundingClientRect();
  const ndcX = ((ev.clientX - rect.left) / rect.width) * 2 - 1;
  const ndcY = -((ev.clientY - rect.top) / rect.height) * 2 + 1;
  raycaster.setFromCamera({ x: ndcX, y: ndcY }, camera);
  const hits = raycaster.intersectObjects(hitTargets, false);
  if (hits.length > 0 && hits[0].distance < 2000) {
    const idx = hits[0].object.userData.index;
    ui.tooltip.style.left = `${ev.clientX}px`;
    ui.tooltip.style.top = `${ev.clientY - 12}px`;
    ui.tooltip.textContent = starsData[idx].number;
    ui.tooltip.style.display = 'block';
  } else {
    ui.tooltip.style.display = 'none';
  }
});

/* click outside to close info panel */
window.addEventListener('pointerdown', (e) => {
  if (ui.infoPanel.style.display === 'block') {
    if (!ui.infoPanel.contains(e.target)) ui.infoPanel.style.display = 'none';
  }
});
ui.infoClose.addEventListener('click', () => { ui.infoPanel.style.display = 'none'; });

/* ========= Animation loop ========= */
function animate() {
  requestAnimationFrame(animate);
  if (controls) controls.update();
  // gentle rotation for effect
  particleSystem.rotation.y += 0.0006;
  renderer.render(scene, camera);
}
function onResize() {
  renderer.setSize(window.innerWidth, window.innerHeight);
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
}

/* ========= UI wiring ========= */
ui.illuminateBtn.addEventListener('click', illuminateFactors);
ui.targetInput.addEventListener('keyup', (e) => { if (e.key === 'Enter') illuminateFactors(); });
ui.regenBtn.addEventListener('click', () => {
  // regenerate starfield (useful during tweaking)
  generateStarfield();
});

/* ========= Kickoff ========= */
initThree();
generateStarfield();
animate();
ui.statusDiv.textContent = 'Generating...';

/* Safety: free worker on unload */
window.addEventListener('beforeunload', () => { if (numberWorker) numberWorker.terminate(); });

</script>
</body>
</html>
