<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Geometric Galaxy Explorer</title>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://unpkg.com/big-integer@1.6.48/BigInteger.min.js"></script>

<style>
:root{
  --bg:#050510; --ui-bg:rgba(18,18,34,0.88); --panel-border:#404060;
  --highlight:#00aaff; --factor:#ffee00; --prime:#ff66ff; --semiprime:#66ffff; --composite:#bfbfbf; --selected:#ff8800;
}
html,body{height:100%;margin:0;background:var(--bg);font-family:system-ui,Segoe UI,Roboto,Arial;color:#e6e6f2;overflow:hidden; touch-action: none;}
canvas#galaxyCanvas{position:fixed;left:0;top:0;width:100%;height:100%;display:block;outline:none; cursor: grab;}
canvas#galaxyCanvas:active { cursor: grabbing; }
.ui-panel{position:fixed;left:10px;right:10px;background:var(--ui-bg);backdrop-filter:blur(6px);border-radius:12px;border:1px solid var(--panel-border);padding:10px 15px;box-sizing:border-box}
#controlsPanel{top:10px}
#infoPanel{bottom:10px;max-height:55%;overflow:hidden;display:none}
#infoHeader{display:flex;align-items:center;justify-content:space-between;padding:6px 8px}
#infoContent{padding:8px}
#analysis-container { display: grid; grid-template-columns: 1fr; gap: 10px; margin-top: 10px; }
.analysis-box { background: #101028; border-radius: 8px; padding: 5px; }
.analysis-box canvas { width: 100%; height: 120px; }
button, select{background:var(--highlight);border:none;padding:10px 12px;border-radius:8px;color:white;font-weight:600;cursor:pointer; font-family: inherit; font-size: inherit;}
button:disabled{opacity:.45;cursor:not-allowed}
select { background-color: #2b2b44; }
.close-btn{background:transparent;border-radius:6px;border:1px solid rgba(255,255,255,0.06);padding:6px 8px;color:#eee;cursor:pointer}
#status{font-size:13px;color:#88a;text-align:center;margin-top:6px}
input[type="text"]{width:100%;padding:8px;border-radius:6px;border:1px solid #2b2b44;background:#0f1222;color:#eaf0ff}
.small{font-size:13px;color:#bfc7d8}
.grid-4{display:grid; grid-template-columns:repeat(4, 1fr); gap:12px;}
.checkbox-label { display:flex; align-items:center; gap: 6px; font-size: 13px; color: #bfc7d8; }
</style>
</head>
<body>
<canvas id="galaxyCanvas"></canvas>

<div id="controlsPanel" class="ui-panel">
  <div class="grid-3">
    <div> <label class="small">Base (a)</label> <input id="baseInput" type="text" value="10"> </div>
    <div> <label class="small">Exponent (b)</label> <input id="exponentInput" type="text" value="3"> </div>
    <div> <label class="small">Addend (c)</label> <input id="addendInput" type="text" value="7"> </div>
  </div>
  <hr style="border-color:var(--panel-border); margin: 12px 0;">
  <div class="grid-4">
    <div> <label class="small">Range Max</label> <input id="maxLimitInput" type="text" value="5000"> </div>
    <div> <label class="small">Geometry</label> <select id="geometrySelect"> <option value="archimedean">Archimedean Spiral</option> <option value="ulam">Ulam Spiral</option> <option value="sphere">Sphere</option> <option value="square">Square Grid</option> <option value="circle">Circular Disc</option> <option value="pyramid">Pyramid</option> </select> </div>
    <div> <label class="small">Y-Axis Dimension</label> <select id="yAxisSelect"> <option value="omega">Prime Complexity (Ω)</option> <option value="sigma">Sum of Divisors (σ)</option> <option value="phi">Euler's Totient (φ)</option> </select> </div>
    <div> <label class="checkbox-label" style="height:100%"> <input type="checkbox" id="primesOnlyToggle" checked> Test Primes Only </label> </div>
  </div>
   <div style="display:flex;gap:12px;align-items:center;margin-top:12px;">
     <label class="checkbox-label" style="height:100%"> <input type="checkbox" id="constellationToggle" checked> Show Factor Constellations </label>
  </div>
  <div style="display:flex;gap:12px;align-items:center;margin-top:12px;">
    <button id="startBtn" style="flex:1;">Generate Universe</button>
  </div>
  <div id="status" class="small">Ready</div>
</div>

<div id="infoPanel" class="ui-panel">
  <div id="infoHeader">
    <strong id="infoPanelTitle">Star Analysis</strong>
    <button id="infoClose" class="close-btn">Close</button>
  </div>
  <div id="infoContent"></div>
  <div id="analysis-container">
    <div class="analysis-box"> <canvas id="primeExplorerCanvas"></canvas> </div>
  </div>
</div>

<script type="module">
document.addEventListener('DOMContentLoaded', () => {

/* ========= CONFIG ========= */
const CANVAS = document.getElementById('galaxyCanvas');
const ui = { startBtn: document.getElementById('startBtn'), baseInput: document.getElementById('baseInput'), exponentInput: document.getElementById('exponentInput'), addendInput: document.getElementById('addendInput'), maxLimitInput: document.getElementById('maxLimitInput'), primesOnlyToggle: document.getElementById('primesOnlyToggle'), geometrySelect: document.getElementById('geometrySelect'), yAxisSelect: document.getElementById('yAxisSelect'), statusDiv: document.getElementById('status'), infoPanel: document.getElementById('infoPanel'), infoClose: document.getElementById('infoClose'), infoPanelTitle: document.getElementById('infoPanelTitle'), infoContent: document.getElementById('infoContent'), primeExplorerCanvas: document.getElementById('primeExplorerCanvas'), constellationToggle: document.getElementById('constellationToggle') };

/* ========= PARSING & UTILS ========= */
function parseBigInt(str) { try { return bigInt(str.replace(/\s/g, '')); } catch (e) { return null; } }
function customSqrt(n) { if (n.isNegative()) return bigInt(-1); if (n.lesserOrEquals(1)) return n; let x = n.shiftRight(1), y; while (true) { y = x.add(n.divide(x)).shiftRight(1); if (y.geq(x)) return x; x = y; }}

/* ========= THREE.JS SETUP ========= */
let scene, camera, renderer, controls, clock;
let particleSystem, geometry, constellationLines;
let starsData = [], hitTargets = [];
let raycaster = new THREE.Raycaster();
let mouse = new THREE.Vector2();
let lastSelectedIndex = null;
let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;

const FACTOR_COLOR = new THREE.Color(getComputedStyle(document.body).getPropertyValue('--factor-color'));
const SELECTED_COLOR = new THREE.Color(getComputedStyle(document.body).getPropertyValue('--selected-color'));

function initThree() {
  scene = new THREE.Scene();
  clock = new THREE.Clock();
  camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 40000);
  renderer = new THREE.WebGLRenderer({ canvas: CANVAS, antialias: true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setSize(window.innerWidth, window.innerHeight);

  geometry = new THREE.BufferGeometry();
  geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array([]), 3));
  geometry.setAttribute('aColor', new THREE.BufferAttribute(new Float32Array([]), 3));
  geometry.setAttribute('aSize', new THREE.BufferAttribute(new Float32Array([]), 1));
  const vertexShader = `attribute vec3 aColor; attribute float aSize; varying vec3 vColor; void main() { vColor = aColor; vec4 mvPosition = modelViewMatrix * vec4(position, 1.0); gl_PointSize = aSize * (400.0 / -mvPosition.z); gl_Position = projectionMatrix * mvPosition; }`;
  const fragmentShader = `varying vec3 vColor; void main() { float dist = length(gl_PointCoord - vec2(0.5)); float alpha = smoothstep(0.5, 0.4, dist); gl_FragColor = vec4(vColor, alpha); }`;
  const mat = new THREE.ShaderMaterial({ vertexShader, fragmentShader, transparent: true, depthWrite: false, blending: THREE.AdditiveBlending, vertexColors: true });
  particleSystem = new THREE.Points(geometry, mat);
  scene.add(particleSystem);

  const lineMat = new THREE.LineBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.3 });
  const lineGeo = new THREE.BufferGeometry();
  constellationLines = new THREE.LineSegments(lineGeo, lineMat);
  scene.add(constellationLines);

  controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.05;

  addBackgroundStars();
  resetCamera();
}

function addBackgroundStars() {
    const starGeo = new THREE.BufferGeometry();
    const starPos = [];
    for(let i=0; i<10000; i++) {
        const x = THREE.MathUtils.randFloatSpread(30000);
        const y = THREE.MathUtils.randFloatSpread(30000);
        const z = THREE.MathUtils.randFloatSpread(30000);
        starPos.push(x,y,z);
    }
    starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
    const starMat = new THREE.PointsMaterial({ color: 0x444444, size: 3 });
    const background = new THREE.Points(starGeo, starMat);
    scene.add(background);
}


function resetCamera(layout = 'archimedean') {
    controls.reset();
    if (layout === 'pyramid' || layout === 'sphere') {
        camera.position.set(500, 500, 1500);
    } else {
        camera.position.set(0, 800, 1200);
    }
    controls.target.set(0,0,0);
    controls.update();
}
function clearGalaxy() {
    starsData = []; hitTargets.forEach(t => scene.remove(t)); hitTargets = []; lastSelectedIndex = null;
    ['position', 'aColor', 'aSize'].forEach(attr => geometry.setAttribute(attr, new THREE.BufferAttribute(new Float32Array([]), attr === 'position' ? 3 : (attr === 'aColor' ? 3 : 1))));
    constellationLines.geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array([]), 3));
}

/* ========= WEB WORKER ========= */
let worker = null;
function makeWorker() {
  const workerSrc = `
    function powMod(base, exp, mod) { let res = 1n; base %= mod; while (exp > 0n) { if (exp % 2n === 1n) res = (res * base) % mod; exp >>= 1n; base = (base * base) % mod; } return res; }
    function getProperties(nStr) {
        const n = BigInt(nStr);
        if (n <= 0n) return { omega: 0, sigma: '0', phi: '0' };
        let tempN = n, omega = 0, sigma = 1n, phi = n;
        if (tempN % 2n === 0n) {
            let count = 0; while (tempN % 2n === 0n) { tempN /= 2n; count++; }
            omega += count; sigma *= (2n ** BigInt(count + 1) - 1n); phi -= phi / 2n;
        }
        for (let i = 3n; i * i <= tempN; i += 2n) {
            if (tempN % i === 0n) {
                let count = 0; while (tempN % i === 0n) { tempN /= i; count++; }
                omega += count; sigma *= (i ** BigInt(count + 1) - 1n) / (i - 1n); phi -= phi / i;
            }
        }
        if (tempN > 1n) { omega++; sigma *= (tempN + 1n); phi -= phi / tempN; }
        return { omega, sigma: sigma.toString(), phi: phi.toString() };
    }
    function sieve(maxNum) {
        const isPrime = new Array(maxNum + 1).fill(true); isPrime[0] = isPrime[1] = false;
        for (let p = 2; p * p <= maxNum; p++) { if (isPrime[p]) { for (let i = p * p; i <= maxNum; i += p) isPrime[i] = false; } }
        const primes = []; for (let i = 2; i <= maxNum; i++) if (isPrime[i]) primes.push(i); return primes;
    }
    self.onmessage = function(e){
        const { aStr, bStr, cStr, max, primesOnly } = e.data;
        const a = BigInt(aStr), b = BigInt(bStr), c = BigInt(cStr);
        const pointsToTest = primesOnly ? sieve(max) : Array.from({length: max}, (_, i) => i + 1);
        const results = [];
        for (const pNum of pointsToTest) {
            const p = BigInt(pNum); if (p === 0n) continue;
            const remainder = (powMod(a, b, p) + c) % p;
            results.push({ p: p.toString(), properties: getProperties(p.toString()), isFactor: remainder === 0n, remainderRatio: Number(remainder) / Number(p) });
            if (results.length % 500 === 0) postMessage({ type: 'progress', count: results.length, total: pointsToTest.length });
        }
        postMessage({ type: 'done', results });
    };
  `;
  const blob = new Blob([workerSrc], { type: 'application/javascript' });
  return new Worker(URL.createObjectURL(blob));
}

function startGeneration() {
  if (worker) worker.terminate();
  worker = makeWorker();
  clearGalaxy();
  ui.startBtn.disabled = true;
  ui.statusDiv.textContent = 'Generating points...';
  resetCamera(ui.geometrySelect.value);

  worker.onmessage = (e) => {
    if (e.data.type === 'progress') { ui.statusDiv.textContent = `Processing... (${e.data.count}/${e.data.total})`; }
    else if (e.data.type === 'done') { buildGalaxyFromResults(e.data.results); ui.statusDiv.textContent = 'Galaxy generated.'; ui.startBtn.disabled = false; }
  };

  worker.postMessage({ aStr: ui.baseInput.value, bStr: ui.exponentInput.value, cStr: ui.addendInput.value, max: parseInt(ui.maxLimitInput.value), primesOnly: ui.primesOnlyToggle.checked, });
}

function buildGalaxyFromResults(results) {
    starsData = results;
    const numStars = results.length;
    let positionArray = new Float32Array(numStars * 3), colorArray = new Float32Array(numStars * 3), sizeArray = new Float32Array(numStars);
    const hitGeo = new THREE.SphereGeometry(15, 8, 8); const hitMat = new THREE.MeshBasicMaterial({ visible: false });
    const layout = ui.geometrySelect.value;
    const yAxisProp = ui.yAxisSelect.value;

    const maxN = results.length > 0 ? parseInt(results[results.length - 1].p) : 1;
    let pyramidPointsPlaced = 0, pyramidY = 0, pyramidLayerWidth = Math.floor(Math.sqrt(numStars / 2));

    for (let i = 0; i < numStars; i++) {
        const star = results[i]; const n = parseInt(star.p); let pos = {x:0, y:0, z:0};
        if(layout === 'archimedean') { const angle = 0.3 * Math.sqrt(n), radius = 2.5 * Math.sqrt(n); pos.x = radius * Math.cos(angle); pos.z = radius * Math.sin(angle); }
        else if (layout === 'ulam') { let k=Math.ceil((Math.sqrt(n)-1)/2), t=2*k+1, m=t*t; t-=1; if(n>=m-t){pos.x=k-(m-n);pos.z=-k}else{m-=t;if(n>=m-t){pos.x=-k;pos.z=-k+(m-n)}else{m-=t;if(n>=m-t){pos.x=-k+(m-n);pos.z=k}else{pos.x=k;pos.z=k-(m-n-t)}}} pos.x*=10;pos.z*=10; }
        else if (layout === 'sphere') { const phi=Math.PI*(3-Math.sqrt(5)), y_sphere=1-(i/(numStars-1))*2, radius=Math.sqrt(1-y_sphere*y_sphere), theta=phi*i, sphereRadius=10*Math.cbrt(maxN); pos.x=Math.cos(theta)*radius*sphereRadius; pos.y=y_sphere*sphereRadius; pos.z=Math.sin(theta)*radius*sphereRadius; }
        else if (layout === 'square') { const width=Math.ceil(Math.sqrt(numStars)), spacing=10; pos.x=(i%width-width/2)*spacing; pos.z=(Math.floor(i/width)-width/2)*spacing; }
        else if (layout === 'circle') { const radius=20*Math.sqrt(i/numStars), angle=i*2.4; pos.x=radius*Math.cos(angle); pos.z=radius*Math.sin(angle); }
        else if (layout === 'pyramid') { const pointsOnThisLayer=pyramidLayerWidth*pyramidLayerWidth, pointIndexOnLayer=i-pyramidPointsPlaced, spacing=20; pos.x=(pointIndexOnLayer%pyramidLayerWidth-pyramidLayerWidth/2)*spacing; pos.z=(Math.floor(pointIndexOnLayer/pyramidLayerWidth)-pyramidLayerWidth/2)*spacing; pos.y=pyramidY*spacing; if(pointIndexOnLayer>=pointsOnThisLayer-1){pyramidPointsPlaced+=pointsOnThisLayer;pyramidY++;pyramidLayerWidth=Math.max(1,pyramidLayerWidth-2)}}

        if (yAxisProp === 'omega') {
            pos.y = star.properties.omega * 25 - 50;
        } else if (yAxisProp === 'sigma') {
            const sigmaVal = bigInt(star.properties.sigma);
            pos.y = Math.log(Number(sigmaVal.toString().slice(0,15))) * 20 - 100;
        } else if (yAxisProp === 'phi') {
             const phiVal = bigInt(star.properties.phi);
             pos.y = Math.log(Number(phiVal.toString().slice(0,15))) * 20 - 100;
        }

        positionArray.set([pos.x,pos.y,pos.z],i*3);
        let color=new THREE.Color();
        if(star.isFactor){color=FACTOR_COLOR;sizeArray[i]=20}else{const hue=(1-star.remainderRatio)*240;color.setHSL(hue/360,1,0.5);sizeArray[i]=8}
        colorArray.set([color.r,color.g,color.b],i*3);
        const hitSphere=new THREE.Mesh(hitGeo,hitMat); hitSphere.position.set(pos.x,pos.y,pos.z); hitSphere.userData.index=i; scene.add(hitSphere); hitTargets.push(hitSphere);
    }
    geometry.setAttribute('position', new THREE.BufferAttribute(positionArray, 3));
    geometry.setAttribute('aColor', new THREE.BufferAttribute(colorArray, 3));
    geometry.setAttribute('aSize', new THREE.BufferAttribute(sizeArray, 1));
    drawFactorConstellation();
}

function drawFactorConstellation() {
    const linePoints = [];
    if (ui.constellationToggle.checked) {
        for(let i=0; i<starsData.length; i++) {
            if (starsData[i].isFactor) {
                linePoints.push(0,0,0);
                const p = geometry.attributes.position.array;
                linePoints.push(p[i*3], p[i*3+1], p[i*3+2]);
            }
        }
    }
    constellationLines.geometry.setAttribute('position', new THREE.Float32BufferAttribute(linePoints, 3));
}

/* ========= PICKING & INFO PANEL ========= */
function showInfoForIndex(i) {
  const star = starsData[i];
  ui.infoPanel.style.display = 'block';
  ui.infoPanelTitle.textContent = `Star Analysis: ${star.p}`;
  const props = star.properties;
  ui.infoContent.innerHTML = `<div><strong>Number:</strong> ${star.p}</div>
    <div><strong>Ω(n) (Prime Factors):</strong> ${props.omega}</div>
    <div><strong>σ(n) (Sum of Divisors):</strong> ${props.sigma}</div>
    <div><strong>φ(n) (Euler's Totient):</strong> ${props.phi}</div>
    <div><strong>Harmonic Ratio:</strong> ${star.remainderRatio.toFixed(4)}</div>`;
  drawPrimeExplorerVisualization(star.p);
}

function handlePointerTap(clientX, clientY) {
  mouse.x = (clientX / window.innerWidth) * 2 - 1; mouse.y = -(clientY / window.innerHeight) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);
  const intersects = raycaster.intersectObjects(hitTargets, false);
  if (lastSelectedIndex !== null && starsData[lastSelectedIndex]) {
      const prevStar = starsData[lastSelectedIndex]; let prevColor = new THREE.Color();
      if (prevStar.isFactor) { prevColor = FACTOR_COLOR; } else { const hue = (1 - prevStar.remainderRatio) * 240; prevColor.setHSL(hue/360, 1.0, 0.5); }
      geometry.attributes.aColor.setXYZ(lastSelectedIndex, prevColor.r, prevColor.g, prevColor.b);
      geometry.attributes.aColor.needsUpdate = true;
  }
  if (intersects.length > 0) {
    const idx = intersects[0].object.userData.index; lastSelectedIndex = idx;
    geometry.attributes.aColor.setXYZ(idx, SELECTED_COLOR.r, SELECTED_COLOR.g, SELECTED_COLOR.b);
    geometry.attributes.aColor.needsUpdate = true;
    showInfoForIndex(idx);
  } else { ui.infoPanel.style.display = 'none'; lastSelectedIndex = null; }
}

function drawPrimeExplorerVisualization(numberStr) {
    const n = bigInt(numberStr); const ctx = ui.primeExplorerCanvas.getContext('2d');
    const w = ui.primeExplorerCanvas.width, h = ui.primeExplorerCanvas.height;
    ctx.clearRect(0, 0, w, h); ctx.fillStyle = '#101028'; ctx.fillRect(0,0,w,h);
    if (n.isZero() || n.toString().length > 30) { ctx.fillStyle = '#fff'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText("Too large for geometric view", w/2, h/2); return; }
    const side = customSqrt(n); let factorA = bigInt.one, factorB = n;
    for (let i = side; i.geq(1); i = i.prev()) { if (n.mod(i).isZero()) { factorA = i; factorB = n.divide(i); break; } }
    const scale = Math.min(w / Number(factorB), h / Number(factorA)) * 0.9;
    const rectW = Number(factorB) * scale, rectH = Number(factorA) * scale;
    const rectX = (w - rectW) / 2, rectY = (h - rectH) / 2;
    ctx.strokeStyle = "#00aaff"; ctx.fillStyle = "rgba(0, 170, 255, 0.3)";
    ctx.fillRect(rectX, rectY, rectW, rectH); ctx.strokeRect(rectX, rectY, rectW, rectH);
}

/* ========= MAIN LOOP & EVENTS ========= */
function animate() {
  requestAnimationFrame(animate);
  controls.update();
  const delta = clock.getDelta();
  const panSpeed = 500 * delta;

  // Create a pan vector based on keyboard input
  const panVector = new THREE.Vector3();
  if (moveForward) panVector.z -= panSpeed;
  if (moveBackward) panVector.z += panSpeed;
  if (moveLeft) panVector.x -= panSpeed;
  if (moveRight) panVector.x += panSpeed;

  // Apply the camera's rotation to the pan vector so we move in the direction we're looking
  panVector.applyQuaternion(camera.quaternion);
  camera.position.add(panVector);
  controls.target.add(panVector);

  renderer.render(scene, camera);
}
function onResize() { renderer.setSize(window.innerWidth, window.innerHeight); camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); }

/* --- CONTROLS --- */
function addEventListeners() {
    ui.startBtn.addEventListener('click', startGeneration);
    ui.geometrySelect.addEventListener('change', () => buildGalaxyFromResults(starsData));
    ui.yAxisSelect.addEventListener('change', () => buildGalaxyFromResults(starsData));
    ui.constellationToggle.addEventListener('change', drawFactorConstellation);
    ui.infoClose.addEventListener('click', () => { ui.infoPanel.style.display = 'none'; });
    const onKeyDown = (e) => { switch(e.code){ case 'ArrowUp': case 'KeyW': moveForward=true; break; case 'ArrowLeft': case 'KeyA': moveLeft=true; break; case 'ArrowDown': case 'KeyS': moveBackward=true; break; case 'ArrowRight': case 'KeyD': moveRight=true; break; }};
    const onKeyUp = (e) => { switch(e.code){ case 'ArrowUp': case 'KeyW': moveForward=false; break; case 'ArrowLeft': case 'KeyA': moveLeft=false; break; case 'ArrowDown': case 'KeyS': moveBackward=false; break; case 'ArrowRight': case 'KeyD': moveRight=false; break; }};
    document.addEventListener('keydown', onKeyDown); document.addEventListener('keyup', onKeyUp);
    let ptrStart = null;
    CANVAS.addEventListener('pointerdown', (ev) => { ptrStart = { x: ev.clientX, y: ev.clientY, t: Date.now() }; });
    CANVAS.addEventListener('pointerup', (ev) => { if (!ptrStart) return; const dt = Date.now() - ptrStart.t; const dist = Math.hypot(ev.clientX - ptrStart.x, ev.clientY - ptrStart.y); if (dt < 300 && dist < 16) handlePointerTap(ev.clientX, ev.clientY); ptrStart = null; });
}

/* ========= KICKOFF ========= */
initThree();
addEventListeners();
animate();
startGeneration();

});
</script>
</body>
</html>

