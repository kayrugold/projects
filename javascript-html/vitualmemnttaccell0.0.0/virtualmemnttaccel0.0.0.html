<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Holographic Engine v9 (Paged Kernel)</title>
<style>
    body { background: #020617; color: #e2e8f0; font-family: 'Courier New', monospace; padding: 20px; }
    .card { background: #0f172a; border: 1px solid #1e293b; border-radius: 12px; padding: 25px; max-width: 600px; margin: 0 auto; box-shadow: 0 0 60px rgba(0,0,0,0.6); }
    
    h1 { color: #f43f5e; margin: 0; font-size: 1.6rem; letter-spacing: 2px; text-transform: uppercase; }
    .sub { color: #64748b; font-size: 0.8rem; margin-bottom: 25px; border-bottom: 1px solid #334155; padding-bottom: 10px; }

    /* INPUTS */
    .inputs { display: flex; flex-direction: column; gap: 15px; margin-bottom: 20px; }
    .input-row { display: flex; flex-direction: column; }
    input { background: #1e293b; border: 1px solid #334155; color: #fff; padding: 15px; border-radius: 6px; font-family: inherit; font-weight: bold; font-size: 1.1rem; }
    input:focus { border-color: #f43f5e; outline: none; }
    label { font-size: 11px; color: #64748b; margin-bottom: 5px; font-weight: bold; letter-spacing: 1px; }

    /* TELEMETRY */
    .dashboard { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 20px; }
    .panel { background: #020617; border: 1px solid #334155; border-radius: 6px; padding: 10px; text-align: center; }
    .lbl { font-size: 9px; color: #64748b; display: block; margin-bottom: 2px; }
    .val { font-size: 14px; color: #fff; font-weight: bold; }
    
    .prog-container { margin-bottom: 20px; }
    .bar-bg { height: 8px; background: #1e293b; border-radius: 4px; overflow: hidden; margin-top: 5px;}
    .bar-fill { height: 100%; background: #3b82f6; width: 0%; transition: width 0.2s; }
    .status-text { display: flex; justify-content: space-between; font-size: 10px; color: #64748b; }

    .btn { width: 100%; padding: 20px; border: none; border-radius: 8px; font-weight: 900; font-size: 18px; cursor: pointer; text-transform: uppercase; background: #f43f5e; color: #fff; }
    .btn:disabled { background: #334155; color: #64748b; cursor: not-allowed; }

    .log { margin-top: 20px; height: 250px; overflow-y: auto; font-size: 11px; color: #94a3b8; background: #020617; border: 1px solid #334155; padding: 15px; white-space: pre-wrap; border-radius: 8px; }
</style>
</head>
<body>

<div class="card">
    <h1>Holographic v9</h1>
    <div class="sub">PAGED MEMORY KERNEL â€¢ NO LIMITS</div>

    <div class="inputs">
        <div class="input-row"><label>BASE</label><input id="base" type="number" value="10"></div>
        <div class="input-row"><label>EXPONENT</label><input id="exp" value="1000000000"></div>
        <div class="input-row"><label>ADD</label><input id="add" type="number" value="61"></div>
    </div>

    <div class="dashboard">
        <div class="panel"><span class="lbl">RUNTIME</span><span id="timer" class="val" style="color:#22c55e">0.0s</span></div>
        <div class="panel"><span class="lbl">MEMORY</span><span id="memStat" class="val">0 MB</span></div>
    </div>

    <div class="prog-container">
        <div class="status-text"><span id="opStatus">IDLE</span><span id="opPct">0%</span></div>
        <div class="bar-bg"><div id="fill" class="bar-fill"></div></div>
    </div>

    <button id="btn" onclick="run()">INITIALIZE & RUN</button>
    <div id="log" class="log">System Ready.</div>
</div>

<script>
const workerCode = `
// ==========================================
// PAGED HOLOGRAPHIC KERNEL
// ==========================================

const MOD = 998244353n;
const ROOT = 3n;
const PAGE_BITS = 24; // 16M elements per page
const PAGE_SIZE = 1 << PAGE_BITS; 
const PAGE_MASK = PAGE_SIZE - 1;

// --- VIRTUAL VECTOR (PAGED MEMORY) ---
class VirtualVector {
    constructor(size) {
        this.size = size;
        this.numPages = Math.ceil(size / PAGE_SIZE);
        this.pages = [];
    }
    
    allocate() {
        for(let i=0; i<this.numPages; i++) {
            this.pages.push(new Int32Array(PAGE_SIZE));
        }
        return this.numPages * PAGE_SIZE * 4; // Bytes
    }
    
    // Optimized Accessors
    get(i) {
        return this.pages[i >>> PAGE_BITS][i & PAGE_MASK];
    }
    
    set(i, val) {
        this.pages[i >>> PAGE_BITS][i & PAGE_MASK] = val;
    }
}

function power(a, b) {
    let res = 1n; a %= MOD;
    while (b > 0n) {
        if (b & 1n) res = (res * a) % MOD;
        a = (a * a) % MOD; b >>= 1n;
    }
    return res;
}

// PAGED NTT ALGORITHM
// (Slightly slower than raw array due to get/set calls, but safer)
function ntt(vec, invert) {
    const n = vec.size;
    
    // 1. Bit Reversal
    let j = 0;
    for (let i = 1; i < n; i++) {
        let bit = n >> 1;
        while (j & bit) { j ^= bit; bit >>= 1; }
        j ^= bit;
        if (i < j) { 
            const temp = vec.get(i); 
            vec.set(i, vec.get(j)); 
            vec.set(j, temp); 
        }
    }

    // 2. Butterfly
    let stage = 0;
    const totalStages = Math.log2(n);

    for (let len = 2; len <= n; len <<= 1) {
        let wlen = power(ROOT, (MOD - 1n) / BigInt(len));
        if (invert) wlen = power(wlen, MOD - 2n);

        for (let i = 0; i < n; i += len) {
            let w = 1n;
            for (let j = 0; j < len / 2; j++) {
                // Access via Virtual Vector
                const idxU = i + j;
                const idxV = i + j + len / 2;
                
                const u = BigInt(vec.get(idxU));
                const v = (BigInt(vec.get(idxV)) * w) % MOD;
                
                vec.set(idxU, Number((u + v) % MOD));
                vec.set(idxV, Number((u - v + MOD) % MOD));
                
                w = (w * wlen) % MOD;
            }
        }
        
        stage++;
        postMessage({type:'prog', pct: stage/totalStages, phase: invert ? 'INVERSE' : 'FORWARD'});
    }

    // 3. Inverse Scaling
    if (invert) {
        const ninv = power(BigInt(n), MOD - 2n);
        for (let i = 0; i < n; i++) {
            vec.set(i, Number((BigInt(vec.get(i)) * ninv) % MOD));
        }
    }
}

self.onmessage = function(e) {
    try {
        const { base, exp, add } = e.data;
        const BASE = BigInt(base);
        const EXP = BigInt(exp);
        const ADD = BigInt(add);
        
        // 1. CALC SIZE
        const digits = Number(EXP) * Math.log10(Number(BASE));
        const needed = Math.ceil(digits / 6); // Density 6
        let size = 1;
        while(size < needed) size <<= 1;
        
        postMessage({type:'log', msg:\`Target: 10^\${EXP} + \${ADD}\`});
        postMessage({type:'log', msg:\`Vector Size: \${(size/1e6).toFixed(1)}M Elements\`});
        postMessage({type:'log', msg:'Allocating Virtual RAM (Paged)...' });
        
        // 2. VIRTUAL ALLOCATION
        const vec = new VirtualVector(size);
        const bytes = vec.allocate();
        postMessage({type:'mem', val: Math.round(bytes/1024/1024)});
        
        // 3. INITIALIZE
        const leadingIndex = Math.floor(Number(EXP) / 6);
        const remainderPower = Number(EXP) % 6;
        vec.set(0, Number(ADD));
        vec.set(leadingIndex, Math.pow(10, remainderPower));
        
        // 4. FORWARD
        postMessage({type:'log', msg:'Starting Forward NTT...'});
        const t1 = Date.now();
        ntt(vec, false);
        postMessage({type:'log', msg:\`Forward Done (\${((Date.now()-t1)/1000).toFixed(1)}s)\`});
        
        // 5. SQUARE
        postMessage({type:'log', msg:'Spectral Squaring...'});
        for(let i=0; i<size; i++) {
            const v = BigInt(vec.get(i));
            vec.set(i, Number((v*v)%MOD));
        }
        
        // 6. INVERSE
        postMessage({type:'log', msg:'Starting Inverse NTT...'});
        const t2 = Date.now();
        ntt(vec, true);
        postMessage({type:'log', msg:\`Inverse Done (\${((Date.now()-t2)/1000).toFixed(1)}s)\`});
        
        // 7. VERIFY PEEK
        postMessage({type:'log', msg:'Propagating Carries...'});
        
        let carry = 0n;
        const resultDigits = [];
        const limit = Math.min(size, 20); 
        
        for(let i=0; i<limit; i++) {
            let val = BigInt(vec.get(i)) + carry;
            const chunk = val % 1000000n;
            carry = val / 1000000n;
            let s = chunk.toString();
            while(s.length < 6) s = "0" + s;
            resultDigits.push(s);
        }
        
        const cleanStr = resultDigits.slice(0, 5).join(' ') + " ...";
        postMessage({type:'result', val: cleanStr});
        postMessage({type:'done'});
        
    } catch(err) {
        postMessage({type:'error', msg:err.message});
    }
};
`;

const blob = new Blob([workerCode], {type:'text/javascript'});
const url = URL.createObjectURL(blob);
let w;
let timerInterval;
let startTime;

function run() {
    if(w) w.terminate();
    w = new Worker(url);
    
    // RESET UI
    document.getElementById('log').innerText = "Initializing...";
    document.getElementById('btn').disabled = true;
    document.getElementById('btn').innerText = "CALCULATING...";
    document.getElementById('fill').style.width = "0%";
    
    startTime = Date.now();
    clearInterval(timerInterval);
    timerInterval = setInterval(() => {
        const d = (Date.now() - startTime) / 1000;
        document.getElementById('timer').innerText = d.toFixed(1) + "s";
    }, 100);
    
    w.onmessage = e => {
        const d = e.data;
        if(d.type === 'log') {
            const log = document.getElementById('log');
            log.innerText += "\n" + d.msg;
            log.scrollTop = log.scrollHeight;
        }
        if(d.type === 'mem') document.getElementById('memStat').innerText = d.val + " MB";
        
        if(d.type === 'prog') {
            const pct = d.pct * 100;
            document.getElementById('fill').style.width = pct + "%";
            document.getElementById('opStatus').innerText = d.phase;
            document.getElementById('opPct').innerText = Math.round(pct) + "%";
            
            const bar = document.getElementById('fill');
            if(d.phase === 'FORWARD') bar.style.backgroundColor = "#3b82f6";
            else bar.style.backgroundColor = "#a855f7";
        }
        
        if(d.type === 'result') {
            document.getElementById('log').innerText += "\n\n>> VERIFIED DIGITS:\n" + d.val;
        }
        
        if(d.type === 'done') {
            clearInterval(timerInterval);
            document.getElementById('btn').disabled = false;
            document.getElementById('btn').innerText = "RUN NEW TEST";
            document.getElementById('opStatus').innerText = "SUCCESS";
            document.getElementById('fill').style.backgroundColor = "#22c55e";
        }
        
        if(d.type === 'error') {
            clearInterval(timerInterval);
            document.getElementById('log').innerText += "\nERROR: " + d.msg;
            document.getElementById('btn').disabled = false;
            document.getElementById('btn').innerText = "FAILED";
            document.getElementById('btn').style.background = "#f43f5e";
        }
    };
    
    w.postMessage({
        base: document.getElementById('base').value,
        exp: document.getElementById('exp').value,
        add: document.getElementById('add').value
    });
}
</script>
</body>
</html>
