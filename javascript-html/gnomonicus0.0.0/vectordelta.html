<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Codex Gnomonicus v0.0.7 (Vector Trace)</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/big-integer@1.6.48/BigInteger.min.js"></script>
    <style>
        :root {
            --bg: #020617; 
            --panel: #0f172a; 
            --border: #1e293b;
            --cyan: #22d3ee; 
            --pink: #f472b6; 
            --green: #34d399;
            --gold: #fbbf24;
            --text: #e2e8f0;
            --font-mono: 'Roboto Mono', monospace;
        }

        body {
            margin: 0;
            background-color: var(--bg);
            color: var(--text);
            font-family: var(--font-mono);
            overflow: hidden;
            touch-action: none;
        }

        /* HUD CONTROLS */
        #hud {
            position: absolute; top: 0; left: 0; width: 100%;
            padding: 10px; box-sizing: border-box;
            display: flex; justify-content: space-between;
            pointer-events: none; z-index: 10;
        }
        .stat-box { 
            background: rgba(15, 23, 42, 0.9); 
            padding: 6px 12px; 
            border-radius: 4px; 
            border: 1px solid var(--cyan); 
            font-size: 0.9rem; 
            color: var(--cyan);
            font-weight: bold;
            box-shadow: 0 0 10px rgba(34, 211, 238, 0.1);
        }

        /* DATA CARD */
        #card {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            width: 90%; max-width: 400px;
            background: rgba(15, 23, 42, 0.95); 
            border: 1px solid var(--gold);
            padding: 0; border-radius: 8px;
            box-shadow: 0 0 30px rgba(0,0,0,0.8);
            display: none; flex-direction: column;
            font-size: 0.85rem;
            z-index: 40; overflow: hidden;
            backdrop-filter: blur(5px);
        }
        
        .card-header { 
            font-size: 1.1rem; color: #000; font-weight: bold;
            text-align: center; padding: 10px; background: var(--gold);
            letter-spacing: 1px;
        }

        .card-body { padding: 15px; display: flex; flex-direction: column; gap: 8px; }

        .data-row { display: flex; justify-content: space-between; align-items: center; border-bottom: 1px dotted #334155; padding-bottom: 4px;}
        .data-lbl { color: #94a3b8; font-size: 0.7rem; text-transform: uppercase; font-weight: bold; letter-spacing: 1px; }
        .data-val { font-weight: bold; color: #fff; font-size: 0.9rem; font-family: monospace; }
        
        /* VECTOR BOX */
        .vector-box {
            background: rgba(251, 191, 36, 0.05); 
            border: 1px solid var(--gold); 
            padding: 8px; margin-top: 5px; 
            border-radius: 4px;
        }
        .v-title { color: var(--gold); font-size: 0.7rem; font-weight: bold; margin-bottom: 4px; text-transform: uppercase; text-align: center; }
        .v-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; text-align: center; }
        .v-val { color: #fff; font-size: 1.1rem; font-weight: bold; }
        .v-sub { font-size: 0.6rem; color: #64748b; }

        canvas { display: block; width: 100%; height: 100%; }
    </style>
</head>
<body>

    <div id="hud">
        <div class="stat-box">ROW <span id="disp-row" style="color:#fff">--</span></div>
        <div class="stat-box">ZOOM <span id="disp-scale" style="color:#fff">1.0x</span></div>
    </div>

    <div id="card">
        <div class="card-header">TAPE ID: <span id="c-tape">--</span></div>
        <div class="card-body">
            
            <div class="data-row">
                <span class="data-lbl">SOURCE (START)</span>
                <span class="data-val" id="c-coord">--</span>
            </div>

            <div class="vector-box">
                <div class="v-title">JUMP TARGET (x3)</div>
                <div style="text-align:center; color:var(--gold); font-size:1.2rem; font-weight:900; margin-bottom:5px;" id="c-target">--</div>
                <div class="v-grid">
                    <div>
                        <div class="v-val" id="d-row">--</div>
                        <div class="v-sub">ROW DIFF (Δk)</div>
                    </div>
                    <div>
                        <div class="v-val" id="d-col">--</div>
                        <div class="v-sub">COL DIFF (Δc)</div>
                    </div>
                </div>
            </div>

            <div class="data-row" style="margin-top:5px; border:none;">
                <span class="data-lbl" style="color:var(--pink)">TARGET GAP</span>
                <span class="data-val" id="c-gap" style="color:var(--pink)">--</span>
            </div>
            
        </div>
    </div>

    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d', { alpha: false });

        let scale = 60;
        let offsetX = window.innerWidth / 2;
        let offsetY = 100;
        
        // VECTOR STATE
        let activeVector = null; // { start: {r, c, id}, end: {r, c, id} }

        let evCache = [];
        let prevDiff = -1;
        let clickStartPos = {x:0, y:0};

        function init() {
            window.addEventListener('resize', resize);
            resize();
            canvas.addEventListener('pointerdown', onPointerDown);
            canvas.addEventListener('pointermove', onPointerMove);
            canvas.addEventListener('pointerup', onPointerUp);
            canvas.addEventListener('pointercancel', onPointerUp);
            canvas.addEventListener('pointerout', onPointerUp);
            canvas.addEventListener('pointerleave', onPointerUp);
            canvas.addEventListener('wheel', onWheel, {passive: false});
            canvas.addEventListener('click', onClick);
            requestAnimationFrame(draw);
        }

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            draw();
        }

        // --- MATH LOGIC ---
        function getGridInfo(r, c) {
            let R = BigInt(r) + 1n; 
            let halfW = R - 1n;
            let endID = R * R;
            let offsetFromEnd = halfW - BigInt(c);
            let tapeID = endID - offsetFromEnd;
            return { r: r, c: c, tapeID: tapeID, R: R };
        }

        function getCoordsFromTape(T_val) {
            try {
                let T = BigInt(T_val);
                let R = bigSqrt(T); 
                if (R*R < T) R++;
                let endID = R * R;
                let offsetFromEnd = endID - T;
                let halfW = R - 1n;
                let c = halfW - offsetFromEnd;
                return { r: Number(R) - 1, c: Number(c), valid: true };
            } catch(e) { return { valid: false }; }
        }

        function bigSqrt(value) {
            if (value < 0n) return -1n;
            if (value < 2n) return value;
            let x = value;
            let y = (x + 1n) / 2n;
            while (y < x) { x = y; y = (value / x + x) / 2n; }
            return x;
        }

        // --- DRAWING ---
        function draw() {
            // Dark Mode Background
            ctx.fillStyle = "#020617";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            let startRow = Math.floor(-offsetY / scale);
            let endRow = startRow + Math.ceil(canvas.height / scale) + 1;
            if (startRow < 0) startRow = 0;
            let midX = offsetX;

            document.getElementById('disp-row').innerText = startRow + 1;
            document.getElementById('disp-scale').innerText = (scale/60).toFixed(1) + "x";

            ctx.textAlign = "center"; ctx.textBaseline = "middle";
            let fontSize = Math.max(10, scale * 0.35);
            ctx.font = `bold ${fontSize}px monospace`;

            // Draw Grid
            for (let r = startRow; r < endRow; r++) {
                let y = offsetY + r * scale;
                let R = r + 1;
                let halfW = R - 1;
                
                let screenLeftC = Math.floor((-offsetX) / scale) - 1;
                let screenRightC = Math.floor((canvas.width - offsetX) / scale) + 1;
                let startC = Math.max(-halfW, screenLeftC);
                let endC = Math.min(halfW, screenRightC);

                for (let c = startC; c <= endC; c++) {
                    let x = midX + c * scale;
                    let info = getGridInfo(r, c);
                    
                    let isStart = (activeVector && activeVector.start.id === info.tapeID);
                    let isEnd = (activeVector && activeVector.end.id === info.tapeID);
                    let isCorner = (c === halfW); 
                    let isCenter = (c === 0);

                    // Cell Background
                    ctx.fillStyle = "#0f172a"; 
                    if (isCenter) ctx.fillStyle = "rgba(34, 211, 238, 0.05)"; 
                    if (isCorner) ctx.fillStyle = "rgba(251, 191, 36, 0.05)"; 
                    if (isStart) ctx.fillStyle = "rgba(34, 211, 238, 0.3)"; 
                    if (isEnd) ctx.fillStyle = "rgba(251, 191, 36, 0.3)";

                    ctx.fillRect(x - scale/2 + 1, y - scale/2 + 1, scale - 2, scale - 2);

                    // Borders
                    ctx.lineWidth = 1;
                    if (isCorner) { ctx.strokeStyle = "#fbbf24"; ctx.lineWidth = 2; }
                    else if (isCenter) ctx.strokeStyle = "#22d3ee";
                    else ctx.strokeStyle = "#1e293b";
                    
                    if (isStart) { ctx.strokeStyle = "#22d3ee"; ctx.lineWidth = 3; }
                    if (isEnd) { ctx.strokeStyle = "#fbbf24"; ctx.lineWidth = 3; }

                    ctx.strokeRect(x - scale/2 + 1, y - scale/2 + 1, scale - 2, scale - 2);

                    // Text
                    ctx.fillStyle = "#64748b";
                    if (isCenter) ctx.fillStyle = "#22d3ee";
                    if (isCorner) ctx.fillStyle = "#fbbf24";
                    if (isStart || isEnd) ctx.fillStyle = "#fff";

                    if (scale > 20) {
                        let txt = info.tapeID.toString();
                        if (txt.length > 6) txt = txt.substring(0, 2) + ".." + txt.slice(-2);
                        ctx.fillText(txt, x, y);
                    }
                }
            }

            // Draw Vector Line (Gold)
            if (activeVector) {
                drawVectorLine();
            }
        }

        function drawVectorLine() {
            let startX = offsetX + activeVector.start.c * scale;
            let startY = offsetY + activeVector.start.r * scale;
            let endX = offsetX + activeVector.end.c * scale;
            let endY = offsetY + activeVector.end.r * scale;

            ctx.shadowBlur = 15;
            ctx.shadowColor = "#fbbf24";
            ctx.strokeStyle = "#fbbf24";
            ctx.lineWidth = Math.max(2, scale * 0.08);
            ctx.lineCap = "round";

            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
            ctx.stroke();

            // Reset
            ctx.shadowBlur = 0;
            ctx.lineWidth = 1;
        }

        // --- INTERACTION ---
        function onClick(e) {
            const dist = Math.hypot(e.clientX - clickStartPos.x, e.clientY - clickStartPos.y);
            if (dist > 10) return; 
            
            let r = Math.floor((e.clientY - (offsetY - scale/2)) / scale);
            let c = Math.floor((e.clientX - (offsetX - scale/2)) / scale);
            let info = getGridInfo(r, c);
            
            // Check if valid cell (within pyramid bounds)
            let R = r + 1;
            let halfW = R - 1;
            if (Math.abs(c) > halfW) return; // Clicked outside pyramid

            // 1. Set Start
            let startNode = { r: r, c: c, id: info.tapeID };

            // 2. Calculate Target (x3)
            let targetID = info.tapeID * 3n;
            let targetCoords = getCoordsFromTape(targetID);

            if (targetCoords.valid) {
                let endNode = { r: targetCoords.r, c: targetCoords.c, id: targetID };
                activeVector = { start: startNode, end: endNode };

                // 3. Update Card
                updateCard();
                draw();
            }
        }

        function updateCard() {
            let s = activeVector.start;
            let e = activeVector.end;
            let dRow = e.r - s.r;
            let dCol = e.c - s.c;

            document.getElementById('card').style.display = 'flex';
            document.getElementById('c-tape').innerText = s.id.toString();
            document.getElementById('c-coord').innerText = `R:${s.r+1}, C:${s.c}`;
            
            document.getElementById('c-target').innerText = e.id.toString();
            document.getElementById('d-row').innerText = "+" + dRow;
            document.getElementById('d-col').innerText = (dCol >= 0 ? "+" : "") + dCol;
            
            document.getElementById('c-gap').innerText = Math.abs(e.c).toString();
        }

        // --- EVENTS ---
        function onPointerDown(ev) { evCache.push(ev); clickStartPos={x:ev.clientX, y:ev.clientY}; }
        function onPointerMove(ev) {
            const index = evCache.findIndex(e => e.pointerId === ev.pointerId);
            if (index > -1) evCache[index] = ev;
            if (evCache.length === 1) {
                offsetX += ev.movementX; offsetY += ev.movementY; requestAnimationFrame(draw);
            } else if (evCache.length === 2) {
                const curDiff = Math.hypot(evCache[0].clientX - evCache[1].clientX, evCache[0].clientY - evCache[1].clientY);
                const midX = (evCache[0].clientX + evCache[1].clientX) / 2;
                const midY = (evCache[0].clientY + evCache[1].clientY) / 2;
                if (prevDiff > 0) {
                    let zoomFactor = 1.0 + (curDiff - prevDiff) * 0.005;
                    if (curDiff < prevDiff) zoomFactor = 1.0 - (prevDiff - curDiff) * 0.005;
                    const newScale = scale * zoomFactor;
                    if (newScale > 0.5 && newScale < 500) {
                        offsetX = midX - (midX - offsetX) * zoomFactor;
                        offsetY = midY - (midY - offsetY) * zoomFactor;
                        scale = newScale;
                    }
                }
                prevDiff = curDiff; requestAnimationFrame(draw);
            }
        }
        function onPointerUp(ev) {
            const index = evCache.findIndex(e => e.pointerId === ev.pointerId);
            if (index > -1) evCache.splice(index, 1);
            if (evCache.length < 2) prevDiff = -1;
        }
        function onWheel(ev) {
            ev.preventDefault();
            const zoomFactor = ev.deltaY > 0 ? 0.9 : 1.1;
            const newScale = scale * zoomFactor;
            if (newScale > 0.5 && newScale < 500) {
                offsetX = ev.clientX - (ev.clientX - offsetX) * zoomFactor;
                offsetY = ev.clientY - (ev.clientY - offsetY) * zoomFactor;
                scale = newScale; draw();
            }
        }

        init();
    </script>
</body>
</html>
