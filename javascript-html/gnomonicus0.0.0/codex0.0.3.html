<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Codex Gnomonicus: The Factor Decoder</title>
    <link href="https://fonts.googleapis.com/css2?family=Architects+Daughter&family=Roboto+Mono:wght@500&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/big-integer@1.6.48/BigInteger.min.js"></script>
    <style>
        :root {
            --bg-paper: #f9f3e3;
            --ink-black: #1a1a1a;
            --ink-red: #c0392b;
            --ink-blue: #2980b9;
            --font-hand: 'Architects Daughter', cursive;
            --font-mono: 'Roboto Mono', monospace;
        }

        body {
            margin: 0;
            background-color: var(--bg-paper);
            color: var(--ink-black);
            font-family: var(--font-hand);
            overflow: hidden;
            touch-action: none;
        }

        body::before {
            content: "";
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-image: url("data:image/svg+xml,%3Csvg width='100' height='100' viewBox='0 0 100 100' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.8' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)' opacity='0.08'/%3E%3C/svg%3E");
            pointer-events: none; z-index: -1;
        }

        #hud {
            position: absolute; top: 0; left: 0; width: 100%;
            padding: 15px; box-sizing: border-box;
            display: flex; justify-content: space-between;
            pointer-events: none; z-index: 10;
        }
        .stat-box { background: rgba(255,255,255,0.8); padding: 5px 10px; border-radius: 4px; border: 1px dashed var(--ink-black); }

        #btn-jump {
            position: absolute; bottom: 30px; right: 30px;
            width: 60px; height: 60px;
            background: var(--ink-black); color: #fff;
            border-radius: 50%; border: none;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            font-family: var(--font-hand); font-size: 1.2rem;
            display: flex; justify-content: center; align-items: center;
            cursor: pointer; z-index: 50;
        }
        #btn-jump:active { transform: scale(0.95); }

        /* THE DECODER CARD */
        #card {
            position: absolute; bottom: 100px; left: 50%; transform: translateX(-50%);
            width: 90%; max-width: 380px;
            background: #fff; border: 2px solid var(--ink-black);
            padding: 15px; border-radius: 4px;
            box-shadow: 8px 8px 0 rgba(0,0,0,0.15);
            display: none; flex-direction: column; gap: 8px;
            font-family: var(--font-mono); font-size: 0.95rem;
            z-index: 40;
        }
        .card-header { 
            font-family: var(--font-hand); font-size: 1.6rem; color: var(--ink-red); 
            border-bottom: 2px dashed #ddd; margin-bottom: 10px; padding-bottom: 5px;
            text-align: center;
        }
        .data-row { display: flex; justify-content: space-between; align-items: center; }
        .data-lbl { color: #666; font-size: 0.8rem; text-transform: uppercase; }
        .data-val { font-weight: bold; color: var(--ink-black); }
        .highlight-val { color: var(--ink-blue); font-size: 1.1rem; }
        .factor-box {
            background: #f0fdf4; border: 1px solid #86efac; padding: 10px;
            margin-top: 5px; text-align: center; border-radius: 4px;
        }

        canvas { display: block; width: 100%; height: 100%; }
    </style>
</head>
<body>

    <div id="hud">
        <div class="stat-box">Row: <span id="disp-row">--</span></div>
        <div class="stat-box">Scale: <span id="disp-scale">1.0</span></div>
    </div>

    <button id="btn-jump" onclick="askJump()">Go</button>

    <div id="card" onclick="this.style.display='none'">
        <div class="card-header">Tape ID: <span id="c-tape">--</span></div>
        
        <div class="data-row">
            <span class="data-lbl">Coordinate</span>
            <span class="data-val" id="c-coord">--</span>
        </div>
        
        <div class="data-row" style="margin-top:5px;">
            <span class="data-lbl">Anchor (a)</span>
            <span class="data-val" id="c-anchor">--</span>
        </div>
        <div class="data-row">
            <span class="data-lbl">Gap (b)</span>
            <span class="data-val" id="c-gap">--</span>
        </div>

        <div style="border-top: 1px solid #eee; margin: 8px 0;"></div>

        <div class="data-row">
            <span class="data-lbl">CARGO (Value)</span>
            <span class="data-val highlight-val" id="c-val">--</span>
        </div>

        <div class="factor-box">
            <div class="data-lbl" style="margin-bottom:4px;">FACTORS DETECTED</div>
            <div class="data-val" id="c-factors" style="color:#15803d; font-size:1.1rem;">--</div>
        </div>
        
        <div style="text-align:center; color:#999; font-size:0.7rem; margin-top:8px;">(Position = Factors)</div>
    </div>

    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d', { alpha: false });

        // --- STATE ---
        let scale = 60;
        let offsetX = window.innerWidth / 2;
        let offsetY = 100;
        let selected = null;

        // --- INPUT STATE ---
        let evCache = [];
        let prevDiff = -1;
        let clickStartPos = {x:0, y:0};

        function init() {
            window.addEventListener('resize', resize);
            resize();

            canvas.addEventListener('pointerdown', onPointerDown);
            canvas.addEventListener('pointermove', onPointerMove);
            canvas.addEventListener('pointerup', onPointerUp);
            canvas.addEventListener('pointercancel', onPointerUp);
            canvas.addEventListener('pointerout', onPointerUp);
            canvas.addEventListener('pointerleave', onPointerUp);
            canvas.addEventListener('wheel', onWheel, {passive: false});
            canvas.addEventListener('click', onClick);

            requestAnimationFrame(draw);
        }

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            draw();
        }

        // --- MATH: GNOMON DECODER ---
        // 1. Grid Logic: Square Pyramid
        // 2. Value Logic: Odd Number Map
        //    Row R (1-based) corresponds to Anchor a = 2(R-1) + 1  [i.e., 1, 3, 5, 7...]
        //    Actually, let's align with the user's Square vision:
        //    Visual Row 1 -> 1 cell -> 1^2. (Anchor 1).
        //    Visual Row 2 -> 3 cells -> 3^2. (Anchor 3).
        //    So R (1-based) maps to Anchor a = 2R - 1.
        
        function getGridInfo(r, c) {
            let R = BigInt(r) + 1n; // 1-based Row
            let halfW = R - 1n;     // Width extends from -(R-1) to +(R-1)
            
            if (BigInt(Math.abs(c)) > halfW) return null; // Out of bounds
            
            // Tape ID (Address)
            let endID = R * R;
            let offsetFromEnd = halfW - BigInt(c);
            let tapeID = endID - offsetFromEnd;
            
            // DECODER LOGIC (The "Where are the factors?" part)
            // Anchor a = 2R - 1
            // Gap b = offsetFromCenter? 
            // In the "Odd" Grid: Center is a^2. Steps are 2a.
            // Let's use the explicit geometric map:
            // a = 2R - 1.
            // b = c * 2 ? No.
            // Let's use the Difference of Squares directly.
            // Center (c=0) is a^2.
            // Factors at center: a * a.
            // Position c corresponds to gap b = |c|.
            // Wait, difference of squares is a^2 - b^2.
            // But the grid steps are usually linear (a^2 - 2a, etc).
            // Let's use the standard "Gnomon Table" definition:
            // Center = (2R-1)^2.
            // Value = (2R-1)^2 - c * (4(R-1) + 2).
            // This preserves the "Odd Composites" structure.
            
            let a = 2n * R - 1n; // Anchor (1, 3, 5...)
            let spine = a * a;
            let step = 2n * a; // 4R - 2? No, 2*Anchor.
            
            // Calculate Value N
            // If c > 0 (right), subtract? If c < 0 (left), add?
            // Standard Gnomon: Spine is Left.
            // Pyramid Gnomon: Spine is Center.
            // Let's define: Center is Square. Right is smaller. Left is bigger (Mirror).
            
            let val = spine - (BigInt(c) * step);
            
            // Factors?
            // If N = a^2 - c(2a) = a(a - 2c).
            // Factors are: a and (a - 2c).
            // Let's verify:
            // Row 2 (a=3). Center 9. (3x3).
            // c=1. Val = 9 - 1(6) = 3. Factors 3x1. Correct.
            // c=-1. Val = 9 - (-1)(6) = 15. Factors 3x5. Correct.
            
            let f1 = a;
            let f2 = a - (2n * BigInt(c));
            
            // Ensure positive presentation for factors
            let p1 = f1;
            let p2 = f2;
            if (p1 < 0n) p1 = -p1;
            if (p2 < 0n) p2 = -p2;
            if (p1 > p2) { let t=p1; p1=p2; p2=t; } // sort

            return {
                R: R,
                c: BigInt(c),
                tapeID: tapeID,
                a: a,
                gap: BigInt(c), // The "Gap" in this specific map is c
                val: val,
                factors: `${p1} Ã— ${p2}`,
                isEnd: (BigInt(c) === halfW),
                isCenter: (c === 0)
            };
        }

        function getCoordsFromTape(T_str) {
            try {
                let T = bigInt(T_str);
                let R = bigSqrt(T.value); 
                if (R*R < T.value) R++;
                let endID = R * R;
                let offsetFromEnd = endID - T.value;
                let halfW = R - 1n;
                let c = halfW - offsetFromEnd;
                return { r: Number(R) - 1, c: Number(c), valid: true };
            } catch(e) { return { valid: false }; }
        }

        function bigSqrt(value) {
            if (value < 0n) return -1n;
            if (value < 2n) return value;
            let x = value;
            let y = (x + 1n) / 2n;
            while (y < x) { x = y; y = (value / x + x) / 2n; }
            return x;
        }

        // --- DRAWING ---
        function draw() {
            ctx.fillStyle = "#f9f3e3";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            let startRow = Math.floor(-offsetY / scale);
            let endRow = startRow + Math.ceil(canvas.height / scale) + 1;
            if (startRow < 0) startRow = 0;

            let midX = offsetX;

            document.getElementById('disp-row').innerText = startRow + 1;
            document.getElementById('disp-scale').innerText = (scale/60).toFixed(1) + "x";

            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            let fontSize = Math.max(10, scale * 0.4);
            ctx.font = `${fontSize}px 'Architects Daughter', cursive`;

            for (let r = startRow; r < endRow; r++) {
                let y = offsetY + r * scale;
                let R = r + 1;
                let halfW = R - 1;

                let screenLeftC = Math.floor((-offsetX) / scale) - 1;
                let screenRightC = Math.floor((canvas.width - offsetX) / scale) + 1;
                
                let startC = Math.max(-halfW, screenLeftC);
                let endC = Math.min(halfW, screenRightC);

                for (let c = startC; c <= endC; c++) {
                    // Quick check for bounds before heavy math
                    if (Math.abs(c) > halfW) continue;

                    let x = midX + c * scale;
                    let tapeID = null;
                    
                    // We need Tape ID for rendering
                    let bigR = BigInt(R);
                    let endID = bigR * bigR;
                    let offsetFromEnd = BigInt(halfW - c);
                    tapeID = endID - offsetFromEnd;

                    // Selection Highlight
                    if (selected && selected.tapeID === tapeID) {
                        ctx.fillStyle = "rgba(255, 255, 0, 0.4)";
                        ctx.fillRect(x - scale/2 + 2, y - scale/2 + 2, scale - 4, scale - 4);
                        ctx.strokeStyle = "#c0392b";
                        ctx.lineWidth = 3;
                        ctx.strokeRect(x - scale/2 + 2, y - scale/2 + 2, scale - 4, scale - 4);
                    }

                    // Colors
                    if (c === halfW) ctx.fillStyle = "#c0392b"; // End
                    else if (c === 0) ctx.fillStyle = "#2980b9"; // Center
                    else ctx.fillStyle = "#1a1a1a";

                    // LOD
                    if (scale > 20) {
                        let txt = tapeID.toString();
                        if (txt.length > 6) txt = txt.substring(0, 2) + ".." + txt.slice(-2);
                        ctx.fillText(txt, x, y);
                    } else {
                        ctx.fillRect(x - 2, y - 2, 4, 4);
                    }
                }
            }
        }

        // --- INTERACTION ---
        function onPointerDown(ev) { evCache.push(ev); clickStartPos={x:ev.clientX, y:ev.clientY}; }
        function onPointerMove(ev) {
            const index = evCache.findIndex(e => e.pointerId === ev.pointerId);
            if (index > -1) evCache[index] = ev;

            if (evCache.length === 1) {
                offsetX += ev.movementX;
                offsetY += ev.movementY;
                requestAnimationFrame(draw);
            } else if (evCache.length === 2) {
                const curDiff = Math.hypot(evCache[0].clientX - evCache[1].clientX, evCache[0].clientY - evCache[1].clientY);
                const midX = (evCache[0].clientX + evCache[1].clientX) / 2;
                const midY = (evCache[0].clientY + evCache[1].clientY) / 2;

                if (prevDiff > 0) {
                    let zoomFactor = 1.0 + (curDiff - prevDiff) * 0.005;
                    if (curDiff < prevDiff) zoomFactor = 1.0 - (prevDiff - curDiff) * 0.005;
                    const newScale = scale * zoomFactor;
                    if (newScale > 0.5 && newScale < 500) {
                        offsetX = midX - (midX - offsetX) * zoomFactor;
                        offsetY = midY - (midY - offsetY) * zoomFactor;
                        scale = newScale;
                    }
                }
                prevDiff = curDiff;
                requestAnimationFrame(draw);
            }
        }
        function onPointerUp(ev) {
            const index = evCache.findIndex(e => e.pointerId === ev.pointerId);
            if (index > -1) evCache.splice(index, 1);
            if (evCache.length < 2) prevDiff = -1;
        }
        function onWheel(ev) {
            ev.preventDefault();
            const zoomFactor = ev.deltaY > 0 ? 0.9 : 1.1;
            const newScale = scale * zoomFactor;
            if (newScale > 0.5 && newScale < 500) {
                offsetX = ev.clientX - (ev.clientX - offsetX) * zoomFactor;
                offsetY = ev.clientY - (ev.clientY - offsetY) * zoomFactor;
                scale = newScale;
                draw();
            }
        }

        function onClick(e) {
            const dist = Math.hypot(e.clientX - clickStartPos.x, e.clientY - clickStartPos.y);
            if (dist > 10) return; 

            let r = Math.floor((e.clientY - (offsetY - scale/2)) / scale);
            let c = Math.floor((e.clientX - (offsetX - scale/2)) / scale);

            let info = getGridInfo(r, c);
            if (info) {
                selected = { tapeID: info.tapeID };
                showCard(info);
                draw();
            }
        }

        function askJump() {
            let val = prompt("Enter Tape ID to Jump to:");
            if (val) {
                let coords = getCoordsFromTape(val);
                if (coords.valid) {
                    offsetY = (canvas.height / 2) - (coords.r * scale);
                    offsetX = (canvas.width / 2) - (coords.c * scale);
                    let T = bigInt(val).value;
                    selected = { tapeID: T };
                    let info = getGridInfo(coords.r, coords.c);
                    if(info) showCard(info);
                    draw();
                }
            }
        }

        function showCard(info) {
            document.getElementById('card').style.display = 'flex';
            document.getElementById('c-tape').innerText = info.tapeID.toString();
            document.getElementById('c-coord').innerText = `Row ${info.R}, Col ${info.c}`;
            document.getElementById('c-anchor').innerText = info.a.toString();
            document.getElementById('c-gap').innerText = info.gap.toString();
            document.getElementById('c-val').innerText = info.val.toString();
            document.getElementById('c-factors').innerText = info.factors;
        }

        init();
    </script>
</body>
</html>
