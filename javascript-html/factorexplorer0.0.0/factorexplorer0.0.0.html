<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Prime Factory: Builder & Explorer</title>
<script src="https://unpkg.com/big-integer@1.6.48/BigInteger.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.52/Tone.js"></script>

<style>
  /* --- GLOBAL STYLES --- */
  :root { --bg: #071011; --grid: #152428; --cell: #00ff66; --cell-border: #00331a; --ui-bg: rgba(255,255,255,0.92); }
  html,body{height:100%;margin:0;font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif; overflow: hidden; touch-action: none;}
  canvas{display:block; width:100vw; height:100vh; touch-action:none; position: fixed; top: 0; left: 0; background-color: var(--bg); transition: background-color 0.5s ease;}
  .action-btn { padding: 4px 12px; font-size: 13px; border-radius: 4px; border: 1px solid #aaa; background-color: #f0f0f0; cursor: pointer; }
  .action-btn:hover { background-color: #e0e0e0; }
  .action-btn:disabled { background-color: #ccc; cursor: not-allowed; }

  /* --- TAB CONTROLS --- */
  .tabs-container {
    position: absolute;
    top: 12px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 100;
    background: var(--ui-bg);
    border-radius: 8px;
    padding: 4px;
    display: flex;
    gap: 4px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.2);
  }
  .tab-btn {
    padding: 6px 16px;
    font-size: 14px;
    font-weight: 500;
    border: none;
    background: transparent;
    border-radius: 6px;
    cursor: pointer;
    transition: background-color 0.2s, color 0.2s;
  }
  .tab-btn.active {
    background-color: #007bff;
    color: white;
  }
  .ui-container.hidden {
      display: none !important;
  }

  /* --- BUILDER: UI PANELS --- */
  .ui-panel {
    background:var(--ui-bg);
    padding:8px 12px;
    border-radius:8px;
    z-index:41;
    display: flex;
    flex-direction: column;
    gap: 6px;
    position: absolute;
    transition: all 0.3s ease;
    box-shadow: 0 2px 10px rgba(0,0,0,0.2);
  }
  #info{ left:12px; top:12px; }
  #patternTester { right: 12px; top: 12px; width: 450px; max-width: 90vw; }
  #primePanelContainer{ bottom:12px; left:50%; transform:translateX(-50%); width:auto; max-width:90vw; }
  .panel-header { display: flex; justify-content: space-between; align-items: center; width: 100%; margin-bottom: 4px; }
  .panel-header h4 { margin: 0; font-size: 14px; }
  .panel-toggle-btn { background: none; border: none; cursor: pointer; padding: 2px; line-height: 1; color: #555; }
  .panel-toggle-btn:hover { color: #000; }
  .ui-panel.collapsed .panel-content, .ui-panel.collapsed .panel-header h4 { display: none; }
  #info.collapsed { width: 44px; height: 44px; padding: 0; left: 0; top: 12px; border-radius: 0 8px 8px 0; justify-content: center; align-items: center; }
  #patternTester.collapsed { width: 44px; height: 44px; padding: 0; right: 0; top: 12px; border-radius: 8px 0 0 8px; justify-content: center; align-items: center; }
  #primePanelContainer.collapsed { width: 180px; height: 44px; padding: 0; bottom: 0; border-radius: 8px 8px 0 0; justify-content: center; align-items: center; }
  .ui-panel.collapsed .panel-toggle-btn { display: block; }

  /* --- BUILDER: SPECIFIC ELEMENTS --- */
  #targetContainer { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; }
  #panelRow {display: flex; justify-content: center; align-items: center; gap: 8px; flex-wrap: wrap;}
  .prime-block{width:40px;height:26px;background:var(--cell);border:2px solid var(--cell-border);border-radius:6px;display:inline-flex;align-items:center;justify-content:center;font-weight:700;cursor:pointer;touch-action:none;flex-shrink:0;}
  label{font-size:12px;margin-right:6px}
  input[type="text"], input[type="number"] {font-size:13px;padding:4px 6px; border: 1px solid #ccc; border-radius: 4px;}
  #target, #primeSelectorInput, #shareBaseUrlInput { width: 88px; }
  input[readonly] { background-color: #eee; }
  .small{font-size:12px;color:#444;margin-top:6px}
  #trashCan { position: absolute; bottom: 12px; right: 12px; width: 50px; height: 50px; background-color: var(--ui-bg); border-radius: 50%; display: flex; align-items: center; justify-content: center; z-index: 50; cursor: pointer; transition: background-color 0.2s, transform 0.2s; }
  #trashCan svg { width: 24px; height: 24px; color: #333; }
  #trashCan.over-trash { background-color: #ffdddd; transform: scale(1.1); }
  #trashCan.over-trash svg { color: #c00; }
  .checkbox-container { display: flex; align-items: center; gap: 6px; font-size: 12px; }
  .checkbox-container input { margin: 0; }
  #shareModal { display: none; position: fixed; left: 50%; top: 50%; transform: translate(-50%, -50%); background: var(--ui-bg); padding: 20px; border-radius: 8px; z-index: 101; box-shadow: 0 5px 15px rgba(0,0,0,0.3); width: 90%; max-width: 400px; }
  #shareModal p { margin: 0 0 10px 0; font-size: 14px; font-weight: bold; }
  #shareModal input { width: 100%; padding: 8px; font-size: 13px; box-sizing: border-box; margin-bottom: 12px; }
  #shareModal button { float: right; }
  .share-url-container { display: flex; align-items: center; gap: 6px; margin-top: 4px; flex-wrap: wrap; }
  .share-url-container input { flex-grow: 1; width: auto; min-width: 150px; transition: border-color 0.2s; }
  .share-url-container input.error { border-color: red; }
  #numberInfo { font-size: 12px; color: #333; margin-top: 4px; padding-top: 4px; border-top: 1px solid #ddd; }
  .info-prop { font-weight: bold; }
  .pattern-input-row { display: flex; gap: 10px; align-items: center; width: 100%; flex-wrap: wrap; }
  .pattern-input-row input { flex-grow: 1; }
  #patternResults { margin-top: 10px; width: 100%; max-height: 150px; overflow-y: auto; background: rgba(0,0,0,0.02); border-radius: 4px; padding: 6px; font-size: 12px; font-family: monospace; }
  .result-line { display: flex; justify-content: space-between; align-items: center; padding: 2px 4px; border-bottom: 1px solid #eee; }
  .result-line > span:last-child { display: flex; align-items: center; gap: 8px; }
  .result-prime { color: #090; }
  .result-composite { color: #900; }
  .add-to-grid-btn { padding: 0; width: 20px; height: 20px; line-height: 18px; text-align: center; font-size: 16px; border-radius: 50%; flex-shrink: 0; }

  /* --- EXPLORER: UI PANEL --- */
  #explorerInfoPanel {
    position: absolute;
    top: 60px; /* Positioned below the tabs */
    left: 10px;
    background: rgba(255, 255, 255, 0.85);
    padding: 10px;
    border: 1px solid #ccc;
    font-size: 14px;
    border-radius: 8px;
    z-index: 50;
    box-shadow: 0 2px 10px rgba(0,0,0,0.2);
  }
   .info-group { display: flex; align-items: center; margin-bottom: 5px; }
   .info-group label { margin-right: 5px; white-space: nowrap; }
   .info-input { width: 100px; padding: 3px; border: 1px solid #ccc; border-radius: 3px; }
   #status { margin-top: 5px; color: gray; }
   hr { margin: 10px 0; border: none; border-top: 1px solid #ddd; }
   .red-text { color: red; }
   .green-text { color: green; }
   .yellow-text { color: #ff9900; }
   .gray-text { color:#666; }
   .badge { padding:1px 6px; border-radius:10px; border:1px solid #ccc; font-size:12px; margin-left:6px; }

</style>
</head>
<body>

<canvas id="mainCanvas"></canvas>

<div class="tabs-container">
    <button id="tabBuilder" class="tab-btn active">Builder</button>
    <button id="tabExplorer" class="tab-btn">Explorer</button>
</div>

<div id="builderUI" class="ui-container">
    <div id="info" class="ui-panel">
        <div class="panel-header">
            <h4>Controls</h4>
            <button class="panel-toggle-btn" data-icon="controls"></button>
        </div>
        <div class="panel-content">
          <div id="targetContainer">
            <label for="target" style="margin:0;">Target:</label>
            <input id="target" type="text" value="100" />
            <button id="autoFactorBtn" class="action-btn">Auto-Factor</button>
            <button id="clearAllBtn" class="action-btn">Clear All</button>
            <button id="shareBtn" class="action-btn">Share</button>
            <button id="newChallengeBtn" class="action-btn" style="display: none;">New Challenge</button>
          </div>
          <div><strong id="composite">Composite: 1</strong></div>
          <div id="numberInfo"></div>
          <div style="display: flex; flex-wrap: wrap; gap: 12px;">
            <div class="checkbox-container">
              <input type="checkbox" id="colorCodeToggle" />
              <label for="colorCodeToggle" style="margin:0;">Color-code primes</label>
            </div>
            <div class="checkbox-container">
              <input type="checkbox" id="challengeModeToggle" />
              <label for="challengeModeToggle" style="margin:0;">Challenge Mode</label>
            </div>
            <div class="checkbox-container">
                <input type="checkbox" id="arrangeFactorsToggle" />
                <label for="arrangeFactorsToggle" style="margin:0;">Arrange Factors</label>
            </div>
          </div>
           <div class="share-url-container">
              <label for="shareBaseUrlInput" style="margin:0; font-size: 12px;">Share/Load URL:</label>
              <input type="text" id="shareBaseUrlInput" placeholder="Paste full link and press Enter">
          </div>
          <div class="small">Pan, pinch/wheel zoom, drag blocks, tap to rotate.</div>
        </div>
    </div>

    <div id="patternTester" class="ui-panel collapsed">
        <div class="panel-header">
            <h4>Pattern Explorer</h4>
            <button class="panel-toggle-btn" data-icon="pattern"></button>
        </div>
        <div class="panel-content">
            <div class="pattern-input-row">
                <label for="patternInput" style="margin:0;">f(n) =</label>
                <input type="text" id="patternInput" value="n^2 ± (n-1)">
                <label for="nStart">from n =</label>
                <input type="number" id="nStart" value="2" style="width: 40px;">
                <label for="nEnd">to</label>
                <input type="number" id="nEnd" value="20" style="width: 40px;">
                <button id="testPatternBtn" class="action-btn">Run</button>
            </div>
            <div id="patternResults"></div>
        </div>
    </div>

    <div id="primePanelContainer" class="ui-panel">
        <div class="panel-header">
            <h4>Prime Blocks</h4>
            <button class="panel-toggle-btn" data-icon="blocks"></button>
        </div>
        <div class="panel-content">
          <div id="primeSelectorContainer">
            <label for="primeSelectorInput" style="margin:0;">Primes around:</label>
            <input type="text" id="primeSelectorInput" value="13" style="width: 60px;">
            <button id="getPrimesBtn" class="action-btn">Go</button>
          </div>
          <div id="panelRow"></div>
        </div>
    </div>

    <div id="trashCan">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg>
    </div>

    <div id="shareModal">
      <p>Share URL</p>
      <input type="text" id="shareUrlInput" readonly>
      <button id="closeShareModalBtn" class="action-btn">Close</button>
    </div>
</div>

<div id="explorerUI" class="ui-container hidden">
    <div id="explorerInfoPanel">
     <div class="info-group">
       <label for="valueInput">Total Blocks:</label>
       <input type="text" id="valueInput" class="info-input" value="1007" inputmode="text">
     </div>
     <div class="info-group">
       <label><input type="checkbox" id="primeToggle" checked> Prime check (≤ 1e12)</label>
     </div>
     <div id="status"></div>
     <hr>
     <span id="labelTotalBlocks">Total Blocks:</span> <span id="totalBlocksDisplay"></span><br>
     Width (A): <span id="width"></span><span id="widthPrime" class="badge gray-text"></span><br>
     Height (B): <span id="height"></span><span id="heightPrime" class="badge gray-text"></span><br>
     <span id="labelBlocksRemaining">Blocks Remaining:</span> <span id="blocks"></span><br>
     <span id="labelModRemainder" style="display:none;">Mod Remainder:</span> <span id="modRemainder" style="display:none;"></span><br>
     Diagonal Slope: <span id="slope"></span><br>
     Diagonal Angle: <span id="angle"></span>°<br>
     Center Point: <span id="centerPoint"></span>
    </div>
</div>

<script>
/* ---=---=---=---=---=---=---=---=---=---=--- */
/* ---         COMBINED SCRIPT AREA        --- */
/* ---=---=---=---=---=---=---=---=---=---=--- */

/* --- GLOBAL AND SHARED STATE --- */
const canvas = document.getElementById('mainCanvas');
const ctx = canvas.getContext('2d');
let currentMode = 'builder'; // 'builder' or 'explorer'

// Shared canvas transform state
let offsetX = 0, offsetY = 0;
let scale = 1;
let pointerMap = new Map(); // For multi-touch pan/zoom

// Shared configuration
const GRID_SIZE = 36; // Base grid size for Builder, adapted for Explorer

/* --- CANVAS & RESIZE SETUP --- */
function resizeCanvas(){
  const dpr = window.devicePixelRatio || 1;
  canvas.width = Math.round(window.innerWidth * dpr);
  canvas.height = Math.round(window.innerHeight * dpr);
  canvas.style.width = window.innerWidth + 'px';
  canvas.style.height = window.innerHeight + 'px';
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

/* --- MODE SWITCHING LOGIC --- */
const tabBuilder = document.getElementById('tabBuilder');
const tabExplorer = document.getElementById('tabExplorer');
const builderUI = document.getElementById('builderUI');
const explorerUI = document.getElementById('explorerUI');

function setMode(mode) {
    if (mode === currentMode) return;
    currentMode = mode;

    if (mode === 'builder') {
        tabBuilder.classList.add('active');
        tabExplorer.classList.remove('active');
        builderUI.classList.remove('hidden');
        explorerUI.classList.add('hidden');
        canvas.style.backgroundColor = 'var(--bg)';
        document.body.style.background = ''; // Reset body bg
        builder.updateComposite(); // Recalculate and check for target match
    } else { // 'explorer'
        tabBuilder.classList.remove('active');
        tabExplorer.classList.add('active');
        builderUI.classList.add('hidden');
        explorerUI.classList.remove('hidden');
        explorer.performCalculation(); // Initialize explorer state
    }
}
tabBuilder.addEventListener('click', () => setMode('builder'));
tabExplorer.addEventListener('click', () => setMode('explorer'));

/* ---=---=---=---=---=---=---=---=---=---=--- */
/* ---      PRIME BUILDER (MODE 1)       --- */
/* ---=---=---=---=---=---=---=---=---=---=--- */
const builder = (() => {
    /* STATE */
    let placedBlocks = [];
    let draggingFromPanel = null;
    let movingBlockState = null;
    let lastTapCandidate = null;

    /* UI REFS */
    const panelRow = document.getElementById('panelRow');
    const compositeEl = document.getElementById('composite');
    const numberInfoEl = document.getElementById('numberInfo');
    const targetInput = document.getElementById('target');
    const autoFactorBtn = document.getElementById('autoFactorBtn');
    const clearAllBtn = document.getElementById('clearAllBtn');
    const shareBtn = document.getElementById('shareBtn');
    const newChallengeBtn = document.getElementById('newChallengeBtn');
    const primeSelectorInput = document.getElementById('primeSelectorInput');
    const getPrimesBtn = document.getElementById('getPrimesBtn');
    const trashCan = document.getElementById('trashCan');
    const colorCodeToggle = document.getElementById('colorCodeToggle');
    const challengeModeToggle = document.getElementById('challengeModeToggle');
    const arrangeFactorsToggle = document.getElementById('arrangeFactorsToggle');
    const shareModal = document.getElementById('shareModal');
    const shareUrlInput = document.getElementById('shareUrlInput');
    const closeShareModalBtn = document.getElementById('closeShareModalBtn');
    const shareBaseUrlInput = document.getElementById('shareBaseUrlInput');
    const patternInput = document.getElementById('patternInput');
    const nStartInput = document.getElementById('nStart');
    const nEndInput = document.getElementById('nEnd');
    const testPatternBtn = document.getElementById('testPatternBtn');
    const patternResultsEl = document.getElementById('patternResults');

    /* COLOR HELPERS */
    const PREDEFINED_COLORS = {
        '1': { bg: '#dbe4f0', border: '#b2bdd1' }, '2': { bg: '#ff8787', border: '#e06a6a' }, '3': { bg: '#74c0fc', border: '#5d9ad9' }, '5': { bg: '#ffd43b', border: '#c8a62d' }, '7': { bg: '#da77f2', border: '#b561cc' }, '11': { bg: '#69db7c', border: '#52a960' }, '13': { bg: '#ff922b', border: '#c87121' }, '17': { bg: '#20c997', border: '#19a179' }, '19': { bg: '#91a7ff', border: '#7486cc' },
    };
    function getColorForPrime(prime) {
        const pStr = prime.toString();
        if (PREDEFINED_COLORS[pStr]) return PREDEFINED_COLORS[pStr];
        const hue = (Number(prime.mod(360).valueOf()) * 37) % 360;
        return { bg: `hsl(${hue}, 70%, 70%)`, border: `hsl(${hue}, 60%, 50%)` };
    }

    /* HELPERS: cell shapes and rebuild */
    function makeRowShape(prime, anchorX, anchorY){
      const n = Number(prime.valueOf());
      const cells = [];
      for(let i=0;i<n;i++) cells.push({x: anchorX + i, y: anchorY});
      return { prime: bigInt(prime), orientation: 'h', anchor:{x:anchorX,y:anchorY}, cells };
    }
    function rebuildCellsForBlock(block){
      const n = block.cells.length;
      const ax = block.anchor.x, ay = block.anchor.y;
      const arr = [];
      if(block.orientation === 'h'){
        for(let i=0;i<n;i++) arr.push({x: ax + i, y: ay});
      } else {
        for(let i=0;i<n;i++) arr.push({x: ax, y: ay + i});
      }
      block.cells = arr;
    }
    function rotateBlock(block){
      block.orientation = (block.orientation === 'h') ? 'v' : 'h';
      rebuildCellsForBlock(block);
    }

    /* PRIME NUMBER HELPERS */
    function isPrime(n) {
        n = bigInt(n);
        if (n.leq(1)) return false; if (n.leq(3)) return true;
        if (n.isEven() || n.mod(3).isZero()) return false;
        let i = bigInt(5);
        while (i.multiply(i).leq(n)) {
            if (n.mod(i).isZero() || n.mod(i.add(2)).isZero()) return false;
            i = i.add(6);
        }
        return true;
    }
    function getPrimeFactors(num) {
        let n = bigInt(num); const factors = []; if (n.leq(1)) return factors;
        while (n.isEven()) { factors.push(bigInt(2)); n = n.divide(2); }
        for (let i = bigInt(3); i.multiply(i).leq(n); i = i.add(2)) {
            while (n.mod(i).isZero()) { factors.push(i); n = n.divide(i); }
        }
        if (n.gt(1)) { factors.push(n); }
        return factors;
    }

    /* PANEL: create prime block buttons based on target */
    function renderPrimePanel(target) {
        let targetNum;
        try { targetNum = bigInt(String(target).trim()); if (targetNum.lt(2)) targetNum = bigInt(2); } catch (e) { targetNum = bigInt(13); }
        const primesToShow = new Set();
        const NUM_PRIMES_BEFORE = 2, NUM_PRIMES_AFTER = 4;
        if(isPrime(targetNum)) { primesToShow.add(targetNum.toString()); }
        let current = targetNum.prev(); let foundBefore = 0;
        while (foundBefore < NUM_PRIMES_BEFORE && current.greater(1)) { if (isPrime(current)) { primesToShow.add(current.toString()); foundBefore++; } current = current.prev(); }
        current = targetNum.next(); let foundAfter = 0; const searchLimit = current.add(500);
        while (foundAfter < NUM_PRIMES_AFTER && current.lt(searchLimit)) { if (isPrime(current)) { primesToShow.add(current.toString()); foundAfter++; } current = current.next(); }
        const finalPrimes = Array.from(new Set([ "1", "2", ...primesToShow ])).map(s => bigInt(s)).sort((a,b) => a.compareTo(b));
        panelRow.innerHTML = '';
        const useColors = colorCodeToggle.checked;
        finalPrimes.forEach(p => {
            const el = document.createElement('div');
            el.className = 'prime-block'; el.textContent = String(p); el.dataset.prime = String(p);
            if (useColors) { const colors = getColorForPrime(p); el.style.backgroundColor = colors.bg; el.style.borderColor = colors.border; }
            else { el.style.backgroundColor = ''; el.style.borderColor = ''; }
            panelRow.appendChild(el);
            el.addEventListener('pointerdown', (ev) => {
                ev.preventDefault(); if (arrangeFactorsToggle.checked) return;
                draggingFromPanel = { pointerId: ev.pointerId, prime: bigInt(String(p)), clientX: ev.clientX, clientY: ev.clientY, gridX: 0, gridY: 0, overCanvas: false };
                window.addEventListener('pointermove', panelPointerMove);
                window.addEventListener('pointerup', panelPointerUp);
            });
        });
    }

    /* TRASH CAN HELPER */
    function isOverTrash(clientX, clientY) {
        const rect = trashCan.getBoundingClientRect();
        return ( clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom );
    }

    /* PANEL drag move & up handlers */
    function panelPointerMove(e){
      if(!draggingFromPanel || e.pointerId !== draggingFromPanel.pointerId) return;
      draggingFromPanel.clientX = e.clientX; draggingFromPanel.clientY = e.clientY;
      const rect = canvas.getBoundingClientRect();
      draggingFromPanel.overCanvas = (e.clientX >= rect.left && e.clientX <= rect.right && e.clientY >= rect.top && e.clientY <= rect.bottom);
      if(draggingFromPanel.overCanvas){
        const { gx, gy } = shared.clientToGrid(e.clientX, e.clientY);
        draggingFromPanel.gridX = Math.round(gx);
        draggingFromPanel.gridY = Math.round(gy);
      }
      trashCan.classList.toggle('over-trash', isOverTrash(e.clientX, e.clientY));
      e.preventDefault();
    }
    function panelPointerUp(e){
      if(!draggingFromPanel || e.pointerId !== draggingFromPanel.pointerId) return;
      if (draggingFromPanel.overCanvas && !isOverTrash(e.clientX, e.clientY)) {
        placedBlocks.push(makeRowShape(draggingFromPanel.prime, draggingFromPanel.gridX, draggingFromPanel.gridY));
        updateComposite();
      }
      trashCan.classList.remove('over-trash'); draggingFromPanel = null;
      window.removeEventListener('pointermove', panelPointerMove);
      window.removeEventListener('pointerup', panelPointerUp);
    }

    /* DATA ANALYSIS & UPDATE */
    function getNumberProperties(factors) {
        if (factors.length === 0) return { totalFactors: 0, uniqueFactors: 0, classifications: [] };
        const counts = new Map();
        for (const p of factors) { const pStr = p.toString(); counts.set(pStr, (counts.get(pStr) || 0) + 1); }
        const classifications = []; const exponents = Array.from(counts.values());
        if (exponents.every(e => e % 2 === 0)) classifications.push('Perfect Square');
        if (exponents.every(e => e % 3 === 0)) classifications.push('Perfect Cube');
        return { totalFactors: factors.length, uniqueFactors: counts.size, classifications };
    }
    function getDivisors(n) {
        const divisors = [];
        for (let i = 1; i * i <= n; i++) {
            if (n % i === 0) { divisors.push(i); if (i * i !== n) divisors.push(n / i); }
        }
        return divisors;
    }
    function arrangeFactors() {
        if (!arrangeFactorsToggle.checked || placedBlocks.length === 0) return;
        let totalCells = 0; placedBlocks.forEach(b => totalCells += b.cells.length);
        const divisors = getDivisors(totalCells);
        let bestFit = { w: totalCells, h: 1, diff: totalCells - 1 };
        divisors.forEach(d => { const other = totalCells / d; if (Math.abs(d - other) < bestFit.diff) bestFit = { w: Math.max(d, other), h: Math.min(d, other), diff: Math.abs(d-other) }; });
        const { w, h } = bestFit; const grid = Array(h).fill().map(() => Array(w).fill(false));
        placedBlocks.sort((a, b) => b.prime.compareTo(a.prime));
        for (const block of placedBlocks) {
            let placed = false;
            for (let r = 0; r < h; r++) { for (let c = 0; c < w; c++) {
                    if (grid[r][c]) continue;
                    block.orientation = 'h'; rebuildCellsForBlock(block);
                    let canPlaceH = (c + block.cells.length <= w);
                    if (canPlaceH) { for(let i=0; i<block.cells.length; i++) if (grid[r][c+i]) { canPlaceH = false; break; } }
                    if (canPlaceH) { block.anchor.x = c; block.anchor.y = r; rebuildCellsForBlock(block); for(let i=0; i<block.cells.length; i++) grid[r][c+i] = true; placed = true; break; }
                    block.orientation = 'v'; rebuildCellsForBlock(block);
                    let canPlaceV = (r + block.cells.length <= h);
                    if (canPlaceV) { for(let i=0; i<block.cells.length; i++) if (grid[r+i][c]) { canPlaceV = false; break; } }
                    if (canPlaceV) { block.anchor.x = c; block.anchor.y = r; rebuildCellsForBlock(block); for(let i=0; i<block.cells.length; i++) grid[r+i][c] = true; placed = true; break; }
                } if(placed) break; }
             if (!placed) { block.anchor.x = 0; block.anchor.y = 0; rebuildCellsForBlock(block); }
        }
    }
    function updateComposite(){
      if (arrangeFactorsToggle.checked) arrangeFactors();
      let prod = bigInt(1), sum = bigInt(0); const primeFactors = [];
      placedBlocks.forEach(b => { prod = prod.multiply(b.prime); sum = sum.add(b.prime); primeFactors.push(b.prime); });
      compositeEl.innerHTML = `Composite: ${prod.toString()} <span style="font-weight: normal; color: #555;">[Sum: ${sum.toString()}]</span>`;
      const properties = getNumberProperties(primeFactors);
      let infoHtml = `<div><span class="info-prop">Total Factors:</span> ${properties.totalFactors} | <span class="info-prop">Unique:</span> ${properties.uniqueFactors}</div>`;
      if (properties.classifications.length > 0) infoHtml += `<div><span class="info-prop">Classification:</span> ${properties.classifications.join(', ')}</div>`;
      numberInfoEl.innerHTML = infoHtml;
      const target = bigInt(String(targetInput.value.trim() || "0"));
      document.body.style.background = (!target.isZero() && prod.equals(target)) ? '#043' : '';
    }

    /* STATE SHARING */
    function serializeState() { return placedBlocks.map(b => `${b.prime.toString()},${b.anchor.x},${b.anchor.y},${b.orientation}`).join(';'); }
    function deserializeAndLoadState(stateString) {
        if (typeof stateString !== 'string' || !stateString) return false;
        try {
            const newBlocks = [];
            stateString.split(';').forEach(blockStr => {
                if (!blockStr) return;
                const parts = blockStr.split(','); if (parts.length !== 4) return;
                const newBlock = makeRowShape(bigInt(parts[0]), parseInt(parts[1], 10), parseInt(parts[2], 10));
                if (parts[3] === 'v') rotateBlock(newBlock);
                newBlocks.push(newBlock);
            });
            placedBlocks = newBlocks;
        } catch(e) { console.error("Failed to parse state string:", e); return false; }
        updateComposite(); return true;
    }
    function loadStateFromURL() {
        if (window.location.hash) {
            try { deserializeAndLoadState(atob(window.location.hash.substring(1))); }
            catch (e) { console.error("Failed to load state from URL hash:", e); window.location.hash = ''; }
        }
    }

    /* EVENT LISTENERS */
    targetInput.addEventListener('input', updateComposite);
    autoFactorBtn.addEventListener('click', () => {
        if (challengeModeToggle.checked) return;
        try {
            const targetNum = bigInt(String(targetInput.value.trim()));
            if (targetNum.lt(2)) { placedBlocks = []; updateComposite(); return; };
            const factors = getPrimeFactors(targetNum);
            placedBlocks = factors.map(f => makeRowShape(f, 0, 0));
            updateComposite();
        } catch(e) { console.error("Invalid number for auto-factoring:", e); }
    });
    clearAllBtn.addEventListener('click', () => {
        placedBlocks = []; updateComposite();
        if (!challengeModeToggle.checked) window.location.hash = '';
    });
    shareBtn.addEventListener('click', () => {
        let baseUrl = shareBaseUrlInput.value.trim().split('#')[0] || window.location.href.split('#')[0];
        const finalUrl = baseUrl + '#' + btoa(serializeState());
        shareUrlInput.value = finalUrl; shareModal.style.display = 'block'; shareUrlInput.select();
        try { document.execCommand('copy'); shareBtn.textContent = 'Copied!'; setTimeout(() => { shareBtn.textContent = 'Share'; }, 2000); }
        catch (err) { console.error('Could not copy text: ', err); }
    });
    closeShareModalBtn.addEventListener('click', () => { shareModal.style.display = 'none'; });
    shareBaseUrlInput.addEventListener('keyup', (ev) => {
        if (ev.key === 'Enter') {
            const parts = shareBaseUrlInput.value.split('#');
            if (parts.length > 1 && parts[1]) {
                try {
                    const success = deserializeAndLoadState(atob(parts[1]));
                    if (success) { window.location.hash = parts[1]; shareBaseUrlInput.value = ''; shareBaseUrlInput.classList.remove('error'); }
                    else { shareBaseUrlInput.classList.add('error'); setTimeout(() => shareBaseUrlInput.classList.remove('error'), 1000); }
                } catch (e) { shareBaseUrlInput.classList.add('error'); setTimeout(() => shareBaseUrlInput.classList.remove('error'), 1000); }
            }
        }
    });
    const generateNewPrimes = () => renderPrimePanel(primeSelectorInput.value);
    getPrimesBtn.addEventListener('click', generateNewPrimes);
    primeSelectorInput.addEventListener('keyup', (ev) => { if (ev.key === 'Enter') generateNewPrimes(); });
    colorCodeToggle.addEventListener('change', () => renderPrimePanel(primeSelectorInput.value));

    /* CHALLENGE MODE */
    function startNewChallenge() {
        const primes = [2, 3, 5, 7, 11, 13, 2, 3, 5];
        let challengeNumber = primes[Math.floor(Math.random() * primes.length)] * primes[Math.floor(Math.random() * primes.length)];
        if (Math.random() > 0.6) challengeNumber *= primes[Math.floor(Math.random() * primes.length)];
        targetInput.value = challengeNumber; placedBlocks = []; updateComposite();
    }
    newChallengeBtn.addEventListener('click', startNewChallenge);
    challengeModeToggle.addEventListener('change', (ev) => {
        const isEnabled = ev.target.checked;
        targetInput.readOnly = isEnabled; autoFactorBtn.disabled = isEnabled;
        newChallengeBtn.style.display = isEnabled ? 'inline-block' : 'none';
        if (isEnabled) startNewChallenge();
        else { targetInput.value = '100'; placedBlocks = []; updateComposite(); }
    });
    arrangeFactorsToggle.addEventListener('change', updateComposite);

    /* PATTERN EXPLORER */
    function safeCalculate(expression, n) {
        const jsExpression = expression.replace(/[^0-9n\+\-\*\/\^\(\)\s]/g, '').replace(/\^/g, '**');
        try { return bigInt(new Function('n', 'return ' + jsExpression)(bigInt(n))); }
        catch (e) { console.error("Pattern evaluation error:", e); return null; }
    }
    testPatternBtn.addEventListener('click', () => {
        patternResultsEl.innerHTML = '';
        const formula = patternInput.value;
        const nStart = parseInt(nStartInput.value, 10), nEnd = parseInt(nEndInput.value, 10);
        if (isNaN(nStart) || isNaN(nEnd) || nStart > nEnd) { patternResultsEl.textContent = 'Invalid range.'; return; }
        const formulas = formula.includes('±') ? [formula.replace('±', '+'), formula.replace('±', '-')] : [formula];
        for (let i = nStart; i <= nEnd; i++) {
            formulas.forEach((f, idx) => {
                const result = safeCalculate(f, i);
                if (result !== null && result.gt(0)) {
                    const isP = isPrime(result);
                    const line = document.createElement('div'); line.className = 'result-line';
                    let formulaPart = `f(${i})` + (formulas.length > 1 ? (idx === 0 ? ` (+) = ${result}` : ` (-) = ${result}`) : ` = ${result}`);
                    const formulaSpan = document.createElement('span'); formulaSpan.textContent = formulaPart;
                    const statusSpan = document.createElement('span');
                    const statusText = document.createElement('span');
                    statusText.className = isP ? 'result-prime' : 'result-composite'; statusText.textContent = isP ? 'Prime' : 'Composite';
                    statusSpan.appendChild(statusText);
                    if (isP && result.lt(100)) {
                        const addButton = document.createElement('button');
                        addButton.innerHTML = `+`; addButton.className = 'action-btn add-to-grid-btn';
                        addButton.title = 'Add this prime to the grid';
                        addButton.onclick = (e) => { e.stopPropagation();
                            if (arrangeFactorsToggle.checked) placedBlocks.push(makeRowShape(result, 0, 0));
                            else { const center = shared.clientToGrid(canvas.clientWidth / 2, canvas.clientHeight / 2); placedBlocks.push(makeRowShape(result, center.gx, center.gy)); }
                            updateComposite();
                        };
                        statusSpan.appendChild(addButton);
                    }
                    line.appendChild(formulaSpan); line.appendChild(statusSpan); patternResultsEl.appendChild(line);
                }
            });
        }
    });

    /* PANEL TOGGLING */
    const ICONS = {
        controls: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg>`,
        pattern: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M13.02 5.02a8 8 0 0 0-9.04 9.04"></path><path d="M18.98 18.98a8 8 0 0 0-9.04-9.04"></path><path d="M12 2v2"></path><path d="M12 20v2"></path><path d="m4.93 4.93 1.41 1.41"></path><path d="m17.66 17.66 1.41 1.41"></path><path d="M2 12h2"></path><path d="M20 12h2"></path><path d="m6.34 17.66-1.41 1.41"></path><path d="m19.07 4.93-1.41 1.41"></path></svg>`,
        blocks: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="7" height="7"></rect><rect x="14" y="3" width="7" height="7"></rect><rect x="14" y="14" width="7" height="7"></rect><rect x="3" y="14" width="7" height="7"></rect></svg>`,
        minimize: `<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="12" x2="19" y2="12"></line></svg>`
    };
    document.querySelectorAll('.panel-toggle-btn').forEach(btn => {
        const panel = btn.closest('.ui-panel'); const iconType = btn.dataset.icon;
        btn.innerHTML = panel.classList.contains('collapsed') ? ICONS[iconType] : ICONS.minimize;
        btn.addEventListener('click', () => {
            const isCollapsed = panel.classList.toggle('collapsed');
            btn.innerHTML = isCollapsed ? ICONS[iconType] : ICONS.minimize;
        });
    });

    // --- Public methods and properties for builder ---
    return {
        init: () => {
            loadStateFromURL();
            renderPrimePanel(primeSelectorInput.value);
            if (placedBlocks.length === 0) updateComposite();
            window.addEventListener('resize', updateComposite);
        },
        updateComposite,
        draw: () => {
              const cssW = canvas.clientWidth, cssH = canvas.clientHeight;
              const startCol = Math.floor((-offsetX) / (GRID_SIZE * scale)) - 2;
              const endCol = Math.ceil((cssW - offsetX) / (GRID_SIZE * scale)) + 2;
              const startRow = Math.floor((-offsetY) / (GRID_SIZE * scale)) - 2;
              const endRow = Math.ceil((cssH - offsetY) / (GRID_SIZE * scale)) + 2;

              ctx.lineWidth = 1 / scale; ctx.strokeStyle = '#123233';
              for(let c = startCol; c <= endCol; c++){ const x = c * GRID_SIZE; ctx.beginPath(); ctx.moveTo(x + 0.5/scale, startRow*GRID_SIZE); ctx.lineTo(x + 0.5/scale, endRow*GRID_SIZE); ctx.stroke(); }
              for(let r = startRow; r <= endRow; r++){ const y = r * GRID_SIZE; ctx.beginPath(); ctx.moveTo(startCol*GRID_SIZE, y + 0.5/scale); ctx.lineTo(endCol*GRID_SIZE, y + 0.5/scale); ctx.stroke(); }

              const useColors = colorCodeToggle.checked;
              for(const block of placedBlocks){
                if (useColors) { const colors = getColorForPrime(block.prime); ctx.fillStyle = colors.bg; ctx.strokeStyle = colors.border; }
                else { ctx.fillStyle = 'rgba(0,255,102,1)'; ctx.strokeStyle = 'rgba(0,34,12,1)'; }
                for(const cell of block.cells){ const x = cell.x * GRID_SIZE, y = cell.y * GRID_SIZE; ctx.fillRect(x, y, GRID_SIZE, GRID_SIZE); ctx.strokeRect(x, y, GRID_SIZE, GRID_SIZE); }
                const mid = Math.floor(block.cells.length/2), mc = block.cells[mid];
                ctx.fillStyle = '#000'; ctx.font = `${Math.max(12, GRID_SIZE*0.38)}px system-ui`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                if (block.orientation === 'h') ctx.fillText(block.prime.toString(), (mc.x + 0.5) * GRID_SIZE, (mc.y + 0.5) * GRID_SIZE);
                else { ctx.save(); ctx.translate((mc.x + 0.5) * GRID_SIZE, (mc.y + 0.5) * GRID_SIZE); ctx.rotate(-Math.PI / 2); ctx.fillText(block.prime.toString(), 0, 0); ctx.restore(); }
              }
              if (movingBlockState) {
                const block = movingBlockState.block;
                if (useColors) { const colors = getColorForPrime(block.prime); ctx.fillStyle = colors.bg; ctx.strokeStyle = colors.border; }
                else { ctx.fillStyle = 'rgba(0,255,102,1)'; ctx.strokeStyle = 'rgba(0,34,12,1)'; }
                ctx.globalAlpha = 0.75;
                for(const cell of block.cells){ const x = cell.x * GRID_SIZE, y = cell.y * GRID_SIZE; ctx.fillRect(x + 1, y + 1, GRID_SIZE - 2, GRID_SIZE - 2); ctx.strokeRect(x + 1, y + 1, GRID_SIZE - 2, GRID_SIZE - 2); }
                const mid = Math.floor(block.cells.length/2), mc = block.cells[mid];
                ctx.fillStyle = '#000'; ctx.fillText(block.prime.toString(), (mc.x + 0.5) * GRID_SIZE, (mc.y + 0.5) * GRID_SIZE);
                ctx.globalAlpha = 1.0;
              }
              if(draggingFromPanel && draggingFromPanel.overCanvas){
                const n = Number(draggingFromPanel.prime.valueOf()), ax = draggingFromPanel.gridX, ay = draggingFromPanel.gridY;
                ctx.globalAlpha = isOverTrash(draggingFromPanel.clientX, draggingFromPanel.clientY) ? 0.2 : 0.65;
                if (useColors) { const colors = getColorForPrime(draggingFromPanel.prime); ctx.fillStyle = colors.bg; ctx.strokeStyle = colors.border; }
                else { ctx.fillStyle = 'rgba(0,200,120,0.95)'; ctx.strokeStyle = 'rgba(0,36,12,0.95)'; }
                for(let i=0;i<n;i++){ const cx = (ax + i) * GRID_SIZE, cy = ay * GRID_SIZE; ctx.fillRect(cx + 1, cy + 1, GRID_SIZE - 2, GRID_SIZE - 2); ctx.strokeRect(cx + 1, cy + 1, GRID_SIZE - 2, GRID_SIZE - 2); }
                ctx.globalAlpha = 1; ctx.fillStyle = '#000'; ctx.font = `${Math.max(12,GRID_SIZE*0.36)}px system-ui`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                const midCell = { x: ax + Math.floor(n/2), y: ay };
                ctx.fillText(draggingFromPanel.prime.toString(), (midCell.x + 0.5) * GRID_SIZE, (midCell.y + 0.5) * GRID_SIZE);
              }
        },
        pointerDown: (ev) => {
            if(draggingFromPanel && ev.pointerId === draggingFromPanel.pointerId) return;
            const { gx, gy } = shared.clientToGrid(ev.clientX, ev.clientY);
            for(let i = placedBlocks.length - 1; i >= 0; i--){
                const block = placedBlocks[i];
                if(block.cells.some(c => c.x === gx && c.y === gy)){
                    if (arrangeFactorsToggle.checked) lastTapCandidate = { pointerId: ev.pointerId, clientX: ev.clientX, clientY: ev.clientY, time: Date.now(), block: block };
                    else {
                        movingBlockState = { pointerId: ev.pointerId, block: block, originalIndex: i, offsetCellX: gx - block.anchor.x, offsetCellY: gy - block.anchor.y };
                        placedBlocks.splice(i, 1);
                        lastTapCandidate = { pointerId: ev.pointerId, clientX: ev.clientX, clientY: ev.clientY, time: Date.now() };
                    }
                    try{ canvas.setPointerCapture(ev.pointerId); }catch(e){} return;
                }
            }
            lastTapCandidate = { pointerId: ev.pointerId, clientX: ev.clientX, clientY: ev.clientY, time: Date.now() };
            try{ canvas.setPointerCapture(ev.pointerId); }catch(e){}
        },
        pointerMove: (ev) => {
            if(draggingFromPanel && ev.pointerId === draggingFromPanel.pointerId) return true;
            if(movingBlockState && ev.pointerId === movingBlockState.pointerId){
              const { gx, gy } = shared.clientToGrid(ev.clientX, ev.clientY);
              movingBlockState.block.anchor.x = gx - movingBlockState.offsetCellX;
              movingBlockState.block.anchor.y = gy - movingBlockState.offsetCellY;
              rebuildCellsForBlock(movingBlockState.block); updateComposite();
              trashCan.classList.toggle('over-trash', isOverTrash(ev.clientX, ev.clientY));
              return true; // Event was handled
            }
            return false; // Event was not handled
        },
        pointerUp: (ev) => {
            if(movingBlockState && lastTapCandidate && movingBlockState.pointerId === ev.pointerId && lastTapCandidate.pointerId === ev.pointerId){
                const wasMoving = movingBlockState; movingBlockState = null;
                const dt = Date.now() - lastTapCandidate.time;
                const isTap = dt < 350 && (Math.abs(ev.clientX - lastTapCandidate.clientX) <= 8 && Math.abs(ev.clientY - lastTapCandidate.clientY) <= 8);
                if (isTap && !arrangeFactorsToggle.checked) { placedBlocks.push(wasMoving.block); rotateBlock(wasMoving.block); }
                else if (!isOverTrash(ev.clientX, ev.clientY)) {
                    if (!arrangeFactorsToggle.checked) { wasMoving.block.anchor.x = Math.round(wasMoving.block.anchor.x); wasMoving.block.anchor.y = Math.round(wasMoving.block.anchor.y); rebuildCellsForBlock(wasMoving.block); }
                    placedBlocks.push(wasMoving.block);
                }
                trashCan.classList.remove('over-trash'); updateComposite(); lastTapCandidate = null; return;
            }
            if(lastTapCandidate && lastTapCandidate.pointerId === ev.pointerId && arrangeFactorsToggle.checked){
                const isTap = (Date.now() - lastTapCandidate.time) < 350 && (Math.abs(ev.clientX - lastTapCandidate.clientX) <= 8 && Math.abs(ev.clientY - lastTapCandidate.clientY) <= 8);
                if(isTap && lastTapCandidate.block) { rotateBlock(lastTapCandidate.block); updateComposite(); }
            }
            lastTapCandidate = null;
        }
    };
})();

/* ---=---=---=---=---=---=---=---=---=---=--- */
/* ---     PRIME EXPLORER (MODE 2)       --- */
/* ---=---=---=---=---=---=---=---=---=---=--- */
const explorer = (() => {
    /* STATE */
    let rect = {x: 2, y: 2, w: 0, h: 0};
    let handles = [];
    let activeHandle = null;
    let isPanning = false;
    let fireworks = [];
    let isSuccessState = false;

    // Big number calculation state
    let totalBlocks = bigInt(1007), originalInput = bigInt(1007);
    let totalBase = null, totalExponent = null, totalMultiplication = null, totalAddition = null;
    let exactWidth = bigInt(0), exactHeight = bigInt(0);
    let isBigNumberMode = false;
    const logarithmicThreshold = 75;

    /* UI REFS */
    const valueInput = document.getElementById('valueInput');
    const statusDiv = document.getElementById('status');
    const totalBlocksDisplay = document.getElementById('totalBlocksDisplay');
    const infoWidth = document.getElementById('width');
    const infoHeight = document.getElementById('height');
    const infoBlocks = document.getElementById('blocks');
    const infoModRemainder = document.getElementById('modRemainder');
    const labelTotalBlocks = document.getElementById('labelTotalBlocks');
    const labelBlocksRemaining = document.getElementById('labelBlocksRemaining');
    const labelModRemainder = document.getElementById('labelModRemainder');
    const infoSlope = document.getElementById('slope');
    const infoAngle = document.getElementById('angle');
    const infoCenterPoint = document.getElementById('centerPoint');
    const widthPrimeEl  = document.getElementById('widthPrime');
    const heightPrimeEl = document.getElementById('heightPrime');
    const primeToggleEl = document.getElementById('primeToggle');

    /* AUDIO & VISUALS */
    let synth = null, reverb = null;
    async function initializeAudio() {
       try {
           await Tone.start();
           synth = new Tone.PolySynth(Tone.Synth, { oscillator: { type: "sine" }, envelope: { attack: 0.05, decay: 0.2, sustain: 0.1, release: 0.5 } }).toDestination();
           reverb = new Tone.Reverb(2).toDestination(); synth.connect(reverb);
       } catch (e) { console.error("Audio initialization failed:", e); }
    }
    function playSynthChord() {
       if (!synth) return;
       const now = Tone.now(); const chord = ["C4", "E4", "G4"];
       synth.triggerAttackRelease(chord, "8n", now); synth.triggerAttackRelease(chord, "8n", now + 0.2); synth.triggerAttackRelease(chord, "8n", now + 0.4);
    }
    const FIREWORK_COUNT = 300, FIREWORK_LIFETIME = 240, FIREWORK_MAX_VELOCITY_FACTOR = 0.02;
    function createFireworks() {
     fireworks = []; const maxVel = Math.max(canvas.width, canvas.height) * FIREWORK_MAX_VELOCITY_FACTOR;
     for (let i = 0; i < FIREWORK_COUNT; i++) fireworks.push({ x: canvas.width / 2, y: canvas.height / 2, vx: (Math.random() - 0.5) * maxVel, vy: (Math.random() - 0.5) * maxVel, radius: 5, color: `hsl(${Math.random() * 360}, 100%, 50%)`, alpha: 1, life: FIREWORK_LIFETIME });
    }
    function drawFireworks() {
     for (let i = fireworks.length - 1; i >= 0; i--) {
       let p = fireworks[i]; p.x += p.vx; p.y += p.vy; p.vy += 0.05; p.alpha -= 1 / FIREWORK_LIFETIME; p.life--;
       if (p.life <= 0) { fireworks.splice(i, 1); continue; }
       ctx.fillStyle = p.color; ctx.globalAlpha = p.alpha; ctx.beginPath(); ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2); ctx.fill();
     }
     ctx.globalAlpha = 1;
    }

    /* MATH HELPERS */
    function customSqrt(n) {
     if (n.isNegative()) return bigInt(-1); if (n.leq(1)) return n;
     let x = n.divide(2), y = n.divide(x);
     while (x.greater(y)) { x = x.add(y).divide(2); y = n.divide(x); }
     return x.times(x).greater(n) ? x.minus(1) : x;
    }
    function dist(x1, y1, x2, y2) { return Math.hypot(x2 - x1, y2 - y1); }

    /* PRIME CHECKING */
    const PRIME_CHECK_LIMIT = bigInt("1000000000000");
    const SMALL_PRIMES = [2,3,5,7,11,13,17,19,23,29,31];
    const MR_BASES = [2,3,5,7,11];
    const primeCache = new Map();
    function millerRabin(n) {
     if (n.lesser(2)) return false; if (n.equals(2)) return true; if (n.isEven()) return false;
     let d = n.minus(1), s = 0;
     while (d.isEven()) { d = d.divide(2); s++; }
     for (const a of MR_BASES) {
       const A = bigInt(a); if (A.greaterOrEquals(n)) continue;
       let x = A.modPow(d, n); if (x.equals(1) || x.equals(n.minus(1))) continue;
       let cont = false;
       for (let r = 1; r < s; r++) { x = x.multiply(x).mod(n); if (x.equals(n.minus(1))) { cont = true; break; } }
       if (!cont) return false;
     }
     return true;
    }
    function primeStatus(n) {
     const key = n.toString(); if (primeCache.has(key)) return primeCache.get(key);
     if (n.lesser(2)) { primeCache.set(key, "composite"); return "composite"; }
     if (n.greater(PRIME_CHECK_LIMIT)) { primeCache.set(key, "too-large"); return "too-large"; }
     for (const p of SMALL_PRIMES) { const bp = bigInt(p); if (n.equals(bp)) { primeCache.set(key, "prime"); return "prime"; } if (n.mod(bp).isZero()) { primeCache.set(key, "composite"); return "composite"; } }
     const res = millerRabin(n) ? "prime" : "composite";
     primeCache.set(key, res); return res;
    }
    function setPrimeBadge(el, status) {
     if (!el) return;
     if (status === "prime")   { el.textContent = "Prime"; el.className = "badge green-text"; }
     else if (status === "composite") { el.textContent = "Composite"; el.className = "badge red-text"; }
     else { el.textContent = "Too large"; el.className = "badge gray-text"; }
    }

    /* UI UPDATE */
    let lastWidthStr = "", lastHeightStr = "";
    function updateInfo() {
         const blocksUsed = exactWidth.times(exactHeight);
         let isWidthDivisible = false, isHeightDivisible = false;
         if (!isBigNumberMode) {
           isWidthDivisible = exactWidth.greater(0) && originalInput.mod(exactWidth).isZero();
           isHeightDivisible = exactHeight.greater(0) && originalInput.mod(exactHeight).isZero();
         } else if (totalBase !== null) {
           if (exactWidth.greater(0)) {
               let rem = totalMultiplication.mod(exactWidth).multiply(totalBase.modPow(totalExponent, exactWidth)).plus(totalAddition).mod(exactWidth);
               if (rem.isNegative()) rem = rem.add(exactWidth); isWidthDivisible = rem.isZero();
           }
           if (exactHeight.greater(0)) {
               let rem = totalMultiplication.mod(exactHeight).multiply(totalBase.modPow(totalExponent, exactHeight)).plus(totalAddition).mod(exactHeight);
               if (rem.isNegative()) rem = rem.add(exactHeight); isHeightDivisible = rem.isZero();
           }
         }
         infoWidth.className = isWidthDivisible ? "green-text" : "red-text";
         infoHeight.className = isHeightDivisible ? "green-text" : "red-text";

         if (isBigNumberMode) {
           labelTotalBlocks.style.display = 'inline'; labelBlocksRemaining.style.display = 'none'; labelModRemainder.style.display = 'inline';
           infoBlocks.style.display = 'none'; infoModRemainder.style.display = 'inline';
           let baseStr = totalBase.toString(), multStr = totalMultiplication.toString();
           let addStr = totalAddition.isNegative() ? " - 1" : totalAddition.isZero() ? "" : " + " + totalAddition.toString();
           totalBlocksDisplay.innerText = (multStr === "1") ? `${baseStr}^${shared.formatNumberWithCommas(totalExponent)}${addStr}` : `${multStr}*${baseStr}^${shared.formatNumberWithCommas(totalExponent)}${addStr}`;
           if (blocksUsed.isZero()) infoModRemainder.innerText = "N/A";
           else {
               let totalRemainder = totalMultiplication.mod(blocksUsed).multiply(totalBase.modPow(totalExponent, blocksUsed)).plus(totalAddition).mod(blocksUsed);
               if (totalRemainder.isNegative()) totalRemainder = totalRemainder.add(blocksUsed);
               infoModRemainder.innerText = shared.formatNumberWithCommas(totalRemainder); infoModRemainder.className = totalRemainder.isZero() ? "green-text" : "red-text";
           }
         } else {
           labelTotalBlocks.style.display = 'inline'; labelBlocksRemaining.style.display = 'inline'; labelModRemainder.style.display = 'none';
           infoBlocks.style.display = 'inline'; infoModRemainder.style.display = 'none';
           totalBlocksDisplay.innerText = shared.formatNumberWithCommas(totalBlocks);
           const blocksRemaining = totalBlocks.minus(blocksUsed);
           infoBlocks.innerText = shared.formatNumberWithCommas(blocksRemaining); infoBlocks.className = blocksRemaining.isZero() ? "green-text" : "red-text";
         }
         infoWidth.innerText = shared.formatNumberWithCommas(exactWidth); infoHeight.innerText = shared.formatNumberWithCommas(exactHeight);
         infoSlope.innerText = (rect.h / rect.w).toFixed(2); infoAngle.innerText = (Math.atan2(rect.h, rect.w) * 180 / Math.PI).toFixed(1);
         infoCenterPoint.innerText = `(${(rect.x + rect.w / 2).toFixed(2)}, ${(rect.y + rect.h / 2).toFixed(2)})`;
         if (primeToggleEl.checked) {
           const wStr = exactWidth.toString(), hStr = exactHeight.toString();
           if (wStr !== lastWidthStr) { lastWidthStr = wStr; setPrimeBadge(widthPrimeEl, primeStatus(exactWidth)); }
           if (hStr !== lastHeightStr) { lastHeightStr = hStr; setPrimeBadge(heightPrimeEl, primeStatus(exactHeight)); }
         } else { setPrimeBadge(widthPrimeEl, "too-large"); setPrimeBadge(heightPrimeEl, "too-large"); }
    }
    function updateHandles() {
        handles = [ {x: rect.x, y: rect.y, name: "tl"}, {x: rect.x + rect.w, y: rect.y, name: "tr"}, {x: rect.x, y: rect.y + rect.h, name: "bl"}, {x: rect.x + rect.w, y: rect.y + rect.h, name: "br"} ];
    }
    function parseInput(inputString) {
        const sanitized = inputString.replace(/\s/g, '');
        const prothPattern = /^(\d+)\*2\^(\d+)\+1$/, mersennePattern = /^2\^(\d+)-1$/, powerPattern = /^(\d+)\^(.+?)(?:\+(\d+))?$/;
        let match;
        if ((match = sanitized.match(prothPattern))) {
            const n = bigInt(match[2]);
            if (n.geq(logarithmicThreshold)) return { type: 'bigNumber', base: bigInt(2), exponent: n, multiplication: bigInt(match[1]), addition: bigInt(1) };
            return { type: 'number', total: bigInt(match[1]).multiply(bigInt(2).pow(n)).plus(1) };
        }
        if ((match = sanitized.match(mersennePattern))) {
            const exp = bigInt(match[1]);
            if (exp.geq(logarithmicThreshold)) return { type: 'bigNumber', base: bigInt(2), exponent: exp, multiplication: bigInt(1), addition: bigInt(-1) };
            return { type: 'number', total: bigInt(2).pow(exp).minus(1) };
        }
        if ((match = sanitized.match(powerPattern))) {
            const exp = bigInt(match[2]);
            if (exp.geq(logarithmicThreshold)) return { type: 'bigNumber', base: bigInt(match[1]), exponent: exp, multiplication: bigInt(1), addition: match[3] ? bigInt(match[3]) : bigInt(0) };
            return { type: 'number', total: bigInt(match[1]).pow(exp).plus(match[3] ? bigInt(match[3]) : bigInt(0)) };
        }
        return { type: 'number', total: bigInt(sanitized) };
    }
    function performCalculation() {
        statusDiv.innerText = "Calculating...";
        try {
            const result = parseInput(valueInput.value);
            isBigNumberMode = (result.type === 'bigNumber');
            if (isBigNumberMode) {
                originalInput = bigInt(0); totalBase = result.base; totalExponent = result.exponent; totalMultiplication = result.multiplication; totalAddition = result.addition;
                totalBlocks = null; exactWidth = totalExponent; exactHeight = totalExponent;
            } else {
                originalInput = result.total; totalBase = null; totalExponent = null; totalMultiplication = null; totalAddition = null;
                totalBlocks = result.total; if (totalBlocks.isNegative()) { statusDiv.innerText = "Error: Input must be non-negative."; return; }
                const side = customSqrt(totalBlocks); exactWidth = side; exactHeight = side;
            }
            rect.w = exactWidth.valueOf(); rect.h = exactHeight.valueOf();
            const padding = 1.2;
            const requiredScaleX = canvas.width / (rect.w * GRID_SIZE * padding);
            const requiredScaleY = canvas.height / (rect.h * GRID_SIZE * padding);
            scale = Math.min(requiredScaleX, requiredScaleY);
            offsetX = (canvas.width / 2) - ((rect.x + rect.w / 2) * GRID_SIZE * scale);
            offsetY = (canvas.height / 2) - ((rect.y + rect.h / 2) * GRID_SIZE * scale);
            updateHandles(); statusDiv.innerText = "Calculation complete.";
        } catch (error) { statusDiv.innerText = "Error: Invalid input format."; }
    }
    valueInput.addEventListener('keyup', (ev) => { if (ev.key === 'Enter') performCalculation(); });

    // --- Public methods and properties for explorer ---
    return {
        init: () => {
            initializeAudio();
            performCalculation();
        },
        performCalculation,
        draw: () => {
             let isWidthDivisible = false, isHeightDivisible = false;
             if (!isBigNumberMode) {
               isWidthDivisible = exactWidth.greater(0) && originalInput.mod(exactWidth).isZero(); isHeightDivisible = exactHeight.greater(0) && originalInput.mod(exactHeight).isZero();
             } else if (totalBase !== null) {
               if (exactWidth.greater(0)) { let rem = totalMultiplication.mod(exactWidth).multiply(totalBase.modPow(totalExponent, exactWidth)).plus(totalAddition).mod(exactWidth); if (rem.isNegative()) rem = rem.add(exactWidth); isWidthDivisible = rem.isZero(); }
               if (exactHeight.greater(0)) { let rem = totalMultiplication.mod(exactHeight).multiply(totalBase.modPow(totalExponent, exactHeight)).plus(totalAddition).mod(exactHeight); if (rem.isNegative()) rem = rem.add(exactHeight); isHeightDivisible = rem.isZero(); }
             }
             const blocksMatch = isBigNumberMode ? (infoModRemainder.className === 'green-text' && !infoModRemainder.innerText.includes('N/A')) : exactWidth.times(exactHeight).equals(originalInput);
             const bothFactors = isWidthDivisible && isHeightDivisible && blocksMatch;
             const oneFactor = isWidthDivisible ^ isHeightDivisible;

             if (bothFactors) { canvas.style.backgroundColor = "lime"; if (!isSuccessState) { createFireworks(); playSynthChord(); isSuccessState = true; } }
             else if (oneFactor) { canvas.style.backgroundColor = "yellow"; isSuccessState = false; }
             else { canvas.style.backgroundColor = "#fff"; isSuccessState = false; }

             drawFireworks();
             const minX = -offsetX / scale / GRID_SIZE, maxX = (canvas.width - offsetX) / scale / GRID_SIZE;
             const minY = -offsetY / scale / GRID_SIZE, maxY = (canvas.height - offsetY) / scale / GRID_SIZE;
             const isLogarithmic = (isBigNumberMode && totalExponent.geq(logarithmicThreshold));
             ctx.strokeStyle = "#ddd"; ctx.lineWidth = 1/scale;
             const gridDrawer = (isLogarithmic) ?
                (ticks, drawFunc) => ticks.forEach(tick => drawFunc(tick * GRID_SIZE)) :
                (ticks, drawFunc) => ticks.forEach(tick => drawFunc(tick * GRID_SIZE));

             const xScale = isLogarithmic ? d3.scaleLog().domain([Math.max(1, minX), maxX]).range([Math.max(1, minX), maxX]) : d3.scaleLinear().domain([minX, maxX]).range([minX, maxX]);
             const yScale = isLogarithmic ? d3.scaleLog().domain([Math.max(1, minY), maxY]).range([Math.max(1, minY), maxY]) : d3.scaleLinear().domain([minY, maxY]).range([minY, maxY]);

             gridDrawer(xScale.ticks(), x => { ctx.beginPath(); ctx.moveTo(x, minY * GRID_SIZE); ctx.lineTo(x, maxY * GRID_SIZE); ctx.stroke(); });
             gridDrawer(yScale.ticks(), y => { ctx.beginPath(); ctx.moveTo(minX * GRID_SIZE, y); ctx.lineTo(maxX * GRID_SIZE, y); ctx.stroke(); });

             ctx.strokeStyle = "blue"; ctx.lineWidth = 2/scale;
             ctx.strokeRect(rect.x * GRID_SIZE, rect.y * GRID_SIZE, rect.w * GRID_SIZE, rect.h * GRID_SIZE);
             ctx.strokeStyle = "red"; ctx.beginPath(); ctx.moveTo(rect.x * GRID_SIZE, rect.y * GRID_SIZE); ctx.lineTo((rect.x + rect.w) * GRID_SIZE, (rect.y + rect.h) * GRID_SIZE); ctx.stroke();
             ctx.strokeStyle = "green"; ctx.beginPath(); ctx.moveTo((rect.x + rect.w) * GRID_SIZE, rect.y * GRID_SIZE); ctx.lineTo(rect.x * GRID_SIZE, (rect.y + rect.h) * GRID_SIZE); ctx.stroke();
             if (!isBigNumberMode && totalBlocks.greater(0)) {
                 const side = customSqrt(totalBlocks);
                 ctx.strokeStyle = "yellow"; ctx.lineWidth = 2 / scale; ctx.setLineDash([10 / scale, 10 / scale]);
                 ctx.strokeRect(rect.x * GRID_SIZE, rect.y * GRID_SIZE, side.valueOf() * GRID_SIZE, side.valueOf() * GRID_SIZE);
                 ctx.setLineDash([]);
             }
             let handleSize = Math.max(10, 10/scale);
             for (let h of handles) { ctx.fillStyle = (activeHandle && activeHandle.name === h.name) ? "blue" : "orange"; ctx.fillRect(h.x * GRID_SIZE - handleSize/2, h.y * GRID_SIZE - handleSize/2, handleSize, handleSize); }
             updateInfo();
        },
        pointerDown: (ev) => {
            let mx = (ev.clientX - offsetX) / scale, my = (ev.clientY - offsetY) / scale;
            for (let h of handles) { if (dist(mx, my, h.x * GRID_SIZE, h.y * GRID_SIZE) < Math.max(20, 20/scale)) { activeHandle = h; return; } }
            isPanning = true;
        },
        pointerMove: (ev) => {
            if (activeHandle) {
                let mx = (ev.clientX - offsetX) / scale / GRID_SIZE;
                let my = (ev.clientY - offsetY) / scale / GRID_SIZE;
                if (activeHandle.name === "tl") { rect.w = rect.w + rect.x - mx; rect.h = rect.h + rect.y - my; rect.x = mx; rect.y = my; }
                else if (activeHandle.name === "tr") { rect.w = mx - rect.x; rect.h = rect.h + rect.y - my; rect.y = my; }
                else if (activeHandle.name === "bl") { rect.w = rect.w + rect.x - mx; rect.x = mx; rect.h = my - rect.y; }
                else if (activeHandle.name === "br") { rect.w = mx - rect.x; rect.h = my - rect.y;
                    const panThresholdX = canvas.clientWidth * 0.10, panThresholdY = canvas.clientHeight * 0.10, panSpeed = 1.5;
                    if (ev.clientX < panThresholdX) offsetX += (panThresholdX - ev.clientX) * panSpeed;
                    if (ev.clientX > canvas.clientWidth - panThresholdX) offsetX -= (ev.clientX - (canvas.clientWidth - panThresholdX)) * panSpeed;
                    if (ev.clientY > canvas.clientHeight - panThresholdY) offsetY -= (ev.clientY - (canvas.clientHeight - panThresholdY)) * panSpeed;
                }
                rect.w = Math.max(1, rect.w); rect.h = Math.max(1, rect.h);
                exactWidth = bigInt(Math.round(rect.w)); exactHeight = bigInt(Math.round(rect.h));
                updateHandles();
                return true; // Event was handled
            }
            return false; // Event was not handled
        },
        pointerUp: (ev) => {
            if (activeHandle) {
                rect.w = Math.round(rect.w); rect.h = Math.round(rect.h);
                exactWidth = bigInt(rect.w); exactHeight = bigInt(rect.h);
                updateHandles();
            }
            activeHandle = null; isPanning = false;
        }
    };
})();

/* ---=---=---=---=---=---=---=---=---=---=--- */
/* ---        SHARED EVENT HANDLERS        --- */
/* ---=---=---=---=---=---=---=---=---=---=--- */
const shared = (() => {
    let lastPan = null;
    let pinchPrev = null;

    function clientToGrid(clientX, clientY){
      const rect = canvas.getBoundingClientRect();
      const cssX = clientX - rect.left - offsetX;
      const cssY = clientY - rect.top - offsetY;
      const gx = Math.floor(cssX / (GRID_SIZE * scale));
      const gy = Math.floor(cssY / (GRID_SIZE * scale));
      return { gx, gy, cssX, cssY };
    }

    function formatNumberWithCommas(bigIntNumber) {
        if (!bigIntNumber) return "";
        return bigIntNumber.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
    }

    canvas.addEventListener('pointerdown', (ev) => {
        pointerMap.set(ev.pointerId, { clientX: ev.clientX, clientY: ev.clientY });
        if (currentMode === 'builder') builder.pointerDown(ev);
        else explorer.pointerDown(ev);
        try{ canvas.setPointerCapture(ev.pointerId); }catch(e){}
    });

    canvas.addEventListener('pointermove', (ev) => {
        if (!pointerMap.has(ev.pointerId)) return;
        pointerMap.set(ev.pointerId, { clientX: ev.clientX, clientY: ev.clientY });

        // Handle multi-touch pinch first
        if (pointerMap.size >= 2) {
            const pts = Array.from(pointerMap.values());
            const newDist = Math.hypot(pts[0].clientX - pts[1].clientX, pts[0].clientY - pts[1].clientY);
            if (!pinchPrev) {
                pinchPrev = { dist: newDist, midX: (pts[0].clientX + pts[1].clientX)/2, midY: (pts[0].clientY + pts[1].clientY)/2 };
                return;
            }
            const factor = newDist / pinchPrev.dist; if (!isFinite(factor) || factor <= 0) return;
            const midX = (pts[0].clientX + pts[1].clientX)/2, midY = (pts[0].clientY + pts[1].clientY)/2;
            const rect = canvas.getBoundingClientRect();
            offsetX = (midX - rect.left) - ( ((midX - rect.left) - offsetX) * factor );
            offsetY = (midY - rect.top) - ( ((midY - rect.top) - offsetY) * factor );
            scale *= factor;
            pinchPrev.dist = newDist;
            lastPan = null; // Prevent panning after pinch
            return;
        }

        // Handle single-touch actions
        if (pointerMap.size === 1) {
            let handledByMode = false;
            if (currentMode === 'builder') {
                handledByMode = builder.pointerMove(ev);
            } else { // 'explorer'
                handledByMode = explorer.pointerMove(ev);
            }

            // If not handled by a specific mode action (like dragging a block/handle), then pan.
            if (!handledByMode) {
                const p = pointerMap.values().next().value;
                if (!lastPan) {
                    lastPan = { x: p.clientX, y: p.clientY };
                } else {
                    offsetX += p.clientX - lastPan.x;
                    offsetY += p.clientY - lastPan.y;
                    lastPan = { x: p.clientX, y: p.clientY };
                }
            }
        }
    });

    canvas.addEventListener('pointerup', (ev) => {
        pointerMap.delete(ev.pointerId);
        try { canvas.releasePointerCapture(ev.pointerId); } catch(e) {}

        if (currentMode === 'builder') builder.pointerUp(ev);
        else explorer.pointerUp(ev);

        if (pointerMap.size < 2) pinchPrev = null;
        if (pointerMap.size < 1) lastPan = null;
    });

    canvas.addEventListener('wheel', (ev) => {
        ev.preventDefault();
        const factor = 1 + (ev.deltaY < 0 ? 1 : -1) * 0.1;
        const rect = canvas.getBoundingClientRect();
        offsetX = (ev.clientX-rect.left) - (((ev.clientX-rect.left) - offsetX) * factor);
        offsetY = (ev.clientY-rect.top) - (((ev.clientY-rect.top) - offsetY) * factor);
        scale *= factor;
    });

    return { clientToGrid, formatNumberWithCommas };
})();


/* --- MAIN DRAW LOOP --- */
function drawLoop(){
  ctx.clearRect(0,0,canvas.clientWidth, canvas.clientHeight);
  ctx.save();
  ctx.translate(offsetX, offsetY);
  ctx.scale(scale, scale);

  if (currentMode === 'builder') {
      builder.draw();
  } else {
      explorer.draw();
  }

  ctx.restore();
  requestAnimationFrame(drawLoop);
}

/* --- INITIALIZATION --- */
builder.init();
explorer.init(); // Initialize both, but only one is visible
setMode('builder'); // Set the default mode
requestAnimationFrame(drawLoop);

</script>
</body>
</html>
