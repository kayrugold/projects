<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D Elliptical Factor Explorer (Three.js)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/big-integer@1.6.48/BigInteger.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background-color: #0d0d1a;
            color: #f0f0f0;
            font-family: 'Inter', sans-serif;
            touch-action: none; /* Disable browser gestures for smooth 3D control */
        }
        #info {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 15px;
            border-radius: 8px;
            z-index: 10;
            max-width: 90%;
            text-align: center;
            font-size: 14px;
        }
        input[type=text] {
            width: 80px;
            padding: 4px;
            margin: 0 5px;
            border-radius: 4px;
            border: 1px solid #5d5d81;
            background-color: #3e3e6e;
            color: #ffffff;
        }
        .result {
            margin-top: 5px;
            font-weight: bold;
        }
        .factor { color: #00ff00; }
        .non-factor { color: #ff8c00; }
    </style>
</head>
<body>
    <div id="info">
        N = (<input type="text" id="baseInput" value="10">^<input type="text" id="exponentInput" value="10">) + <input type="text" id="addendInput" value="7">
        <button onclick="updateSystem()">Update N</button>
        <div class="result">
            Status: <span id="status">Ready</span><br>
            Checking Prime (p): <span id="currentPrime">0</span>
        </div>
    </div>
    <div id="container"></div>

    <script>
        // --- Setup and Constants ---
        const P_LIMIT = 500; // Max prime to check (for visualization purposes)
        const ORBIT_RADIUS = 100;
        const BLACK_HOLE_SIZE = 5;
        
        // --- Global State ---
        let N_Base = bigInt(10);
        let N_Exp = bigInt(10);
        let N_Add = bigInt(7);
        let N_Value = bigInt(0);
        let primes = [];
        let primeObjects = [];
        let primeIndex = 0;
        let rotationSpeed = 0.005;

        // --- Three.js Variables ---
        let scene, camera, renderer, starSystem;
        let lastTouchX, lastTouchY;
        let isDragging = false;

        // --- DOM Elements ---
        const statusDisplay = document.getElementById('status');
        const currentPrimeDisplay = document.getElementById('currentPrime');
        const container = document.getElementById('container');
        const baseInput = document.getElementById('baseInput');
        const exponentInput = document.getElementById('exponentInput');
        const addendInput = document.getElementById('addendInput');

        // --- Utility Functions ---

        function parseBigInt(str) {
            str = String(str).replace(/\s/g, '');
            if (str.includes('e') || str.includes('E')) {
                const parts = str.toLowerCase().split('e');
                return bigInt(parts[0]).multiply(bigInt(10).pow(bigInt(parts[1])));
            }
            return bigInt(str);
        }

        // --- Factor Math (The Real Check) ---

        function powMod(base, exp, mod) {
            let result = bigInt(1);
            base = base.mod(mod);
            while (exp.greater(0)) {
                if (exp.isOdd()) {
                    result = result.multiply(base).mod(mod);
                }
                exp = exp.divide(2);
                base = base.square().mod(mod);
            }
            return result;
        }

        function checkFactor(p) {
            if (N_Value.isZero()) return false;
            if (p.lesserOrEquals(1)) return false;

            try {
                // N = a^b + c
                const remPow = powMod(N_Base, N_Exp, p);
                const finalRem = remPow.add(N_Add).mod(p);
                return finalRem.isZero();
            } catch (e) {
                console.error("Factor check error:", e);
                return false;
            }
        }

        // --- Prime Generation (Sieve) ---

        function generatePrimes(limit) {
            const sieve = new Array(limit + 1).fill(true);
            sieve[0] = sieve[1] = false;
            for (let i = 2; i * i <= limit; i++) {
                if (sieve[i]) {
                    for (let j = i * i; j <= limit; j += i) sieve[j] = false;
                }
            }
            const primesList = [];
            for (let i = 2; i <= limit; i++) {
                if (sieve[i]) primesList.push(bigInt(i));
            }
            return primesList;
        }

        // --- Three.js Visualization ---

        function init3D() {
            // Scene and Camera
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 200;

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            container.appendChild(renderer.domElement);
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 5); // soft white light
            scene.add(ambientLight);
            
            // Star System Group (for easy rotation)
            starSystem = new THREE.Group();
            scene.add(starSystem);

            // Black Hole (Central Singularity)
            const singularityGeometry = new THREE.SphereGeometry(BLACK_HOLE_SIZE, 32, 32);
            const singularityMaterial = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.9 });
            const singularityMesh = new THREE.Mesh(singularityGeometry, singularityMaterial);
            starSystem.add(singularityMesh);

            // Generate initial primes and setup
            primes = generatePrimes(P_LIMIT);
            createStarOrbits();

            // Event Listeners for 3D Control
            renderer.domElement.addEventListener('mousedown', onMouseDown, false);
            renderer.domElement.addEventListener('mousemove', onMouseMove, false);
            renderer.domElement.addEventListener('mouseup', onMouseUp, false);
            renderer.domElement.addEventListener('touchstart', onTouchStart, false);
            renderer.domElement.addEventListener('touchmove', onTouchMove, false);
            renderer.domElement.addEventListener('touchend', onTouchEnd, false);
            window.addEventListener('resize', onWindowResize, false);
        }

        function createStarOrbits() {
            // Clear existing stars
            while (primeObjects.length) {
                starSystem.remove(primeObjects.pop());
            }

            // Create Elliptical Torus (Visual Guide, semi-transparent)
            const torusGeometry = new THREE.TorusGeometry(ORBIT_RADIUS * 0.9, 0.5, 16, 100);
            const torusMaterial = new THREE.MeshBasicMaterial({ color: 0x3333FF, transparent: true, opacity: 0.2, side: THREE.DoubleSide });
            const torusMesh = new THREE.Mesh(torusGeometry, torusMaterial);
            starSystem.add(torusMesh);


            primes.forEach((p, index) => {
                const isFactor = checkFactor(p);
                const color = isFactor ? 0x00ff00 : 0xffa500; // Green for factor, Orange for non-factor

                // Position based on Archimedes Spiral/Ellipse concept
                const radius = ORBIT_RADIUS + (index % 10) * 2;
                const angle = index * 0.8;
                
                const starGeometry = new THREE.SphereGeometry(isFactor ? 1.5 : 0.8, 8, 8);
                const starMaterial = new THREE.MeshBasicMaterial({ color: color });
                const starMesh = new THREE.Mesh(starGeometry, starMaterial);

                // Initial position on a slightly elongated ellipse
                starMesh.position.x = radius * Math.cos(angle);
                starMesh.position.y = radius * Math.sin(angle) * 0.5; // Flattened ellipse
                starMesh.position.z = radius * Math.sin(angle) * 0.8; 

                // Store state for animation
                starMesh.userData = {
                    prime: p,
                    isFactor: isFactor,
                    originalRadius: radius,
                    initialAngle: angle,
                    targetAngle: isFactor ? Math.random() * Math.PI * 2 : 0,
                    wobbleSpeed: Math.random() * 0.05 + 0.02
                };

                primeObjects.push(starMesh);
                starSystem.add(starMesh);
            });
        }

        function animate() {
            requestAnimationFrame(animate);

            // Rotate the entire system for dynamic viewing
            if (!isDragging) {
                starSystem.rotation.y += rotationSpeed;
                starSystem.rotation.x += rotationSpeed / 3;
            }

            // Animate star orbits and factor alignment
            const time = performance.now() * 0.0001;
            
            primeObjects.forEach(star => {
                const data = star.userData;
                const radius = data.originalRadius;
                
                if (data.isFactor) {
                    // Factor stars move towards the fixed "Zero-Remainder Axis" (Y-axis) in a stable way
                    const alignmentFactor = Math.sin(time * 5);
                    star.position.x = radius * Math.sin(data.initialAngle + time * 0.5);
                    star.position.z = radius * Math.cos(data.initialAngle + time * 0.5);
                    // Star snaps closer to the Y-axis (alignment)
                    star.position.y = alignmentFactor * 10; 
                } else {
                    // Non-factor stars move chaotically (wobble and scatter)
                    star.position.x = radius * Math.cos(data.initialAngle + time) * Math.sin(time * data.wobbleSpeed);
                    star.position.y = radius * Math.sin(data.initialAngle + time) * Math.cos(time * data.wobbleSpeed);
                    star.position.z = radius * Math.sin(data.initialAngle + time) * 0.8;
                }
            });

            // Cycle through primes for display update
            if (primeObjects.length > 0) {
                primeIndex = (primeIndex + 1) % primeObjects.length;
                currentPrimeDisplay.textContent = primeObjects[primeIndex].userData.prime.toString();
                currentPrimeDisplay.className = primeObjects[primeIndex].userData.isFactor ? 'factor' : 'non-factor';
            }
            
            renderer.render(scene, camera);
        }

        // --- Control Handlers ---

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onMouseDown(e) {
            e.preventDefault();
            isDragging = true;
            lastTouchX = e.clientX;
            lastTouchY = e.clientY;
        }

        function onMouseMove(e) {
            if (!isDragging) return;
            const deltaX = e.clientX - lastTouchX;
            const deltaY = e.clientY - lastTouchY;
            
            // Adjust rotation based on drag distance
            starSystem.rotation.y += deltaX * 0.005;
            starSystem.rotation.x += deltaY * 0.005;

            lastTouchX = e.clientX;
            lastTouchY = e.clientY;
        }

        function onMouseUp() {
            isDragging = false;
        }

        function onTouchStart(e) {
            e.preventDefault();
            if (e.touches.length === 1) {
                isDragging = true;
                lastTouchX = e.touches[0].clientX;
                lastTouchY = e.touches[0].clientY;
            }
        }

        function onTouchMove(e) {
            e.preventDefault();
            if (!isDragging || e.touches.length !== 1) return;
            onMouseMove({ clientX: e.touches[0].clientX, clientY: e.touches[0].clientY });
        }

        function onTouchEnd() {
            isDragging = false;
        }

        // --- Main Initialization ---

        function updateSystem() {
            try {
                N_Base = parseBigInt(baseInput.value);
                N_Exp = parseBigInt(exponentInput.value);
                N_Add = parseBigInt(addendInput.value);
                N_Value = N_Base.pow(N_Exp).add(N_Add); // Calculate N_Value (for status, not math)
                statusDisplay.textContent = 'Calculating Orbits...';
                
                // Re-create the system based on new N
                createStarOrbits();
                statusDisplay.textContent = 'Exploration Active.';
            } catch (e) {
                statusDisplay.textContent = 'Input Error!';
                console.error("Input parsing failed:", e);
            }
        }

        window.onload = function() {
            updateSystem(); // Initial setup
            init3D();
            animate();
        };

    </script>
</body>
</html>
