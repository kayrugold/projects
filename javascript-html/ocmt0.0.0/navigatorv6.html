<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>GNOMON NAVIGATOR v16: CONSTRUCTOR</title>
<style>
    :root { --bg: #020617; --panel: #0f172a; --a: #facc15; --cyan: #22d3ee; --pink: #f472b6; --green: #34d399; }
    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; user-select: none; }
    body { background: var(--bg); color: #e2e8f0; font-family: monospace; height: 100dvh; margin: 0; display: flex; flex-direction: column; overflow: hidden; }
    
    /* TOP BAR */
    .top { background: var(--panel); border-bottom: 2px solid var(--a); padding: 10px; display: flex; justify-content: space-between; align-items: center; height: 50px; z-index: 10; }
    .title { font-weight: 900; color: var(--a); font-size: 1rem; }
    .btn-reset { background: #ef4444; border: none; color: #fff; padding: 5px 12px; border-radius: 4px; font-weight: bold; cursor: pointer; font-size: 0.8rem; }

    /* SPLIT LAYOUT */
    .workspace { flex: 1; display: flex; overflow: hidden; }
    
    /* LEFT: NAVIGATOR GRID */
    .nav-pane { flex: 1; position: relative; border-right: 2px solid #334155; }
    canvas { display: block; width: 100%; height: 100%; cursor: crosshair; }

    /* RIGHT: GNOMON STAGE */
    .geo-pane { width: 40%; background: #0b1120; display: flex; flex-direction: column; padding: 10px; border-left: 1px solid #000; }
    .geo-header { text-align: center; margin-bottom: 10px; font-size: 0.8rem; color: #94a3b8; }
    .geo-stage { flex: 1; display: flex; justify-content: center; align-items: center; position: relative; }
    
    /* DOT GRID SYSTEM */
    .dot-grid { display: grid; gap: 2px; transition: all 0.3s; }
    .dot { width: 12px; height: 12px; background: #1e293b; border-radius: 2px; transition: background 0.2s; }
    .dot.active { background: var(--cyan); box-shadow: 0 0 5px var(--cyan); }
    .dot.new { background: var(--a); animation: flash 0.5s; }
    
    @keyframes flash { 0% { background: #fff; } 100% { background: var(--a); } }

    /* FOOTER */
    .footer { background: var(--panel); border-top: 1px solid #1e293b; padding: 10px; height: 80px; display: flex; flex-direction: column; justify-content: center; z-index: 10; }
    .sum-readout { font-size: 1.2rem; font-weight: 900; text-align: center; color: var(--green); margin-bottom: 4px; }
    .seq-readout { font-size: 0.75rem; text-align: center; color: #64748b; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
</style>
</head>
<body>

<div class="top">
    <div class="title">GNOMON CONSTRUCTOR</div>
    <button class="btn-reset" onclick="resetAll()">RESET</button>
</div>

<div class="workspace">
    <div class="nav-pane" id="navWrap">
        <canvas id="gridCanvas"></canvas>
    </div>

    <div class="geo-pane">
        <div class="geo-header">VISUAL SUMMATION</div>
        <div class="geo-stage">
            <div id="dotGrid" class="dot-grid"></div>
        </div>
    </div>
</div>

<div class="footer">
    <div class="sum-readout" id="sumOut">TOTAL: 0</div>
    <div class="seq-readout" id="seqOut">Select odd numbers (1, 3, 5...)</div>
</div>

<script>
// --- WORKER ---
var workerBlob = new Blob([
    "self.onmessage = function(e) {" +
    "  var items = e.data.items;" +
    "  var res = items.map(function(it) {" +
    "    var k = BigInt(it.r), b = BigInt(it.c);" +
    "    if (b > k) return null;" +
    "    var P2 = (k * 2n) + 1n, P1 = P2 - (b * 2n);" +
    "    var a = (P2 + P1) / 2n, N = P2 * P1;" +
    "    return { r: it.r, c: it.c, a: a.toString(), b: b.toString(), val: N.toString(), isSq: (b === 0n) };" +
    "  }).filter(function(x){ return x !== null; });" +
    "  self.postMessage(res);" +
    "};"
], {type: 'application/javascript'});

// --- STATE ---
var canvas = document.getElementById('gridCanvas'), ctx = canvas.getContext('2d'), navWrap = document.getElementById('navWrap');
var worker = new Worker(URL.createObjectURL(workerBlob));
var cellS = 50, viewPos = { r: 0n, c: 0n }, scroll = { x: 0, y: 0 };
var cellCache = {}, selection = []; 
var currentSquareSize = 0; // The dimension of the square on the right

worker.onmessage = function(e) { e.data.forEach(function(p) { cellCache[p.r + "|" + p.c] = p; }); draw(); };
window.onresize = function() { canvas.width = navWrap.clientWidth; canvas.height = navWrap.clientHeight; draw(); };
window.onresize(); request();

function resetAll() {
    selection = [];
    currentSquareSize = 0;
    renderGeoGrid();
    updateFooter();
    draw();
}

function handleTap(cell) {
    var val = parseInt(cell.val);
    
    // Logic: Is this a valid next gnomon?
    // The next gnomon size needed is always 2*currentSize + 1
    var needed = 2 * currentSquareSize + 1;
    
    if (val === needed) {
        // Valid Addition
        addGnomon(val, cell);
    } else {
        // Invalid - Flash error or ignore? Let's allow but visual chaos might occur.
        // Actually, let's enforce the sequence for the "Constructor" game feel.
        // Or, to be flexible, just add it. But the visualizer works best with perfect squares.
        // Let's implement the "Next Gnomon" logic for perfect stacking.
        
        // If they click out of order, we just add it to the list but can't draw a perfect square.
        // BUT, the user wants to see the "L-Shape".
        // Let's assume we are building a square.
        
        if (val % 2 !== 0) { // Must be odd
             addGnomon(val, cell);
        }
    }
}

function addGnomon(val, cell) {
    // Add to data
    selection.push({ val: val, r: cell.r, c: cell.c });
    
    // Update Geometry
    // We are adding 'val' dots.
    // If val fits the sequence (1, 3, 5...), we grow the square.
    // current area = size^2. New area = size^2 + val.
    // If size^2 + val is a perfect square, we increment size.
    
    var oldTotal = currentSquareSize * currentSquareSize;
    var newTotal = oldTotal + val;
    var newRoot = Math.round(Math.sqrt(newTotal));
    
    if (newRoot * newRoot === newTotal) {
        currentSquareSize = newRoot;
    } else {
        // Imperfect addition (just piles up dots)
        // For visualization sake, let's just track total dots
    }
    
    renderGeoGrid(val);
    updateFooter();
    draw();
}

function renderGeoGrid(lastAddedVal) {
    var container = document.getElementById('dotGrid');
    container.innerHTML = '';
    
    // We want to visualize a square of size 'currentSquareSize'
    // But if we added random numbers, we might have extra dots.
    
    // Total dots
    var totalDots = selection.reduce((sum, item) => sum + item.val, 0);
    
    // Calculate display grid dimensions
    // Try to keep it square-ish
    var dim = Math.ceil(Math.sqrt(totalDots));
    if (dim < 1) dim = 1;
    
    container.style.gridTemplateColumns = `repeat(${dim}, 1fr)`;
    container.style.width = (dim * 14) + "px";
    
    // Render dots
    // We want to color code them by "Batch" (Gnomon Layer)
    
    var dotsRendered = 0;
    
    selection.forEach((layer, idx) => {
        var isLast = (idx === selection.length - 1);
        for(var i=0; i<layer.val; i++) {
            var dot = document.createElement('div');
            dot.className = isLast ? 'dot new' : 'dot active';
            
            // Color Logic: Cycle colors
            var hue = (idx * 40) % 360;
            if (!isLast) dot.style.backgroundColor = `hsl(${hue}, 70%, 50%)`;
            else dot.style.backgroundColor = 'var(--a)'; // Gold for newest
            
            container.appendChild(dot);
            dotsRendered++;
        }
    });
    
    // Fill remaining grid with empty if needed? No, just flow.
}

function updateFooter() {
    var total = selection.reduce((sum, item) => sum + item.val, 0);
    var seq = selection.map(s => s.val).join(" + ");
    
    var root = Math.sqrt(total);
    var isSq = Number.isInteger(root) && total > 0;
    
    var html = `TOTAL: <span style="color:${isSq ? 'var(--a)' : '#fff'}">${total}</span>`;
    if (isSq) html += ` (${root}Â²)`;
    
    document.getElementById('sumOut').innerHTML = html;
    document.getElementById('seqOut').innerText = seq || "Tap odd numbers to build";
}

function request() { 
    var items = []; 
    var rows = Math.ceil(canvas.height / cellS) + 2, cols = Math.ceil(canvas.width / cellS) + 2;
    for(var r = -2; r < rows; r++) for(var c = -2; c < cols; c++) 
        items.push({r: (viewPos.r + BigInt(r)).toString(), c: (viewPos.c + BigInt(c)).toString()}); 
    worker.postMessage({items: items}); 
}

function draw() {
    ctx.fillStyle = '#020617'; ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Connection Line for Selection
    if (selection.length > 0) {
        ctx.beginPath(); ctx.strokeStyle = 'rgba(250, 204, 21, 0.5)'; ctx.lineWidth = 2;
        var first = true;
        selection.forEach(s => {
            var x = (Number(s.c) - Number(viewPos.c)) * cellS + scroll.x + cellS/2;
            var y = (Number(s.r) - Number(viewPos.r)) * cellS + scroll.y + cellS/2;
            if(first) { ctx.moveTo(x,y); first=false; } else { ctx.lineTo(x,y); }
        });
        ctx.stroke();
    }

    var rows = Math.ceil(canvas.height / cellS) + 4, cols = Math.ceil(canvas.width / cellS) + 4;
    for (var r = -2; r < rows; r++) {
        for (var c = -2; c < cols; c++) {
            var gr = viewPos.r + BigInt(r), gc = viewPos.c + BigInt(c);
            if (gc < 0n || gc > gr) continue;
            var x = c * cellS + scroll.x, y = r * cellS + scroll.y, cell = cellCache[gr + "|" + gc];

            ctx.strokeStyle = '#1e293b'; ctx.lineWidth = 1; ctx.strokeRect(x, y, cellS, cellS);

            if (cell) {
                var isSel = selection.some(s => s.r === cell.r && s.c === cell.c);
                
                if (isSel) {
                    ctx.fillStyle = 'rgba(34, 211, 238, 0.2)'; ctx.fillRect(x, y, cellS, cellS);
                    ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.strokeRect(x, y, cellS, cellS);
                } else if (cell.isSq) {
                    ctx.fillStyle = 'rgba(250, 204, 21, 0.05)'; ctx.fillRect(x, y, cellS, cellS);
                }

                if (cellS > 30) {
                    ctx.textAlign = 'center'; 
                    ctx.fillStyle = isSel ? '#fff' : (cell.isSq ? '#facc15' : '#64748b');
                    ctx.font = "bold " + Math.floor(cellS/4) + "px monospace";
                    ctx.fillText(cell.val, x + cellS/2, y + cellS/2 + 4);
                }
            }
        }
    }
}

// --- TOUCH ---
var touchStart = null, lastPinch = 0, state = 'IDLE';
navWrap.addEventListener('touchstart', function(e) {
    if (e.touches.length === 1) { state = 'PAN'; touchStart = { x: e.touches[0].clientX, y: e.touches[0].clientY, sx: scroll.x, sy: scroll.y }; }
}, {passive: false});

navWrap.addEventListener('touchmove', function(e) {
    e.preventDefault();
    if (state === 'PAN') {
        var dx = e.touches[0].clientX - touchStart.x, dy = e.touches[0].clientY - touchStart.y;
        scroll.x = touchStart.sx + dx; scroll.y = touchStart.sy + dy;
        request(); draw();
    }
}, {passive: false});

navWrap.addEventListener('touchend', function(e) {
    if (state === 'PAN' && e.changedTouches.length > 0 && Math.abs(e.changedTouches[0].clientX - touchStart.x) < 5) {
        var rect = canvas.getBoundingClientRect();
        var c = Math.floor((e.changedTouches[0].clientX - rect.left - scroll.x) / cellS);
        var r = Math.floor((e.changedTouches[0].clientY - rect.top - scroll.y) / cellS);
        var k = viewPos.r + BigInt(r), b = viewPos.c + BigInt(c);
        if(b >= 0n && b <= k) {
            var cell = cellCache[k + "|" + b];
            if(cell) handleTap(cell);
        }
    }
    state = 'IDLE';
});
</script>
</body>
</html>
