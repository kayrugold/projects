I've removed the Highway Buttons (the shortcuts for Row 49, 81, etc.) that were located directly under the "Resolve" button. I also updated the title to simply "ROW-MAJOR CLOCK" to remove the reference to Fermat in the UI as well.
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ROW-MAJOR CLOCK v1.3</title>
<style>
    :root {
        --bg: #020617; --panel: #0f172a; --border: #1e293b;
        --cyan: #22d3ee; --pink: #f472b6; --green: #34d399; --text: #e2e8f0; --dim: #64748b;
        --anchor: #facc15;
    }
    body { background: var(--bg); color: var(--text); font-family: 'Courier New', monospace; margin: 0; display: flex; flex-direction: column; height: 100vh; overflow: hidden; }

    /* Removed padding-bottom since buttons are gone */
    .controls { background: var(--panel); border-bottom: 2px solid var(--anchor); padding: 15px; display: flex; flex-direction: column; gap: 12px; z-index: 100; box-shadow: 0 4px 20px rgba(0,0,0,0.5); }
    .status-bar { font-size: 11px; color: var(--anchor); display: flex; justify-content: space-between; font-weight: bold; text-transform: uppercase; letter-spacing: 1px; }
    
    .input-group { display: flex; gap: 10px; }
    input { background: rgba(0,0,0,0.3); border: 1px solid var(--border); color: #fff; padding: 12px; font-family: inherit; font-size: 16px; font-weight: bold; flex: 1; outline: none; text-align: center; border-radius: 4px; }
    input:focus { border-color: var(--anchor); background: #000; }
    
    .action-btns { display: flex; gap: 5px; }
    button { border: none; padding: 12px; font-weight: 900; cursor: pointer; text-transform: uppercase; border-radius: 4px; flex: 1; font-size: 13px; transition: all 0.1s; }
    button:active { transform: translateY(2px); }
    
    .btn-id { background: var(--dim); color: #fff; }
    .btn-resolve { background: var(--green); color: #000; }
    
    /* Removed .highway-btns styles */

    .tape-container { flex: 1; overflow-y: auto; position: relative; scroll-behavior: smooth; }
    table { width: 100%; border-collapse: collapse; font-size: 15px; }
    thead { position: sticky; top: 0; background: var(--bg); z-index: 10; box-shadow: 0 2px 10px rgba(0,0,0,0.8); }
    th { text-align: left; padding: 12px; color: var(--dim); font-size: 10px; text-transform: uppercase; border-bottom: 1px solid var(--border); letter-spacing: 1px; }
    td { padding: 10px 12px; border-bottom: 1px solid #0f172a; font-variant-numeric: tabular-nums; }
    tr:hover { background: rgba(250, 204, 21, 0.05); }

    .col-record { color: #fff; font-family: 'Consolas', 'Monaco', monospace; }
    
    .val-a { color: var(--anchor); font-weight: bold; }
    .val-N { color: #fff; font-weight: bold; }
    .val-geo { color: var(--pink); opacity: 0.8; font-size: 0.9em; }
    .symbol { color: var(--dim); margin: 0 5px; }
    
    .target-row { border-left: 4px solid var(--green); background: rgba(52, 211, 153, 0.1) !important; }
</style>
</head>
<body>

    <div class="controls">
        <div class="status-bar">
            <span>ROW-MAJOR CLOCK v1.3</span>
            <span id="sysStatus">READY</span>
        </div>
        
        <div class="input-group">
            <input type="text" id="inpSearch" placeholder="Enter position (L) or N to resolve...">
        </div>
        
        <div class="action-btns">
            <button class="btn-id" onclick="forceID()">SET POSITION</button>
            <button class="btn-resolve" onclick="forceScan()">RESOLVE N</button>
        </div>

        </div>

    <div class="tape-container" id="tapeContainer">
        <table id="tapeTable">
            <thead>
                <tr>
                    <th>Canonical Record [ a : N @ a-b ]</th>
                </tr>
            </thead>
            <tbody id="tapeBody"></tbody>
        </table>
    </div>

<script>
    // --- WORKER: Row-Major Unpacker ---
    const unpackerWorkerCode = `
    self.onmessage = function(e) {
        const { startL_str, count } = e.data;
        let L = BigInt(startL_str);
        let results = [];

        function sqrtBigInt(n) {
            if (n < 2n) return n;
            let x = n; let y = (x + 1n) / 2n;
            while (x > y) { x = y; y = (x + n / x) / 2n; }
            return x;
        }

        for (let i = 0; i < count; i++) {
            let disc = 8n * L + 9n;
            let root = sqrtBigInt(disc);
            let m = (root - 3n) / 2n;
            while (m * (m + 3n) / 2n < L) m++;
            while ((m - 1n) * (m + 2n) / 2n >= L) m--;

            const cumPrev = (m - 1n) * (m + 2n) / 2n;
            const posInRow = L - cumPrev;

            const P2 = m * 2n + 1n;
            const b = posInRow - 1n;
            const P1 = P2 - b * 2n;
            const a = P2 - b;
            const N = P2 * P1;

            results.push({
                a: a.toString(),
                b: b.toString(),
                N: N.toString()
            });
            L++;
        }
        self.postMessage(results);
    };
    `;
    const unpackerWorker = new Worker(URL.createObjectURL(new Blob([unpackerWorkerCode], {type: "application/javascript"})));

    // --- RESOLVER WORKER ---
    const scannerWorkerCode = `
    self.onmessage = function(e) {
        const N_str = e.data;
        const N = BigInt(N_str);

        function sqrtBigInt(n) {
            if (n < 2n) return n;
            let x = n; let y = (x + 1n) / 2n;
            while (x > y) { x = y; y = (x + n / x) / 2n; }
            return x;
        }

        let a = sqrtBigInt(N);
        if (a * a < N) a++;

        const limit = 2000000;
        for (let i = 0; i < limit; i++) {
            const diff = a * a - N;
            const b = sqrtBigInt(diff);
            if (b * b === diff) {
                const P1 = a - b;
                if (P1 > 0n) {
                    const P2 = a + b;
                    const m = (P2 - 1n) / 2n;
                    const cumPrev = (m - 1n) * (m + 2n) / 2n;
                    const pos = b + 1n;
                    const L = cumPrev + pos;
                    self.postMessage({ found: true, L: L.toString() });
                    return;
                }
            }
            a++;
        }
        self.postMessage({ found: false });
    };
    `;
    const scannerWorker = new Worker(URL.createObjectURL(new Blob([scannerWorkerCode], {type: "application/javascript"})));

    // --- APP LOGIC ---
    let currentL = 1n;
    let isLoading = false;
    let targetL = -1n;

    function forceID() {
        const val = document.getElementById('inpSearch').value.trim();
        if (!val) return;
        try {
            jumpToID(BigInt(val));
        } catch (e) {
            alert("Invalid position");
        }
    }

    function forceScan() {
        const val = document.getElementById('inpSearch').value.trim();
        if (!val) return;
        document.getElementById('sysStatus').innerText = "RESOLVING...";
        scannerWorker.postMessage(val);
    }

    scannerWorker.onmessage = function(e) {
        if (e.data.found) {
            const L = BigInt(e.data.L);
            document.getElementById('sysStatus').innerText = `RESOLVED AT POSITION ${L}`;
            jumpToID(L);
        } else {
            alert("Geometry not found in local sector.");
            document.getElementById('sysStatus').innerText = "IDLE";
        }
    };

    function jumpToID(idVal) {
        targetL = BigInt(idVal);
        let start = targetL - 10n;
        if (start < 1n) start = 1n;
        currentL = start;
        document.getElementById('sysStatus').innerText = `POSITION ${targetL}`;
        document.getElementById('tapeBody').innerHTML = "";
        fetchBatch();
    }

    function fetchBatch() {
        if (isLoading) return;
        isLoading = true;
        unpackerWorker.postMessage({ startL_str: currentL.toString(), count: 60 });
    }

    unpackerWorker.onmessage = function(e) {
        const data = e.data;
        const tbody = document.getElementById('tapeBody');
        let html = "";
        data.forEach((item, index) => {
            const thisPos = currentL + BigInt(index);
            let rowClass = (thisPos === targetL) ? "target-row" : "";
            
            const notation = `<span class="val-a">${item.a}</span><span class="symbol">:</span><span class="val-N">${item.N}</span><span class="symbol">@</span><span class="val-geo">${item.a}-${item.b}</span>`;

            html += `<tr class="${rowClass}"><td class="col-record">${notation}</td></tr>`;
        });
        tbody.insertAdjacentHTML('beforeend', html);
        currentL += BigInt(data.length);
        isLoading = false;
    };

    document.getElementById('tapeContainer').addEventListener('scroll', (e) => {
        const el = e.target;
        if (el.scrollTop + el.clientHeight >= el.scrollHeight - 200) fetchBatch();
    });

    // Start at position 1
    jumpToID(1);
</script>
</body>
</html>

