<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>GNOMON NAVIGATOR v9.0</title>
<style>
    :root { --bg: #020617; --a: #facc15; --cyan: #22d3ee; --pink: #f472b6; --blue: #3b82f6; }
    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; user-select: none; }
    body { background: var(--bg); color: #e2e8f0; font-family: monospace; height: 100dvh; margin: 0; display: flex; flex-direction: column; overflow: hidden; touch-action: none; }
    
    .top { background: #0f172a; border-bottom: 2px solid var(--a); padding: 8px; display: flex; gap: 4px; z-index: 10; height: 56px; align-items: center; }
    input { background: #000; border: 1px solid var(--a); color: #fff; padding: 8px; flex: 1; font-weight: bold; outline: none; border-radius: 4px; font-size: 16px; min-width: 0; }
    .btn { border: none; padding: 0 12px; font-weight: 900; cursor: pointer; border-radius: 4px; color: #000; font-size: 11px; height: 38px; display: grid; place-items: center; }
    
    .layout { flex: 1; position: relative; background: #000; overflow: hidden; }
    canvas { display: block; width: 100%; height: 100%; }
    
    .reticle { 
        position: absolute; top: 50%; left: 50%; width: 24px; height: 24px; 
        border: 2px solid rgba(255,255,255,0.3); transform: translate(-50%, -50%); 
        pointer-events: none; transition: border-color 0.2s; 
    }
    .reticle::before { content: ''; position: absolute; top: 50%; left: -100vw; right: -100vw; height: 1px; background: rgba(255,255,255,0.1); }
    .reticle::after { content: ''; position: absolute; left: 50%; top: -100vh; bottom: -100vh; width: 1px; background: rgba(255,255,255,0.1); }

    .footer { background: #0b1120; border-top: 1px solid #1e293b; padding: 8px; height: 85px; display: flex; flex-direction: column; justify-content: center; z-index: 10; }
    .eq-box { font-size: 1.1rem; font-weight: bold; text-align: center; }
</style>
</head>
<body>

<div class="top">
    <input id="inpN" type="text" placeholder="N..." value="1007">
    <button class="btn" style="background:#34d399;" onclick="resolveN()">FIND</button>
    <button id="btnTgl" class="btn" style="background:#64748b; color:#fff;" onclick="toggleView()">DOTS</button>
    <button class="btn" style="background:#f472b6;" onclick="resetView()">RESET</button>
</div>

<div class="layout" id="canvasWrap">
    <canvas id="gridCanvas"></canvas>
    <div id="reticle" class="reticle"></div>
</div>

<div class="footer">
    <div style="display:flex; justify-content:space-between; font-size:0.6rem; font-weight:bold; margin-bottom:4px; color:#64748b;">
        <span>BUNCH: <span id="bunchLen" style="color:var(--a)">--</span></span>
        <span id="stateDebug">READY</span>
    </div>
    <div class="eq-box" id="eqOut">
        <span style="color:var(--cyan)">N</span> = <span style="color:var(--a)">a</span>² - <span style="color:var(--pink)">b</span>²
    </div>
</div>

<script>
// --- WORKER: Math Engine ---
var workerBlob = new Blob([
    "self.onmessage = function(e) {" +
    "  var items = e.data.items;" +
    "  var res = items.map(function(it) {" +
    "    var k = BigInt(it.r), b = BigInt(it.c);" +
    "    if (b > k) return null;" +
    "    var P2 = (k * 2n) + 1n, P1 = P2 - (b * 2n);" +
    "    var a = (P2 + P1) / 2n, N = P2 * P1;" +
    "    return { r: it.r, c: it.c, a: a.toString(), b: b.toString(), val: N.toString(), isSq: (b === 0n) };" +
    "  }).filter(function(x){ return x !== null; });" +
    "  self.postMessage(res);" +
    "};"
], {type: 'application/javascript'});

// --- STATE ---
var canvas = document.getElementById('gridCanvas'), ctx = canvas.getContext('2d'), wrap = document.getElementById('canvasWrap');
var worker = new Worker(URL.createObjectURL(workerBlob));
var cellS = 90, viewPos = { r: 0n, c: 0n }, scroll = { x: 0, y: 0 };
var cellCache = {}, selectedAnchor = null, showGrid = true;
var isPanning = false, isPinching = false;

// --- INIT ---
worker.onmessage = function(e) { e.data.forEach(function(p) { cellCache[p.r + "|" + p.c] = p; }); draw(); };
window.onresize = function() { canvas.width = wrap.clientWidth; canvas.height = wrap.clientHeight; draw(); };
window.onresize(); request();

// --- CONTROLS ---
function toggleView() { showGrid = !showGrid; document.getElementById('btnTgl').innerText = showGrid ? "DOTS" : "GRID"; draw(); }
function resetView() { viewPos = { r: 0n, c: 0n }; scroll = { x: 0, y: 0 }; cellS = 90; cellCache = {}; request(); draw(); }

function resolveN() {
    var N = BigInt(document.getElementById('inpN').value), a = BigInt(Math.floor(Math.sqrt(Number(N))));
    if (a * a < N) a++;
    while(true) {
        var b2 = a*a - N, b = BigInt(Math.floor(Math.sqrt(Number(b2))));
        if (b*b === b2) {
            var k = (a+b-1n)/2n; selectedAnchor = a.toString();
            viewPos = { r: k-2n < 0n ? 0n : k-2n, c: b-2n < 0n ? 0n : b-2n }; scroll = {x:0, y:0};
            cellCache = {}; request(); break;
        }
        a++; if (a > N) break;
    }
}

// --- DRAWING ENGINE (Infinite Projection) ---
function draw() {
    ctx.fillStyle = '#020617'; ctx.fillRect(0, 0, canvas.width, canvas.height);

    // 1. PROJECT INFINITE BLUE SPINE (b=0)
    // Spine vector: Starts at (0,0) and moves (1,1) in grid units
    var sX = scroll.x + cellS/2 - Number(viewPos.c)*cellS;
    var sY = scroll.y + cellS/2 - Number(viewPos.r)*cellS;
    
    ctx.beginPath(); ctx.strokeStyle = 'rgba(59, 130, 246, 0.4)'; ctx.lineWidth = Math.max(1, cellS/40);
    // Draw from way off-screen top-left to way off-screen bottom-right
    ctx.moveTo(sX - 50000, sY - 50000); 
    ctx.lineTo(sX + 50000, sY + 50000); 
    ctx.stroke();

    // 2. PROJECT INFINITE GOLD BUNCH (a=const)
    // Slope vector: For a constant anchor, as Row (k) +1, Col (b) +2.
    // But geometrically in this grid, moving 1 unit right (b+1) decreases a by 0.5.
    // Moving 1 unit down (k+1) increases a by 1.
    // So to keep 'a' constant: if we go Down 1 (a+1), we must go Right 2 (a-1).
    // Slope = dy/dx = 1/2.
    
    if (selectedAnchor) {
        var aVal = BigInt(selectedAnchor);
        // Find a reference point where b=0 (The Spine Intersection)
        // At b=0, N=a^2. k = (a-1)/2. 
        var k_ref = (aVal - 1n) / 2n;
        var b_ref = 0n;
        
        var refX = Number(b_ref - viewPos.c) * cellS + scroll.x + cellS/2;
        var refY = Number(k_ref - viewPos.r) * cellS + scroll.y + cellS/2;
        
        ctx.beginPath(); ctx.strokeStyle = 'rgba(250, 204, 21, 0.6)'; ctx.lineWidth = Math.max(2, cellS/25);
        // Draw infinite line with slope 0.5 (2 units right for 1 unit down)
        ctx.moveTo(refX - 100000, refY - 50000);
        ctx.lineTo(refX + 100000, refY + 50000);
        ctx.stroke();
    }

    // 3. DRAW CELLS (LOD System)
    var rows = Math.ceil(canvas.height / cellS) + 4, cols = Math.ceil(canvas.width / cellS) + 4;
    var drawText = cellS > 35; // LOD: Hide text if zoomed out too far

    for (var r = -2; r < rows; r++) {
        for (var c = -2; c < cols; c++) {
            var gr = viewPos.r + BigInt(r), gc = viewPos.c + BigInt(c);
            if (gc < 0n || gc > gr) continue;
            
            var x = c * cellS + scroll.x, y = r * cellS + scroll.y;
            var cell = cellCache[gr + "|" + gc];

            // Grid Style
            if (showGrid) { 
                ctx.strokeStyle = '#1e293b'; ctx.lineWidth = 1; 
                ctx.strokeRect(x, y, cellS, cellS); 
            } else { 
                ctx.fillStyle = '#1e293b'; ctx.beginPath(); 
                ctx.arc(x + cellS/2, y + cellS/2, Math.max(2, cellS/10), 0, 7); ctx.fill(); 
            }

            // Cell Data
            if (cell) {
                if (selectedAnchor && cell.a === selectedAnchor) { 
                    ctx.fillStyle = 'rgba(250, 204, 21, 0.15)'; ctx.fillRect(x, y, cellS, cellS); 
                }
                
                if (drawText) {
                    ctx.textAlign = 'center'; 
                    
                    // Anchor Label
                    ctx.fillStyle = cell.isSq ? '#fff' : '#facc15';
                    ctx.font = "bold " + Math.floor(cellS/6) + "px monospace";
                    ctx.fillText(cell.a, x + cellS/2, y + cellS/2 - 2);
                    
                    // Cargo Label
                    ctx.fillStyle = '#64748b'; 
                    ctx.font = Math.floor(cellS/8) + "px monospace";
                    ctx.fillText(cell.val, x + cellS/2, y + cellS/2 + cellS/4);
                }
            }
        }
    }
    updateLock();
}

function updateLock() {
    // Math based on Center Reticle
    var cx = canvas.width/2, cy = canvas.height/2;
    var c = Math.floor((cx - scroll.x) / cellS), r = Math.floor((cy - scroll.y) / cellS);
    var k = viewPos.r + BigInt(r), b = viewPos.c + BigInt(c);
    
    if(b >= 0n && b <= k) {
        var P2 = k*2n + 1n, P1 = P2 - b*2n;
        var a = (P2+P1)/2n, N = P2*P1;
        document.getElementById('eqOut').innerHTML = '<span style="color:var(--cyan)">'+N+'</span> = <span style="color:var(--a)">'+a+'</span>² - <span style="color:var(--pink)">'+b+'</span>²';
        document.getElementById('bunchLen').innerText = a;
        document.getElementById('reticle').style.borderColor = (b===0n) ? 'var(--a)' : 'rgba(255,255,255,0.4)';
    }
}

function request() { 
    var items = []; 
    // Load a slightly larger buffer than visible
    for(var r = -3; r < 14; r++) for(var c = -3; c < 14; c++) 
        items.push({r: (viewPos.r + BigInt(r)).toString(), c: (viewPos.c + BigInt(c)).toString()}); 
    worker.postMessage({items: items}); 
}

// --- TOUCH ENGINE v9.0 (Strict State Machine) ---
var touchStart = null, lastPinch = 0;
var state = 'IDLE'; // IDLE, PAN, PINCH

wrap.addEventListener('touchstart', function(e) {
    if (e.touches.length === 1) {
        state = 'PAN_WAIT'; // Wait to see if it's a tap or drag
        touchStart = { x: e.touches[0].clientX, y: e.touches[0].clientY, sx: scroll.x, sy: scroll.y };
    } else if (e.touches.length === 2) {
        state = 'PINCH';
        lastPinch = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
    }
    debugState();
}, {passive: false});

wrap.addEventListener('touchmove', function(e) {
    e.preventDefault();
    
    if (state === 'PAN_WAIT' || state === 'PAN') {
        var dx = e.touches[0].clientX - touchStart.x;
        var dy = e.touches[0].clientY - touchStart.y;
        
        // Threshold check to confirm PAN
        if (state === 'PAN_WAIT' && (Math.abs(dx) > 5 || Math.abs(dy) > 5)) state = 'PAN';
        
        if (state === 'PAN') {
            scroll.x = touchStart.sx + dx;
            scroll.y = touchStart.sy + dy;
            
            // Infinite Scroll Logic
            while(scroll.x > 0) { scroll.x -= cellS; viewPos.c -= 1n; touchStart.sx -= cellS; }
            while(scroll.x < -cellS) { scroll.x += cellS; viewPos.c += 1n; touchStart.sx += cellS; }
            while(scroll.y > 0) { scroll.y -= cellS; viewPos.r -= 1n; touchStart.sy -= cellS; }
            while(scroll.y < -cellS) { scroll.y += cellS; viewPos.r += 1n; touchStart.sy += cellS; }
            
            request(); draw();
        }
    } 
    
    else if (state === 'PINCH' && e.touches.length === 2) {
        var dist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
        var cx = (e.touches[0].clientX + e.touches[1].clientX) / 2;
        var cy = (e.touches[0].clientY + e.touches[1].clientY) / 2;
        
        if (lastPinch > 0) {
            var ratio = dist / lastPinch;
            var newS = Math.min(Math.max(cellS * ratio, 10), 400); // 10px min, 400px max
            
            scroll.x = cx - (cx - scroll.x) * (newS / cellS);
            scroll.y = cy - (cy - scroll.y) * (newS / cellS);
            cellS = newS;
            draw();
        }
        lastPinch = dist;
    }
    debugState();
}, {passive: false});

wrap.addEventListener('touchend', function(e) {
    if (state === 'PAN_WAIT' && e.touches.length === 0) {
        // CLEAN TAP DETECTED
        var rect = canvas.getBoundingClientRect();
        var c = Math.floor((touchStart.x - rect.left - scroll.x) / cellS);
        var r = Math.floor((touchStart.y - rect.top - scroll.y) / cellS);
        var k = viewPos.r + BigInt(r), b = viewPos.c + BigInt(c);
        
        // Calculate clicked anchor purely from geometry (no cache needed)
        if (b <= k) {
            var P2 = k * 2n + 1n, P1 = P2 - b * 2n;
            selectedAnchor = ((P2 + P1) / 2n).toString();
            draw();
        }
    }
    if (e.touches.length === 0) state = 'IDLE';
    debugState();
});

function debugState() { document.getElementById('stateDebug').innerText = state; }

</script>
</body>
</html>
