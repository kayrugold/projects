<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <title>Frame Hauler: Turbo Edition</title>
  <script src="https://unpkg.com/big-integer@1.6.48/BigInteger.min.js"></script>
  <style>
    /* TRUCKER THEME: Dark, Industrial, High Contrast */
    body { 
        margin: 0; overflow: hidden; 
        background: #000; color: #0f0; 
        font-family: 'Courier New', monospace; 
        touch-action: none; 
    }
    canvas { display: block; width: 100vw; height: 100vh; }
    
    /* HUD Container */
    #hud-container {
      position: absolute; top: 0; left: 0;
      width: 100%; pointer-events: none;
    }
    
    /* Top Dashboard */
    #dashboard {
      background: rgba(10, 20, 10, 0.9);
      border-bottom: 2px solid #333;
      padding: 10px; pointer-events: auto;
      display: flex; flex-direction: column; gap: 8px;
    }

    h1 { margin: 0; font-size: 1.2rem; color: #ffbf00; text-transform: uppercase; letter-spacing: 2px; text-shadow: 0 0 5px #ffbf00; }

    /* Input Display */
    #input-group { display: flex; gap: 5px; }
    input[type="text"] { 
      flex: 1; background: #111; border: 1px solid #444; color: #0f0; 
      font-family: 'Courier New', monospace; font-size: 1.1rem; padding: 5px;
    }

    /* Gauges Area */
    .gauges { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; font-size: 0.9rem; }
    .gauge-box { border: 1px solid #333; padding: 5px; background: #050505; }
    .label { color: #888; font-size: 0.7rem; text-transform: uppercase; display: block; }
    .val { font-weight: bold; color: #fff; font-size: 1rem; overflow-x: hidden; white-space: nowrap; text-overflow: ellipsis; display: block;}
    .green-glow { text-shadow: 0 0 5px #0f0; color: #0f0; }

    /* Status Light */
    #status-light {
        text-align: center; padding: 8px; font-weight: bold; font-size: 1.1rem;
        background: #220000; color: #f00; border: 1px solid #500;
        margin-top: 5px; text-transform: uppercase;
    }
    #status-light.valid { background: #002200; color: #0f0; border: 1px solid #050; box-shadow: 0 0 10px #0f0 inset; }

    /* Control Stick (Bottom) */
    #controls {
        position: absolute; bottom: 20px; left: 0; width: 100%;
        display: flex; gap: 10px; padding: 0 10px; box-sizing: border-box;
        pointer-events: auto;
    }
    
    button {
        background: #222; border: 1px solid #555; color: #ccc;
        padding: 15px 0; flex: 1; font-family: 'Courier New', monospace;
        font-weight: bold; font-size: 1.2rem; cursor: pointer;
        text-transform: uppercase; border-radius: 4px;
        touch-action: manipulation;
    }
    button:active { background: #444; color: #fff; }
    
    /* The Turbo Button */
    #btn-turbo {
        background: #003366; border-color: #0055aa; color: #fff; flex: 2;
    }
    #btn-turbo:active { background: #004488; box-shadow: 0 0 15px #00aaff; }

    /* Odometer */
    #odometer { 
        position: absolute; bottom: 80px; width: 100%; 
        text-align: center; color: #555; font-size: 0.8rem;
    }
    #odometer span { color: #ffbf00; font-weight: bold; }

  </style>
</head>
<body>

<div id="hud-container">
  <div id="dashboard">
    <div style="display:flex; justify-content:space-between; align-items:center;">
        <h1>Frame Hauler</h1>
        <div style="font-size:0.7rem; color:#666;">V8 TURBO ENGINE</div>
    </div>
    
    <div id="input-group">
        <input type="text" id="inputN" value="10071007" placeholder="LOAD CARGO (N)">
    </div>

    <div class="gauges">
        <div class="gauge-box">
            <span class="label">ROOF (Outer)</span>
            <span id="dispRoof" class="val">--</span>
        </div>
        <div class="gauge-box">
            <span class="label">HOLE (Gap)</span>
            <span id="dispHole" class="val">--</span>
        </div>
    </div>

    <div id="status-light">INVALID FRAME</div>
  </div>
</div>

<div id="odometer">Skipped <span id="skip-count">0</span> dead miles</div>

<div id="controls">
    <button onclick="adjustRoof(-1)">Rev -</button>
    <button onclick="adjustRoof(1)">Rev +</button>
    <button id="btn-turbo" onclick="turboJump()">TURBO SKIP >></button>
</div>

<canvas id="canvas"></canvas>

<script>
// --- ENGINE VARIABLES ---
let N = bigInt("10071007");
let Roof = bigInt(0);
let Hole = bigInt(0);

// --- MODULAR FILTERS (The "Sieve") ---
// We pre-calculate valid squares for these moduli to skip calculations fast.
const MODS = [256, 9, 5, 7, 11, 13, 17, 19]; 
const VALID_SQUARES = {}; // Map of valid remainders for each mod

// --- VISUAL VARIABLES ---
let scale = 1;
let offsetX = 0;
let offsetY = 0;
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

// --- INITIALIZATION ---
window.onload = () => {
    // 1. Pre-compute valid squares (The "Gear Settings")
    initFilters();
    
    // 2. Setup Dimensions
    resize();
    resetToSqrt();
    
    // 3. Center Camera
    offsetX = canvas.width / 2;
    offsetY = canvas.height / 2;
    draw();
};

window.addEventListener('resize', resize);
function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; draw(); }

// --- THE V8 ENGINE (FILTER SETUP) ---
function initFilters() {
    MODS.forEach(m => {
        VALID_SQUARES[m] = new Set();
        for(let i=0; i<m; i++) {
            VALID_SQUARES[m].add((i*i) % m);
        }
    });
    console.log("V8 Filters Primed.");
}

function checkFilters(testRoof, targetN) {
    // Returns TRUE if this Roof is mathematically possible
    // Returns FALSE if we should skip it
    
    // We check (Roof^2 - N) mod M. 
    // Is the result a valid square mod M?
    // If not, the hole CANNOT be a square.
    
    for (let m of MODS) {
        // Quick Modulo using BigInt
        // Calculate (Roof^2 - N) % m
        // Optimization: ( (Roof%m)^2 - (N%m) ) % m
        
        let rMod = testRoof.mod(m).toJSNumber(); // Roof is big, but mod is small
        let nMod = targetN.mod(m).toJSNumber();
        
        // JS handles negative modulo weirdly, fix it:
        let diff = ( (rMod * rMod) - nMod ) % m;
        if (diff < 0) diff += m;
        
        if (!VALID_SQUARES[m].has(diff)) {
            return false; // BLOCKED by filter
        }
    }
    return true; // PASSED all filters
}


// --- LOGIC ---
document.getElementById('inputN').addEventListener('change', (e) => {
    try {
        let val = e.target.value.replace(/\D/g,'');
        if(!val) return;
        N = bigInt(val);
        resetToSqrt();
        document.getElementById('skip-count').innerText = "0";
    } catch(e) { console.log(e); }
});

function resetToSqrt() {
    // Start at Ceil(Sqrt(N))
    Roof = sqrtBigInt(N).add(1);
    recalc();
}

function adjustRoof(delta) {
    Roof = Roof.add(delta);
    let min = sqrtBigInt(N);
    if (Roof.lesserOrEquals(min)) Roof = min.add(1);
    recalc();
}

// --- THE TURBO JUMP ---
function turboJump() {
    let steps = 0;
    const MAX_SEARCH = 10000; // Safety brake so browser doesn't freeze
    
    let tempRoof = Roof;
    let found = false;
    
    // Loop until we find a candidate that passes the filters
    for(let i=0; i<MAX_SEARCH; i++) {
        tempRoof = tempRoof.add(1);
        steps++;
        
        if (checkFilters(tempRoof, N)) {
            // We found a gap in the traffic!
            Roof = tempRoof;
            found = true;
            break;
        }
    }
    
    // Update Odometer
    let odo = document.getElementById('skip-count');
    let currentSkips = parseInt(odo.innerText.replace(/,/g, '')) || 0;
    odo.innerText = (currentSkips + steps).toLocaleString();
    
    if(!found) {
        // If we ran 10k miles and found nothing, just update to where we stopped
        Roof = tempRoof;
        alert("Driving 10,000 miles... nothing yet. Click Turbo again.");
    }
    
    recalc();
}


function recalc() {
    // Calculate Hole
    let roofSq = Roof.square();
    Hole = roofSq.minus(N);
    
    // Update Dashboard
    document.getElementById('dispRoof').innerText = Roof.toString();
    document.getElementById('dispHole').innerText = Hole.toString();
    
    // Check Square
    let isSq = isPerfectSquare(Hole);
    const statusEl = document.getElementById('status-light');
    
    if (isSq) {
        statusEl.innerText = "SUCCESS: " + Hole.toString(); // Show hole size
        statusEl.className = "valid";
        // Calculate factors just for show
        let y = sqrtBigInt(Hole);
        let f1 = Roof.minus(y);
        let f2 = Roof.add(y);
        console.log("Factors found: " + f1.toString() + " x " + f2.toString());
    } else {
        statusEl.innerText = "INVALID FRAME";
        statusEl.className = "";
    }
    draw();
}

// --- MATH HELPERS ---
function sqrtBigInt(value) {
    if (value.lesser(0)) return bigInt(-1);
    if (value.equals(0)) return bigInt(0);
    let x = bigInt(2).pow(value.bitLength().divide(2).add(1));
    let y = bigInt(0);
    while(y.notEquals(x)) {
        y = x;
        x = value.divide(x).add(x).divide(2);
        if(x.equals(y.add(1))) return x;
    }
    return x;
}

function isPerfectSquare(n) {
    if(n.lesser(0)) return false;
    // Quick Bloom filter before heavy sqrt
    let h = n.mod(256).toJSNumber();
    if (!VALID_SQUARES[256].has(h)) return false;
    
    let r = sqrtBigInt(n);
    return r.square().equals(n);
}


// --- DRAWING (Identical to previous, adapted for dark mode) ---
function draw() {
    // Clear (Dark Background)
    ctx.fillStyle = "#000";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    ctx.save();
    ctx.translate(offsetX, offsetY);
    ctx.scale(scale, scale);
    
    let baseSize = 300;
    let ratio = 0;
    
    if (Roof.greater(0)) {
       try {
         let rStr = Roof.toString();
         let hStr = Hole.toString();
         let rTop = parseFloat(rStr.substring(0, 5));
         let hTop = parseFloat(hStr.substring(0, 5));
         let magDiff = (hStr.length/2) - rStr.length; 
         let baseRatio = Math.sqrt(hTop) / rTop;
         ratio = baseRatio * Math.pow(10, magDiff);
       } catch(e) { ratio = 0; }
    }
    
    let sizeOuter = baseSize;
    let sizeInner = baseSize * ratio;
    if (sizeInner < 0) sizeInner = 0;
    if (sizeInner > sizeOuter) sizeInner = sizeOuter;

    // Draw Roof (Blue Steel)
    ctx.strokeStyle = "#0055aa";
    ctx.lineWidth = 2 / scale;
    ctx.strokeRect(-sizeOuter/2, -sizeOuter/2, sizeOuter, sizeOuter);
    
    // Draw Hole (Red/Green Laser)
    let isValid = document.getElementById('status-light').className.includes("valid");
    let holeColor = isValid ? "#0f0" : "#f00";
    let holeFill = isValid ? "rgba(0, 255, 0, 0.2)" : "rgba(255, 0, 0, 0.2)";
    
    ctx.fillStyle = holeFill;
    ctx.strokeStyle = holeColor;
    
    ctx.fillRect(-sizeInner/2, -sizeInner/2, sizeInner, sizeInner);
    ctx.strokeRect(-sizeInner/2, -sizeInner/2, sizeInner, sizeInner);
    
    // Trapezoids (Ghost Lines)
    ctx.beginPath();
    ctx.strokeStyle = "rgba(0, 255, 0, 0.1)";
    ctx.lineWidth = 1 / scale;
    ctx.moveTo(-sizeOuter/2, -sizeOuter/2); ctx.lineTo(-sizeInner/2, -sizeInner/2);
    ctx.moveTo(sizeOuter/2, -sizeOuter/2);  ctx.lineTo(sizeInner/2, -sizeInner/2);
    ctx.moveTo(sizeOuter/2, sizeOuter/2);   ctx.lineTo(sizeInner/2, sizeInner/2);
    ctx.moveTo(-sizeOuter/2, sizeOuter/2);  ctx.lineTo(-sizeInner/2, sizeInner/2);
    ctx.stroke();
    
    ctx.restore();
}

// --- TOUCH HANDLING (Standard Pan/Zoom) ---
let lastTouch = null; let lastDist = 0;
canvas.addEventListener('touchstart', e => { e.preventDefault(); if (e.touches.length===1) lastTouch={x:e.touches[0].clientX, y:e.touches[0].clientY}; else if (e.touches.length===2) { let t1=e.touches[0], t2=e.touches[1]; lastDist=Math.hypot(t2.clientX-t1.clientX, t2.clientY-t1.clientY); lastTouch={x:(t1.clientX+t2.clientX)/2, y:(t1.clientY+t2.clientY)/2}; } }, {passive:false});
canvas.addEventListener('touchmove', e => { e.preventDefault(); if(e.touches.length===1 && lastTouch){ let t=e.touches[0]; offsetX+=t.clientX-lastTouch.x; offsetY+=t.clientY-lastTouch.y; lastTouch={x:t.clientX,y:t.clientY}; draw(); } else if(e.touches.length===2){ let t1=e.touches[0], t2=e.touches[1]; let newDist=Math.hypot(t2.clientX-t1.clientX, t2.clientY-t1.clientY); let newMid={x:(t1.clientX+t2.clientX)/2, y:(t1.clientY+t2.clientY)/2}; let factor=newDist/lastDist; offsetX+=newMid.x-lastTouch.x; offsetY+=newMid.y-lastTouch.y; offsetX=newMid.x-(newMid.x-offsetX)*factor; offsetY=newMid.y-(newMid.y-offsetY)*factor; scale*=factor; lastDist=newDist; lastTouch=newMid; draw(); } }, {passive:false});
canvas.addEventListener('touchend', () => { lastTouch=null; lastDist=0; });

</script>
</body>
</html>
