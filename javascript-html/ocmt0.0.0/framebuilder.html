<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <title>Frame Builder Mobile</title>
  <script src="https://unpkg.com/big-integer@1.6.48/BigInteger.min.js"></script>
  <style>
    body { margin: 0; overflow: hidden; background: #0f172a; color: #e2e8f0; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; touch-action: none; }
    canvas { display: block; width: 100vw; height: 100vh; }
    
    /* Collapsible HUD Container */
    #hud-container {
      position: absolute; top: 10px; left: 10px;
      width: 300px; max-width: 90vw;
      z-index: 100;
      transition: opacity 0.3s;
    }
    
    /* The Toggle Button */
    #hud-toggle {
      background: #334155; color: white; border: 1px solid #475569;
      padding: 10px 15px; border-radius: 8px; cursor: pointer;
      font-size: 1.2rem; margin-bottom: 5px;
      display: inline-block; box-shadow: 0 4px 6px rgba(0,0,0,0.3);
    }

    /* The Main Panel */
    #hud-content {
      background: rgba(30, 41, 59, 0.95);
      padding: 15px; border-radius: 8px;
      border: 1px solid #475569;
      box-shadow: 0 4px 6px rgba(0,0,0,0.3);
      display: block; /* Toggled via JS */
    }
    
    .hidden { display: none !important; }

    h1 { margin: 0 0 15px 0; font-size: 1.2rem; color: #facc15; text-align: center; }
    
    .row { display: flex; justify-content: space-between; margin-bottom: 12px; font-size: 1rem; }
    .val { font-family: monospace; color: #fff; font-weight: bold; }
    
    /* Inputs & Buttons */
    input[type="text"] { 
      width: 100%; box-sizing: border-box; background: #1e293b; 
      border: 1px solid #475569; color: white; padding: 12px; 
      margin-bottom: 15px; font-family: monospace; font-size: 1.1rem; border-radius: 6px;
    }
    
    .btn-group { display: flex; gap: 10px; margin-top: 15px; }
    button {
      flex: 1; padding: 15px; cursor: pointer;
      background: #3b82f6; border: none; color: white; border-radius: 6px;
      font-weight: bold; font-size: 1.1rem;
      touch-action: manipulation; /* Improves touch response */
    }
    button:active { background: #2563eb; transform: scale(0.98); }
    button.auto { background: #10b981; }
    
    #status { 
      margin-top: 15px; padding: 12px; 
      background: #334155; border-radius: 6px; 
      text-align: center; font-weight: bold; font-size: 1rem;
    }
    .success { color: #4ade80; border: 1px solid #4ade80; }
    .fail { color: #f87171; }

    /* Legend */
    .legend { margin-top: 15px; font-size: 0.9rem; color: #94a3b8; text-align: center;}
    .dot { display: inline-block; width: 12px; height: 12px; border-radius: 50%; margin-right: 5px; vertical-align: middle; }
  </style>
</head>
<body>

<div id="hud-container">
  <button id="hud-toggle" onclick="toggleHud()">â˜° Menu</button>
  
  <div id="hud-content">
    <h1>Frame Builder</h1>
    
    <input type="text" id="inputN" value="1007" placeholder="Enter N">
    
    <div class="row">
      <span>Roof (Outer):</span>
      <span id="dispRoof" class="val">32</span>
    </div>
    <div class="row">
      <span>Hole (Gap):</span>
      <span id="dispHole" class="val">17</span>
    </div>

    <div id="status" class="fail">HOLE IS NOT SQUARE</div>

    <div class="btn-group">
      <button onclick="adjustRoof(-1)">-1</button>
      <button onclick="adjustRoof(1)">+1</button>
    </div>
    <div class="btn-group">
      <button onclick="findNextWall()" class="auto">NEXT WALL</button>
    </div>
    
    <div class="legend">
      <span class="dot" style="background:rgba(59, 130, 246, 0.5)"></span>Frame
      <span class="dot" style="background:rgba(255, 0, 0, 0.3); margin-left: 15px;"></span>Hole
    </div>
  </div>
</div>

<canvas id="canvas"></canvas>

<script>
// --- STATE ---
let N = bigInt(1007);
let Roof = bigInt(32);
let Hole = bigInt(0);
let scale = 1;
let offsetX = 0;
let offsetY = 0;

// --- DOM ELEMENTS ---
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const inputN = document.getElementById('inputN');

// --- INITIALIZATION ---
window.onload = () => {
  resize();
  resetToSqrt();
  // Center the view initially
  offsetX = canvas.width / 2;
  offsetY = canvas.height / 2;
  draw();
};

window.addEventListener('resize', resize);
function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  draw();
}

function toggleHud() {
  const content = document.getElementById('hud-content');
  content.classList.toggle('hidden');
}

// --- LOGIC ---
inputN.addEventListener('change', () => {
  try {
    let val = inputN.value.replace(/\D/g,''); // numeric only
    if(!val) return;
    N = bigInt(val);
    resetToSqrt();
  } catch(e) { console.log(e); }
});

function resetToSqrt() {
  // Start slightly above sqrt(N)
  Roof = sqrtBigInt(N).add(1);
  recalc();
}

function adjustRoof(delta) {
  Roof = Roof.add(delta);
  let min = sqrtBigInt(N);
  if (Roof.lesserOrEquals(min)) Roof = min.add(1);
  recalc();
}

function findNextWall() {
  // Simulator: Just jump 1 for now, or implement specific wall logic here
  adjustRoof(1);
}

function recalc() {
  let roofSq = Roof.square();
  Hole = roofSq.minus(N);
  
  document.getElementById('dispRoof').innerText = Roof.toString();
  document.getElementById('dispHole').innerText = Hole.toString();
  
  let isSq = isPerfectSquare(Hole);
  const statusEl = document.getElementById('status');
  
  if (isSq) {
    statusEl.innerText = "SQUARE FOUND!";
    statusEl.className = "success";
    // Play sound or vibration here if desired
  } else {
    statusEl.innerText = "HOLE NOT SQUARE";
    statusEl.className = "fail";
  }
  draw();
}

// --- MATH HELPERS ---
function sqrtBigInt(value) {
    if (value.lesser(0)) return bigInt(-1);
    if (value.equals(0)) return bigInt(0);
    let x = bigInt(2).pow(value.bitLength().divide(2).add(1));
    let y = bigInt(0);
    while(y.notEquals(x)) {
        y = x;
        x = value.divide(x).add(x).divide(2);
        if(x.equals(y.add(1))) return x;
    }
    return x;
}

function isPerfectSquare(n) {
  if(n.lesser(0)) return false;
  let r = sqrtBigInt(n);
  return r.square().equals(n);
}

// --- RENDERING ---
function draw() {
  // Clear background
  ctx.fillStyle = "#0f172a";
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  ctx.save();
  // Apply Transform
  ctx.translate(offsetX, offsetY);
  ctx.scale(scale, scale);
  
  // Calculate relative sizes for visualization
  // Base visual size = 300px
  let baseSize = 300;
  
  // Ratio = sqrt(Hole) / Roof
  // Use floating point approx for drawing only
  let ratio = 0;
  if (Roof.greater(0)) {
     // Approx logic for huge numbers
     let rStr = Roof.toString();
     let hStr = Hole.toString();
     
     // Logarithmic approximation of ratio to prevent underflow
     let logR = rStr.length;
     let logH = hStr.length; // actually log(H), need log(sqrt(H)) = logH / 2
     
     // If hole is tiny relative to roof, use a minimum pixel size
     // We need (sqrt(Hole) / Roof)
     // Let's try simple JS number division first, falling back if Infinity
     try {
       // Grab top 5 digits
       let rTop = parseFloat(rStr.substring(0, 5));
       let hTop = parseFloat(hStr.substring(0, 5));
       // Adjust magnitude
       let magDiff = (hStr.length/2) - rStr.length; // Power of 10 difference
       let baseRatio = Math.sqrt(hTop) / rTop;
       ratio = baseRatio * Math.pow(10, magDiff);
     } catch(e) { ratio = 0; }
  }
  
  let sizeOuter = baseSize;
  let sizeInner = baseSize * ratio;
  
  // Cap inner size to avoid drawing errors
  if (sizeInner < 0) sizeInner = 0;
  if (sizeInner > sizeOuter) sizeInner = sizeOuter;

  // 1. Draw Outer (Roof)
  ctx.strokeStyle = "#3b82f6";
  ctx.lineWidth = 2 / scale; // Keep line width constant visually
  ctx.strokeRect(-sizeOuter/2, -sizeOuter/2, sizeOuter, sizeOuter);
  
  // 2. Draw Inner (Hole)
  let isSuccess = document.getElementById('status').className.includes("success");
  ctx.fillStyle = isSuccess ? "rgba(74, 222, 128, 0.3)" : "rgba(248, 113, 113, 0.3)";
  ctx.strokeStyle = isSuccess ? "#4ade80" : "#f87171";
  
  ctx.fillRect(-sizeInner/2, -sizeInner/2, sizeInner, sizeInner);
  ctx.strokeRect(-sizeInner/2, -sizeInner/2, sizeInner, sizeInner);
  
  // 3. Draw Trapezoids
  ctx.beginPath();
  ctx.strokeStyle = "rgba(255, 255, 255, 0.1)";
  ctx.lineWidth = 1 / scale;
  
  ctx.moveTo(-sizeOuter/2, -sizeOuter/2); ctx.lineTo(-sizeInner/2, -sizeInner/2); // TL
  ctx.moveTo(sizeOuter/2, -sizeOuter/2);  ctx.lineTo(sizeInner/2, -sizeInner/2);  // TR
  ctx.moveTo(sizeOuter/2, sizeOuter/2);   ctx.lineTo(sizeInner/2, sizeInner/2);   // BR
  ctx.moveTo(-sizeOuter/2, sizeOuter/2);  ctx.lineTo(-sizeInner/2, sizeInner/2);  // BL
  ctx.stroke();
  
  // Fill Frame
  ctx.fillStyle = "rgba(59, 130, 246, 0.1)";
  ctx.beginPath();
  ctx.rect(-sizeOuter/2, -sizeOuter/2, sizeOuter, sizeOuter);
  ctx.rect(-sizeInner/2, -sizeInner/2, sizeInner, sizeInner);
  ctx.fill("evenodd");
  
  ctx.restore();
}

// --- TOUCH & PAN/ZOOM LOGIC ---
let lastTouch = null;
let lastDist = 0;

canvas.addEventListener('touchstart', e => {
  e.preventDefault();
  if (e.touches.length === 1) {
    // Start Panning
    lastTouch = { x: e.touches[0].clientX, y: e.touches[0].clientY };
  } else if (e.touches.length === 2) {
    // Start Zooming
    let t1 = e.touches[0];
    let t2 = e.touches[1];
    lastDist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
    lastTouch = { 
      x: (t1.clientX + t2.clientX) / 2, 
      y: (t1.clientY + t2.clientY) / 2 
    };
  }
}, {passive: false});

canvas.addEventListener('touchmove', e => {
  e.preventDefault(); // Prevent scrolling
  
  if (e.touches.length === 1 && lastTouch) {
    // PANNING
    let t = e.touches[0];
    let dx = t.clientX - lastTouch.x;
    let dy = t.clientY - lastTouch.y;
    
    offsetX += dx;
    offsetY += dy;
    
    lastTouch = { x: t.clientX, y: t.clientY };
    draw();
    
  } else if (e.touches.length === 2) {
    // PINCH ZOOMING
    let t1 = e.touches[0];
    let t2 = e.touches[1];
    
    let newDist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
    let newMid = { 
      x: (t1.clientX + t2.clientX) / 2, 
      y: (t1.clientY + t2.clientY) / 2 
    };
    
    // Calculate zoom factor
    let factor = newDist / lastDist;
    
    // Apply Zoom centered on midpoint
    // The Math: NewOffset = Midpoint - (Midpoint - OldOffset) * Factor
    // plus the panning delta of the midpoint itself
    
    // 1. Pan adjustment (midpoint moved)
    offsetX += (newMid.x - lastTouch.x);
    offsetY += (newMid.y - lastTouch.y);
    
    // 2. Zoom adjustment (scale around midpoint)
    // We adjust the World Origin (offsetX, offsetY) so the world point under NewMid stays stationary
    offsetX = newMid.x - (newMid.x - offsetX) * factor;
    offsetY = newMid.y - (newMid.y - offsetY) * factor;
    
    scale *= factor;
    
    lastDist = newDist;
    lastTouch = newMid;
    draw();
  }
}, {passive: false});

canvas.addEventListener('touchend', () => {
  lastTouch = null;
  lastDist = 0;
});

// Simple Mouse Pan/Zoom for testing on laptop
canvas.addEventListener('mousedown', e => {
  lastTouch = {x: e.clientX, y: e.clientY}; 
});
canvas.addEventListener('mousemove', e => {
  if (e.buttons === 1 && lastTouch) {
    offsetX += e.clientX - lastTouch.x;
    offsetY += e.clientY - lastTouch.y;
    lastTouch = {x: e.clientX, y: e.clientY};
    draw();
  }
});
canvas.addEventListener('wheel', e => {
  e.preventDefault();
  let factor = e.deltaY > 0 ? 0.9 : 1.1;
  let mx = e.clientX;
  let my = e.clientY;
  offsetX = mx - (mx - offsetX) * factor;
  offsetY = my - (my - offsetY) * factor;
  scale *= factor;
  draw();
}, {passive: false});

</script>
</body>
</html>
