<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>ANDY'S NAVIGATOR v8.2 (V8 ENGINE)</title>
<style>
    :root {
        --bg: #020617; --panel: #0f172a; --border: #1e293b;
        --cyan: #22d3ee; --text: #e2e8f0; --pink: #f472b6; --green: #34d399;
        --input-bg: rgba(0,0,0,0.3);
    }
    * { box-sizing: border-box; }
    body { 
        background: var(--bg); color: var(--text); font-family: 'Courier New', monospace; 
        height: 100dvh; margin: 0; display: flex; flex-direction: column; overflow: hidden; 
        overscroll-behavior: none;
    }

    /* --- HUD --- */
    .top-section {
        background: var(--panel); border-bottom: 2px solid var(--green);
        padding: 12px; flex-shrink: 0; z-index: 200; display: flex; flex-direction: column; gap: 10px;
        box-shadow: 0 4px 15px rgba(0,0,0,0.5);
    }
    
    .status-line { display: flex; justify-content: space-between; font-size: 0.8rem; color: var(--green); font-weight: bold; text-transform: uppercase; }

    .input-row { display: flex; gap: 8px; }
    #inpCargo { flex: 1; background: var(--input-bg); border: 1px solid #334155; color: #fff; padding: 12px; font-weight: bold; text-align: center; border-radius: 4px; font-size: 1.1rem; outline: none; }
    #inpCargo:focus { border-color: var(--green); background: #000; }
    
    #btnTurbo { 
        background: var(--green); color: #000; border: none; font-weight: 900; 
        padding: 0 20px; border-radius: 4px; cursor: pointer; font-size: 1rem;
        box-shadow: 0 0 10px rgba(52, 211, 153, 0.4); white-space: nowrap;
    }
    #btnTurbo:active { transform: translateY(2px); }

    /* --- CANVAS --- */
    .layout { flex: 1; position: relative; overflow: hidden; background: #000; touch-action: none; }
    canvas { display: block; width: 100%; height: 100%; cursor: crosshair; }

    /* --- DECODER PANEL --- */
    .decoder { background: #0f172a; border-top: 3px solid var(--green); display: flex; flex-direction: column; flex-shrink: 0; padding-bottom: max(10px, env(safe-area-inset-bottom)); }
    
    .big-readout { 
        padding: 12px; display: flex; justify-content: space-between; align-items: baseline; 
        background: #0b1120; border-bottom: 1px solid #1e293b; cursor: pointer;
    }
    .readout-val { font-size: 1.3rem; font-weight: 900; color: var(--green); }
    
    .info-grid { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 5px; padding: 5px; }
    .info-item { background: rgba(255,255,255,0.05); padding: 4px; text-align: center; border-radius: 4px; }
    .info-lbl { font-size: 0.6rem; color: #94a3b8; }
    .info-val { font-weight: bold; color: #fff; font-size: 0.9rem; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }

    /* --- MODAL --- */
    .modal-overlay {
        position: fixed; top: 0; left: 0; right: 0; bottom: 0;
        background: rgba(2, 6, 23, 0.95); z-index: 1000;
        display: none; justify-content: center; align-items: center;
        padding: 20px; backdrop-filter: blur(5px);
    }
    .modal-card {
        background: #0f172a; border: 1px solid var(--green);
        width: 100%; max-width: 600px; max-height: 85vh;
        border-radius: 12px; display: flex; flex-direction: column;
        box-shadow: 0 0 50px rgba(0,0,0,0.8); color: #cbd5e1;
    }
    .modal-header { padding: 15px; border-bottom: 1px solid var(--border); display: flex; justify-content: space-between; align-items: center; }
    .modal-title { font-weight: bold; color: var(--green); font-size: 1.1rem; }
    .modal-close { color: #fff; cursor: pointer; font-size: 1.5rem; line-height: 1; padding: 10px; }
    .modal-body { padding: 20px; overflow-y: auto; }
    
    .full-val-box { 
        background:#0b1120; padding:15px; border-radius:6px; margin-bottom:15px; 
        border:1px solid #334155; font-family:monospace; font-size:0.9rem; 
        max-height:200px; overflow-y:auto; color:#fff; word-break: break-all;
        line-height: 1.4;
    }
    .sec-lbl { color: var(--pink); font-size: 0.75rem; font-weight: bold; margin-bottom: 5px; text-transform: uppercase; }

    #toast {
        position: fixed; top: 150px; left: 50%; transform: translateX(-50%);
        background: rgba(15, 23, 42, 0.95); border: 1px solid var(--green); color: var(--green);
        padding: 10px 20px; border-radius: 20px; font-weight: bold; opacity: 0; pointer-events: none; transition: opacity 0.3s;
        z-index: 500;
    }
    #toast.show { opacity: 1; }
</style>
</head>
<body>

<div id="toast">SCANNING...</div>

<div class="top-section">
    <div class="status-line">
        <span>Frame Fitter v8.2</span>
        <span id="sysStatus">DETECTING CORES...</span>
    </div>
    <div class="input-row">
        <input id="inpCargo" type="text" placeholder="Enter Cargo (N) or ID...">
        <button id="btnTurbo">SCAN</button>
    </div>
</div>

<div class="layout" id="canvasWrap">
    <canvas id="gridCanvas"></canvas>
</div>

<div class="decoder" id="decoderPanel">
    <div class="big-readout">
        <div>
            <div class="info-lbl">ADDRESS</div>
            <div class="readout-val" id="dispAddr">--.--</div>
        </div>
        <div style="text-align:right">
            <div class="info-lbl">CARGO (TAP TO EXPAND)</div>
            <div class="readout-val" id="dispVal" style="color:#fff; font-size:1.1rem;">--</div>
        </div>
    </div>
    <div class="info-grid">
        <div class="info-item">
            <div class="info-lbl">ROW (k)</div>
            <div class="info-val" id="dispK" style="color:var(--green)">--</div>
        </div>
        <div class="info-item">
            <div class="info-lbl">GAP (b)</div>
            <div class="info-val" id="dispB" style="color:var(--pink)">--</div>
        </div>
        <div class="info-item">
            <div class="info-lbl">PURE ID (L)</div>
            <div class="info-val" id="dispL" style="color:#cbd5e1">--</div>
        </div>
    </div>
</div>

<div id="fullValModal" class="modal-overlay">
    <div class="modal-card">
        <div class="modal-header">
            <span class="modal-title">MANIFEST DETAILS</span>
            <span class="modal-close" id="closeFull">×</span>
        </div>
        <div class="modal-body">
            <div class="sec-lbl">CARGO (N)</div>
            <div class="full-val-box" id="fullN" style="color:#fff"></div>
            
            <div class="sec-lbl">FACTORS (P2 × P1)</div>
            <div class="full-val-box" id="fullFactors" style="color:var(--green)"></div>
            
            <div class="sec-lbl">PURE TAPE ID (L)</div>
            <div class="full-val-box" id="fullTape" style="color:#64748b"></div>

            <div class="sec-lbl">GEOMETRY (Anchor.Gap)</div>
            <div class="full-val-box" id="fullSmart" style="color:var(--pink)"></div>
        </div>
    </div>
</div>

<script>
// --- CORE DETECTION ---
const NUM_CORES = navigator.hardwareConcurrency || 4;
document.getElementById('sysStatus').innerText = `READY (${NUM_CORES} CORES DETECTED)`;

// --- WORKER 1: THE MULTI-CORE WORKER CODE ---
const scanWorkerCode = `
self.onmessage = function(e) {
    const { N_str, startOffset, scanLimit } = e.data;
    try {
        const N = BigInt(N_str);
        if(N < 2n) { self.postMessage({found: false}); return; }

        let a = sqrtBigInt(N);
        if (a*a < N) a++;
        
        // JUMP TO WORKER'S SECTOR
        // Each worker starts at a different anchor offset
        a += BigInt(startOffset);
        
        let residue = (a * a) - N;
        const LIMIT = scanLimit; 
        
        for(let i=0; i<LIMIT; i++) {
            const mod16 = Number(residue & 15n);
            if (mod16 === 0 || mod16 === 1 || mod16 === 4 || mod16 === 9) {
                let b = sqrtBigInt(residue);
                if (b * b === residue) {
                    if ((a - b) > 1n) {
                        let P2 = a + b;
                        let k = (P2 - 1n) / 2n;
                        let km1 = k - 1n;
                        let triPrev = (km1 * (km1 + 1n)) / 2n;
                        let L = triPrev + b + 1n;
                        self.postMessage({ found: true, k: k.toString(), b: b.toString(), L: L.toString() });
                        return;
                    }
                }
            }
            residue += (a << 1n) + 1n; 
            a++;
        }
        self.postMessage({ found: false });

    } catch(err) { self.postMessage({ found: false }); }
};
function sqrtBigInt(n) {
    if (n < 2n) return n;
    let x = n; let y = (x + 1n) / 2n;
    while (y < x) { x = y; y = (x + n / x) / 2n; }
    return x;
}
`;

// --- WORKER 2: GRID ENGINE (Visuals) ---
const gridWorkerCode = `
self.onmessage = (ev) => {
    const msg = ev.data;
    const process = (r_in, c_in) => {
        const k = BigInt(r_in);
        const b = BigInt(c_in);
        
        // DRAW GRID EVEN IF EMPTY
        if (b >= k || k === 0n) return { r: r_in, c: c_in, isEmpty: true };

        const P2 = (k * 2n) + 1n;
        const P1 = P2 - (b * 2n);
        
        const a = (P2 + P1) / 2n;
        const N = P2 * P1;
        
        const km1 = k - 1n;
        const triPrev = (km1 * (km1 + 1n)) / 2n;
        const L = triPrev + b + 1n;

        let displayVal = N.toString();
        if (displayVal.length > 8) displayVal = displayVal.slice(0,3) + ".." + displayVal.slice(-3);
        
        return {
            r: r_in, c: c_in, isEmpty: false,
            k: k.toString(), b: b.toString(),
            a: a.toString(), L: L.toString(),
            val: displayVal, fullVal: N.toString(),
            P2: P2.toString(), P1: P1.toString(),
            isSq: (b === 0n)
        };
    };

    if (msg.cmd === 'batch') {
        const res = msg.items.map(it => process(it.r, it.c));
        self.postMessage({ type: 'batch', payload: res });
    } else if (msg.cmd === 'cell') {
        const res = process(msg.r, msg.c);
        self.postMessage({ type: 'cell', payload: res });
    }
};
`;
const gridWorker = new Worker(URL.createObjectURL(new Blob([gridWorkerCode], {type:'application/javascript'})));

// --- APP LOGIC ---
const canvas = document.getElementById('gridCanvas');
const ctx = canvas.getContext('2d', {alpha: false});
const wrap = document.getElementById('canvasWrap');
let DPR = window.devicePixelRatio || 1;
let cellS = 60; 
let viewAnchor = { r: 1n, c: 0n };
let scrollX = 0, scrollY = 0;
let highlight = { r: 1n, c: 0n };
let cellCache = new Map();
let currentCellData = null; 
let workers = []; // The Worker Pool

document.getElementById('btnTurbo').onclick = () => {
    const val = document.getElementById('inpCargo').value.trim();
    if(!val) return;
    try {
        if(val.length < 8) { jumpToID(val); } 
        else {
            startMultiCoreScan(val);
        }
    } catch(e) {}
};

// --- MULTI-CORE SCANNER LOGIC ---
function startMultiCoreScan(N_str) {
    // 1. Kill old workers
    workers.forEach(w => w.terminate());
    workers = [];
    
    document.getElementById('sysStatus').innerText = `FIRING ${NUM_CORES} CORES...`;
    showToast(`SCANNING (${NUM_CORES}X SPEED)`);
    
    const WORKER_LIMIT = 5000000; // Each core checks 5M
    const workerBlob = new Blob([scanWorkerCode], {type:'application/javascript'});
    const workerUrl = URL.createObjectURL(workerBlob);

    for(let i=0; i<NUM_CORES; i++) {
        const w = new Worker(workerUrl);
        
        w.onmessage = function(e) {
            if(e.data.found) {
                // SUCCESS: Stop all other workers
                workers.forEach(wk => wk.terminate());
                workers = [];
                
                document.getElementById('sysStatus').innerText = "TARGET ACQUIRED";
                const k = BigInt(e.data.k);
                const b = BigInt(e.data.b);
                jumpToGrid(k, b);
                showToast("FRAME FITTED");
            }
        };
        
        // Start Worker in its own Sector
        // Core 0: 0 to 5M
        // Core 1: 5M to 10M
        // ...
        w.postMessage({
            N_str: N_str,
            startOffset: i * WORKER_LIMIT,
            scanLimit: WORKER_LIMIT
        });
        
        workers.push(w);
    }
}

function jumpToID(idStr) {
    try {
        const L = BigInt(idStr);
        if (L < 1n) return;
        let val = L * 8n + 1n;
        let root = sqrtBigInt(val);
        let k = (root + 1n) / 2n;
        let km1 = k - 1n;
        let triPrev = (km1 * (km1 + 1n)) / 2n;
        while (triPrev >= L) { k--; km1 = k - 1n; triPrev = (km1 * (km1 + 1n)) / 2n; }
        let b = L - triPrev - 1n;
        jumpToGrid(k, b);
    } catch(e) {}
}

function jumpToGrid(k, b) {
    let rStart = k - 2n; if(rStart < 1n) rStart = 1n;
    let cStart = b - 1n; if(cStart < 0n) cStart = 0n;
    viewAnchor = { r: rStart, c: cStart };
    highlight = { r: k, c: b };
    scrollX = 0; scrollY = 0;
    gridWorker.postMessage({cmd:'cell', r: k.toString(), c: b.toString()});
    cellCache.clear();
    requestBatch();
    draw();
}

function sqrtBigInt(n) {
    if (n < 2n) return n;
    let x = n; let y = (x + 1n) / 2n;
    while (y < x) { x = y; y = (x + n / x) / 2n; }
    return x;
}

// --- GRID VISUALS ---
gridWorker.onmessage = (ev) => {
    const msg = ev.data;
    if (msg.type === 'batch') {
        msg.payload.forEach(p => cellCache.set(`${p.r}|${p.c}`, p));
        draw();
    } else if (msg.type === 'cell') {
        const p = msg.payload;
        cellCache.set(`${p.r}|${p.c}`, p);
        if(p.r === highlight.r.toString() && p.c === highlight.c.toString() && !p.isEmpty) updateDecoder(p);
        draw();
    }
};

function requestBatch() {
    const w = canvas.width / DPR;
    const h = canvas.height / DPR;
    const cols = Math.ceil(w / cellS) + 2;
    const rows = Math.ceil(h / cellS) + 2;
    const items = [];
    
    for(let r = -1; r < rows; r++) {
        for (let c = -1; c < cols; c++) {
            const gridR = viewAnchor.r + BigInt(r);
            const gridC = viewAnchor.c + BigInt(c);
            if (gridR < 1n || gridC < 0n) continue;
            if(!cellCache.has(`${gridR}|${gridC}`)) items.push({r: gridR.toString(), c: gridC.toString()});
        }
    }
    if(items.length) gridWorker.postMessage({cmd:'batch', items});
}

function updateDecoder(p) {
    currentCellData = p;
    document.getElementById('dispAddr').innerText = `${p.a}-${p.b}`;
    let valStr = p.fullVal;
    if(valStr.length > 20) valStr = valStr.slice(0,8) + "..." + valStr.slice(-8);
    document.getElementById('dispVal').innerText = valStr;
    document.getElementById('dispK').innerText = p.k;
    document.getElementById('dispB').innerText = p.b;
    document.getElementById('dispL').innerText = p.L;
}

function draw() {
    const w = canvas.width / DPR;
    const h = canvas.height / DPR;
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
    ctx.fillStyle = '#020617'; ctx.fillRect(0, 0, w, h);

    const cols = Math.ceil(w / cellS) + 2;
    const rows = Math.ceil(h / cellS) + 2;

    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    
    while (scrollX > 0) { scrollX -= cellS; viewAnchor.c -= 1n; }
    while (scrollX <= -cellS) { scrollX += cellS; viewAnchor.c += 1n; }
    while (scrollY > 0) { scrollY -= cellS; viewAnchor.r -= 1n; }
    while (scrollY <= -cellS) { scrollY += cellS; viewAnchor.r += 1n; }

    for (let r = -1; r < rows; r++) { 
        for (let c = -1; c < cols; c++) {
            const gridR = viewAnchor.r + BigInt(r);
            const gridC = viewAnchor.c + BigInt(c);
            const x = c * cellS + scrollX;
            const y = r * cellS + scrollY;
            
            if(gridR < 1n || gridC < 0n) continue;

            const key = `${gridR}|${gridC}`;
            const cell = cellCache.get(key);
            const isSel = (gridR === highlight.r && gridC === highlight.c);
            
            ctx.strokeStyle = '#1e293b'; ctx.lineWidth = 1;
            ctx.strokeRect(x, y, cellS, cellS);

            if (cell && !cell.isEmpty) {
                if(cell.isSq) { ctx.fillStyle = 'rgba(52, 211, 153, 0.05)'; ctx.fillRect(x,y,cellS,cellS); }
                if(isSel) { 
                    ctx.fillStyle = 'rgba(52, 211, 153, 0.2)'; 
                    ctx.fillRect(x,y,cellS,cellS); 
                    ctx.strokeStyle='#fff'; ctx.lineWidth = 2;
                    ctx.strokeRect(x,y,cellS,cellS); 
                }

                const fsID = Math.max(8, Math.floor(cellS * 0.2));
                const fsAddr = Math.max(9, Math.floor(cellS * 0.25));

                ctx.font = `bold ${fsID}px monospace`;
                ctx.fillStyle = isSel ? '#cbd5e1' : '#475569';
                let idStr = cell.L;
                if(idStr.length > 5) idStr = idStr.slice(0,2) + ".." + idStr.slice(-2);
                ctx.fillText(idStr, x + cellS/2, y + cellS*0.3);

                ctx.font = `bold ${fsAddr}px monospace`;
                ctx.fillStyle = isSel ? '#fff' : (cell.isSq ? '#34d399' : '#94a3b8');
                let addrStr = `${cell.a}-${cell.b}`;
                if(cellS < 40) addrStr = cell.b === '0' ? 'SQ' : `.${cell.b}`; 
                ctx.fillText(addrStr, x + cellS/2, y + cellS*0.7);
            } else {
                ctx.fillStyle = '#0f172a';
                ctx.fillRect(x+2, y+2, cellS-4, cellS-4); 
            }
        }
    }
}

let dragging = false, lastX=0, lastY=0, startX=0, startY=0;
let pinchStartDist = 0, pinchStartCellS = 60;
function getDist(t1, t2) { return Math.hypot(t1.clientX-t2.clientX, t1.clientY-t2.clientY); }

function tapSelect(clientX, clientY) {
    const rect = wrap.getBoundingClientRect();
    const relX = clientX - rect.left - scrollX;
    const relY = clientY - rect.top - scrollY;
    const cIdx = Math.floor(relX / cellS);
    const rIdx = Math.floor(relY / cellS);
    const targetR = viewAnchor.r + BigInt(rIdx);
    const targetC = viewAnchor.c + BigInt(cIdx);
    if (targetR < 1n || targetC < 0n) return; 
    
    const key = `${targetR}|${targetC}`;
    const cell = cellCache.get(key);
    
    if(cell && !cell.isEmpty) {
        highlight = { r: targetR, c: targetC };
        updateDecoder(cell);
        draw();
    }
}

wrap.addEventListener('touchstart', e => {
    if(e.touches.length === 2) { dragging=false; pinchStartDist=getDist(e.touches[0], e.touches[1]); pinchStartCellS=cellS; }
    else if(e.touches.length === 1) { dragging=true; lastX=e.touches[0].clientX; lastY=e.touches[0].clientY; startX=lastX; startY=lastY; }
}, {passive:false});
wrap.addEventListener('touchmove', e => { e.preventDefault(); 
    if(e.touches.length===2){ const s=getDist(e.touches[0], e.touches[1])/pinchStartDist; cellS=Math.max(30,Math.min(150,Math.round(pinchStartCellS*s))); requestBatch(); draw(); }
    else if(dragging){ scrollX+=e.touches[0].clientX-lastX; scrollY+=e.touches[0].clientY-lastY; lastX=e.touches[0].clientX; lastY=e.touches[0].clientY; requestBatch(); draw(); }
}, {passive:false});
wrap.addEventListener('touchend', e => { dragging=false; if(e.changedTouches.length>0 && Math.hypot(e.changedTouches[0].clientX-startX, e.changedTouches[0].clientY-startY)<10) tapSelect(e.changedTouches[0].clientX, e.changedTouches[0].clientY); });
wrap.addEventListener('mousedown', e => { dragging=true; lastX=e.clientX; lastY=e.clientY; startX=e.clientX; startY=e.clientY; });
wrap.addEventListener('mousemove', e => { if(dragging){ scrollX+=e.clientX-lastX; scrollY+=e.clientY-lastY; lastX=e.clientX; lastY=e.clientY; requestBatch(); draw(); } });
wrap.addEventListener('mouseup', e => { dragging=false; if(Math.hypot(e.clientX-startX, e.clientY-startY)<5) tapSelect(e.clientX, e.clientY); });

document.getElementById('decoderPanel').onclick = () => { if(currentCellData) {
    document.getElementById('fullN').innerText = currentCellData.fullVal;
    document.getElementById('fullFactors').innerText = `${currentCellData.P2} × ${currentCellData.P1}`;
    document.getElementById('fullTape').innerText = currentCellData.L;
    document.getElementById('fullSmart').innerText = `${currentCellData.a}.${currentCellData.b}`;
    document.getElementById('fullValModal').style.display = 'flex';
}};
document.getElementById('closeFull').onclick = (e) => { e.stopPropagation(); document.getElementById('fullValModal').style.display = 'none'; };
function showToast(msg) { const t=document.getElementById('toast'); t.innerText=msg; t.classList.add('show'); setTimeout(()=>t.classList.remove('show'),2000); }
function resize() { DPR=window.devicePixelRatio||1; canvas.width=wrap.clientWidth*DPR; canvas.height=wrap.clientHeight*DPR; requestBatch(); draw(); }
window.onresize=resize; resize(); jumpToGrid(1n, 0n);

</script>
</body>
</html>
