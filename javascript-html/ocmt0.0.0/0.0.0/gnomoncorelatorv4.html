<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Gnomon Correlator v12 (Diagonal Smooth)</title>
<style>
    :root {
        --bg: #020617;
        --panel: #0f172a;
        --border: #1e293b;
        --cyan: #22d3ee;
        --text: #e2e8f0;
        --header-bg: #1e293b;
        --selection: #ffffff;
    }
    
    * { box-sizing: border-box; }

    body { 
        background: var(--bg); color: var(--text); 
        font-family: 'Courier New', monospace; 
        height: 100dvh; width: 100vw;
        margin: 0; padding: 0;
        display: flex; flex-direction: column; 
        overflow: hidden;
    }

    /* CONTROLS */
    .controls { 
        padding: 5px 10px; background: #0f172a; border-bottom: 1px solid var(--border); 
        display: flex; gap: 4px; align-items: center; justify-content: space-between;
        flex-shrink: 0; z-index: 200; height: 50px; width: 100%;
    }
    .brand { font-weight: 900; color: #fff; font-size: 0.85rem; letter-spacing: 1px; }
    
    .input-group { display: flex; gap: 6px; align-items: center; }
    .head-input { 
        background: #1e293b; border: 1px solid #334155; 
        color: var(--cyan); padding: 6px; width: 90px; text-align: center; 
        border-radius: 4px; font-weight: bold; font-family: monospace; font-size: 0.9rem;
    }
    .lbl { font-size:0.7rem; color:#94a3b8; font-weight:bold; }
    
    button { 
        background: var(--cyan); border: none; padding: 6px 12px; 
        border-radius: 4px; font-weight: bold; cursor: pointer; color: #000; font-size: 0.75rem;
    }

    /* CANVAS WRAPPER */
    .layout { display: flex; flex-direction: column; flex: 1; overflow: hidden; position: relative; width: 100%; }
    .canvas-wrapper { flex: 1; position: relative; background: #000; overflow: hidden; touch-action: none; }
    canvas { display: block; width: 100%; height: 100%; }

    /* DECODER PANEL (Bottom Fixed) */
    .decoder { 
        background: #0f172a; border-top: 3px solid var(--cyan); 
        display: flex; flex-direction: column; flex-shrink: 0; 
        height: auto; min-height: 220px;
        overflow-y: auto; 
        box-shadow: 0 -10px 50px rgba(0,0,0,0.8); z-index: 150;
    }

    .panel-section { padding: 12px; border-bottom: 1px solid var(--border); display: flex; justify-content: space-between; align-items: center; }
    .sec-title { font-size: 0.65rem; color: #64748b; font-weight: 800; letter-spacing: 1px; margin-bottom: 4px; }

    /* MATH DISPLAY */
    .big-math { background: #0b1120; }
    .bm-val { font-size: 1.6rem; font-weight: 900; color: #fff; }
    .bm-eq { font-size: 0.85rem; color: var(--cyan); font-weight: bold; margin-top: 4px; }

    /* INFO GRID */
    .info-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; padding: 10px; }
    .info-item { background: rgba(255,255,255,0.03); border: 1px solid var(--border); padding: 8px; border-radius: 4px; text-align: center; }
    .info-lbl { font-size: 0.6rem; color: #94a3b8; font-weight: bold; margin-bottom: 2px; }
    .info-val { font-size: 1.1rem; color: #fff; font-weight: bold; }
    
    /* Colors for indices */
    .txt-k { color: #34d399; } /* Green */
    .txt-g { color: #f472b6; } /* Pink */
    .txt-a { color: #3b82f6; } /* Blue */
</style>
</head>
<body>

<div class="controls">
    <span class="brand">GNOMON CORRELATOR v12</span>
    <div class="input-group">
        <span class="lbl">JUMP TO ROW (k):</span>
        <input id="inpK" class="head-input" type="number" value="0" min="0">
        <button id="btnGo">GO</button>
    </div>
</div>

<div class="layout">
    <div class="canvas-wrapper" id="canvasWrap">
        <canvas id="gridCanvas"></canvas>
    </div>

    <div class="decoder">
        <div class="panel-section big-math">
            <div>
                <div class="sec-title">COMPRESSION INDEX (a - b)</div>
                <div id="dispComp" class="bm-val">--</div>
            </div>
            <div style="text-align:right">
                <div class="sec-title">VALUE (N)</div>
                <div id="dispVal" class="bm-eq" style="font-size:1.2rem; color:white">--</div>
            </div>
        </div>

        <div class="info-grid">
            <div class="info-item" style="border-color: rgba(52, 211, 153, 0.3);">
                <div class="info-lbl">ROW KEY (k)</div>
                <div id="dispK" class="info-val txt-k">--</div>
            </div>
            <div class="info-item" style="border-color: rgba(52, 211, 153, 0.3);">
                <div class="info-lbl">COL KEY (j)</div>
                <div id="dispJ" class="info-val txt-k">--</div>
            </div>
            <div class="info-item" style="border-color: rgba(59, 130, 246, 0.3);">
                <div class="info-lbl">OUTER SQUARE (a)</div>
                <div id="dispA" class="info-val txt-a">--</div>
            </div>
            <div class="info-item">
                <div class="info-lbl">INNER GAP (b)</div>
                <div id="dispB" class="info-val">--</div>
            </div>
        </div>
        
        <div style="padding:10px; text-align:center; font-size:0.7rem; color:#64748b;">
            Factorization: P₂ = 2k+1 &nbsp;|&nbsp; P₁ = 2j+1
        </div>
    </div>
</div>

<script>
/* GNOMON CORRELATOR v12 (Diagonal + Smooth)
   - Interface: Correlator Style
   - Layout: Standard Diagonal Grid (k * j)
   - Engine: Pixel-Smooth Virtual Canvas
*/

// --- DOM & CONFIG ---
const canvas = document.getElementById('gridCanvas');
const wrap = document.getElementById('canvasWrap');
const ctx = canvas.getContext('2d', {alpha: false});
const inpK = document.getElementById('inpK');
const btnGo = document.getElementById('btnGo');

let DPR = window.devicePixelRatio || 1;
const CELL_W = 64;
const CELL_H = 64;
const HEADER_SIZE = 40; 

// View state is now PIXEL BASED offset, not integer cells, for smooth scroll
let scrollX = 0;
let scrollY = 0;

let selected = { k: 2, j: 0 };
let cellCache = new Map();

// --- WORKER: BIGINT INDEXING ---
const workerCode = `
self.addEventListener('message', (ev) => {
    const msg = ev.data;
    const P_from_idx = (idx) => idx * 2n + 1n;

    const process = (k_in, j_in) => {
        const k = BigInt(k_in);
        const j = BigInt(j_in);
        
        // Standard Grid Logic: P2 from Row(k), P1 from Col(j)
        // Ensure P2 >= P1 for standard compression notation
        let P2, P1;
        if (k >= j) { P2 = P_from_idx(k); P1 = P_from_idx(j); }
        else        { P2 = P_from_idx(j); P1 = P_from_idx(k); }

        const a = (P2 + P1) / 2n;
        const b = (P2 - P1) / 2n;
        const val = P2 * P1;

        return {
            k: k_in, j: j_in,
            a: a.toString(),
            b: b.toString(),
            val: val.toString(),
            isSq: (k === j),
            isWall: (val % 3n === 0n)
        };
    };

    if (msg.cmd === 'batch') {
        const res = msg.items.map(it => process(it.k, it.j));
        self.postMessage({ type: 'batch', payload: res });
    } else if (msg.cmd === 'cell') {
        const res = process(msg.k, msg.j);
        self.postMessage({ type: 'cell', payload: res });
    }
});
`;
const worker = new Worker(URL.createObjectURL(new Blob([workerCode], {type:'application/javascript'})));

worker.onmessage = (ev) => {
    const msg = ev.data;
    if (msg.type === 'batch') {
        msg.payload.forEach(p => cellCache.set(`${p.k}|${p.j}`, p));
        draw();
    } else if (msg.type === 'cell' && msg.payload) {
        const p = msg.payload;
        cellCache.set(`${p.k}|${p.j}`, p);
        if(selected.k === p.k && selected.j === p.j) updateDecoder(p);
        draw();
    }
};

// --- DRAWING ENGINE (Smooth Scroll) ---
function draw() {
    const w = canvas.width / DPR;
    const h = canvas.height / DPR;
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
    
    // Background
    ctx.fillStyle = '#020617';
    ctx.fillRect(0, 0, w, h);

    // Grid Dimensions
    const gridW = w - HEADER_SIZE;
    const gridH = h - HEADER_SIZE;

    // Calculate visible range based on pixel scroll
    // first visible cell index
    const startColIdx = Math.floor(scrollX / CELL_W);
    const startRowIdx = Math.floor(scrollY / CELL_H);
    
    // Pixel offset for smooth movement (modulo)
    const offX = -(scrollX % CELL_W);
    const offY = -(scrollY % CELL_H);

    const colsToDraw = Math.ceil(gridW / CELL_W) + 1;
    const rowsToDraw = Math.ceil(gridH / CELL_H) + 1;

    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    // 1. Draw MAIN GRID Cells
    ctx.save();
    ctx.translate(HEADER_SIZE + offX, HEADER_SIZE + offY);
    
    for (let r = 0; r < rowsToDraw; r++) {
        for (let c = 0; c < colsToDraw; c++) {
            const k = startRowIdx + r;
            const j = startColIdx + c;
            
            // In diagonal mode, we usually render the triangle where k >= j or full grid
            // Let's render full grid for familiarity
            if (k < 0 || j < 0) continue; 

            const x = c * CELL_W;
            const y = r * CELL_H;
            const key = `${k}|${j}`;
            const cell = cellCache.get(key);

            let bg = '#111827';
            let txtColor = '#e2e8f0';

            if (cell) {
                if (cell.isSq) { 
                    bg = 'rgba(59, 130, 246, 0.15)'; 
                    txtColor = '#fff'; 
                } else if (cell.isWall) {
                    bg = '#1a1005';
                    txtColor = '#92400e';
                }
            }

            // Selection
            if (k === selected.k && j === selected.j) {
                bg = '#fff';
                txtColor = '#000';
            }

            // Cell Body
            ctx.fillStyle = bg;
            ctx.fillRect(x, y, CELL_W - 1, CELL_H - 1);
            
            if (k === selected.k && j === selected.j) {
                ctx.strokeStyle = '#22d3ee';
                ctx.lineWidth = 2;
                ctx.strokeRect(x, y, CELL_W - 1, CELL_H - 1);
            }

            // Text: Compression Index (a - b)
            if (cell) {
                ctx.font = 'bold 12px monospace';
                ctx.fillStyle = txtColor;
                ctx.fillText(`${cell.a}-${cell.b}`, x + CELL_W/2, y + CELL_H/2);
            } else {
                ctx.font = '10px monospace';
                ctx.fillStyle = '#334155';
                ctx.fillText('...', x + CELL_W/2, y + CELL_H/2);
            }
        }
    }
    ctx.restore();

    // 2. Draw STICKY HEADERS (Top)
    ctx.save();
    ctx.translate(HEADER_SIZE + offX, 0); // Move with X scroll only
    for (let c = 0; c < colsToDraw; c++) {
        const j = startColIdx + c;
        if(j < 0) continue;
        const x = c * CELL_W;
        
        ctx.fillStyle = '#1e293b';
        ctx.fillRect(x, 0, CELL_W - 1, HEADER_SIZE - 2);
        
        ctx.fillStyle = '#22d3ee'; 
        ctx.fillRect(x, HEADER_SIZE - 2, CELL_W - 1, 2);

        ctx.font = 'bold 12px monospace';
        ctx.fillStyle = '#22d3ee';
        ctx.fillText(j, x + CELL_W/2, HEADER_SIZE/2);
    }
    ctx.restore();

    // 3. Draw STICKY HEADERS (Left)
    ctx.save();
    ctx.translate(0, HEADER_SIZE + offY); // Move with Y scroll only
    for (let r = 0; r < rowsToDraw; r++) {
        const k = startRowIdx + r;
        if(k < 0) continue;
        const y = r * CELL_H;

        ctx.fillStyle = '#1e293b';
        ctx.fillRect(0, y, HEADER_SIZE - 1, CELL_H - 1);

        ctx.fillStyle = '#22d3ee';
        ctx.fillRect(HEADER_SIZE - 2, y, 2, CELL_H - 1);

        ctx.font = 'bold 11px monospace';
        ctx.fillStyle = '#34d399'; 
        ctx.fillText(k, HEADER_SIZE/2, y + CELL_H/2);
    }
    ctx.restore();

    // Corner Block
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(0, 0, HEADER_SIZE, HEADER_SIZE);
    ctx.strokeStyle = '#22d3ee';
    ctx.strokeRect(0, 0, HEADER_SIZE, HEADER_SIZE);
    ctx.font = 'bold 10px monospace';
    ctx.fillStyle = '#fff';
    ctx.fillText('k \\ j', HEADER_SIZE/2, HEADER_SIZE/2);
}

// --- LOGIC & INTERACTION ---
function requestBatch() {
    const w = canvas.width / DPR;
    const h = canvas.height / DPR;
    const gridW = w - HEADER_SIZE;
    const gridH = h - HEADER_SIZE;
    
    const startColIdx = Math.floor(scrollX / CELL_W);
    const startRowIdx = Math.floor(scrollY / CELL_H);
    
    const cols = Math.ceil(gridW / CELL_W) + 2;
    const rows = Math.ceil(gridH / CELL_H) + 2;
    
    const items = [];

    for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
            const k = startRowIdx + r;
            const j = startColIdx + c;
            const key = `${k}|${j}`;
            if (!cellCache.has(key)) items.push({k, j});
        }
    }
    if (items.length) worker.postMessage({cmd: 'batch', items});
}

function updateDecoder(p) {
    if(!p) return;
    document.getElementById('dispComp').innerText = `${p.a} - ${p.b}`;
    document.getElementById('dispVal').innerText = p.val;
    document.getElementById('dispK').innerText = p.k;
    document.getElementById('dispJ').innerText = p.j;
    document.getElementById('dispA').innerText = p.a;
    document.getElementById('dispB').innerText = p.b;
}

function select(k, j) {
    selected = { k, j };
    const key = `${k}|${j}`;
    const p = cellCache.get(key);
    if(p) updateDecoder(p);
    else worker.postMessage({cmd: 'cell', k, j});
    draw();
}

let isDragging = false;
let lastX = 0, lastY = 0;
// Velocity variables
let velX = 0, velY = 0;
let rafId = null;

wrap.addEventListener('pointerdown', e => {
    isDragging = true; lastX = e.clientX; lastY = e.clientY;
    velX = 0; velY = 0; // Stop momentum
    if(rafId) cancelAnimationFrame(rafId);
    wrap.setPointerCapture(e.pointerId);
});

wrap.addEventListener('pointermove', e => {
    if (!isDragging) return;
    const dx = e.clientX - lastX;
    const dy = e.clientY - lastY;
    
    // Smooth Scroll: update pixel offset directly
    scrollX -= dx;
    scrollY -= dy;
    
    if(scrollX < 0) scrollX = 0;
    if(scrollY < 0) scrollY = 0;

    lastX = e.clientX; lastY = e.clientY;
    
    // Track velocity for throw
    velX = dx; velY = dy;
    
    requestBatch(); draw();
});

wrap.addEventListener('pointerup', e => {
    isDragging = false;
    
    // Click detection (small movement)
    const rect = canvas.getBoundingClientRect();
    // Use raw clientX/Y delta for click check logic
    if (Math.abs(velX) < 2 && Math.abs(velY) < 2) {
         const cx = (e.clientX - rect.left) * DPR;
         const cy = (e.clientY - rect.top) * DPR;
         if (cx > HEADER_SIZE && cy > HEADER_SIZE) {
             // Calculate cell based on pixel offsets
             const j = Math.floor((cx - HEADER_SIZE + (scrollX % CELL_W) + (Math.floor(scrollX/CELL_W)*CELL_W)) / CELL_W); 
             // Simplified: just add scroll + pixel pos
             const rawX = cx - HEADER_SIZE + scrollX;
             const rawY = cy - HEADER_SIZE + scrollY;
             const c = Math.floor(rawX / CELL_W);
             const r = Math.floor(rawY / CELL_H);
             select(r, c);
         }
         return;
    }

    // Momentum throw
    function momentum() {
        if(Math.abs(velX) < 0.1 && Math.abs(velY) < 0.1) return;
        
        scrollX -= velX;
        scrollY -= velY;
        
        if(scrollX < 0) { scrollX = 0; velX = 0; }
        if(scrollY < 0) { scrollY = 0; velY = 0; }
        
        velX *= 0.95; // Friction
        velY *= 0.95;
        
        requestBatch(); draw();
        rafId = requestAnimationFrame(momentum);
    }
    momentum();
});

// Jump Controls
btnGo.addEventListener('click', () => {
    const k = parseInt(inpK.value) || 0;
    // Jump to that row
    scrollY = k * CELL_H;
    scrollX = 0; // Reset col
    cellCache.clear(); 
    requestBatch(); 
    select(k, 0);
});

function resize() {
    DPR = window.devicePixelRatio || 1;
    canvas.width = wrap.clientWidth * DPR;
    canvas.height = wrap.clientHeight * DPR;
    requestBatch(); draw();
}
window.addEventListener('resize', resize);

// Init
resize();
select(2, 2);

</script>
</body>
</html>
