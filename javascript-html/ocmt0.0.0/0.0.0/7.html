<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>ANDY'S NAVIGATOR v7.2 (Selection Fixed)</title>
<style>
    :root {
        --bg: #020617; --panel: #0f172a; --border: #1e293b;
        --cyan: #22d3ee; --text: #e2e8f0; --pink: #f472b6; --green: #34d399;
        --input-bg: rgba(0,0,0,0.3);
    }
    * { box-sizing: border-box; }
    body { 
        background: var(--bg); color: var(--text); font-family: 'Courier New', monospace; 
        height: 100dvh; margin: 0; display: flex; flex-direction: column; overflow: hidden; 
        overscroll-behavior: none;
    }

    /* DASHBOARD */
    .top-section {
        background: var(--panel); border-bottom: 2px solid var(--cyan);
        padding: 8px; flex-shrink: 0; z-index: 200; display: flex; flex-direction: column; gap: 8px;
        box-shadow: 0 4px 15px rgba(0,0,0,0.5);
    }
    .tape-row { display: flex; gap: 8px; align-items: center; background: #1e293b; padding: 4px; border-radius: 4px; border: 1px solid var(--cyan); }
    .tape-lbl { font-weight: 900; color: var(--bg); background: var(--cyan); padding: 4px 8px; border-radius: 2px; font-size: 0.8rem; white-space: nowrap; }
    #inpTapeID { flex: 1; background: transparent; border: none; color: #fff; font-family: inherit; font-weight: bold; font-size: 1rem; outline: none; min-width: 0; }
    #btnGoTape { background: var(--green); color: #000; border: none; font-weight: 900; padding: 6px 12px; cursor: pointer; border-radius: 2px; }

    .cargo-row { display: flex; gap: 8px; }
    #inpFind { flex: 1; background: var(--input-bg); border: 1px solid #334155; color: #fff; padding: 8px; font-weight: bold; text-align: center; border-radius: 4px; font-size: 16px; }
    #btnFind { background: var(--pink); color: #000; border: none; font-weight: 900; padding: 0 15px; border-radius: 4px; cursor: pointer; }

    /* CANVAS */
    .layout { flex: 1; position: relative; overflow: hidden; background: #000; touch-action: none; }
    canvas { display: block; width: 100%; height: 100%; cursor: crosshair; }

    /* DECODER */
    .decoder { background: #0f172a; border-top: 3px solid var(--cyan); display: flex; flex-direction: column; flex-shrink: 0; padding-bottom: max(10px, env(safe-area-inset-bottom)); }
    .big-readout { padding: 10px; display: flex; justify-content: space-between; align-items: baseline; background: #0b1120; border-bottom: 1px solid #1e293b; }
    .readout-val { font-size: 1.2rem; font-weight: 900; color: var(--cyan); }
    
    .info-grid { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 5px; padding: 5px; }
    .info-item { background: rgba(255,255,255,0.05); padding: 4px; text-align: center; border-radius: 4px; }
    .info-lbl { font-size: 0.6rem; color: #94a3b8; }
    .info-val { font-weight: bold; color: #fff; font-size: 0.9rem; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    
    /* TOAST */
    #toast {
        position: fixed; top: 120px; left: 50%; transform: translateX(-50%);
        background: rgba(15, 23, 42, 0.95); border: 1px solid var(--cyan); color: var(--cyan);
        padding: 10px 20px; border-radius: 20px; font-weight: bold; opacity: 0; pointer-events: none; transition: opacity 0.3s;
        z-index: 500;
    }
    #toast.show { opacity: 1; }
</style>
</head>
<body>

<div id="toast">JUMPING...</div>

<div class="top-section">
    <div class="tape-row">
        <div class="tape-lbl">ID (L)</div>
        <input id="inpTapeID" type="text" placeholder="Paste Tape ID...">
        <button id="btnGoTape">GO</button>
    </div>
    <div class="cargo-row">
        <input id="inpFind" type="text" placeholder="Or Enter Cargo (N)...">
        <button id="btnFind">SCAN</button>
    </div>
</div>

<div class="layout" id="canvasWrap">
    <canvas id="gridCanvas"></canvas>
</div>

<div class="decoder">
    <div class="big-readout">
        <div>
            <div class="info-lbl">ADDRESS (Smart ID)</div>
            <div class="readout-val" id="dispAddr">--.--</div>
        </div>
        <div style="text-align:right">
            <div class="info-lbl">CARGO (N)</div>
            <div class="readout-val" id="dispVal" style="color:#fff; font-size:1rem;">--</div>
        </div>
    </div>
    <div class="info-grid">
        <div class="info-item">
            <div class="info-lbl">ROW (k)</div>
            <div class="info-val" id="dispK" style="color:var(--green)">--</div>
        </div>
        <div class="info-item">
            <div class="info-lbl">GAP (b)</div>
            <div class="info-val" id="dispB" style="color:var(--pink)">--</div>
        </div>
        <div class="info-item">
            <div class="info-lbl">TAPE ID (L)</div>
            <div class="info-val" id="dispL" style="color:#cbd5e1">--</div>
        </div>
    </div>
</div>

<script>
// --- WORKER ---
const workerCode = `
self.onmessage = (ev) => {
    const msg = ev.data;
    const process = (r_in, c_in) => {
        const k = BigInt(r_in);
        const b = BigInt(c_in);
        
        const P2 = (k * 2n) + 1n;
        const P1 = P2 - (b * 2n);
        if (P1 <= 0n) return null;

        const a = (P2 + P1) / 2n;
        const N = P2 * P1;
        
        const triK = (k * (k + 1n)) / 2n;
        const L = triK + b;

        let displayVal = N.toString();
        if (displayVal.length > 8) displayVal = displayVal.slice(0,3) + ".." + displayVal.slice(-3);
        
        return {
            r: r_in, c: c_in,
            k: k.toString(), b: b.toString(),
            a: a.toString(), L: L.toString(),
            val: displayVal, fullVal: N.toString(),
            P2: P2.toString(), P1: P1.toString(),
            isSq: (b === 0n)
        };
    };

    if (msg.cmd === 'batch') {
        const res = msg.items.map(it => process(it.r, it.c)).filter(x => x);
        self.postMessage({ type: 'batch', payload: res });
    } else if (msg.cmd === 'cell') {
        const res = process(msg.r, msg.c);
        self.postMessage({ type: 'cell', payload: res });
    }
};
`;
const worker = new Worker(URL.createObjectURL(new Blob([workerCode], {type:'application/javascript'})));

// --- APP STATE ---
const canvas = document.getElementById('gridCanvas');
const ctx = canvas.getContext('2d', {alpha: false});
const wrap = document.getElementById('canvasWrap');
let DPR = window.devicePixelRatio || 1;
let cellS = 60; 
let viewAnchor = { r: 0n, c: 0n };
let scrollX = 0, scrollY = 0;
let highlight = { r: 0n, c: 0n }; // Selection State
let cellCache = new Map();

// --- TAPE LOGIC ---
function jumpToID(idStr) {
    try {
        const L = BigInt(idStr);
        if (L < 1n) return;
        
        showToast(`UNPACKING ID...`);
        let val = L * 8n + 1n;
        let root = sqrtBigInt(val);
        let k = (root - 1n) / 2n;
        let triK = (k * (k + 1n)) / 2n;
        while (triK > L) { k--; triK = (k * (k + 1n)) / 2n; }
        let b = L - triK;
        jumpToGrid(k, b);
        document.getElementById('inpTapeID').value = idStr;
    } catch(e) { showToast("Invalid ID"); }
}

function jumpToGrid(k, b) {
    // Center the view roughly, but 'viewAnchor' is top-left in this renderer logic
    // We set viewAnchor so that (k,b) is visible
    // Let's set viewAnchor slightly 'before' k,b so it isn't tucked in corner
    let rStart = k - 2n; if(rStart < 0n) rStart = 0n;
    let cStart = b - 1n; if(cStart < 0n) cStart = 0n;
    
    viewAnchor = { r: rStart, c: cStart };
    highlight = { r: k, c: b }; // SELECT IT
    scrollX = 0; scrollY = 0;
    
    // Explicitly fetch data for the decoder panel
    worker.postMessage({cmd:'cell', r: k.toString(), c: b.toString()});
    
    cellCache.clear();
    requestBatch();
    draw();
}

function sqrtBigInt(n) {
    if (n < 2n) return n;
    let x = n; let y = (x + 1n) / 2n;
    while (y < x) { x = y; y = (x + n / x) / 2n; }
    return x;
}

// --- SCANNER ---
function findCargo() {
    const val = document.getElementById('inpFind').value.trim();
    if(!val) return;
    showToast("SCANNING...");
    try {
        const N = BigInt(val);
        let a = sqrtBigInt(N);
        if (a*a < N) a++;
        let found = false;
        for(let i=0; i<50000; i++) {
            let res = a*a - N;
            let b = sqrtBigInt(res);
            if(b*b === res) {
                let P2 = a+b;
                let k = (P2 - 1n)/2n;
                jumpToGrid(k, b);
                showToast("CARGO FOUND");
                found = true; break;
            }
            a++;
        }
        if(!found) showToast("NOT FOUND (Try ID)");
    } catch(e) { showToast("Invalid N"); }
}

// --- WORKER HANDLER ---
worker.onmessage = (ev) => {
    const msg = ev.data;
    if (msg.type === 'batch') {
        msg.payload.forEach(p => cellCache.set(`${p.r}|${p.c}`, p));
        draw();
    } else if (msg.type === 'cell') {
        const p = msg.payload;
        cellCache.set(`${p.r}|${p.c}`, p);
        // Only update decoder if this cell is the one currently highlighted
        if(p.r === highlight.r.toString() && p.c === highlight.c.toString()) {
            updateDecoder(p);
        }
        draw();
    }
};

function requestBatch() {
    const w = canvas.width / DPR;
    const h = canvas.height / DPR;
    const cols = Math.ceil(w / cellS) + 2;
    const rows = Math.ceil(h / cellS) + 2;
    const items = [];
    
    for(let r = -1; r < rows; r++) {
        for (let c = -1; c < cols; c++) {
            const gridR = viewAnchor.r + BigInt(r);
            const gridC = viewAnchor.c + BigInt(c);
            if (gridR < 0n || gridC < 0n || gridC > gridR) continue;

            if(!cellCache.has(`${gridR}|${gridC}`)) {
                 items.push({r: gridR.toString(), c: gridC.toString()});
            }
        }
    }
    if(items.length) worker.postMessage({cmd:'batch', items});
}

function updateDecoder(p) {
    document.getElementById('dispAddr').innerText = `${p.a}-${p.b}`;
    let valStr = p.fullVal;
    if(valStr.length > 20) valStr = valStr.slice(0,8) + "..." + valStr.slice(-8);
    document.getElementById('dispVal').innerText = valStr;
    document.getElementById('dispK').innerText = p.k;
    document.getElementById('dispB').innerText = p.b;
    document.getElementById('dispL').innerText = p.L;
}

// --- DRAWING ---
function draw() {
    const w = canvas.width / DPR;
    const h = canvas.height / DPR;
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
    ctx.fillStyle = '#020617'; ctx.fillRect(0, 0, w, h);

    const cols = Math.ceil(w / cellS) + 2;
    const rows = Math.ceil(h / cellS) + 2;

    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    
    // Smooth Infinite Scroll Logic
    while (scrollX > 0) { scrollX -= cellS; viewAnchor.c -= 1n; }
    while (scrollX <= -cellS) { scrollX += cellS; viewAnchor.c += 1n; }
    while (scrollY > 0) { scrollY -= cellS; viewAnchor.r -= 1n; }
    while (scrollY <= -cellS) { scrollY += cellS; viewAnchor.r += 1n; }

    for (let r = -1; r < rows; r++) { 
        for (let c = -1; c < cols; c++) {
            const gridR = viewAnchor.r + BigInt(r);
            const gridC = viewAnchor.c + BigInt(c);
            const x = c * cellS + scrollX;
            const y = r * cellS + scrollY;
            
            if(gridR < 0n || gridC < 0n || gridC > gridR) continue;

            const key = `${gridR}|${gridC}`;
            const cell = cellCache.get(key);
            const isSel = (gridR === highlight.r && gridC === highlight.c);
            
            ctx.strokeStyle = '#1e293b'; ctx.lineWidth = 1;
            ctx.strokeRect(x, y, cellS, cellS);

            if (cell) {
                // Background
                if(cell.isSq) { ctx.fillStyle = 'rgba(34, 211, 238, 0.05)'; ctx.fillRect(x,y,cellS,cellS); }
                if(isSel) { 
                    ctx.fillStyle = 'rgba(244, 114, 182, 0.2)'; 
                    ctx.fillRect(x,y,cellS,cellS); 
                    ctx.strokeStyle='#fff'; ctx.lineWidth = 2;
                    ctx.strokeRect(x,y,cellS,cellS); 
                }

                // Fonts
                const fsID = Math.max(8, Math.floor(cellS * 0.2));
                const fsAddr = Math.max(9, Math.floor(cellS * 0.25));

                // 1. TAPE ID
                ctx.font = `bold ${fsID}px monospace`;
                ctx.fillStyle = isSel ? '#cbd5e1' : '#475569';
                let idStr = cell.L;
                if(idStr.length > 5) idStr = idStr.slice(0,2) + ".." + idStr.slice(-2);
                ctx.fillText(idStr, x + cellS/2, y + cellS*0.3);

                // 2. ADDRESS
                ctx.font = `bold ${fsAddr}px monospace`;
                ctx.fillStyle = isSel ? '#fff' : (cell.isSq ? '#22d3ee' : '#94a3b8');
                let addrStr = `${cell.a}-${cell.b}`;
                if(cellS < 40) addrStr = cell.b === '0' ? 'SQ' : `.${cell.b}`; 
                ctx.fillText(addrStr, x + cellS/2, y + cellS*0.7);
            }
        }
    }
}

// --- TOUCH & TAP LOGIC (Restored) ---
let dragging = false, lastX=0, lastY=0, startX=0, startY=0;
let pinchStartDist = 0, pinchStartCellS = 60;

function getDist(t1, t2) { return Math.hypot(t1.clientX-t2.clientX, t1.clientY-t2.clientY); }

// Tap Selection Logic
function tapSelect(clientX, clientY) {
    const rect = wrap.getBoundingClientRect();
    const relX = clientX - rect.left - scrollX;
    const relY = clientY - rect.top - scrollY;
    
    const cIdx = Math.floor(relX / cellS);
    const rIdx = Math.floor(relY / cellS);
    
    const targetR = viewAnchor.r + BigInt(rIdx);
    const targetC = viewAnchor.c + BigInt(cIdx);
    
    if (targetR < 0n || targetC < 0n || targetC > targetR) return; // Ignore click outside valid grid
    
    // Highlight
    highlight = { r: targetR, c: targetC };
    
    // Ask worker for details
    worker.postMessage({cmd:'cell', r: targetR.toString(), c: targetC.toString()});
    
    draw();
}

wrap.addEventListener('touchstart', e => {
    if(e.touches.length === 2) {
        dragging = false;
        pinchStartDist = getDist(e.touches[0], e.touches[1]);
        pinchStartCellS = cellS;
    } else if (e.touches.length === 1) {
        dragging = true;
        lastX = e.touches[0].clientX; lastY = e.touches[0].clientY;
        startX = lastX; startY = lastY;
    }
}, {passive:false});

wrap.addEventListener('touchmove', e => {
    e.preventDefault(); 
    if(e.touches.length === 2) {
        const dist = getDist(e.touches[0], e.touches[1]);
        const scale = dist / pinchStartDist;
        let newS = Math.round(pinchStartCellS * scale);
        if(newS < 30) newS = 30; if(newS > 150) newS = 150;
        cellS = newS;
        requestBatch(); draw();
    } else if (dragging && e.touches.length === 1) {
        const dx = e.touches[0].clientX - lastX;
        const dy = e.touches[0].clientY - lastY;
        scrollX += dx; scrollY += dy;
        lastX = e.touches[0].clientX; lastY = e.touches[0].clientY;
        requestBatch(); draw();
    }
}, {passive:false});

wrap.addEventListener('touchend', e => {
    dragging = false;
    if(e.changedTouches.length > 0) {
        const t = e.changedTouches[0];
        const dist = Math.hypot(t.clientX - startX, t.clientY - startY);
        if(dist < 10) tapSelect(t.clientX, t.clientY); // TAP DETECTED
    }
});

// Mouse Support
wrap.addEventListener('mousedown', e => { dragging=true; lastX=e.clientX; lastY=e.clientY; startX=e.clientX; startY=e.clientY; });
wrap.addEventListener('mousemove', e => {
    if(dragging) {
        scrollX += e.clientX-lastX; scrollY += e.clientY-lastY;
        lastX=e.clientX; lastY=e.clientY;
        requestBatch(); draw();
    }
});
wrap.addEventListener('mouseup', e => {
    dragging=false; 
    const dist = Math.hypot(e.clientX - startX, e.clientY - startY);
    if(dist < 5) tapSelect(e.clientX, e.clientY); // CLICK DETECTED
});
wrap.addEventListener('wheel', e => {
    e.preventDefault();
    let newS = cellS - Math.sign(e.deltaY)*5;
    if(newS < 30) newS = 30; if(newS > 150) newS = 150;
    cellS = newS;
    requestBatch(); draw();
}, {passive:false});


// Init
document.getElementById('btnGoTape').onclick = () => jumpToID(document.getElementById('inpTapeID').value.trim());
document.getElementById('btnFind').onclick = findCargo;
function showToast(msg) {
    const t = document.getElementById('toast');
    t.innerText = msg; t.classList.add('show');
    setTimeout(() => t.classList.remove('show'), 2000);
}
function resize() {
    DPR = window.devicePixelRatio || 1;
    canvas.width = wrap.clientWidth * DPR;
    canvas.height = wrap.clientHeight * DPR;
    requestBatch(); draw();
}
window.onresize = resize;
resize();
jumpToID("1");

</script>
</body>
</html>
