<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Number Theory Factor Finder (FactorHunter 9.3)</title>
<!-- We need this on the main page for the S-List Resolver (Step 4) -->
<script src="https://unpkg.com/big-integer@1.6.48/BigInteger.min.js"></script>
<style>
:root {
--bg-color: #f3f4f6;
--text-color: #1f2937;
--card-bg: #fff;
--card-text: #374151;
--input-bg: #f9fafb;
--input-border: #d1d5db;
--button-bg: #2563eb;
--button-hover: #1d4ed8;
--log-bg: #e2e8f0;
--progress-bg: #4caf50;
--header-color: #1d4ed8;
--warning-bg: #f97316; /* Orange 500 */
--warning-hover: #ea580c; /* Orange 600 */
--resolve-bg: #16a34a; /* Green 600 */
--resolve-hover: #15803d; /* Green 700 */
--smin-bg: #2563eb; /* Blue 600 */
--smin-hover: #1d4ed8; /* Blue 700 */
--combined-bg: #be123c; /* Rose 700 */
--combined-hover: #9f1239; /* Rose 800 */
}
body {
font-family: system-ui, sans-serif;
background: var(--bg-color);
color: var(--text-color);
display:flex;
justify-content:center;
align-items:center;
min-height:100vh;
flex-direction:column;
padding:2rem;
max-height: 100vh;
overflow-y: auto;
}
.container {
max-width: 900px;
width: 100%;
background: var(--card-bg);
border-radius: .5rem;
box-shadow: 0 10px 15px rgba(0,0,0,.1);
padding: 2.5rem;
margin-top: 2rem;
max-height: calc(100vh - 4rem);
overflow-y: auto;
}
h2 { text-align:center; color: var(--header-color); margin-bottom: 2rem; font-size:2rem; font-weight:700; }
h3 { margin-top:1.5rem; margin-bottom:1rem; color:var(--card-text); border-bottom:2px solid var(--input-border); padding-bottom:.5rem; }
.grid { display:grid; grid-template-columns: repeat(auto-fit, minmax(200px,1fr)); gap: 1.5rem; }
.input-group, .button-group { display:flex; flex-direction:column; }
label { margin-bottom:.5rem; font-weight:600; }
input[type="text"] { padding:.75rem; border:1px solid var(--input-border); border-radius:.25rem; background:var(--input-bg); color:var(--card-text); font-size:1rem; }
input:focus { outline:none; border-color:var(--button-bg); }
.button-group { flex-direction:row; flex-wrap:wrap; gap:.75rem; margin-top:1rem; }
button { padding:.75rem 1.25rem; border:none; border-radius:.25rem; background:var(--button-bg); color:#fff; font-weight:600; cursor:pointer; }
button:hover:not(:disabled){ background: var(--button-hover); }
button:disabled { background:#9ca3af; cursor:not-allowed; }

/* --- Button Color Overrides --- */
#resolveSASButton { background-color: var(--resolve-bg); }
#resolveSASButton:hover:not(:disabled) { background-color: var(--resolve-hover); }
#verifyButton { background-color: #6d28d9; } /* Violet 700 */
#verifyButton:hover:not(:disabled) { background-color: #5b21b6; } /* Violet 800 */
#findSMinButton { background-color: var(--smin-bg); }
#findSMinButton:hover:not(:disabled) { background-color: var(--smin-hover); }
/* Combined button color */
.auto-run-combined { background-color: var(--combined-bg) !important; }
.auto-run-combined:hover:not(:disabled) { background-color: var(--combined-hover) !important; }


#progressBarContainer { width:100%; background:#e0e0e0; border-radius:.25rem; margin-top:1.5rem; overflow:hidden; }
#progressBar { height:25px; width:0%; background:var(--progress-bg); text-align:center; line-height:25px; color:white; font-weight:bold; transition: width .2s ease; }
#results { margin-top:1.5rem; font-weight:700; color:var(--header-color); font-size:1.1rem; }
/* --- NEW: Separate output windows --- */
#logOutput, #sCandidatesOutput, #factorsOutput {
width:100%;
height:150px;
overflow-y:auto;
border:1px solid var(--input-border);
background:var(--log-bg);
padding:1rem;
font-family: monospace;
white-space:pre-wrap;
margin-top:1rem;
border-radius:.25rem;
}
.row { display:grid; grid-template-columns: repeat(auto-fit,minmax(200px,1fr)); gap:1.5rem; align-items:end; }
details { margin-top: 1rem; border: 1px solid var(--input-border); padding: 1rem; border-radius: 0.25rem; }
summary { font-weight: 600; cursor: pointer; }
.h3-container { display: flex; justify-content: space-between; align-items: center; }
.copy-button { padding: 0.25rem 0.5rem; font-size: 0.8rem; background: #6b7280; }
.copy-button:hover { background: #4b5563; }
.radio-group { display: flex; flex-wrap: wrap; gap: 1rem; margin-bottom: 1rem; }
.radio-group label { display: flex; align-items: center; font-weight: normal; margin-bottom: 0; }
.radio-group input[type="radio"] { margin-right: 0.5rem; }
#candidateInput {
height: 100px;
font-family: monospace;
resize: none;
}
</style>
</head>
<body>
<div class="container">
<h2>Number Theory Factor Finder (FactorHunter 9.3)</h2>
<h3>Number to Factor ($\mathbf{a^b + c}$ form)</h3>
<div class="grid">
<div class="input-group">
<label for="baseInput">Base (a)</label>
<input type="text" id="baseInput" value="10">
</div>
<div class="input-group">
<label for="exponentInput">Exponent (b)</label>
<input type="text" id="exponentInput" value="100000">
</div>
<div class="input-group">
<label for="addendInput">Addend (c)</label>
<input type="text" id="addendInput" value="19">
</div>
</div>
<!-- Single Divisor Verification Section -->
<h3>Single Divisor Verification (Fast & Scalable)</h3>
<div class="row">
<div class="input-group">
<label for="divisorInput">Divisor to verify</label>
<input type="text" id="divisorInput" value="">
</div>
<div class="button-group">
<button id="verifyButton">Verify Divisor $\mathbf{d}$ (Mod Check)</button>
</div>
</div>

<!-- NEW: S_min Finder Section -->
<h3>Step 1: Find S_min (For Monstrous Numbers)</h3>
<p class="text-sm font-semibold text-gray-500" style="font-size: 0.875rem; margin-bottom: 1rem;">
    Calculates the <strong>exact</strong> starting line `S_min` for the S-Search.
</p>
<div class="button-group">
    <button id="findSMinButton">Find S_min (Streaming Sqrt)</button>
</div>

<!-- Search Mode -->
<h3>Step 2: Search Mode</h3>
<div class="radio-group">
<label><input type="radio" name="searchMode" id="modePrime" value="prime"> Scan Primes (Fast)</label>
<label><input type="radio" name="searchMode" id="modeSGS" value="sgs" checked> Screen S-List (SGS Filter Only - Fast)</label>
<label><input type="radio" name="searchMode" id="modeCombined" value="combined"> <strong>SGS Filter + SÂ² Resolver (Heavy)</strong></label>
</div>

<!-- Search Parameters -->
<h3>Step 3: Search Parameters (Used by Workers)</h3>
<div class="grid">
<div class="input-group">
<label for="minLimitInput">Min Limit (S or Prime)</label>
<input type="text" id="minLimitInput" value="1">
</div>
<div class="input-group">
<label for="maxLimitInput">Max Limit (S or Prime)</label>
<input type="text" id="maxLimitInput" value="1000">
</div>
<div class="input-group">
<label for="chunkSizeInput">Chunk Size</label>
<input type="text" id="chunkSizeInput" value="200000">
</div>
</div>

<!-- ADVANCED PRIME FILTERING -->
<details>
<summary>Advanced Prime Filtering (Only used in "Scan Primes" mode)</summary>
<p>Optionally, search only for prime factors of the form $\mathbf{p = k \cdot m + n}$.</p>
<div class="grid">
<div class="input-group">
<label for="kMultiple">Multiple (m)</label>
<input type="text" id="kMultiple" placeholder="e.g., 198">
</div>
<div class="input-group">
<label for="kAddend">Addend (n)</label>
<input type="text" id="kAddend" placeholder="e.g., 1">
</div>
<div class="button-group" style="align-items: flex-start;">
<button id="suggestFilterButton" style="margin-top: 1.75rem;">Suggest Filter</button>
</div>
</div>
</details>


<!-- S-Augmented Sieve (SAS) Resolver Section -->
<h3>Step 4: S-List Resolver (Manual)</h3>
<p class="text-sm font-semibold text-gray-500" style="font-size: 0.875rem; margin-bottom: 1rem;">
Only use this after running the "SGS Filter Only" (Step 2) to get a list of candidates.
</p>
<div class="row">
<div class="input-group" style="grid-column: 1 / span 2;">
<label for="candidateInput">Paste S-Candidates Here (One per line)</label>
<textarea id="candidateInput" placeholder="Paste S values from the SGS filter output."></textarea>
</div>
<div class="button-group" style="align-items: flex-start; grid-column: 1 / span 2; margin-top: 0;">
    <button id="resolveSASButton">
        Resolve S-List $\mathbf{(S^2 - 4N = k^2)}$
    </button>
</div>
</div>

<!-- Controls -->
<h3>Controls</h3>
<div class="button-group">
<button id="checkWorkerButton">Run Worker (Single Chunk)</button>
<button id="autoRunButton">Auto-Run chunks</button>
<input type="checkbox" id="autoRepeatCheck">
<label for="autoRepeatCheck" style="margin-bottom: 0;">Auto Repeat</label>
<button id="stopButton" disabled>Stop</button>
</div>
<div id="progressBarContainer">
<div id="progressBar">0%</div>
</div>
<div id="results">Status: Idle</div>

<!-- Main Log -->
<div class="h3-container">
    <h3>Main Log</h3>
    <button id="copyLogButton" class="copy-button">Copy Log</button> <!-- NEW -->
</div>
<pre id="logOutput">Log: Ready. Use Step 1 for huge numbers, or set range and run Step 3.</pre>

<!-- NEW: S-Candidates Output -->
<div class="h3-container">
<h3 id="sCandidatesHeader">Found S-Candidates</h3>
<button id="copyCandidatesButton" class="copy-button">Copy List</button>
</div>
<pre id="sCandidatesOutput"></pre>

<!-- NEW: Found Factors Output -->
<div class="h3-container">
<h3 id="factorsHeader">Found Factors</h3>
<button id="copyFactorsButton" class="copy-button">Copy Factors</button>
</div>
<pre id="factorsOutput"></pre>

</div>
<script>
// --- GLOBAL STATE & CONFIGURATION ---
// --- (All DOM elements) ---
const baseInput = document.getElementById('baseInput');
const exponentInput = document.getElementById('exponentInput');
const addendInput = document.getElementById('addendInput');
const divisorInput = document.getElementById('divisorInput');
const minLimitInput = document.getElementById('minLimitInput');
const maxLimitInput = document.getElementById('maxLimitInput');
const chunkSizeInput = document.getElementById('chunkSizeInput');
const kMultipleInput = document.getElementById('kMultiple');
const kAddendInput = document.getElementById('kAddend');
const verifyButton = document.getElementById('verifyButton');
const checkWorkerButton = document.getElementById('checkWorkerButton');
const autoRunButton = document.getElementById('autoRunButton');
const stopButton = document.getElementById('stopButton');
const autoRepeatCheck = document.getElementById('autoRepeatCheck');
const progressBar = document.getElementById('progressBar');
const resultsDiv = document.getElementById('results');
const logOutput = document.getElementById('logOutput');
const sCandidatesOutput = document.getElementById('sCandidatesOutput'); // NEW
const factorsOutput = document.getElementById('factorsOutput'); // NEW
const copyLogButton = document.getElementById('copyLogButton'); // NEW
const copyCandidatesButton = document.getElementById('copyCandidatesButton'); // NEW (Renamed)
const copyFactorsButton = document.getElementById('copyFactorsButton'); // NEW
const modePrime = document.getElementById('modePrime');
const modeSGS = document.getElementById('modeSGS');
const modeCombined = document.getElementById('modeCombined');
const sCandidatesHeader = document.getElementById('sCandidatesHeader'); // NEW
const factorsHeader = document.getElementById('factorsHeader'); // NEW
const candidateInput = document.getElementById('candidateInput');
const resolveSASButton = document.getElementById('resolveSASButton');
const findSMinButton = document.getElementById('findSMinButton');
const suggestFilterButton = document.getElementById('suggestFilterButton');

// --- (State variables) ---
let workerPool = [];
let sqrtWorker = null;
const numWorkers = navigator.hardwareConcurrency || 4;
let activeWorkers = 0;
let isScanning = false;
let foundFactors = new Set();
let sCandidateList = new Set(); // Use Set for auto-deduping
let currentMin = 0n;
let workerProgress = new Array(numWorkers).fill(0);
let workerChunks = new Array(numWorkers).fill(null);
let totalScanned = 0n;
let totalRange = 0n;
let currentSearchMode = 'sgs'; // 'prime', 'sgs', 'combined'
const QR_SCREEN_PRIMES = [3n, 5n, 7n, 11n, 13n, 17n, 19n, 23n, 29n];
let N_MODS_CACHE = {};
const EXPONENT_SAFE_LIMIT = 10000n;

// --- Utility Functions ---
function parseBigInt(str) {
    if (!str) return 0n;
    str = str.replace(/\s/g, '');
    if (str.includes('+') || str.includes('-') || str.includes('*')) {
        try {
            return BigInt(eval(str.replace(/\*\*/g, '**')));
        } catch (e) {
            return BigInt(str);
        }
    }
    return BigInt(str);
}
function log(msg) {
    logOutput.textContent += msg + '\n';
    logOutput.scrollTop = logOutput.scrollHeight;
}

// --- NEW: logSGS and logFactor ---
// Writes to the S-Candidates window
function logSGS(s_candidate) {
    if (!sCandidateList.has(s_candidate)) {
        sCandidateList.add(s_candidate);
        // Throttle UI updates to prevent crash
        if (sCandidateList.size % 100 === 0) {
            sCandidatesOutput.textContent = Array.from(sCandidateList).slice(-100).join('\n'); // Show last 100
        }
    }
}
// Writes to the Factors window
function logFactor(factor) {
     if (!foundFactors.has(factor)) {
        foundFactors.add(factor);
        factorsOutput.textContent = Array.from(foundFactors).join('\n');
    }
}

function setStatus(t) { resultsDiv.textContent = 'Status: ' + t; }
function setProgress(p) {
    const percent = Math.min(100, Math.max(0, p)).toFixed(2);
    progressBar.style.width = percent + '%';
    progressBar.textContent = percent + '%';
}
function updateSieveProgress() {
    if (totalRange <= 0n) {
        progressBar.style.width = '0%';
        progressBar.textContent = '0.00%';
        return;
    }
    const progressPercent = Math.min(100, Number(totalScanned * 10000n / totalRange) / 100);
    progressBar.style.width = progressPercent + '%';
    progressBar.textContent = progressPercent.toFixed(2) + '%';
}
function powMod(base, exp, mod) {
    let result = 1n;
    base %= mod;
    while (exp > 0n) {
        if ((exp & 1n) === 1n) result = (result * base) % mod;
        exp >>= 1n;
        base = (base * base) % mod;
    }
    return result;
}
function powModWithProgress(base, exp, mod, onProgress) {
    let result = 1n;
    base %= mod;
    const expNumber = (exp > Number.MAX_SAFE_INTEGER) ? Number(exp.toString().slice(0, 10)) * 1e15 : Number(exp);
    const totalBits = expNumber.toString(2).length;
    let processedBits = 0;
    let exp_copy = exp;
    while (exp_copy > 0n) {
        if ((exp_copy & 1n) === 1n) result = (result * base) % mod;
        exp_copy >>= 1n;
        base = (base * base) % mod;
        processedBits++;
        if (onProgress && processedBits % 64 === 0) onProgress(processedBits / totalBits * 100);
    }
    if (onProgress) onProgress(100);
    return result;
}
// Main thread only needs integerSqrt for the *manual* Step 4 resolver
function integerSqrt(n) {
    // Use the global bigInt library
    if (typeof bigInt === 'undefined') {
        log("Error: big-integer.js not loaded on main page.");
        return null;
    }
    if (n.lesser(0)) return null;
    return n.sqrt();
}

// --- S_min (Streaming Sqrt) Worker Code ---
const sqrtWorkerCode = `
    const chunk_size = 9;
    const BASE = 10 ** chunk_size;

    // --- Chunked Arithmetic Functions (MSB-first) ---
    function trim(c) {
        let i = 0;
        while (i < c.length - 1 && c[i] === 0) i++;
        return c.slice(i);
    }
    function cmp(a, b) {
        a = trim(a); b = trim(b);
        if (a.length !== b.length) return a.length > b.length ? 1 : -1;
        for (let i = 0; i < a.length; i++) {
            if (a[i] !== b[i]) return a[i] > b[i] ? 1 : -1;
        }
        return 0;
    }
    function add(a, b) {
        let a_rev = a.slice().reverse(); let b_rev = b.slice().reverse();
        let n = Math.max(a_rev.length, b_rev.length), carry = 0, out = [];
        for (let i = 0; i < n; i++) {
            let s = (a_rev[i] || 0) + (b_rev[i] || 0) + carry;
            out.push(s % BASE);
            carry = Math.floor(s / BASE);
        }
        if (carry) out.push(carry);
        return out.reverse();
    }
    function sub(a, b) { // a - b, assumes a >= b
        let a_rev = a.slice().reverse(); let b_rev = b.slice().reverse();
        let n = a_rev.length, borrow = 0, out = [];
        for (let i = 0; i < n; i++) {
            let v = a_rev[i] - (b_rev[i] || 0) - borrow;
            if (v < 0) { v += BASE; borrow = 1; } else { borrow = 0; }
            out.push(v);
        }
        return trim(out.reverse());
    }
    function mulSmall(a, s) {
        if (s === 0) return [0];
        let a_rev = a.slice().reverse(), carry = 0, out = [];
        for (const d of a_rev) {
            let p = d * s + carry;
            out.push(p % BASE);
            carry = Math.floor(p / BASE);
        }
        while (carry > 0) {
            out.push(carry % BASE);
            carry = Math.floor(carry / BASE);
        }
        return out.reverse();
    }
    function chunksToString(chunks) {
        if (!chunks || chunks.length === 0) return "0";
        let s = chunks[0].toString();
        for (let i = 1; i < chunks.length; i++) {
            s += chunks[i].toString().padStart(chunk_size, '0');
        }
        return s;
    }

    // --- N String Generation (moved to worker) ---
    function generateNString(aStr, bStr, cStr) {
        if (aStr !== '10') {
            throw new Error('Streaming string generation currently only supports base 10.');
        }
        const b = BigInt(bStr);
        const c = BigInt(cStr);
        const cStr_abs = c < 0n ? c.toString().substring(1) : c.toString();
        const cLen = cStr_abs.length;

        if (c < 0n) {
             throw new Error('Streaming Sqrt for c < 0 (a^b - c) is not yet supported.');
        }

        if (b < cLen) {
            return (BigInt(10)**b + c).toString();
        }

        const numZeros = b - BigInt(cLen);
        let nStr = '1';

        const practicalZeroLimit = 5000000; // Increased limit
        if (numZeros > practicalZeroLimit) {
            self.postMessage({ type: 'log', message: 'WARNING: Exponent is too large for full string generation. Simulating with a capped number of zeros.' });
        }

        const zerosToRepeat = numZeros < BigInt(practicalZeroLimit) ? numZeros : BigInt(practicalZeroLimit);
        if (zerosToRepeat > 0) {
            nStr += '0'.repeat(Number(zerosToRepeat));
        }
        nStr += c.toString().padStart(cLen, '0');

        return nStr;
    }


    // --- Main Streaming Sqrt Function ---
    self.onmessage = function(e) {
        const { a, b, c } = e.data;

        let nStr;
        try {
             self.postMessage({ type: 'log', message: 'Generating string representation of N...' });
             nStr = generateNString(a, b, c);
             self.postMessage({ type: 'log', message: \`N has \${nStr.length} digits. Starting streaming square root calculation...\` });
        } catch (err) {
            self.postMessage({ type: 'error', message: 'Failed to generate N string: ' + err.message });
            return;
        }

        const groupDigits = 2 * chunk_size;

        let padLength = nStr.length % groupDigits;
        if (padLength !== 0) {
            padLength = groupDigits - padLength;
        }
        const paddedNStr = '0'.repeat(padLength) + nStr;

        const groups = [];
        for (let i = 0; i < paddedNStr.length; i += groupDigits) {
            groups.push(paddedNStr.substring(i, i + groupDigits));
        }

        let root = [0];
        let remainder = [0];
        const totalGroups = groups.length;

        groups.forEach((group, index) => {
            remainder.push(0, 0);
            const groupChunks = [parseInt(group.substring(0, chunk_size), 10), parseInt(group.substring(chunk_size), 10)];
            remainder = add(remainder, groupChunks);

            let prefix = mulSmall(root, 2);
            prefix.push(0);

            let lo = 0, hi = BASE - 1, chosen = 0;
            while (lo <= hi) {
                let mid = Math.floor((lo + hi) / 2);
                let t = add(prefix, [mid]);
                let trial = mulSmall(t, mid);
                if (cmp(trial, remainder) <= 0) {
                    chosen = mid;
                    lo = mid + 1;
                } else {
                    hi = mid - 1;
                }
            }

            let t_chosen = add(prefix, [chosen]);
            let trial_chosen = mulSmall(t_chosen, chosen);
            remainder = sub(remainder, trial_chosen);

            root.push(chosen);
            root = trim(root);

            if (index % 100 === 0) { // Throttle progress updates
                self.postMessage({ type: 'progress', value: ((index + 1) / totalGroups) * 100 });
            }
        });

        self.postMessage({ type: 'progress', value: 100 });
        self.postMessage({ type: 'result', root: chunksToString(root), remainder: chunksToString(remainder) });
    };
`;


// --- SGS/Prime/Combined Sieve Worker Code ---
const workerCode = `
// Must import the library *inside* the worker
self.importScripts('https://unpkg.com/big-integer@1.6.48/BigInteger.min.js');

// --- Custom Sqrt for big-integer.js ---
function newBigIntSqrt(n) {
    if (n.isNegative()) throw new Error("Cannot sqrt negative number");
    if (n.lesser(2)) return n;

    const one = self.bigInt.one;
    const two = self.bigInt.two;

    let x = n.shiftRight(one); // n / 2
    if (x.isZero()) return n;
    let y;
    while (true) {
        y = x.add(n.divide(x)).shiftRight(one); // (x + n/x) / 2
        if (y.geq(x)) {
            return x;
        }
        x = y;
    }
}


function powMod(base, exp, mod) {
    let result = self.bigInt.one;
    base = base.mod(mod);
    while (exp.greater(0)) {
        if (exp.isOdd()) result = result.multiply(base).mod(mod);
        exp = exp.shiftRight(1);
        base = base.square().mod(mod);
    }
    return result;
}

function legendreSymbol(a, p) {
    if (p.equals(2)) return 1;
    a = a.mod(p).add(p).mod(p);
    const ls = powMod(a, p.subtract(1).shiftRight(1), p);
    if (ls.equals(p.subtract(1))) return -1;
    return 1;
}

self.onmessage = e => {
    let { mode, a, b, c, min, max, workerIndex, N_mods, candidates, N_str } = e.data;

    // --- Shared Variables ---
    const a_bi = self.bigInt(a);
    const b_bi = self.bigInt(b);
    const c_bi = self.bigInt(c);
    let min_bi = self.bigInt(min);
    let max_bi = self.bigInt(max);
    const rangeInChunk = max_bi.subtract(min_bi);
    let lastProgress = -1;

    // --- Mode: SGS Filter Only (Fast, Low-memory) ---
    if (mode === 'sgs') {
        const QR_SCREEN_PRIMES = [3n, 5n, 7n, 11n, 13n, 17n, 19n, 23n, 29n].map(p => self.bigInt(p));
        let candidatesFound = [];

        for (let S = min_bi; S.leq(max_bi); S = S.add(1)) {
            let passes = true;
            for (const p of QR_SCREEN_PRIMES) {
                const N_mod_p = self.bigInt(N_mods[p.toString()]);
                const S_sq_mod_p = S.square().mod(p);
                const fourN_mod_p = N_mod_p.multiply(4).mod(p);

                let D_mod_p = S_sq_mod_p.subtract(fourN_mod_p).mod(p);
                if (D_mod_p.lesser(0)) D_mod_p = D_mod_p.add(p);

                if (legendreSymbol(D_mod_p, p) === -1) {
                    passes = false;
                    break;
                }
            }

            if (passes) {
                // Buffer candidates and send in chunks to avoid flooding
                candidatesFound.push(S.toString());
                if (candidatesFound.length >= 100) {
                    self.postMessage({ type: 'sCandidatesFound', candidates: candidatesFound, workerIndex });
                    candidatesFound = []; // Clear buffer
                }
            }

            if (rangeInChunk.greater(0)) {
                const progress = S.subtract(min_bi).multiply(100).divide(rangeInChunk).toJSNumber();
                if (Math.floor(progress) > lastProgress) {
                    self.postMessage({ type: 'progress', progress: Math.floor(progress), workerIndex, mode: mode });
                    lastProgress = Math.floor(progress);
                }
            }
        }
        // Send any remaining candidates
        if (candidatesFound.length > 0) {
            self.postMessage({ type: 'sCandidatesFound', candidates: candidatesFound, workerIndex });
        }

    // --- Mode: SGS + SÂ² Resolver (Heavy, High-memory) ---
    } else if (mode === 'combined') {
        const QR_SCREEN_PRIMES = [3n, 5n, 7n, 11n, 13n, 17n, 19n, 23n, 29n].map(p => self.bigInt(p));
        let N, fourN;
        try {
            // This is the "heavy" part: calculate full N inside the worker
            N = a_bi.pow(b_bi).add(c_bi);
            fourN = N.multiply(4);
        } catch (err) {
            self.postMessage({ type: 'error', message: 'Failed to calculate N in worker: ' + err.message, workerIndex });
            return;
        }

        for (let S = min_bi; S.leq(max_bi); S = S.add(1)) {
            // 1. Fast Filter (SGS)
            let passes = true;
            for (const p of QR_SCREEN_PRIMES) {
                const N_mod_p = N.mod(p);
                const S_sq_mod_p = S.square().mod(p);
                const fourN_mod_p = N_mod_p.multiply(4).mod(p);

                let D_mod_p = S_sq_mod_p.subtract(fourN_mod_p).mod(p);
                if (D_mod_p.lesser(0)) D_mod_p = D_mod_p.add(p);

                if (legendreSymbol(D_mod_p, p) === -1) {
                    passes = false;
                    break;
                }
            }

            // 2. Heavy Resolve (SAS)
            if (passes) {
                const S_sq = S.square();
                if (S_sq.lesser(fourN)) continue;

                const D = S_sq.subtract(fourN);
                const k = newBigIntSqrt(D); // Use our custom sqrt

                if (k.square().equals(D)) {
                    // Found it!
                    const P = S.add(k).shiftRight(1);
                    const Q = S.subtract(k).shiftRight(1);

                    if (Q.greater(1) && P.multiply(Q).equals(N)) {
                        self.postMessage({ type: 'factorFound', P: P.toString(), Q: Q.toString(), workerIndex });
                        // Don't stop, keep searching chunk
                    }
                }
            }

            // 3. Progress
            if (rangeInChunk.greater(0)) {
                const progress = S.subtract(min_bi).multiply(100).divide(rangeInChunk).toJSNumber();
                if (Math.floor(progress) > lastProgress) {
                    self.postMessage({ type: 'progress', progress: Math.floor(progress), workerIndex, mode: mode });
                    lastProgress = Math.floor(progress);
                }
            }
        }

    // --- Mode: Manual S-List Resolver (Step 4) ---
    } else if (mode === 'resolve_sas') {
        const N = self.bigInt(N_str);
        const fourN = N.multiply(4);
        let factorsFound = [];
        let checkedCount = 0;

        for (const S_str of candidates) {
            const S = self.bigInt(S_str);
            const S_sq = S.square();

            if (S_sq.lesser(fourN)) continue;

            const D = S_sq.subtract(fourN);
            const k = newBigIntSqrt(D);

            if (k.square().equals(D)) {
                const P = S.add(k).shiftRight(1);
                const Q = S.subtract(k).shiftRight(1);

                if (Q.greater(1) && P.multiply(Q).equals(N)) {
                    factorsFound.push({ P: P.toString(), Q: Q.toString() });
                }
            }

            checkedCount++;
            if (checkedCount % 100 === 0) {
                 self.postMessage({ type: 'resolverProgress', progress: Math.floor(checkedCount * 100 / candidates.length), workerIndex });
            }
        }

        self.postMessage({ type: 'factorsResolved', factors: factorsFound, workerIndex });

    // --- Mode: Prime Factor Scan (Not implemented in this snippet) ---
    } else if (mode === 'prime') {
        // Prime scanning logic would go here
        // ...
    }

    // *** THE FIX ***
    // Only send min/max if they are defined. For resolve_sas, they are not.
    let minStr = (typeof min !== 'undefined' && min !== null) ? min.toString() : '0';
    let maxStr = (typeof max !== 'undefined' && max !== null) ? max.toString() : '0';
    self.postMessage({ type: 'done', min: minStr, max: maxStr, workerIndex, mode: mode });
};
`;

const workerDataURI = 'data:application/javascript;base64,' + btoa(workerCode);

// --- Core App Logic (Main Thread Functions) ---

function calculateNMods(a, b, c) {
    const N_mods = {};
    for (const p of QR_SCREEN_PRIMES) {
         const remPow = powMod(a, b, p);
         const remC = c % p;
         let remN = (remPow + remC) % p;
         if (remN < 0n) remN += p;
         N_mods[p.toString()] = Number(remN);
    }
    return N_mods;
}

function handleWorkerMessage(e) {
    const data = e.data;
    const workerIndex = data.workerIndex;

    if (data.type === 'sCandidatesFound') {
        // This is from 'sgs' (Filter Only) mode
        data.candidates.forEach(s => logSGS(s)); // NEW: Use logSGS
        setStatus(`Filter found ${data.candidates.length} new S-candidates in chunk.`);
        sCandidatesHeader.textContent = `Found S-Candidates (${sCandidateList.size} total)`;

    } else if (data.type === 'factorFound') {
        // This is from 'combined' mode
        log(`ðŸŽ‰ FACTOR PAIR FOUND! (Worker ${workerIndex})`);
        log(`P: ${data.P}`);
        log(`Q: ${data.Q}`);
        logFactor(data.P); // NEW: Use logFactor
        logFactor(data.Q);
        setStatus(`Factor found! P=${data.P}`);

    } else if (data.type === 'factorsResolved') {
        // This is from 'resolve_sas' (Manual Step 4)
        data.factors.forEach(f => {
            log(`ðŸŽ‰ FACTOR PAIR FOUND! P=${f.P.toLocaleString()}, Q=${f.Q.toLocaleString()}`);
            logFactor(f.P); // NEW: Use logFactor
            logFactor(f.Q);
        });
        setStatus(`S-List Resolution Complete. Found ${data.factors.length} non-trivial factor pairs.`);

    } else if (data.type === 'resolverProgress') {
        setStatus(`Resolving candidates... ${data.progress}% complete.`);

    } else if (data.type === 'progress') {
        const newProgress = data.progress;
        const lastProgress = workerProgress[workerIndex];
        const chunkInfo = workerChunks[workerIndex];
        if (chunkInfo && newProgress > lastProgress) {
            const progressDelta = BigInt(newProgress - lastProgress);
            const numbersScannedInDelta = (chunkInfo.size * progressDelta) / 100n;
            totalScanned += numbersScannedInDelta;
            workerProgress[workerIndex] = newProgress;
            updateSieveProgress();
        }
    } else if (data.type === 'done') {
        const lastProgress = workerProgress[workerIndex];
        const chunkInfo = workerChunks[workerIndex];
        if (chunkInfo && lastProgress < 100) {
            const progressDelta = BigInt(100 - lastProgress);
            const numbersScannedInDelta = (chunkInfo.size * progressDelta) / 100n;
            totalScanned += numbersScannedInDelta;
        }
        workerChunks[workerIndex] = null;
        workerProgress[workerIndex] = 100;

        updateSieveProgress();

        // Re-assign chunk *only* if we are in a scanning mode
        if (data.mode === 'sgs' || data.mode === 'combined' || data.mode === 'prime') {
            // Try to assign a new chunk to this now-idle worker
            if (!assignNextChunk(workerIndex)) {
                // If no chunk was assigned, this worker is done
                activeWorkers--;
                if (activeWorkers === 0) {
                    setStatus('Scan complete.');
                    log('Scan complete.');
                    if (currentSearchMode === 'sgs') {
                        sCandidatesOutput.textContent = Array.from(sCandidateList).join('\n');
                        log(`SGS Filter complete. Found ${sCandidateList.size} total candidates.`);
                    }
                    stopScan(); // Final stop
                }
            }
        } else if (data.mode === 'resolve_sas') {
             log('--- S-List Resolver Check Complete ---');
             stopScan(); // Make sure buttons re-enable
        }
    } else if (data.type === 'error') {
        setStatus('Worker error');
        log(`Worker ${workerIndex} error: ${data.message}`);
        stopScan(true);
    }
}

// *** BUG FIX LOGIC IS HERE ***
function assignNextChunk(workerIndex) {
    const maxVal = parseBigInt(maxLimitInput.value);

    // Check if we are done
    if (!isScanning || currentMin > maxVal) {
        return false; // Signal that no chunk was assigned
    }

    let chunkSize = parseBigInt(chunkSizeInput.value);

    // Different chunking strategies
    if (currentSearchMode === 'combined') {
        chunkSize = BigInt(Math.max(1, Math.floor(Number(chunkSize) / 1000)));
        if (chunkSize > 2000n) chunkSize = 2000n;
        if (currentMin === parseBigInt(minLimitInput.value)) { // Only log on first chunk
             log(`Warning: Combined mode is slow. Chunk size capped at ${chunkSize}.`);
        }
    } else if (currentSearchMode === 'sgs' && chunkSize > 1000000n) {
        chunkSize = 1000000n;
        if (currentMin === parseBigInt(minLimitInput.value)) {
            log('Warning: SGS chunk size capped at 1,000,000 for stability.');
        }
    }

    const chunkMin = currentMin;
    let chunkMax = currentMin + chunkSize - 1n;
    if (chunkMax > maxVal) chunkMax = maxVal;

    // *** THIS IS THE KEY FIX ***
    // We *immediately* update currentMin for the *next* worker
    currentMin = chunkMax + 1n;

    workerProgress[workerIndex] = 0;
    workerChunks[workerIndex] = { size: chunkMax - chunkMin + 1n };

    workerPool[workerIndex].postMessage({
        mode: currentSearchMode,
        a: baseInput.value,
        b: exponentInput.value,
        c: addendInput.value,
        min: chunkMin.toString(),
        max: chunkMax.toString(),
        workerIndex,
        N_mods: N_MODS_CACHE
    });

    return true; // Signal that a chunk *was* assigned
}

async function createWorker(workerIndex) {
    return new Promise(resolve => {
        // Terminate old worker if it exists
        if (workerPool[workerIndex]) {
            workerPool[workerIndex].terminate();
        }
        const worker = new Worker(workerDataURI);
        worker.onmessage = e => {
            handleWorkerMessage(e);
        };
        worker.onerror = e => {
            setStatus('Worker error');
            log(`Worker ${workerIndex} error: ${e.message}`);
            stopScan(true);
            resolve(null);
        };
        workerPool[workerIndex] = worker;
        resolve(worker);
    });
}

async function startParallelScan(singleChunk = false, isAutoRepeat = false) {
    if (modeSGS.checked) currentSearchMode = 'sgs';
    else if (modeCombined.checked) currentSearchMode = 'combined';
    else currentSearchMode = 'prime';

    if (!isAutoRepeat) {
        stopScan(true); // Clear previous scans
        logOutput.textContent = 'Log:\n';
        sCandidatesOutput.textContent = ''; // Clear S-Candidates
        factorsOutput.textContent = ''; // Clear Factors
        foundFactors.clear();
        sCandidateList.clear();
    } else {
        log('\n--- Starting new auto-repeat scan ---');
    }

    if (!baseInput.value || !exponentInput.value || !addendInput.value) {
        setStatus('Error: Base, Exponent, or Addend is empty.');
        log('Validation Failed: Please fill all fields.');
        return;
    }

    const a = parseBigInt(baseInput.value);
    const b = parseBigInt(exponentInput.value);
    const c = parseBigInt(addendInput.value);

    setStatus('Pre-calculating modular exponentiations (a^b mod p)...');
    N_MODS_CACHE = calculateNMods(a, b, c);
    log('Pre-calculation complete. Starting worker screening.');

    isScanning = true;
    checkWorkerButton.disabled = true;
    autoRunButton.disabled = true;
    stopButton.disabled = false;
    findSMinButton.disabled = true;
    resolveSASButton.disabled = true; // Disable resolver during scan

    const maxVal = parseBigInt(maxLimitInput.value);
    let minVal = parseBigInt(minLimitInput.value);

    if (currentSearchMode === 'sgs') {
        sCandidatesHeader.textContent = "Found S-Candidates (SGS Filter)";
        log(`--- S-Candidate Screening (SGS Filter) Mode Activated ---`);
    } else if (currentSearchMode === 'combined') {
        factorsHeader.textContent = "Found Factors (Combined Mode)";
        log(`--- SGS Filter + SÂ² Resolver (Combined) Mode Activated ---`);
        log(`WARNING: This mode is VERY slow. It calculates the full N in the worker.`);
    } else {
        factorsHeader.textContent = "Found Factors (Prime Scan)";
        log(`--- Prime Factor Search Mode Activated ---`);
        if (minVal < 2n) minVal = 2n;
    }

    totalScanned = 0n;
    totalRange = maxVal > minVal ? maxVal - minVal + 1n : 0n;
    workerChunks.fill(null);
    workerProgress.fill(0);
    updateSieveProgress();

    // *** THE BUG FIX ***
    // currentMin *must* be reset here.
    currentMin = minVal;

    activeWorkers = 0; // Start at 0
    for (let i = 0; i < numWorkers; i++) {
        if (await createWorker(i)) {
            if (assignNextChunk(i)) { // assignNextChunk will update currentMin
                activeWorkers++; // Only increment if a chunk was *successfully* assigned
            }
        }
        if (singleChunk && activeWorkers > 0) break; // If single chunk mode, only launch one
        if (currentMin > maxVal) break; // Stop assigning chunks if we're done
    }

    if (activeWorkers === 0) {
        log('No chunks to assign (range is empty or invalid).');
        setStatus('Idle');
        stopScan(); // Stop to re-enable buttons
    } else {
        setStatus(`Scanning with ${activeWorkers} workers...`);
    }
}

function stopScan(userInitiated = false) {
    isScanning = false;
    // Terminate all workers in the pool
    workerPool.forEach(w => {
        if (w) w.terminate();
    });
    workerPool = []; // Clear the pool
    activeWorkers = 0; // Set to 0 to prevent re-assignment
    stopButton.disabled = true;
    checkWorkerButton.disabled = false;
    autoRunButton.disabled = false;
    findSMinButton.disabled = false;
    resolveSASButton.disabled = false; // Re-enable resolver

    if (resultsDiv.textContent.startsWith('Status: Scanning') || resultsDiv.textContent.startsWith('Status: Checking')) {
        setStatus('Stopped');
        log('Scan stopped.');
    }

    if (!userInitiated && autoRepeatCheck.checked && isFinite(Number(parseBigInt(maxLimitInput.value)))) {
        setStatus('Preparing next range...');
        log('Auto Repeat: Preparing next range...');
        updateRangeForRepeat();
        setTimeout(() => startParallelScan(false, true), 100);
    } else {
        // Final dump of all candidates for SGS mode
        if (currentSearchMode === 'sgs' && sCandidateList.size > 0) {
             sCandidatesOutput.textContent = Array.from(sCandidateList).join('\n');
        }
        // Factors are already in their box
    }
}

function updateRangeForRepeat() {
    const minVal = parseBigInt(minLimitInput.value);
    const maxVal = parseBigInt(maxLimitInput.value);
    const rangeSize = maxVal - minVal;
    const newMin = maxVal + 1n;
    const newMax = newMin + rangeSize;
    minLimitInput.value = newMin.toString();
    maxLimitInput.value = newMax.toString();
    log(`--- Auto Repeat: Updated range to [${newMin}, ${newMax}]`);
}


// 2. Workerized SAS Resolver (S^2 - 4N = k^2)
async function resolveSASFactors() {
    const candidates = candidateInput.value.trim().split('\n').map(s => s.trim()).filter(s => s.length > 0);
    if (candidates.length === 0) {
        setStatus('Error: Paste S-Candidates first.');
        return;
    }

    const a = parseBigInt(baseInput.value);
    const b = parseBigInt(exponentInput.value);
    const c = parseBigInt(addendInput.value);

    if (b > EXPONENT_SAFE_LIMIT) {
        setStatus('ERROR: Exponent too large for direct N calculation.');
        log(`ERROR: Exponent (${b}) exceeds safe limit (${EXPONENT_SAFE_LIMIT} for direct N calculation).`);
        log('The S-List Resolver requires the full number N. This number is too big.');
        return;
    }

    // Use main-thread bigInt library
    const N = bigInt(a).pow(b).add(c);
    const N_str = N.toString();

    setStatus(`Starting S-List Resolver (Workerized for stability)...`);
    log(`--- Starting S-List Resolver (Workerized for stability) ---`);
    log(`Sending ${candidates.length} candidates to worker for check...`);

    // Disable buttons during resolve
    isScanning = true;
    resolveSASButton.disabled = true;
    stopButton.disabled = false;
    autoRunButton.disabled = true;
    checkWorkerButton.disabled = true;
    findSMinButton.disabled = true;

    if (!workerPool[0]) {
        await createWorker(0);
    }

    workerPool[0].postMessage({
        mode: 'resolve_sas',
        candidates: candidates,
        N_str: N_str,
        workerIndex: 0
    });
}


// 3. Single Divisor Verification Logic
function verify() {
    try {
        setStatus('Verifying divisor...');
        setProgress(0);
        log('--- Single divisor verification ---');
        const a = parseBigInt(baseInput.value);
        const b = parseBigInt(exponentInput.value);
        const c = parseBigInt(addendInput.value);
        const d = parseBigInt(divisorInput.value);
        if (d <= 0n) throw new Error('Divisor must be positive.');

        const remPow = powModWithProgress(a, b, d, p => {
            setProgress(p * 0.95);
        });

        const finalRem = (remPow + (c % d) + d) % d;

        log(`(${a}^${b} + ${c}) mod ${d} = ${finalRem.toLocaleString()}`);

        if (finalRem === 0n) {
            setStatus('Divides exactly âœ”');
            log(`Result: 0 â†’ ${d.toLocaleString()} divides a^b + c`);
            logFactor(d);
        } else {
            setStatus('Not a factor âœ–');
            log(`Result: ${finalRem.toLocaleString()} â†’ not divisible by ${d.toLocaleString()}`);
        }
        setProgress(100);
    } catch (e) {
        setStatus('Error');
        log('Error: ' + e.message);
    }
}

// --- S_min Calculation Functions ---
function startSMinCalc() {
    if (isScanning || sqrtWorker) {
        log("Cannot start S_min calculation while another scan is active.");
        return;
    }

    log('--- Starting Streaming Sqrt S_min calculation ---');
    setStatus('Initializing S_min worker...');
    setProgress(0);

    const aStr = baseInput.value;
    const bStr = exponentInput.value;
    const cStr = addendInput.value;

    if (aStr !== "10") {
        log("Error: S_min finder currently only supports base 10.");
        setStatus("Error: Base must be 10 for S_min finder.");
        return;
    }

    isScanning = true;
    findSMinButton.disabled = true;
    checkWorkerButton.disabled = true;
    autoRunButton.disabled = true;
    stopButton.disabled = false;

    sqrtWorker = new Worker(URL.createObjectURL(new Blob([sqrtWorkerCode], { type: 'application/javascript' })));

    sqrtWorker.onmessage = (e) => {
        if (e.data.type === 'progress') {
            setStatus(`Calculating sqrt(N)... ${e.data.value.toFixed(2)}%`);
            setProgress(e.data.value);
        } else if (e.data.type === 'log') {
            log(e.data.message);
        } else if (e.data.type === 'result') {
            const { root, remainder } = e.data;
            log(`Streaming sqrt complete.`);
            log(`Floor(sqrt(N)) has ${root.length} digits.`);

            // Need to use main-thread bigInt for this final calculation
            const floor_sqrt = bigInt(root);
            const rem = bigInt(remainder);

            let s_min = floor_sqrt.multiply(2);
            if (rem.greater(0)) {
                s_min = s_min.add(1);
            }

            const s_min_str = s_min.toString();
            log(`Calculated S_min = ${s_min_str.substring(0, 60)}... (${s_min_str.length} digits)`);

            minLimitInput.value = s_min_str; // AUTO-POPULATE

            log(`âœ… S_min auto-populated in 'Min Limit' field.`);
            log(`Now, set a 'Max Limit' (e.g., S_min + 1,000,000) and run the filter!`);
            setStatus('S_min found and populated!');
            stopSMinCalc();
        } else if (e.data.type === 'error') {
            log(`S_min Worker Error: ${e.data.message}`);
            setStatus('Error in S_min calculation.');
            stopSMinCalc();
        }
    };

    sqrtWorker.onerror = (e) => {
        log(`S_min Worker Error: ${e.message}`);
        setStatus('Error in S_min calculation.');
        stopSMinCalc();
    };

    sqrtWorker.postMessage({ a: aStr, b: bStr, c: cStr });
}

function stopSMinCalc() {
    if (sqrtWorker) {
        sqrtWorker.terminate();
        sqrtWorker = null;
    }
    isScanning = false;
    findSMinButton.disabled = false;
    checkWorkerButton.disabled = false;
    autoRunButton.disabled = false;
    stopButton.disabled = true;
    if (resultsDiv.textContent.includes('...')) {
        setStatus('Stopped by user.');
    }
}

// --- Event Listeners and Initial Setup ---
function setSearchMode() {
    if (modeSGS.checked) currentSearchMode = 'sgs';
    else if (modeCombined.checked) currentSearchMode = 'combined';
    else currentSearchMode = 'prime';

    // Visual feedback for the "heavy" mode
    if (currentSearchMode === 'combined') {
        log('Mode switched to Combined Sieve + Resolver. WARNING: This mode is very slow and calculates the full N in the worker.');
        autoRunButton.classList.add('auto-run-combined');
        checkWorkerButton.classList.add('auto-run-combined');
    } else {
         if (currentSearchMode === 'sgs') {
             log('Mode switched to S-Candidate Screening (SGS Filter Only). This is fast and will produce a list for Step 4.');
         } else {
              log('Mode switched to Prime Factor Search.');
         }
        autoRunButton.classList.remove('auto-run-combined');
        checkWorkerButton.classList.remove('auto-run-combined');
    }
}

// --- Copy Button Logic ---
function copyToClipboard(text) {
    const textArea = document.createElement('textarea');
    textArea.value = text;
    document.body.appendChild(textArea);
    textArea.select();
    try {
        document.execCommand('copy');
        log('Content copied to clipboard!');
    } catch (err) {
        log('Failed to copy content.');
    }
    document.body.removeChild(textArea);
}

// --- SAFE EVENT LISTENERS (wait for DOM) ---
window.addEventListener('load', () => {
    // All elements are guaranteed to exist now

    // Step 4 Resolver
    document.getElementById('resolveSASButton').addEventListener('click', resolveSASFactors);

    // Single Divisor Verification
    document.getElementById('verifyButton').addEventListener('click', verify);

    // Step 3 Controls
    document.getElementById('checkWorkerButton').addEventListener('click', () => startParallelScan(true, false));
    document.getElementById('autoRunButton').addEventListener('click', () => startParallelScan(false, false));
    document.getElementById('stopButton').addEventListener('click', () => {
        if (isScanning && sqrtWorker) {
            stopSMinCalc(); // Stop S_min calc
        } else if (isScanning) {
            stopScan(true); // Stop SGS/Prime scan
        } else {
            // Handle case where resolver is running
            stopScan(true); // This will just re-enable buttons
        }
    });

    // Step 1 S_min Finder
    document.getElementById('findSMinButton').addEventListener('click', startSMinCalc);

    // Step 2 Mode Switches
    document.getElementById('modeSGS').addEventListener('change', setSearchMode);
    document.getElementById('modeCombined').addEventListener('change', setSearchMode);
    document.getElementById('modePrime').addEventListener('change', setSearchMode);

    // Advanced Filter Suggestion
    document.getElementById('suggestFilterButton').addEventListener('click', () => {
        const b = parseBigInt(document.getElementById('exponentInput').value);
        const c = parseBigInt(document.getElementById('addendInput').value);
        if (c.equals(1)) {
            log('Detected form a^b + 1. Suggesting filter p = 2*b*k + 1.');
            document.getElementById('kMultiple').value = (b.multiply(2)).toString();
            document.getElementById('kAddend').value = '1';
            return;
        }
        if (c.equals(-1)) {
            log('Detected form a^b - 1. Suggesting filter p = b*k + 1.');
            document.getElementById('kMultiple').value = b.toString();
            document.getElementById('kAddend').value = '1';
            return;
        }
        log('No simple algebraic pattern detected for filter suggestion.');
    });

    // --- NEW: Copy Button Listeners ---
    document.getElementById('copyLogButton').addEventListener('click', () => {
        copyToClipboard(logOutput.textContent);
    });

    document.getElementById('copyCandidatesButton').addEventListener('click', () => {
        copyToClipboard(Array.from(sCandidateList).join('\n'));
    });

    document.getElementById('copyFactorsButton').addEventListener('click', () => {
         copyToClipboard(Array.from(foundFactors).join('\n'));
    });

    // --- Initial Page Load Setup ---
    log('FactorHunter 9.3 Loaded: Stale state bug fixed.');
    document.getElementById('baseInput').value = "10";
    document.getElementById('exponentInput').value = "3";
    document.getElementById('addendInput').value = "729"; // N=1729
    document.getElementById('minLimitInput').value = "1";
    document.getElementById('maxLimitInput').value = "1000";
    document.getElementById('candidateInput').value = "";
    setSearchMode(); // Initialize
});

</script>
</body>
</html>

