<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Number Theory Factor Finder (Ultimate Version - Optimized)</title>
<style>
:root {
  --bg-color: #f3f4f6;
  --text-color: #1f2937;
  --card-bg: #fff;
  --card-text: #374151;
  --input-bg: #f9fafb;
  --input-border: #d1d5db;
  --button-bg: #2563eb;
  --button-hover: #1d4ed8;
  --log-bg: #e2e8f0;
  --progress-bg: #4caf50;
  --header-color: #1d4ed8;
}
body { font-family: system-ui, sans-serif; background: var(--bg-color); color: var(--text-color); display:flex; justify-content:center; align-items:center; min-height:100vh; flex-direction:column; padding:2rem; }
.container { max-width: 900px; width: 100%; background: var(--card-bg); border-radius: .5rem; box-shadow: 0 10px 15px rgba(0,0,0,.1); padding: 2.5rem; margin-top: 2rem; }
h2 { text-align:center; color: var(--header-color); margin-bottom: 2rem; font-size:2rem; font-weight:700; }
h3 { margin-top:1.5rem; margin-bottom:1rem; color:var(--card-text); border-bottom:2px solid var(--input-border); padding-bottom:.5rem; }
.grid { display:grid; grid-template-columns: repeat(auto-fit, minmax(200px,1fr)); gap: 1.5rem; }
.input-group, .button-group { display:flex; flex-direction:column; }
label { margin-bottom:.5rem; font-weight:600; }
input[type="text"] { padding:.75rem; border:1px solid var(--input-border); border-radius:.25rem; background:var(--input-bg); color:var(--card-text); font-size:1rem; }
input:focus { outline:none; border-color:var(--button-bg); }
.button-group { flex-direction:row; flex-wrap:wrap; gap:.75rem; margin-top:1rem; }
button { padding:.75rem 1.25rem; border:none; border-radius:.25rem; background:var(--button-bg); color:#fff; font-weight:600; cursor:pointer; }
button:hover:not(:disabled){ background: var(--button-hover); }
button:disabled { background:#9ca3af; cursor:not-allowed; }
#progressBarContainer { width:100%; background:#e0e0e0; border-radius:.25rem; margin-top:1.5rem; overflow:hidden; }
#progressBar { height:25px; width:0%; background:var(--progress-bg); text-align:center; line-height:25px; color:white; font-weight:bold; transition: width .2s ease; }
#results { margin-top:1.5rem; font-weight:700; color:var(--header-color); font-size:1.1rem; }
#logOutput, #factorsOutput { width:100%; height:150px; overflow-y:auto; border:1px solid var(--input-border); background:var(--log-bg); padding:1rem; font-family: monospace; white-space:pre-wrap; margin-top:1rem; border-radius:.25rem; }
.row { display:grid; grid-template-columns: repeat(auto-fit,minmax(200px,1fr)); gap:1.5rem; align-items:end; }
details { margin-top: 1rem; border: 1px solid var(--input-border); padding: 1rem; border-radius: 0.25rem; }
summary { font-weight: 600; cursor: pointer; }
.h3-container { display: flex; justify-content: space-between; align-items: center; }
.copy-button { padding: 0.25rem 0.5rem; font-size: 0.8rem; background: #6b7280; }
.copy-button:hover { background: #4b5563; }
</style>
</head>
<body>
<div class="container">
<h2>Number Theory Factor Finder (Ultimate Version - Optimized)</h2>
<h3>Number to Factor</h3>
<div class="grid">
  <div class="input-group">
    <label for="baseInput">Base (a)</label>
    <input type="text" id="baseInput" value="10">
  </div>
  <div class="input-group">
    <label for="exponentInput">Exponent (b)</label>
    <input type="text" id="exponentInput" value="1000000000">
  </div>
  <div class="input-group">
    <label for="addendInput">Addend (c)</label>
    <input type="text" id="addendInput" value="19">
  </div>
</div>
<h3>Single Divisor Verification (fast, deterministic)</h3>
<div class="row">
  <div class="input-group">
    <label for="divisorInput">Divisor to verify</label>
    <input type="text" id="divisorInput" value="5104699">
  </div>
  <div class="button-group">
    <button id="verifyButton">Verify divisor (fast)</button>
    <button id="quickCheckButton">Quick check 5104699</button>
  </div>
</div>
<h3>Search Parameters (optional prime scanning)</h3>
<div class="grid">
  <div class="input-group">
    <label for="minLimitInput">Min Limit</label>
    <input type="text" id="minLimitInput" value="4e6" placeholder="e.g., 2 or 1e15">
  </div>
  <div class="input-group">
    <label for="maxLimitInput">Max Limit</label>
    <input type="text" id="maxLimitInput" value="4e6+200000" placeholder="e.g., 5000000 or 1e309">
  </div>
  <div class="input-group">
    <label for="chunkSizeInput">Chunk Size</label>
    <input type="text" id="chunkSizeInput" value="200000">
  </div>
</div>
<details>
    <summary>Advanced Prime Filtering</summary>
    <p>Optionally, search only for prime factors of the form <code>p = k*m + n</code>. The "Suggest Filter" button can help find common forms.</p>
    <div class="grid">
        <div class="input-group">
            <label for="kMultiple">Multiple (m)</label>
            <input type="text" id="kMultiple" placeholder="e.g., 198">
        </div>
        <div class="input-group">
            <label for="kAddend">Addend (n)</label>
            <input type="text" id="kAddend" placeholder="e.g., 1">
        </div>
        <div class="button-group" style="align-items: flex-start;">
             <button id="suggestFilterButton" style="margin-top: 1.75rem;">Suggest Filter</button>
        </div>
    </div>
</details>
<h3>Pre-computation Checks</h3>
<div class="input-group" style="flex-direction: row; align-items: center; gap: 0.5rem;">
  <input type="checkbox" id="algebraicCheck" checked>
  <label for="algebraicCheck" style="margin-bottom: 0;">Check for simple algebraic factors (fast)</label>
</div>
<h3>Controls</h3>
<div class="button-group">
  <button id="checkWorkerButton">Scan primes with Worker</button>
  <button id="autoRunButton">Auto-Run chunks</button>
  <input type="checkbox" id="autoRepeatCheck">
  <label for="autoRepeatCheck" style="margin-bottom: 0;">Auto Repeat</label>
  <button id="stopButton" disabled>Stop</button>
</div>
<div id="progressBarContainer">
  <div id="progressBar">0%</div>
</div>
<div id="results">Status: Idle</div>

<h3>Main Log</h3>
<pre id="logOutput">Log: </pre>

<div class="h3-container">
    <h3>Found Factors</h3>
    <button id="copyFactorsButton" class="copy-button">Copy</button>
</div>
<pre id="factorsOutput"></pre>

</div>

<script>
// --- UI Element References ---
const baseInput = document.getElementById('baseInput');
const exponentInput = document.getElementById('exponentInput');
const addendInput = document.getElementById('addendInput');
const divisorInput = document.getElementById('divisorInput');
const minLimitInput = document.getElementById('minLimitInput');
const maxLimitInput = document.getElementById('maxLimitInput');
const chunkSizeInput = document.getElementById('chunkSizeInput');
const kMultipleInput = document.getElementById('kMultiple');
const kAddendInput = document.getElementById('kAddend');
const algebraicCheck = document.getElementById('algebraicCheck');
const suggestFilterButton = document.getElementById('suggestFilterButton');
const verifyButton = document.getElementById('verifyButton');
const quickCheckButton = document.getElementById('quickCheckButton');
const checkWorkerButton = document.getElementById('checkWorkerButton');
const autoRunButton = document.getElementById('autoRunButton');
const stopButton = document.getElementById('stopButton');
const autoRepeatCheck = document.getElementById('autoRepeatCheck');
const progressBar = document.getElementById('progressBar');
const resultsDiv = document.getElementById('results');
const logOutput = document.getElementById('logOutput');
const factorsOutput = document.getElementById('factorsOutput');
const copyFactorsButton = document.getElementById('copyFactorsButton');

// --- Global State Variables ---
let workerPool = [];
const numWorkers = navigator.hardwareConcurrency || 4;
let activeWorkers = 0;
let isScanning = false;
let foundFactors = new Set();
let currentMin = 0n;
let workerProgress = new Array(numWorkers).fill(0);
let workerChunks = new Array(numWorkers).fill(null);
let totalScanned = 0n;
let totalRange = 0n;

// --- Algorithmic Constants & Thresholds ---
const SIEVE_THRESHOLD = 1000000000000n;
const MAX_CHUNK_FOR_SIEVE = 10000000n;
const TRIAL_DIVISION_LIMIT = 1000;

// --- Utility Functions ---
function parseBigInt(str) {
  if (!str) return 0n;
  str = str.replace(/\s/g, '');

  if (str.includes('+')) {
    const terms = str.split('+');
    return terms.reduce((sum, term) => sum + parseBigInt(term), 0n);
  }

  if (str.includes('e') || str.includes('E')) {
    const parts = str.toLowerCase().split('e');
    return BigInt(parts[0]) * 10n ** BigInt(parts[1]);
  }
  return BigInt(str);
}

function log(msg) {
  logOutput.textContent += msg + '\n';
  logOutput.scrollTop = logOutput.scrollHeight;
}

function logFactor(factor) {
  if (!foundFactors.has(factor.toString())) {
      foundFactors.add(factor.toString());
      factorsOutput.textContent = Array.from(foundFactors).join('\n');
  }
}

function setStatus(t) { resultsDiv.textContent = 'Status: ' + t; }

function setProgress() {
  if (totalRange <= 0n) {
    progressBar.style.width = '0%';
    progressBar.textContent = '0.00%';
    return;
  }
  const progressPercent = Math.min(100, Number(totalScanned * 10000n / totalRange) / 100);

  progressBar.style.width = progressPercent + '%';
  progressBar.textContent = progressPercent.toFixed(2) + '%';
}

function powMod(base, exp, mod) {
  let result = 1n;
  base %= mod;
  while (exp > 0n) {
    if ((exp & 1n) === 1n) result = (result * base) % mod;
    exp >>= 1n;
    base = (base * base) % mod;
  }
  return result;
}

function powModWithProgress(base, exp, mod, onProgress) {
  let result = 1n;
  base %= mod;
  const totalBits = exp.toString(2).length;
  let processedBits = 0;
  while (exp > 0n) {
    if ((exp & 1n) === 1n) result = (result * base) % mod;
    exp >>= 1n;
    base = (base * base) % mod;
    processedBits++;
    if (onProgress && processedBits % 8 === 0) onProgress(processedBits / totalBits * 100);
  }
  if (onProgress) onProgress(100);
  return result;
}

// --- Single Divisor Verification Logic ---
function verify() {
  try {
    setStatus('Verifying divisor...');
    progressBar.style.width = '0%';
    progressBar.textContent = '0.00%';
    log('--- Single divisor verification ---');
    const a = parseBigInt(baseInput.value);
    const b = parseBigInt(exponentInput.value);
    const c = parseBigInt(addendInput.value);
    const d = parseBigInt(divisorInput.value);
    if (d <= 0n) throw new Error('Divisor must be positive.');
    const remPow = powModWithProgress(a, b, d, p => {
        progressBar.style.width = p * 0.95 + '%';
        progressBar.textContent = (p * 0.95).toFixed(2) + '%';
    });
    const finalRem = (remPow + (c % d) + d) % d;
    log(`a^b mod d = ${remPow}`);
    log(`(a^b + c) mod d = ${finalRem}`);
    if (finalRem === 0n) {
      setStatus(`Divides exactly ✔`);
      log(`Result: 0 → ${d} divides a^b + c`);
      logFactor(d);
    } else {
      setStatus(`Not a factor ✖`);
      log(`Result: ${finalRem} → not divisible by ${d}`);
    }
    progressBar.style.width = '100%';
    progressBar.textContent = '100.00%';
  } catch (e) {
    setStatus('Error');
    log('Error: ' + e.message);
  }
}
verifyButton.addEventListener('click', verify);
quickCheckButton.addEventListener('click', () => {
  baseInput.value = "10";
  exponentInput.value = "1000000000";
  addendInput.value = "19";
  divisorInput.value = "5104699";
  verify();
});

// --- Web Worker Code ---
const workerCode = `
function powMod(base, exp, mod) {
  let result = 1n;
  base %= mod;
  while (exp > 0n) {
    if ((exp & 1n) === 1n) result = (result * base) % mod;
    exp >>= 1n;
    base = (base * base) % mod;
  }
  return result;
}

function legendreSymbol(a, p) {
    const ls = powMod(a, (p - 1n) >> 1n, p);
    if (ls === p - 1n) return -1;
    return Number(ls);
}

function randomBigInt(low, high) {
  const diff = high - low;
  const bitLength = diff.toString(2).length;
  const byteLength = Math.ceil(bitLength / 8);
  const buf = new Uint8Array(byteLength);
  crypto.getRandomValues(buf);
  let rand = 0n;
  for (let i = 0; i < byteLength; i++) {
    rand = (rand << 8n) | BigInt(buf[i]);
  }
  return low + (rand % diff);
}

function millerRabinTest(n, k = 20) {
  if (n <= 1n) return false;
  if (n <= 3n) return true;
  if ((n & 1n) === 0n) return false;

  if (n > 1000000000000000000n) k = 5;

  let d = n - 1n;
  let r = 0n;
  while ((d & 1n) === 0n) {
    d >>= 1n;
    r++;
  }

  const witnesses = (n < 3825123056546413051n) ? [2n, 3n, 5n, 7n, 11n, 13n, 23n] : null;
  if (witnesses && k > witnesses.length) k = witnesses.length;

  for (let i = 0; i < k; i++) {
    let a = witnesses ? witnesses[i] : randomBigInt(2n, n - 2n);
    if (a >= n - 1n) continue;

    let x = powMod(a, d, n);
    if (x === 1n || x === n - 1n) continue;

    let composite = true;
    for (let j = 1n; j < r; j++) {
      x = powMod(x, 2n, n);
      if (x === n - 1n) {
        composite = false;
        break;
      }
      if (x === 1n) break;
    }
    if (composite) return false;
  }
  return true;
}

function generateSmallPrimes(limit) {
    const isPrime = new Array(limit + 1).fill(true);
    isPrime[0] = isPrime[1] = false;
    for (let i = 2; i * i <= limit; i++) {
        if (isPrime[i]) {
            for (let j = i * i; j <= limit; j += i) isPrime[j] = false;
        }
    }
    return isPrime.reduce((p, v, i) => { if(v) p.push(BigInt(i)); return p; }, []);
}

self.onmessage = e => {
  let { a, b, c, min, max, workerIndex, k_m, k_n } = e.data;
  a = BigInt(a); b = BigInt(b); c = BigInt(c); min = BigInt(min); max = BigInt(max);
  k_m = BigInt(k_m); k_n = BigInt(k_n);

  let primes = [];
  const useSieve = max < ${SIEVE_THRESHOLD}n && (max - min) < ${MAX_CHUNK_FOR_SIEVE}n;
  const bIsEven = (b & 1n) === 0n;
  const negC = -c;

  if (useSieve) {
    const sqrtMax = BigInt(Math.ceil(Math.sqrt(Number(max < 1n << 53n ? max : 1n << 53n))));
    const smallPrimes = generateSmallPrimes(Number(sqrtMax));
    const rangeSize = Number(max - min + 1n);
    const isPrimeInRange = new Array(rangeSize).fill(true);

    if (min <= 1n) {
        if (min === 0n) { isPrimeInRange[0] = false; isPrimeInRange[1] = false; }
        else { isPrimeInRange[0] = false; }
    }

    for (const p of smallPrimes) {
      if (p * p > max) break;
      let start = (min / p) * p;
      if (start < min) start += p;
      if (start === p) start += p;
      for (let multiple = start; multiple <= max; multiple += p) {
        isPrimeInRange[Number(multiple - min)] = false;
      }
    }
    for (let i = 0; i < rangeSize; i++) {
      if (isPrimeInRange[i]) {
        primes.push(min + BigInt(i));
      }
    }
  } else {
    let current = min;
    const rangeInChunk = max - min;
    let lastProgress = -1;
    if ((current & 1n) === 0n) current++;

    while(current <= max && (current % 3n === 0n || current % 5n === 0n)) {
      if(current <= 5n) {
          if (current === 3n) current = 5n;
          else if (current === 5n) current = 7n;
          break;
      }
      current += 2n;
    }
    if (current < 7n) current = 7n;

    const wheel = [4n, 2n, 4n, 2n, 4n, 6n, 2n, 6n];
    let wheelIndex = 0;
    const mod30 = current % 30n;
    if(mod30 === 7n) wheelIndex = 0;
    else if(mod30 === 11n) wheelIndex = 1;
    else if(mod30 === 13n) wheelIndex = 2;
    else if(mod30 === 17n) wheelIndex = 3;
    else if(mod30 === 19n) wheelIndex = 4;
    else if(mod30 === 23n) wheelIndex = 5;
    else if(mod30 === 29n) wheelIndex = 6;
    else if(mod30 === 1n) wheelIndex = 7;

    while (current <= max) {
        if (millerRabinTest(current)) primes.push(current);

        if (rangeInChunk > 0n) {
            const iterations = current - min;
            const progress = Number(iterations * 100n / rangeInChunk);
            if (progress > lastProgress) {
                self.postMessage({ type: 'progress', progress, workerIndex });
                lastProgress = progress;
            }
        }
        current += wheel[wheelIndex];
        wheelIndex = (wheelIndex + 1) % 8;
    }
  }

  let finalPrimes = primes;
  if (k_m > 0n) finalPrimes = finalPrimes.filter(p => (p - k_n) % k_m === 0n);
  if (bIsEven) finalPrimes = finalPrimes.filter(p => p === 2n || legendreSymbol(negC, p) !== -1);

  const numPrimes = finalPrimes.length;
  let lastProgress = useSieve ? -1 : 100;

  for (let i = 0; i < numPrimes; i++) {
    const p = finalPrimes[i];
    const rem = (powMod(a, b, p) + c) % p;
    if (rem === 0n) {
      self.postMessage({ type: 'factorFound', factor: p.toString() });
    }

    if (useSieve) {
        const progress = Math.floor(((i + 1) / numPrimes) * 100) || 0;
        if (progress > lastProgress) {
          self.postMessage({ type: 'progress', progress, workerIndex });
          lastProgress = progress;
        }
    }
  }

  self.postMessage({ type: 'done', min: min.toString(), max: max.toString(), workerIndex });
};
`;

function nthRoot(n, k) {
    if (n < 0n || k < 1n) return null;
    if (k === 1n) return n;

    let low = 1n;
    let high = n;

    while (low <= high) {
        const mid = (low + high) >> 1n;
        if (mid === 0n) {
           low = 1n;
           continue;
        }

        let power;
        try {
            power = mid ** k;
        } catch (e) {
            power = -1n;
        }

        if (power === n) {
            return mid;
        } else if (power > 0n && power < n) {
            low = mid + 1n;
        } else {
            high = mid - 1n;
        }
    }
    return null;
}

async function checkAlgebraicFactors() {
    log('--- Checking for simple algebraic factors ---');
    setStatus('Checking for algebraic factors...');
    const a = parseBigInt(baseInput.value);
    const b = parseBigInt(exponentInput.value);
    const c = parseBigInt(addendInput.value);

    if (c > 0n && (b & 1n) === 1n) {
        const d = nthRoot(c, b);
        if (d !== null) {
            const factor = a + d;
            log(`Form a^b + d^b with odd b found (d=${d}). Factor: ${factor}`);
            logFactor(factor);
        }
    }

    if (c < 0n) {
        const c_abs = -c;
        const d = nthRoot(c_abs, b);
        if (d !== null) {
            const factor1 = a - d;
            log(`Form a^b - d^b found (d=${d}). Factor: ${factor1}`);
            logFactor(factor1);
            if ((b & 1n) === 0n) {
                const factor2 = a + d;
                log(`Exponent b is even. Additional factor: ${factor2}`);
                logFactor(factor2);
            }
        }
    }
    log('--- Algebraic check finished ---');
}

async function trialDivision() {
    log('--- Starting pre-computation: trial division ---');
    setStatus(`Checking small primes up to ${TRIAL_DIVISION_LIMIT}...`);

    const limit = TRIAL_DIVISION_LIMIT;
    const isPrime = new Array(limit + 1).fill(true);
    isPrime[0] = isPrime[1] = false;
    for (let i = 2; i * i <= limit; i++) {
        if (isPrime[i]) {
            for (let j = i * i; j <= limit; j += i) isPrime[j] = false;
        }
    }
    const smallPrimes = [];
    for (let i = 2; i <= limit; i++) if (isPrime[i]) smallPrimes.push(BigInt(i));

    const a = parseBigInt(baseInput.value);
    const b = parseBigInt(exponentInput.value);
    const c = parseBigInt(addendInput.value);

    for (const p of smallPrimes) {
        const rem = (powMod(a, b, p) + c) % p;
        if (rem === 0n) {
            log(`Small prime factor found: ${p}`);
            logFactor(p);
        }
    }
    log('--- Trial division finished ---');
}

function createWorker(workerIndex) {
  const worker = new Worker(URL.createObjectURL(new Blob([workerCode], { type: 'application/javascript' })));
  worker.onmessage = handleWorkerMessage;
  worker.onerror = e => {
    setStatus('Worker error');
    log(`Worker ${workerIndex} error: ${e.message}`);
    stopScan(true);
  };
  workerPool[workerIndex] = worker;
  return worker;
}

function handleWorkerMessage(e) {
  if (e.data.type === 'factorFound') {
    const factor = e.data.factor;
    setStatus(`Factor found: ${factor}`);
    log(`Factor found: ${factor}`);
    logFactor(factor);
  } else if (e.data.type === 'progress') {
    const workerIndex = e.data.workerIndex;
    const newProgress = e.data.progress;
    const lastProgress = workerProgress[workerIndex];
    const chunkInfo = workerChunks[workerIndex];

    if (chunkInfo && newProgress > lastProgress) {
        const progressDelta = BigInt(newProgress - lastProgress);
        const numbersScannedInDelta = (chunkInfo.size * progressDelta) / 100n;
        totalScanned += numbersScannedInDelta;
        workerProgress[workerIndex] = newProgress;
        setProgress();
    }
  } else if (e.data.type === 'done') {
    const workerIndex = e.data.workerIndex;
    const lastProgress = workerProgress[workerIndex];
    const chunkInfo = workerChunks[workerIndex];

    if (chunkInfo && lastProgress < 100) {
        const progressDelta = BigInt(100 - lastProgress);
        const numbersScannedInDelta = (chunkInfo.size * progressDelta) / 100n;
        totalScanned += numbersScannedInDelta;
    }
    workerChunks[workerIndex] = null;

    setProgress();
    assignNextChunk(e.data.workerIndex);
  }
}

function assignNextChunk(workerIndex) {
  if (!isScanning || currentMin > parseBigInt(maxLimitInput.value)) {
    activeWorkers--;
    if (activeWorkers === 0) {
      setStatus('Scan complete or stopped.');
      log('Scan complete or stopped.');
      stopScan();
    }
    return;
  }

  let chunkSize = parseBigInt(chunkSizeInput.value);
  if (parseBigInt(maxLimitInput.value) > SIEVE_THRESHOLD) {
    if (chunkSize > 100000000n) {
      chunkSize = 100000000n;
    }
  } else if (chunkSize > MAX_CHUNK_FOR_SIEVE) {
      chunkSize = MAX_CHUNK_FOR_SIEVE;
  }

  const chunkMin = currentMin;
  let chunkMax = currentMin + chunkSize - 1n;
  if (chunkMax > parseBigInt(maxLimitInput.value)) chunkMax = parseBigInt(maxLimitInput.value);

  workerProgress[workerIndex] = 0;
  workerChunks[workerIndex] = { size: chunkMax - chunkMin + 1n };

  workerPool[workerIndex].postMessage({
    a: baseInput.value,
    b: exponentInput.value,
    c: addendInput.value,
    min: chunkMin.toString(),
    max: chunkMax.toString(),
    workerIndex,
    k_m: kMultipleInput.value,
    k_n: kAddendInput.value
  });

  currentMin = chunkMax + 1n;
}

function updateRangeForRepeat() {
  const minVal = parseBigInt(minLimitInput.value);
  const maxVal = parseBigInt(maxLimitInput.value);
  const rangeSize = maxVal - minVal;

  const newMin = maxVal + 1n;
  const newMax = newMin + rangeSize;

  minLimitInput.value = newMin.toString();
  maxLimitInput.value = newMax.toString();

  log(`--- Auto Repeat: Updated range to [${newMin}, ${newMax}] ---`);
}

async function startParallelScan(singleChunk = false, isAutoRepeat = false) {
  if (!isAutoRepeat) {
    stopScan(true);
    logOutput.textContent = 'Log:\n';
    factorsOutput.textContent = '';
    foundFactors.clear();
  } else {
    log('\n--- Starting new auto-repeat scan ---');
  }

  isScanning = true;
  checkWorkerButton.disabled = true;
  autoRunButton.disabled = true;
  stopButton.disabled = false;

  const b = parseBigInt(exponentInput.value);
  if ((b & 1n) === 0n) {
    log('Exponent is even. Activating Quadratic Reciprocity filter.');
  }

  const k_m = parseBigInt(kMultipleInput.value);
  if (k_m > 0n) {
    log(`Advanced filter enabled: Searching for primes of the form k*${k_m} + ${parseBigInt(kAddendInput.value)}`);
  }

  if (algebraicCheck.checked) {
    await new Promise(resolve => setTimeout(resolve, 10));
    await checkAlgebraicFactors();
  }

  if (!isScanning) return;

  await new Promise(resolve => setTimeout(resolve, 10));
  await trialDivision();

  if (!isScanning) return;

  let minVal = parseBigInt(minLimitInput.value);
  if (minVal < 2n) minVal = 2n;

  if (minVal <= TRIAL_DIVISION_LIMIT) {
    log(`Adjusting scan start. Workers will begin scanning from ${TRIAL_DIVISION_LIMIT + 1}.`);
    minVal = BigInt(TRIAL_DIVISION_LIMIT + 1);
  }

  const maxVal = parseBigInt(maxLimitInput.value);
  totalScanned = 0n;
  totalRange = maxVal > minVal ? maxVal - minVal + 1n : 0n;
  workerChunks.fill(null);
  workerProgress.fill(0);
  setProgress();

  currentMin = minVal;

  for (let i = 0; i < numWorkers; i++) {
    createWorker(i);
  }

  activeWorkers = numWorkers;
  setStatus(`Scanning with ${numWorkers} workers...`);

  for (let i = 0; i < numWorkers; i++) {
    if (singleChunk && i > 0) continue;
    assignNextChunk(i);
  }
}

function stopScan(userInitiated = false) {
  isScanning = false;
  workerPool.forEach(w => w.terminate());
  workerPool = [];
  activeWorkers = 0;
  stopButton.disabled = true;
  checkWorkerButton.disabled = false;
  autoRunButton.disabled = false;

  if (resultsDiv.textContent.startsWith('Status: Scanning') || resultsDiv.textContent.startsWith('Status: Checking')) {
    setStatus('Stopped');
    log('Scan stopped.');
  }

  if (!userInitiated && autoRepeatCheck.checked && isFinite(Number(parseBigInt(maxLimitInput.value)))) {
    setStatus('Preparing next range...');
    log('Auto Repeat: Preparing next range...');
    updateRangeForRepeat();
    setTimeout(() => startParallelScan(false, true), 100);
  } else {
    factorsOutput.textContent = Array.from(foundFactors).join('\n');
  }
}

checkWorkerButton.addEventListener('click', () => startParallelScan(true, false));
autoRunButton.addEventListener('click', () => startParallelScan(false, false));
stopButton.addEventListener('click', () => stopScan(true));
suggestFilterButton.addEventListener('click', () => {
    const b = parseBigInt(exponentInput.value);
    const c = parseBigInt(addendInput.value);

    if (c === 1n) {
        log('Detected form a^b + 1. Suggesting filter p = 2*b*k + 1.');
        kMultipleInput.value = (2n * b).toString();
        kAddendInput.value = '1';
        return;
    }

    if (c === -1n) {
        log('Detected form a^b - 1. Suggesting filter p = b*k + 1.');
        kMultipleInput.value = b.toString();
        kAddendInput.value = '1';
        return;
    }

    log('No simple algebraic pattern detected for filter suggestion.');
});

copyFactorsButton.addEventListener('click', () => {
    const textToCopy = Array.from(foundFactors).join('\n');
    const textArea = document.createElement('textarea');
    textArea.value = textToCopy;
    document.body.appendChild(textArea);
    textArea.select();
    try {
        document.execCommand('copy');
        log('Factors copied to clipboard!');
    } catch (err) {
        log('Failed to copy factors.');
    }
    document.body.removeChild(textArea);
});

window.addEventListener('load', () => {
  log('Optimized version: Now with algebraic factorization, QR filter, pre-computation, wheel factorization, bit-shift optimizations, and auto-repeat with persistent factors.');
});
</script>
</body>
</html>

