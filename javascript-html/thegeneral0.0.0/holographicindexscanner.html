<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Index Sniper: Zero Memory Check</title>
    <style>
        :root {
            --bg: #000000;
            --text: #00ff41; /* Matrix Green */
            --dim: #008f11;
            --alert: #ff3333;
            --panel: #111;
        }

        body {
            background-color: var(--bg);
            color: var(--text);
            font-family: 'Courier New', Courier, monospace;
            padding: 40px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }

        h1 {
            text-transform: uppercase;
            border-bottom: 2px solid var(--dim);
            padding-bottom: 10px;
            margin-bottom: 30px;
            letter-spacing: 4px;
        }

        .interface {
            width: 100%;
            max-width: 700px;
            background: var(--panel);
            padding: 30px;
            border: 1px solid var(--dim);
            box-shadow: 0 0 20px rgba(0, 255, 65, 0.1);
        }

        .input-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            color: var(--dim);
            margin-bottom: 10px;
            font-size: 0.9em;
        }

        input {
            width: 100%;
            background: #000;
            border: 1px solid var(--dim);
            color: var(--text);
            padding: 15px;
            font-family: inherit;
            font-size: 1.2em;
            outline: none;
            box-sizing: border-box;
        }

        input:focus { border-color: var(--text); }

        button {
            width: 100%;
            background: var(--dim);
            color: #000;
            border: none;
            padding: 15px;
            font-weight: bold;
            font-size: 1.1em;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: background 0.2s;
        }

        button:hover { background: var(--text); }

        #output {
            margin-top: 30px;
            border-top: 1px dashed var(--dim);
            padding-top: 20px;
        }

        .log-line { margin: 8px 0; }
        .highlight { color: #fff; font-weight: bold; }
        .hit { color: var(--alert); font-weight: bold; font-size: 1.2em; }
        .safe { color: var(--text); font-weight: bold; }
        
        .detail-box {
            margin-top: 15px;
            padding: 15px;
            border: 1px solid var(--dim);
            background: #050505;
            font-size: 0.9em;
        }

    </style>
</head>
<body>

    <h1>Index Sniper v1.0</h1>

    <div class="interface">
        <div class="input-group">
            <label>TARGET COORDINATE (INDEX)</label>
            <input type="text" id="targetIndex" placeholder="e.g. 10^50 + 18" value="10^50 + 18">
            <small style="color:var(--dim); display:block; margin-top:5px;">Supports math expressions (e.g., 10^100, 2**64)</small>
        </div>

        <div class="input-group">
            <label>MAX FAMILY STRIDE TO CHECK</label>
            <input type="number" id="maxStride" value="1000000">
        </div>

        <button onclick="fireSniper()">CHECK COORDINATE</button>

        <div id="output"></div>
    </div>

    <script>
        // --- GENERATE STRIDERS (The "Textbook Memory") ---
        // We generate a list of small primes to use as our "Family Settings".
        let striderList = [];
        const PRECALC_LIMIT = 2000000; // Load 2 million primes into RAM (Fast)

        function initStriders() {
            const sieve = new Uint8Array(PRECALC_LIMIT + 1);
            sieve.fill(1);
            sieve[0]=0; sieve[1]=0;
            for(let i=2; i*i<=PRECALC_LIMIT; i++){
                if(sieve[i]) {
                    for(let j=i*i; j<=PRECALC_LIMIT; j+=i) sieve[j]=0;
                }
            }
            for(let i=2; i<=PRECALC_LIMIT; i++) {
                if(sieve[i]) striderList.push(i);
            }
            console.log("Sniper loaded " + striderList.length + " families.");
        }

        setTimeout(initStriders, 100); // Run on load

        // --- PARSE INPUT (Now with 100% Precision) ---
        function parseInput(str) {
            try {
                // Handle the specific "10^N" or "10**N" format manually for BigInt precision
                // This bypasses the "fuzzy" JS math engine
                if (str.includes('^')) {
                    let parts = str.split('^');
                    let base = BigInt(parts[0].trim());
                    let exp = BigInt(parts[1].trim().split(/[+\-]/)[0]); // Get the exponent
                    
                    let result = base ** exp;
                    
                    // If there was an addition like "+ 18", add it now
                    if (str.includes('+')) {
                        let add = BigInt(str.split('+')[1].trim());
                        result += add;
                    }
                    return result;
                }
                
                // Fallback for simple numbers
                const clean = str.replace(/[^\d]/g, '');
                return BigInt(clean);
            } catch(e) {
                return null;
            }
        }

        // --- THE SNIPER LOGIC ---
        async function fireSniper() {
            const output = document.getElementById('output');
            const inputStr = document.getElementById('targetIndex').value;
            const maxCheck = parseInt(document.getElementById('maxStride').value);
            
            output.innerHTML = '<div class="log-line">Locking onto target...</div>';
            
            // 1. Acquire Target
            const targetIndex = parseInput(inputStr);
            if (targetIndex === null) {
                output.innerHTML = '<div class="hit">ERROR: INVALID COORDINATE</div>';
                return;
            }

            // Calculate the visual "Rim" just for display purposes
            const targetRim = (targetIndex * 2n) - 1n;
            
            let html = `
                <div class="detail-box">
                    <div><strong>TARGET INDEX:</strong> ${targetIndex.toString().substring(0, 20)}...</div>
                    <div><strong>TARGET RIM:</strong> ${targetRim.toString().substring(0, 20)}...</div>
                </div>
                <div class="log-line">Scanning for Stride Impacts...</div>
            `;
            output.innerHTML = html;

            // 2. Run the "Textbook Check"
            // We iterate our list of striders.
            const startTime = performance.now();
            let hitFound = false;

            // Use a specialized loop to allow UI updates if it takes long
            const batchSize = 10000;
            
            for (let i = 0; i < striderList.length; i++) {
                const family = striderList[i];
                if (family > maxCheck) break;
                if (family === 2) continue; // Skip 2 (Even numbers handled by Index logic implicitly)

                const stride = BigInt(family);
                
                // A. GET START POINT
                // Theory: Start = (p^2 + 1) / 2
                const startPoint = (stride * stride + 1n) / 2n;

                // B. THE CHECK
                // If Target < Start, this family hasn't started yet. Impossible to hit.
                if (targetIndex >= startPoint) {
                    const distance = targetIndex - startPoint;
                    
                    // The "Zero Memory" Modulo Check
                    if (distance % stride === 0n) {
                        // HIT CONFIRMED!
                        const hops = distance / stride;
                        
                        output.innerHTML += `
                            <div class="detail-box" style="border-color: var(--alert);">
                                <div class="hit">>>> TARGET DESTROYED <<<</div>
                                <br>
                                <div><strong>Hit by Family:</strong> ${family}</div>
                                <div><strong>Family Start Index:</strong> ${startPoint}</div>
                                <div><strong>Hops to Target:</strong> ${hops}</div>
                                <br>
                                <div>This confirms Index ${targetIndex} is COMPOSITE.</div>
                                <div>(Factors of Rim: ${family} x ${(targetRim / stride)})</div>
                            </div>
                        `;
                        hitFound = true;
                        break; // Stop scanning
                    }
                }

                // Small delay every few thousand checks to keep browser alive
                if (i % batchSize === 0 && i > 0) {
                    await new Promise(r => setTimeout(r, 0));
                }
            }

            if (!hitFound) {
                output.innerHTML += `
                    <div class="detail-box" style="border-color: var(--text);">
                        <div class="safe">>>> NO HITS DETECTED <<<</div>
                        <br>
                        <div>Scanned all families up to Stride: ${maxCheck}</div>
                        <div>Target Index appears clean.</div>
                        <div><strong>Status:</strong> PROBABLE PRIME</div>
                    </div>
                `;
            }

            const endTime = performance.now();
            output.innerHTML += `<div class="log-line" style="color:var(--dim); margin-top:10px;">Scan time: ${(endTime - startTime).toFixed(2)}ms</div>`;
        }
    </script>
</body>
</html>
