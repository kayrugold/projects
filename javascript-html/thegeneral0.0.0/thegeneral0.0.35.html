<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>SGS Poly-Algo Squad (v0.0.35 - Shadow Slide)</title>
<script src="https://cdn.tailwindcss.com"></script>
<style>
:root { --bg-color: #0f172a; --card-bg: #1e293b; --text-main: #e2e8f0; --accent-fermat: #6366f1; --accent-rho: #f59e0b; --accent-p1: #ec4899; --accent-pp1: #06b6d4; --accent-td: #22c55e; --accent-qs: #0ea5e9; --accent-ecm: #f97316; --accent-giga: #ef4444; }
body { font-family: 'Inter', sans-serif; background: var(--bg-color); color: var(--text-main); padding: 1rem; }
.card { max-width: 1000px; margin: 0 auto; background: var(--card-bg); border-radius: 1rem; padding: 1.5rem; box-shadow: 0 20px 25px -5px rgba(0,0,0,0.3); }
.worker-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 0.75rem; margin-top: 1rem; }
.worker-card { padding: 0.75rem; border-radius: 0.5rem; font-size: 0.70rem; font-weight: bold; text-align: center; color: white; transition: all 0.2s ease; box-shadow: 0 4px 6px -1px rgba(0,0,0,0.2); }
.log-box { height: 250px; overflow-y: auto; background: #020617; color: #34d399; padding: 1rem; border-radius: 0.5rem; font-family: monospace; font-size: 0.8rem; border: 1px solid #334155; }
.input { background: #334155; border: 1px solid #475569; color: white; padding: 0.5rem; border-radius: 0.25rem; width: 100%; }
.btn { padding: 0.5rem 1rem; border-radius: 0.5rem; font-weight: bold; cursor: pointer; transition: opacity 0.2s; display: inline-block; text-align: center;}
.bg-fermat { background: var(--accent-fermat); }
.bg-rho { background: var(--accent-rho); color: black; }
.bg-giga { background: var(--accent-giga); color: white; }
.bg-offline { background: #334155 !important; color: #64748b !important; opacity: 0.5; box-shadow: none; border: 1px solid #475569; }
</style>
</head>
<body>
<div class="card">
    <h1 class="text-2xl font-bold text-center text-indigo-400 mb-2">SGS Poly-Algorithm Squad v0.0.35</h1>
    <div class="text-center text-xs text-gray-400 mb-4">
        <span class="text-purple-400 font-bold">UPGRADE: "Shadow Slide" Fermat Engine</span>
    </div>

    <div class="grid grid-cols-3 gap-4 mb-4">
        <div><label class="block text-xs font-bold mb-1 text-gray-400">Base (a)</label><input id="base-input" type="text" class="input" value="10"></div>
        <div><label class="block text-xs font-bold mb-1 text-gray-400">Exp (b)</label><input id="exponent-input" type="text" class="input" value="20"></div>
        <div><label class="block text-xs font-bold mb-1 text-gray-400">Add (c)</label><input id="addend-input" type="text" class="input" value="1"></div>
    </div>
    
    <div class="flex flex-wrap gap-4 justify-center mb-6 items-center">
        <button id="start-btn" class="btn bg-green-600 text-white">Deploy Squad</button>
        <button id="stop-btn" class="btn bg-red-600 text-white" disabled>Abort</button>
    </div>

    <div id="worker-grid" class="worker-grid"></div>

    <div class="mt-4 bg-slate-800 p-3 rounded border border-slate-700">
        <p class="text-xs uppercase font-bold text-slate-400">Result Log</p>
        <pre id="log-output" class="log-box">System Ready. Shadow Engine Online.</pre>
    </div>
</div>

<script>
/* ==================== GLOBALS ==================== */
const NUM_WORKERS = 8;
const GIGA_CHUNK_SIZE = 5000000n;
const FERMAT_CHUNK_SIZE = 20000000n; // Larger chunk size because Shadow Slide is fast

let workers = [];
let isRunning = false;
let currentMissionID = 0; 
let globalGigaFrontier = 0n;
let globalFermatFrontier = 0n;

function log(msg){ const t=new Date().toLocaleTimeString(); const el=document.getElementById('log-output'); el.innerHTML+=`[${t}] ${msg}\n`; el.scrollTop=el.scrollHeight; }

/* ==================== WORKER CODE ==================== */
const factorWorkerCode = `
const SHADOW_MODS = [4096, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31]; // The "Fingerprint" Filters
// Pre-calculate Quadratic Residues for 4096
const QR_4096 = new Uint8Array(4096);
for(let i=0; i<4096; i++) QR_4096[(i*i)%4096] = 1;

let spinIdx=0; const spinners=['|','/','-','\\\\']; function getSpin(){spinIdx=(spinIdx+1)%4;return spinners[spinIdx];}

function powMod(b,e,m){
    let r=1n; b%=m; 
    while(e>0n){ if(e&1n)r=(r*b)%m; e>>=1n; b=(b*b)%m; } 
    return r;
}

// Custom Sqrt for BigInt
function isqrt(n) {
    if (n < 2n) return n;
    let x = n, y = (x + 1n) / 2n;
    while (y < x) { x = y; y = (x + n / x) / 2n; }
    return x;
}

// === THE SHADOW SLIDE (Fermat Upgrade) ===
function runFermatShadow(data) {
    const { a, b, c, startK, chunkSize, idx, mID } = data;
    const bigA = BigInt(a), bigB = BigInt(b), bigC = BigInt(c);
    const K = BigInt(startK);
    const LIMIT = K + BigInt(chunkSize);

    // 1. Calculate the "Shadows" of the Target (N) and the Root (R)
    // We don't construct N. We only find where it sits on the small clocks.
    
    // Calculate N % M for each modulus
    const N_shadows = SHADOW_MODS.map(m => {
        const bigM = BigInt(m);
        // N = a^b + c
        const term1 = powMod(bigA, bigB, bigM);
        const term2 = bigC % bigM;
        return Number((term1 + term2) % bigM);
    });

    // Calculate StartRoot % M for each modulus
    // Root approx = a^(b/2)
    const R_shadows = SHADOW_MODS.map(m => {
        const bigM = BigInt(m);
        const halfExp = bigB / 2n;
        let rootBase = powMod(bigA, halfExp, bigM);
        // Correction for odd exponent: a^(b/2) * sqrt(a)
        if(bigB % 2n === 1n) {
            const sqA = Number(isqrt(bigA % bigM)); // Approx correction
            rootBase = (rootBase * BigInt(sqA)) % bigM;
        }
        return Number(rootBase);
    });

    // 2. The Slide Loop (Addition Only)
    // We track 'k' (offset from root).
    // Current Index Shadow = (R_shadow + k) % M
    
    let k = 0n;
    let currentK = K;

    // Report status
    self.postMessage({type:'status', msg:'Shadow Slide: k='+currentK, idx, mID});

    while (currentK < LIMIT) {
        // We check if (Root + k)^2 - N is a square mod M
        let allPass = true;

        for(let i=0; i<SHADOW_MODS.length; i++) {
            const M = SHADOW_MODS[i];
            
            // Current Index on this clock
            // We can just add 1 to the previous index shadow, but for simplicity here we recalc small mod
            // Optimization: Maintain running counters for each mod
            let idxMod = (R_shadows[i] + Number(currentK % BigInt(M))) % M;
            
            // Calculate Remainder Shadow: (Index^2 - N) % M
            let remShadow = (idxMod * idxMod) - N_shadows[i];
            if(remShadow < 0) remShadow += M;

            // CHECK: Is this remainder a quadratic residue?
            // For 4096 use lookup, for others use simple check or Legendre
            if(M === 4096) {
                if(QR_4096[remShadow] !== 1) { allPass = false; break; }
            } else {
                // Simple square check for small mods
                let isSq = false;
                for(let s=0; s<M; s++) { if((s*s)%M === remShadow) { isSq=true; break; } }
                if(!isSq) { allPass = false; break; }
            }
        }

        if (allPass) {
            // THE FINGERPRINT MATCHED!
            // Only now do we reconstruct the giant numbers to verify.
            self.postMessage({type:'candidate', k: currentK.toString(), idx, mID});
        }

        currentK++;
        if(currentK % 500000n === 0n) {
            self.postMessage({type:'status', msg: getSpin() + ' Sliding k='+currentK, idx, mID});
        }
    }
    
    self.postMessage({type:'fermatDone', idx, mID});
}

function runGigantic(data){
    self.postMessage({type:'status', msg:'Giga Scan...', idx: data.idx, mID: data.mID});
    const a=BigInt(data.a), b=BigInt(data.b), c=BigInt(data.c); 
    let p=BigInt(data.start), end=BigInt(data.end);
    
    while(p<=end){ 
        // Shadow Check for small factors
        const mod=(powMod(a,b,p)+(c%p)+p)%p; 
        if(mod===0n) self.postMessage({type:'factor', val:p.toString(), algo:'GigaSniper', idx: data.idx, mID: data.mID});
        p+=2n; 
    }
    self.postMessage({type:'gigaDone', idx: data.idx, mID: data.mID});
}

self.onmessage = e => {
    if(e.data.mode === 'fermatShadow') runFermatShadow(e.data);
    else if(e.data.mode === 'gigantic') runGigantic(e.data);
};
`;

const workerBlob = new Blob([factorWorkerCode], {type:'application/javascript'});
const workerUrl = URL.createObjectURL(workerBlob);

/* ==================== MAIN LOGIC ==================== */
function initGrid(){
    const g=document.getElementById('worker-grid'); g.innerHTML='';
    for(let i=0;i<NUM_WORKERS;i++){
        const d=document.createElement('div'); d.id=`card-${i}`; d.className='worker-card bg-slate-700';
        d.innerHTML=`Unit ${i}<br><span id="status-${i}" class="opacity-75 font-normal">Idle</span>`;
        g.appendChild(d);
    }
}

function deploySquad(){
    workers.forEach(w=>w&&w.terminate()); workers=Array(NUM_WORKERS).fill(null);
    currentMissionID++; 
    isRunning = true;
    
    // Reset Front lines
    globalGigaFrontier = 3n; // Start checking small factors at 3
    globalFermatFrontier = 0n; // Start sliding k at 0

    const a=document.getElementById('base-input').value;
    const b=document.getElementById('exponent-input').value;
    const c=document.getElementById('addend-input').value;

    document.getElementById('start-btn').disabled=true; 
    document.getElementById('stop-btn').disabled=false;
    log(`Deploying Squad on Target: ${a}^${b} + ${c}`);

    for(let i=0; i<NUM_WORKERS; i++){
        const w = new Worker(workerUrl);
        workers[i] = w;
        w.onmessage = handleMsg;
        
        const card = document.getElementById(`card-${i}`);
        card.classList.remove('bg-offline');
        
        // Split Squad: Half Giga Snipers (Small Factors), Half Fermat Marines (Shadow Slide)
        if(i < NUM_WORKERS/2) {
            // GIGA SNIPERS
            card.className = 'worker-card bg-giga';
            card.innerHTML = `Giga Sniper ${i}<br><span id="status-${i}">Deploying</span>`;
            dispatchGiga(w, i, a, b, c, currentMissionID);
        } else {
            // FERMAT MARINES
            card.className = 'worker-card bg-fermat';
            card.innerHTML = `Fermat Marine ${i}<br><span id="status-${i}">Deploying</span>`;
            dispatchFermat(w, i, a, b, c, currentMissionID);
        }
    }
}

function dispatchGiga(w, idx, a, b, c, mID) {
    if(!isRunning) return;
    const start = globalGigaFrontier;
    const end = start + GIGA_CHUNK_SIZE;
    globalGigaFrontier = end;
    w.postMessage({ mode:'gigantic', a, b, c, start:start.toString(), end:end.toString(), idx, mID });
}

function dispatchFermat(w, idx, a, b, c, mID) {
    if(!isRunning) return;
    const startK = globalFermatFrontier;
    globalFermatFrontier += BigInt(FERMAT_CHUNK_SIZE);
    w.postMessage({ mode:'fermatShadow', a, b, c, startK:startK.toString(), chunkSize:FERMAT_CHUNK_SIZE.toString(), idx, mID });
}

function handleMsg(e) {
    const d = e.data;
    if(d.type === 'status') {
        const el = document.getElementById(`status-${d.idx}`);
        if(el) el.textContent = d.msg;
    } 
    else if(d.type === 'factor') {
        log(`FACTOR FOUND: ${d.val} (${d.algo})`);
    }
    else if(d.type === 'candidate') {
        log(`POSSIBLE SQUARE AT k=${d.k}. Verify locally!`);
    }
    else if(d.type === 'gigaDone') {
        if(isRunning) dispatchGiga(workers[d.idx], d.idx, document.getElementById('base-input').value, document.getElementById('exponent-input').value, document.getElementById('addend-input').value, d.mID);
    }
    else if(d.type === 'fermatDone') {
        if(isRunning) dispatchFermat(workers[d.idx], d.idx, document.getElementById('base-input').value, document.getElementById('exponent-input').value, document.getElementById('addend-input').value, d.mID);
    }
}

document.getElementById('start-btn').onclick = deploySquad;
document.getElementById('stop-btn').onclick = () => { 
    isRunning=false; workers.forEach(w=>w&&w.terminate()); 
    log("Squad Aborted.");
};

initGrid();
</script>
</body>
</html>

