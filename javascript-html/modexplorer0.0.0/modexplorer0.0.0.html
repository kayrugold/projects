<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Modular Number Explorer</title>
    <script src="https://unpkg.com/big-integer@1.6.48/BigInteger.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background-color: #1a1a1a;
            color: #f0f0f0;
            touch-action: none; /* Prevents browser gestures like pinch-zoom */
        }
        canvas {
            display: block;
            background-color: #2c2c2c;
            cursor: grab;
        }
        #infoPanel {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(40, 40, 40, 0.85);
            backdrop-filter: blur(10px);
            border: 1px solid #555;
            padding: 15px;
            border-radius: 12px;
            width: 280px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            display: none; /* Hidden by default */
        }
        #infoPanel h3 {
            margin-top: 0;
            color: #00aaff;
        }
        #numberInfo {
            font-size: 14px;
            line-height: 1.6;
        }
        #numberInfo .label {
            font-weight: bold;
            color: #ccc;
        }
        #numberInfo .value {
            color: #f0f0f0;
            word-wrap: break-word;
        }
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            display: flex;
            gap: 10px;
        }
        button {
            padding: 10px 15px;
            font-size: 14px;
            background-color: #007acc;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color: 0.2s;
        }
        button:hover {
            background-color: #005f99;
        }
        /* Custom Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none; /* Initially hidden */
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        .modal-content {
            background: #2c2c2c;
            padding: 20px 25px;
            border-radius: 10px;
            border: 1px solid #555;
            box-shadow: 0 5px 20px rgba(0,0,0,0.5);
            width: 300px;
        }
        .modal-content h3 {
            margin-top: 0;
        }
        .modal-content input {
            width: 95%;
            padding: 10px;
            margin-top: 10px;
            border-radius: 5px;
            border: 1px solid #555;
            background: #1e1e1e;
            color: #f0f0f0;
            font-size: 16px;
        }
        .modal-buttons {
            margin-top: 20px;
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }
    </style>
</head>
<body>

<canvas id="mainCanvas"></canvas>
<div id="controls">
    <button id="addClockBtn">Add Clock (mod 12)</button>
</div>
<div id="infoPanel">
    <h3>Number Analysis</h3>
    <div id="numberInfo">
        <!-- Content will be generated by JavaScript -->
    </div>
</div>

<!-- Custom Modal for Editing Clocks -->
<div id="editModal" class="modal-overlay">
    <div class="modal-content">
        <h3 id="modalTitle">Edit Clock Modulus</h3>
        <p>Enter a new modulus value (must be > 1).</p>
        <input type="text" id="modalInput" inputmode="decimal">
        <div class="modal-buttons">
            <button id="modalCancel">Cancel</button>
            <button id="modalOk">OK</button>
        </div>
    </div>
</div>

<!-- Confirmation Modal -->
<div id="confirmModal" class="modal-overlay">
    <div class="modal-content">
        <h3 id="confirmTitle">Warning</h3>
        <p id="confirmMessage">Are you sure?</p>
        <div class="modal-buttons">
            <button id="confirmCancel">Cancel</button>
            <button id="confirmOk">OK</button>
        </div>
    </div>
</div>


<script>
// --- SETUP ---
const canvas = document.getElementById('mainCanvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// --- DOM ELEMENTS ---
const addClockBtn = document.getElementById('addClockBtn');
const infoPanel = document.getElementById('infoPanel');
const numberInfoDiv = document.getElementById('numberInfo');
const editModal = document.getElementById('editModal');
const modalInput = document.getElementById('modalInput');
const modalOkBtn = document.getElementById('modalOk');
const modalCancelBtn = document.getElementById('modalCancel');
const confirmModal = document.getElementById('confirmModal');
const confirmMessage = document.getElementById('confirmMessage');
const confirmOkBtn = document.getElementById('confirmOk');
const confirmCancelBtn = document.getElementById('confirmCancel');


// --- STATE ---
let objects = []; // Will hold all our clocks, shapes, etc.
let selectedObject = null;
let editingObject = null; // Object being edited in the modal
let activeTool = null; // Can be 'pan', 'drag', 'resize', 'panNumberLine', or 'numberLineInteraction'
let lastPos = { x: 0, y: 0 };
let startPos = { x: 0, y: 0 }; // To detect drag vs click
let potentialClickTarget = null; // To hold info for a potential click action
let onConfirmCallback = null;
let onCancelCallback = null;


let transform = {
    scale: 1,
    offsetX: 0,
    offsetY: 0
};
let initialResizeInfo = { scale: 1, startX: 0, startY: 0 }; // For smoother resizing

// --- HELPER FUNCTIONS ---
const LOG_SCALE_THRESHOLD = bigInt(100000);

function isPotentiallyHuge(str) {
    const eIndex = str.toLowerCase().indexOf('e');
    if (eIndex !== -1) {
        const exponentStr = str.slice(eIndex + 1);
        const exponent = parseInt(exponentStr, 10);
        // Set the threshold for the warning at an exponent of 1 million
        if (!isNaN(exponent) && exponent >= 1000000) {
            return true;
        }
    }
    return false;
}

function parseScientificNotation(str) {
    str = str.toLowerCase().trim().replace(/\s/g, '');
    const eIndex = str.indexOf('e');
    if (eIndex === -1) {
        return bigInt(str); // Not scientific notation
    }

    const baseStr = str.slice(0, eIndex);
    const exponentStr = str.slice(eIndex + 1);
    
    // bigInt doesn't handle decimal bases, so we have to be careful
    const base = parseFloat(baseStr); 
    const exponent = parseInt(exponentStr, 10);

    if (isNaN(base) || isNaN(exponent)) {
        throw new Error("Invalid scientific notation");
    }

    // This creates the number 1 followed by 'exponent' zeros.
    return bigInt(10).pow(exponent).multiply(base);
}

function getNiceTickStep(modBigInt) {
    if (modBigInt.lesserOrEquals(LOG_SCALE_THRESHOLD)) {
        const mod = modBigInt.toJSNumber();
        if (mod <= 24) {
            if (mod % 6 === 0) return bigInt(6);
            if (mod % 4 === 0) return bigInt(4);
            if (mod % 3 === 0) return bigInt(3);
            if (mod % 5 === 0) return bigInt(5);
            return bigInt(1);
        }
        const targetLabelCount = bigInt(12);
        const roughStep = modBigInt.divide(targetLabelCount);
        const roughStepStr = roughStep.toString();
        const magnitude = bigInt(10).pow(roughStepStr.length - 1);
        if (roughStep.divide(magnitude).greaterOrEquals(5)) return magnitude.multiply(5);
        if (roughStep.divide(magnitude).greaterOrEquals(2)) return magnitude.multiply(2);
        return magnitude;
    } else {
        // For log scale, the "nice" step is always powers of 10
        return bigInt(10);
    }
}

function formatNumber(n) { // n can be bigInt or number
    const nStr = n.toString();
    if (nStr.length > 7) {
        return parseFloat(nStr).toExponential(1);
    }
    return nStr;
}

// --- WEB WORKER SETUP (as an inline Blob) ---
const workerScript = `
    function isPrime(n) { // n is a string here
        const num = BigInt(n);
        if (num <= 1n) return false;
        if (num <= 3n) return true;
        if (num % 2n === 0n || num % 3n === 0n) return false;
        for (let i = 5n; i * i <= num; i = i + 6n) {
            if (num % i === 0n || num % (i + 2n) === 0n) return false;
        }
        return true;
    }
    function getDigitalRoot(nStr) {
        if (nStr.length > 20) return 'Too large'; // Prevent hanging on huge numbers
        let root = 0;
        nStr.split('').forEach(digit => { root += parseInt(digit); });
        return (root - 1) % 9 + 1;
    }
    self.onmessage = function(e) {
        const numberStr = e.data.number.toString();
        const results = {
            number: numberStr,
            isPrime: isPrime(numberStr),
            digitalRoot: getDigitalRoot(numberStr),
            isOdd: numberStr.slice(-1) % 2 !== 0,
        };
        self.postMessage(results);
    };
`;
const blob = new Blob([workerScript], { type: 'application/javascript' });
const numberWorker = new Worker(URL.createObjectURL(blob));

// --- CLASSES ---
class ModularClock {
    constructor(x, y, radius, mod) {
        this.x = x;
        this.y = y;
        this.baseRadius = radius;
        this.scale = 1.0;
        this.mod = bigInt.zero; // Will be set properly in setMod
        this.type = 'clock';
        this.numberLineOffset = 0;
        this.baseTickSpacing = 40;
        this.numberLineZoom = 1.0; // Separate zoom for the number line
        this.handleSize = 15; // Screen pixels for the handle
        this.isBeyondBigInt = false;
        this.logMod = 0;
        this.setMod(mod);
    }
    
    setMod(input) {
        const inputStr = String(input).trim();
        try {
            const newMod = parseScientificNotation(inputStr);
            if (newMod.lesserOrEquals(1)) {
                console.error("Modulus must be > 1");
                return;
            }
            this.mod = newMod;
            this.isBeyondBigInt = false;
            if (this.mod.greater(LOG_SCALE_THRESHOLD)) {
                this.logMod = this.mod.toString().length - 1;
            } else {
                this.logMod = 0;
            }
        } catch (err) {
            if (err instanceof RangeError || (err.message && err.message.includes("Maximum BigInt size exceeded"))) {
                console.log("Handling as a beyond-BigInt number.");
                this.isBeyondBigInt = true;
                try {
                    const eIndex = inputStr.toLowerCase().indexOf('e');
                    const exponentStr = inputStr.slice(eIndex + 1);
                    this.logMod = parseInt(exponentStr, 10);
                    // We still need a placeholder this.mod for comparisons like lesserOrEquals
                    // Let's set it to be just over the threshold so it acts like a log-scale number
                    this.mod = LOG_SCALE_THRESHOLD.plus(1);
                } catch (parseErr) {
                     console.error("Could not parse exponent from huge number string:", inputStr);
                }
            } else {
                console.error("Invalid BigInt input:", inputStr, err);
            }
        }
    }

    getRadius() {
        return this.baseRadius * this.scale;
    }

    getNumberLineWidth() {
        return this.getRadius() * 4;
    }

    getTickSpacing() {
        return this.baseTickSpacing * this.scale * this.numberLineZoom;
    }

    getBoundingBox() {
        const boxPadding = 10;
        const radius = this.getRadius();
        const numberLineWidth = this.getNumberLineWidth();
        const lineY = this.y + radius + (50 * this.scale);
        const numberLineHeight = 80 * this.scale;

        const top = this.y - radius - boxPadding;
        const left = this.x - numberLineWidth / 2 - boxPadding;
        const right = this.x + numberLineWidth / 2 + boxPadding;
        const bottom = lineY + numberLineHeight / 2;
        
        return {
            x: left,
            y: top,
            width: right - left,
            height: bottom - top
        };
    }

    draw(ctx, transform, isSelected) {
        ctx.save();
        
        const radius = this.getRadius();

        // --- Draw Clock ---
        ctx.strokeStyle = '#00aaff';
        ctx.fillStyle = '#1e1e1e';
        ctx.lineWidth = 3;
        
        ctx.beginPath();
        ctx.arc(this.x, this.y, radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();

        // --- Adaptive Clock Face Drawing ---
        ctx.fillStyle = '#f0f0f0';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        if (this.isBeyondBigInt || this.mod.greater(LOG_SCALE_THRESHOLD)) {
            this.drawLogScale(ctx, radius);
        } else {
            this.drawLinearScale(ctx, radius);
        }
        
        ctx.strokeStyle = '#00aaff';

        // --- Draw Number Line ---
        const numberLineWidth = this.getNumberLineWidth();
        const lineY = this.y + radius + (50 * this.scale);
        const lineStartX = this.x - numberLineWidth / 2;
        const tickSpacing = this.getTickSpacing();
        const tickSize = 10 * this.scale;

        ctx.strokeStyle = '#ccc';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(lineStartX, lineY);
        ctx.lineTo(lineStartX + numberLineWidth, lineY);
        ctx.stroke();
        
        const nlineFontSize = 14 * this.scale * this.numberLineZoom;
        const scaledNumberYOffset = 25 * this.scale;
        const scaledRemainderYOffset = 20 * this.scale;
        ctx.font = `${nlineFontSize}px Arial`;

        const firstVisibleNumber = Math.floor(this.numberLineOffset / tickSpacing);
        const firstTickX = lineStartX - (this.numberLineOffset % tickSpacing);
        const numTicksToDraw = Math.ceil(numberLineWidth / tickSpacing) + 2;

        for (let i = 0; i < numTicksToDraw; i++) {
            const currentNumberValue = firstVisibleNumber + i;
            const xPos = firstTickX + (i * tickSpacing);

            ctx.fillStyle = '#f0f0f0';
            ctx.fillText(currentNumberValue, xPos, lineY + scaledNumberYOffset);
            
            let remainder;
            if (this.isBeyondBigInt) {
                remainder = bigInt(currentNumberValue);
            } else {
                remainder = bigInt(currentNumberValue).mod(this.mod);
            }
            ctx.fillStyle = '#f0ad4e';
            ctx.fillText(remainder.toString(), xPos, lineY - scaledRemainderYOffset);

            ctx.beginPath();
            ctx.moveTo(xPos, lineY - tickSize / 2);
            ctx.lineTo(xPos, lineY + tickSize / 2);
            ctx.stroke();
        }
        
        if (isSelected) {
            const bbox = this.getBoundingBox();
            ctx.strokeStyle = 'lime';
            ctx.lineWidth = 2 / transform.scale;
            ctx.setLineDash([5 / transform.scale, 5 / transform.scale]);
            ctx.strokeRect(bbox.x, bbox.y, bbox.width, bbox.height);
            ctx.setLineDash([]);

            // Draw Resize Handle
            const handlePos = this.getResizeHandlePosition();
            const handleScreenSize = this.handleSize / transform.scale;
            ctx.fillStyle = 'lime';
            ctx.fillRect(handlePos.x - handleScreenSize / 2, handlePos.y - handleScreenSize / 2, handleScreenSize, handleScreenSize);

            // Draw Close Button
            const closePos = this.getCloseButtonPosition();
            const closeBtnScreenSize = (this.handleSize * 1.2) / transform.scale;
            ctx.fillStyle = '#d9534f';
            ctx.beginPath();
            ctx.arc(closePos.x, closePos.y, closeBtnScreenSize / 2, 0, Math.PI * 2);
            ctx.fill();

            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2 / transform.scale;
            ctx.beginPath();
            const crossOffset = closeBtnScreenSize * 0.25;
            ctx.moveTo(closePos.x - crossOffset, closePos.y - crossOffset);
            ctx.lineTo(closePos.x + crossOffset, closePos.y + crossOffset);
            ctx.moveTo(closePos.x + crossOffset, closePos.y - crossOffset);
            ctx.lineTo(closePos.x - crossOffset, closePos.y + crossOffset);
            ctx.stroke();
        }

        ctx.restore();
    }

    drawLinearScale(ctx, radius) {
        const labelStep = getNiceTickStep(this.mod);
        const labelsOutside = this.mod.greater(20);
        const baseFontSize = Math.max(8, radius * 0.18);
        const fontSize = labelsOutside ? baseFontSize * 0.8 : baseFontSize;
        ctx.font = `${fontSize}px Arial`;
        
        const maxVisualTicks = 1000;
        let drawingStep = bigInt.one;
        if (this.mod.greater(maxVisualTicks)) {
            const calculatedStep = this.mod.divide(maxVisualTicks);
            drawingStep = bigInt.max(calculatedStep, bigInt.one);
        }

        for (let i = bigInt.zero; i.lesser(this.mod); i = i.add(drawingStep)) {
            const isMajorTick = i.mod(labelStep).isZero();
            const angle = (i.toJSNumber() / this.mod.toJSNumber()) * 2 * Math.PI - Math.PI / 2;
            
            const outerRadius = labelsOutside ? radius - 2 : radius * 0.8;
            const tickStartRadius = isMajorTick ? outerRadius - (10 * this.scale) : outerRadius - (5 * this.scale);
            
            this.drawTick(ctx, angle, tickStartRadius, radius, isMajorTick);

            if (isMajorTick) {
                const labelRadius = labelsOutside ? radius + (12 * this.scale) : radius * 0.8;
                const labelX = this.x + Math.cos(angle) * labelRadius;
                const labelY = this.y + Math.sin(angle) * labelRadius;
                ctx.fillText(formatNumber(i), labelX, labelY);
            }
        }
    }

    drawLogScale(ctx, radius) {
        const baseFontSize = Math.max(8, radius * 0.15);
        ctx.font = `${baseFontSize}px Arial`;
        
        const sampleLabelWidth = ctx.measureText("1e100000").width;
        const requiredArcLength = sampleLabelWidth * 1.5;
        const minAngleSeparation = requiredArcLength / (radius + 12 * this.scale);

        const anglePerLogUnit = (2 * Math.PI) / this.logMod;
        let logStep = 1;
        if (anglePerLogUnit < minAngleSeparation) {
            logStep = Math.max(1, Math.ceil(minAngleSeparation / anglePerLogUnit));
        }

        for (let p = 0; p <= this.logMod; p += logStep) {
            const angle = (p / this.logMod) * 2 * Math.PI - Math.PI / 2;
            
            this.drawTick(ctx, angle, radius - (10 * this.scale), radius, true);

            const labelRadius = radius + (12 * this.scale);
            const labelX = this.x + Math.cos(angle) * labelRadius;
            const labelY = this.y + Math.sin(angle) * labelRadius;
            ctx.fillText(`1e${p}`, labelX, labelY);
        }
    }

    drawTick(ctx, angle, startRadius, endRadius, isMajor) {
        const tickStartX = this.x + Math.cos(angle) * startRadius;
        const tickStartY = this.y + Math.sin(angle) * startRadius;
        const tickEndX = this.x + Math.cos(angle) * endRadius;
        const tickEndY = this.y + Math.sin(angle) * endRadius;

        ctx.beginPath();
        ctx.moveTo(tickStartX, tickStartY);
        ctx.lineTo(tickEndX, tickEndY);
        ctx.strokeStyle = isMajor ? '#fff' : '#888';
        ctx.lineWidth = isMajor ? 2 : 1;
        ctx.stroke();
    }


    isHit(x, y) {
        const radius = this.getRadius();
        const dx = x - this.x;
        const dy = y - this.y;
        return dx * dx + dy * dy < radius * radius;
    }
    
    getTickValueAt(x, y) {
        const radius = this.getRadius();
        const isInLogMode = this.isBeyondBigInt || this.mod.greater(LOG_SCALE_THRESHOLD);
        if (!isInLogMode) return null;

        const baseFontSize = Math.max(8, radius * 0.15);
        const sampleLabelWidth = baseFontSize * 5; // Estimate label width
        const hitRadius = sampleLabelWidth / 2;

        const logMod = this.logMod;
        const anglePerLogUnit = (2 * Math.PI) / logMod;
        const requiredArcLength = sampleLabelWidth * 1.5;
        const minAngleSeparation = requiredArcLength / (radius + 12 * this.scale);
        
        let logStep = 1;
        if (anglePerLogUnit < minAngleSeparation) {
            logStep = Math.max(1, Math.ceil(minAngleSeparation / anglePerLogUnit));
        }

        for (let p = 0; p <= logMod; p += logStep) {
            const angle = (p / logMod) * 2 * Math.PI - Math.PI / 2;
            const labelRadius = radius + (12 * this.scale);
            const labelX = this.x + Math.cos(angle) * labelRadius;
            const labelY = this.y + Math.sin(angle) * labelRadius;

            const dx = x - labelX;
            const dy = y - labelY;
            if (dx * dx + dy * dy < hitRadius * hitRadius) {
                return `1e${p}`;
            }
        }
        return null;
    }

    isHittingNumberLine(x, y) {
        const radius = this.getRadius();
        const numberLineWidth = this.getNumberLineWidth();
        const lineY = this.y + radius + (50 * this.scale);
        const startX = this.x - numberLineWidth / 2;
        const hitBoxHeight = 60 * this.scale;
        return (
            x >= startX &&
            x <= startX + numberLineWidth &&
            y >= lineY - hitBoxHeight / 2 &&
            y <= lineY + hitBoxHeight / 2
        );
    }

    getNumberAt(x, y) {
        if (!this.isHittingNumberLine(x, y)) return null;
        
        const lineStartX = this.x - this.getNumberLineWidth() / 2;
        const tickSpacing = this.getTickSpacing();

        const firstVisibleNumber = Math.floor(this.numberLineOffset / tickSpacing);
        const firstTickX = lineStartX - (this.numberLineOffset % tickSpacing);
        
        const relativeX = x - firstTickX;
        const index = Math.round(relativeX / tickSpacing);
        
        return firstVisibleNumber + index;
    }

    getResizeHandlePosition() {
        const bbox = this.getBoundingBox();
        return {
            x: bbox.x + bbox.width,
            y: bbox.y + bbox.height
        };
    }

    isHittingResizeHandle(x, y, scale) {
        const handlePos = this.getResizeHandlePosition();
        const handleScreenSize = this.handleSize / scale;
        const dx = x - handlePos.x;
        const dy = y - handlePos.y;
        return dx * dx + dy * dy < (handleScreenSize * 1.5) * (handleScreenSize * 1.5);
    }
    
    getCloseButtonPosition() {
        const bbox = this.getBoundingBox();
        return {
            x: bbox.x + bbox.width,
            y: bbox.y
        };
    }

    isHittingCloseButton(x, y, scale) {
        const closePos = this.getCloseButtonPosition();
        const handleScreenSize = (this.handleSize * 1.2) / scale;
        const dx = x - closePos.x;
        const dy = y - closePos.y;
        return dx * dx + dy * dy < (handleScreenSize * 0.75) * (handleScreenSize * 0.75); // Slightly smaller hit area than the visual circle
    }

}

// --- CORE LOGIC ---
function addObject(obj) {
    objects.push(obj);
}

function draw() {
    requestAnimationFrame(() => {
        ctx.save();
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.translate(transform.offsetX, transform.offsetY);
        ctx.scale(transform.scale, transform.scale);
        objects.forEach(obj => {
            obj.draw(ctx, transform, obj === selectedObject);
        });
        ctx.restore();
    });
}

function getPos(evt) {
    const rect = canvas.getBoundingClientRect();
    const clientX = evt.touches ? evt.touches[0].clientX : evt.clientX;
    const clientY = evt.touches ? evt.touches[0].clientY : evt.clientY;
    return {
        x: (clientX - rect.left - transform.offsetX) / transform.scale,
        y: (clientY - rect.top - transform.offsetY) / transform.scale
    };
}


// --- EVENT LISTENERS ---
addClockBtn.addEventListener('click', () => {
    const worldX = (canvas.width / 2 - transform.offsetX) / transform.scale;
    const worldY = (canvas.height / 2 - transform.offsetY) / transform.scale;
    addObject(new ModularClock(worldX, worldY, 100, 12));
});

function startInteraction(e) {
    const currentPos = { x: e.touches ? e.touches[0].clientX : e.clientX, y: e.touches ? e.touches[0].clientY : e.clientY };
    lastPos = currentPos;
    startPos = currentPos;
    const worldPos = getPos(e);
    
    activeTool = null;
    potentialClickTarget = null;
    
    // --- New: Check for close button click first ---
    if (selectedObject && selectedObject.isHittingCloseButton(worldPos.x, worldPos.y, transform.scale)) {
        objects = objects.filter(obj => obj !== selectedObject);
        selectedObject = null;
        return; // End interaction immediately
    }

    if (selectedObject && selectedObject.isHittingResizeHandle(worldPos.x, worldPos.y, transform.scale)) {
        activeTool = 'resize';
        initialResizeInfo.scale = selectedObject.scale;
        initialResizeInfo.startX = lastPos.x;
        initialResizeInfo.startY = lastPos.y;
        return;
    }
    
    let hitObject = null;
    let numberLineHit = null;
    let logTickHitValue = null;

    for (let i = objects.length - 1; i >= 0; i--) {
        const obj = objects[i];
        if (obj.isHit(worldPos.x, worldPos.y)) {
            hitObject = obj;
            break;
        }
        if (obj.getTickValueAt) {
            logTickHitValue = obj.getTickValueAt(worldPos.x, worldPos.y);
            if (logTickHitValue) {
                hitObject = obj; // Treat this as hitting the object
                break;
            }
        }
        if (obj.isHittingNumberLine && obj.isHittingNumberLine(worldPos.x, worldPos.y)) {
            numberLineHit = obj;
            break;
        }
    }

    if (logTickHitValue) {
        selectedObject = hitObject;
        activeTool = 'clockInteraction';
        potentialClickTarget = { type: 'logTick', value: logTickHitValue, from: hitObject };
    } else if (hitObject) {
        selectedObject = hitObject;
        activeTool = 'drag';
    } else if (numberLineHit) {
        selectedObject = numberLineHit;
        activeTool = 'numberLineInteraction'; // Tentative: could be a click or a pan
        const num = numberLineHit.getNumberAt(worldPos.x, worldPos.y);
        if (num !== null) {
            potentialClickTarget = { type: 'numberLine', object: numberLineHit, number: num };
        }
    } else {
        selectedObject = null;
        activeTool = 'pan';
    }
}

canvas.addEventListener('mousedown', startInteraction);
canvas.addEventListener('touchstart', startInteraction);


canvas.addEventListener('dblclick', (e) => {
    const worldPos = getPos(e);
    let hitObject = null;
    for (const obj of objects) {
        if (obj.isHit(worldPos.x, worldPos.y)) {
            hitObject = obj;
            break;
        }
    }

    if (hitObject && hitObject.type === 'clock') {
        editingObject = hitObject;
        modalInput.value = hitObject.isBeyondBigInt ? `1e${hitObject.logMod}` : hitObject.mod.toString();
        editModal.style.display = 'flex';
        modalInput.focus();
        modalInput.select();
    }
});

function moveInteraction(e) {
    if (activeTool === null) {
        const worldPos = getPos(e);
        let cursorSet = false;
        
        if(selectedObject && selectedObject.isHittingCloseButton(worldPos.x, worldPos.y, transform.scale)) {
            canvas.style.cursor = 'pointer';
            cursorSet = true;
        }
        if (!cursorSet && selectedObject && selectedObject.isHittingResizeHandle(worldPos.x, worldPos.y, transform.scale)) {
            canvas.style.cursor = 'nwse-resize';
            cursorSet = true;
        }
        if (!cursorSet) {
             for (const obj of objects) {
                if (obj.isHittingNumberLine && obj.isHittingNumberLine(worldPos.x, worldPos.y)) {
                    canvas.style.cursor = 'ew-resize';
                    cursorSet = true;
                    break;
                }
            }
        }
        if (!cursorSet) canvas.style.cursor = 'grab';
        return;
    }

    const currentPos = { x: e.touches ? e.touches[0].clientX : e.clientX, y: e.touches ? e.touches[0].clientY : e.clientY };
    const dx = currentPos.x - lastPos.x;
    const dy = currentPos.y - lastPos.y;
    
    const distMoved = Math.hypot(currentPos.x - startPos.x, currentPos.y - startPos.y);
    if (distMoved > 5) { // Drag threshold of 5 pixels
         if (activeTool === 'numberLineInteraction') {
            activeTool = 'panNumberLine';
            potentialClickTarget = null;
         } else if (activeTool === 'clockInteraction') {
            activeTool = 'drag';
            potentialClickTarget = null;
         }
    }

    lastPos = currentPos;


    switch (activeTool) {
        case 'drag':
            canvas.style.cursor = 'move';
            if (selectedObject) {
                selectedObject.x += dx / transform.scale;
                selectedObject.y += dy / transform.scale;
            }
            break;
        case 'pan':
            canvas.style.cursor = 'grabbing';
            transform.offsetX += dx;
            transform.offsetY += dy;
            break;
        case 'panNumberLine':
            canvas.style.cursor = 'ew-resize';
            if (selectedObject) {
                selectedObject.numberLineOffset -= dx / transform.scale;
            }
            break;
        case 'resize':
            canvas.style.cursor = 'nwse-resize';
            if (selectedObject) {
                const totalDx = currentPos.x - initialResizeInfo.startX;
                const totalDy = currentPos.y - initialResizeInfo.startY;
                const change = (totalDx + totalDy);
                
                const sensitivity = 0.005; 
                const newScale = initialResizeInfo.scale + (change * sensitivity);
                
                selectedObject.scale = Math.max(0.3, newScale);
            }
            break;
    }
}

canvas.addEventListener('mousemove', moveInteraction);
canvas.addEventListener('touchmove', moveInteraction);


function endInteraction() {
    if (potentialClickTarget) {
        if (potentialClickTarget.type === 'numberLine') {
            numberWorker.postMessage({ number: potentialClickTarget.number });
            infoPanel.style.display = 'block';
        } else if (potentialClickTarget.type === 'logTick') {
            const newModStr = potentialClickTarget.value;
            // This is the new safe-guard logic
            try {
                const newModValue = parseScientificNotation(newModStr);
                if (newModValue.lesserOrEquals(1)) {
                    console.warn("Ignoring click on log tick <= 1 to prevent invalid clock state.");
                } else {
                    const parentClock = potentialClickTarget.from;
                    const newClock = new ModularClock(parentClock.x + parentClock.getRadius() * 1.5, parentClock.y, 100, newModValue);
                    addObject(newClock);
                    selectedObject = newClock;
                }
            } catch (err) {
                console.error("Error parsing log tick value:", newModStr, err);
            }
        }
    }

    activeTool = null;
    potentialClickTarget = null;
    canvas.style.cursor = 'grab';
}

canvas.addEventListener('mouseup', endInteraction);
canvas.addEventListener('touchend', endInteraction);
canvas.addEventListener('mouseleave', endInteraction);


canvas.addEventListener('wheel', (e) => {
    e.preventDefault();
    const worldPos = getPos(e);

    let numberLineHit = null;
    for (const obj of objects) {
        if (obj.isHittingNumberLine && obj.isHittingNumberLine(worldPos.x, worldPos.y)) {
            numberLineHit = obj;
            break;
        }
    }
    
    const factor = Math.pow(1.001, -e.deltaY);

    if (numberLineHit) {
        numberLineHit.numberLineZoom *= factor;
        numberLineHit.numberLineZoom = Math.max(0.25, Math.min(4, numberLineHit.numberLineZoom));
    } else {
        const mouseX = e.clientX;
        const mouseY = e.clientY;
        transform.offsetX = mouseX - (mouseX - transform.offsetX) * factor;
        transform.offsetY = mouseY - (mouseY - transform.offsetY) * factor;
        transform.scale *= factor;
    }
});

window.addEventListener('resize', () => {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
});

numberWorker.onmessage = function(e) {
    const data = e.data;
    numberInfoDiv.innerHTML = `
        <p><span class="label">Number:</span> <span class="value">${data.number}</span></p>
        <p><span class="label">Is Prime:</span> <span class="value">${data.isPrime ? 'Yes' : 'No'}</span></p>
        <p><span class="label">Is Odd:</span> <span class="value">${data.isOdd ? 'Yes' : 'No'}</span></p>
        <p><span class="label">Digital Root:</span> <span class="value">${data.digitalRoot}</span></p>
    `;
};

// --- MODAL LOGIC ---
function showConfirmationModal(message, onConfirm, onCancel) {
    confirmMessage.textContent = message;
    onConfirmCallback = onConfirm;
    onCancelCallback = onCancel;
    confirmModal.style.display = 'flex';
}

function closeEditModal() {
    editModal.style.display = 'none';
    editingObject = null;
}

function closeConfirmModal() {
    confirmModal.style.display = 'none';
    onConfirmCallback = null;
    onCancelCallback = null;
}


function confirmEdit() {
    if (!editingObject) {
        return closeEditModal();
    }

    const inputStr = modalInput.value;
    const targetObject = editingObject; // Preserve the object reference
    
    if (isPotentiallyHuge(inputStr)) {
        closeEditModal(); // Close the edit modal first
        showConfirmationModal(
            "This is a very large number and may take a moment to process. Your browser might become unresponsive. You might have to press 'Wait' a few times. Continue?",
            () => { // onConfirm
                targetObject.setMod(inputStr); // Use the preserved reference
            }
        );
    } else {
        targetObject.setMod(inputStr);
        closeEditModal();
    }
}

modalOkBtn.addEventListener('click', confirmEdit);
modalCancelBtn.addEventListener('click', closeEditModal);
modalInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') confirmEdit();
    else if (e.key === 'Escape') closeEditModal();
});

confirmOkBtn.addEventListener('click', () => {
    if (onConfirmCallback) onConfirmCallback();
    closeConfirmModal();
});

confirmCancelBtn.addEventListener('click', () => {
    if (onCancelCallback) onCancelCallback();
    closeConfirmModal();
});


// --- INITIALIZATION ---
addObject(new ModularClock(canvas.width / 2, canvas.height / 2, 100, 12));
setInterval(draw, 1000 / 60); // 60 FPS redraw loop

</script>
</body>
</html>

