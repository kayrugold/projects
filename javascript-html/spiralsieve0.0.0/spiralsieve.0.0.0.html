<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Spiral Sieve v2.0: Harmonic Explorer</title>
    <!-- KaTeX for beautiful math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');
        :root {
            --bg-color: #05080a; --text-color: #00ff00; --input-bg: #222;
            --border-color: #004400; --button-bg: #008800; --button-hover: #00cc00;
            --factor-color: #ffff00; --modal-bg: #0a0a0a; --prime-color: #66ff66;
            --structure-line-color: rgba(75, 0, 130, 0.4); 
            --ghost-spiral-color: rgba(0, 255, 0, 0.15); 
        }
        html, body {
            font-family: 'VT323', monospace; background: var(--bg-color); color: var(--text-color);
            margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden;
        }
        .main-container {
            width: 100%; height: 100%; display: flex; flex-direction: column;
            padding: 10px; box-sizing: border-box;
        }
        .header-content { flex-shrink: 0; max-width: 1200px; width: 100%; margin: 0 auto; }
        h1, p { margin: 0 0 10px 0; }
        .katex { font-size: 1.1em; } /* Style for rendered math formula */
        canvas {
            background-color: var(--bg-color); display: block; touch-action: none; 
            width: 100%; flex-grow: 1; border-radius: 4px;
            border: 1px solid var(--border-color); margin-top: 10px;
            transition: opacity 0.3s ease-in-out;
        }
        .controls {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(130px, 1fr)); 
            gap: 8px; margin-bottom: 10px; align-items: end;
        }
        .controls-row { display: contents; }
        @media (min-width: 1200px) { .controls { grid-template-columns: repeat(6, 1fr); } }
        .controls label { display: block; font-size: 0.9em; margin-bottom: 2px; }
        .controls input, .controls button, .controls select, .controls .checkbox-container { height: 36px; box-sizing: border-box; }
        .controls input, .controls select {
            width: 100%; padding: 4px; background: var(--input-bg);
            border: 1px solid var(--border-color); color: var(--text-color);
            font-family: 'VT323', monospace; font-size: 1.1em;
        }
        .controls button {
            background: var(--button-bg); color: var(--bg-color); border: none; padding: 8px 10px;
            cursor: pointer; transition: background 0.2s, transform 0.1s; font-family: 'VT323', monospace;
            font-size: 1em; box-shadow: 0 0 5px var(--button-bg);
        }
        .controls button:hover { background: var(--button-hover); }
        .controls button:active { transform: scale(0.97); }
        .controls button:disabled { background: #555; cursor: not-allowed; opacity: 0.7; transform: none; }
        .checkbox-container { display: flex; align-items: center; justify-content: center; gap: 5px; font-size: 0.9em; white-space: nowrap;}
        
        .resonance-container {
            grid-column: 1 / -1; border: 1px solid var(--border-color);
            border-radius: 4px; padding: 8px; margin-top: 10px; display: none;
        }
        .resonance-container.active { display: block; }
        .resonance-header h3 { margin: 0; font-size: 1.2em; }
        .resonance-input-row { display: flex; gap: 8px; margin-bottom: 8px; }
        .resonance-input-row input { flex-grow: 1; }
        .resonance-list { font-size: 1em; display: flex; flex-direction: column; gap: 6px; }
        .resonance-item { display: flex; align-items: center; gap: 8px; }
        .resonance-item .color-swatch { width: 16px; height: 16px; border: 1px solid #555; flex-shrink: 0;}
        .resonance-item button { background: #aa0000; font-size: 0.8em; padding: 2px 6px; height: auto; }

        #info-box {
            position: fixed; bottom: 15px; right: 15px; background: rgba(0, 0, 0, 0.9);
            padding: 8px; border: 1px solid var(--text-color); z-index: 10;
            font-size: 0.9em; min-width: 160px; max-width: 50vw; border-radius: 4px;
        }
        .modal {
            display: none; position: fixed; z-index: 100; left: 0; top: 0; width: 100%; height: 100%;
            overflow: auto; background-color: rgba(0, 0, 0, 0.8); justify-content: center; align-items: center;
        }
        .modal-content {
            background-color: var(--modal-bg); color: var(--text-color); margin: 10% auto;
            padding: 20px; border: 2px solid var(--text-color); width: 90%; max-width: 600px;
            box-shadow: 0 0 15px var(--text-color);
        }
        .close-button { color: var(--text-color); float: right; font-size: 28px; font-weight: bold; cursor: pointer; }
        #tooltip {
            position: fixed; display: none; background: var(--factor-color); color: var(--bg-color);
            padding: 5px 10px; border-radius: 4px; font-size: 1.2em; pointer-events: none;
            z-index: 101; box-shadow: 0 0 10px var(--factor-color); opacity: 0; transition: opacity 0.2s;
        }
    </style>
</head>
<body>

<div class="main-container">
    <div class="header-content">
        <h1>Spiral Sieve v2.0</h1>
        <p>Explore factors of <span id="math-formula">N = a^b + c</span> by visualizing their harmonic signature on a logarithmic spiral.</p>
        <p style="font-size:0.9em;">Controls: Pan (Drag), Zoom (Scroll/Pinch), Identify (Tap), Keyboard (Arrows/+-)</p>
        <div class="controls">
            <div class="controls-row">
                <div><label for="baseA">Base (a)</label><input type="text" id="baseA" value="10"></div>
                <div><label for="expB">Exponent (b)</label><input type="text" id="expB" value="1000000000"></div>
                <div><label for="addC">Addend (c)</label><input type="text" id="addC" value="19"></div>
                <div><label for="maxPoints">Range to Test</label><input type="text" id="maxPoints" value="15000"></div>
                <div><label for="displayMode">Display Mode</label>
                    <select id="displayMode">
                        <option value="harmonic" selected>Harmonic Signature</option>
                        <option value="resonance">Resonance Sieve (CRT)</option>
                        <option value="distribution">Prime Distribution</option>
                    </select>
                </div>
                <button id="startButton">RUN</button>
            </div>
             <div class="controls-row">
                 <div></div> 
                 <div></div> 
                 <div class="checkbox-container"><input type="checkbox" id="show6kLinesToggle" checked><label for="show6kLinesToggle">Show 6k Lines</label></div>
                 <div class="checkbox-container"><input type="checkbox" id="showGhostToggle" checked><label for="showGhostToggle">Show Ghost Spiral</label></div>
                 <div class="checkbox-container" id="primeOnlyContainer"><input type="checkbox" id="primeOnlyToggle" checked><label for="primeOnlyToggle">Primes Only</label></div>
                <button id="helpButton">HELP [ ? ]</button>
            </div>
            <div id="resonanceContainer" class="resonance-container">
                <h3>Resonance Sieve (Chinese Remainder Theorem)</h3>
                <div class="resonance-input-row">
                    <input type="text" id="resonancePrimeInput" placeholder="Add prime filter (max 3)">
                    <button id="addResonanceBtn">Add Filter</button>
                </div>
                <div id="resonanceList" class="resonance-list"></div>
            </div>
        </div>
    </div>
    <canvas id="spiralCanvas"></canvas>
    <div id="info-box">
        <span class="info-header">STATUS:</span>
        <span id="info_target" class="info-line">N: 10^1000000000 + 19</span>
        <span id="info_status" class="info-line">Status: Idle</span>
        <span id="info_factors" class="info-line">Factors: 0</span>
        <span id="info_range" class="info-line">Range: 1 to 15000</span>
    </div>
    <div id="tooltip"></div>
</div>

<div id="helpModal" class="modal">
  <div class="modal-content">
    <span class="close-button">&times;</span>
    <h2>Interactive Guide (v2.0)</h2>
    <p>This program combines the best features of previous versions into a unified, powerful tool for exploring number theory.</p>
    <ul>
        <li><strong>Display Modes:</strong> Choose your visualization.
            <ul>
                <li><strong>Harmonic Signature:</strong> Colors points by their modular remainder, revealing deep structural patterns. A "hot" red color means the remainder is small (close to being a factor), while "cool" blue means it's large. Grey dots indicate numbers too large for precise remainder calculation in the browser, but the factor check still works.</li>
                <li><strong>Resonance Sieve (CRT):</strong> A tool for visualizing the Chinese Remainder Theorem. Add up to 3 prime filters (e.g., 3, 5, 7) to color the spiral. Points that are multiples of the first prime are Red, second are Green, third are Blue. Where they overlap, colors combine (Yellow, Cyan, Magenta, White), making it easy to spot numbers with specific divisibility properties.</li>
                <li><strong>Prime Distribution:</strong> A classic view showing the location of prime numbers in green.</li>
            </ul>
        </li>
         <li><strong>Interaction:</strong> Panning, zooming, and tapping to identify numbers are fully supported on touch and mouse devices. You can also use <strong>Arrow Keys</strong> to pan and <strong>+/- keys</strong> to zoom.</li>
    </ul>
  </div>
</div>

<script>
    // --- DOM ELEMENT SELECTION ---
    const canvas = document.getElementById('spiralCanvas');
    const ctx = canvas.getContext('2d', { alpha: false });
    const tooltip = document.getElementById('tooltip');
    const maxPointsInput = document.getElementById('maxPoints');
    const baseAInput = document.getElementById('baseA');
    const expBInput = document.getElementById('expB');
    const addCInput = document.getElementById('addC');
    const startButton = document.getElementById('startButton');
    const helpButton = document.getElementById('helpButton');
    const displayModeSelect = document.getElementById('displayMode');
    const primeOnlyToggle = document.getElementById('primeOnlyToggle');
    const primeOnlyContainer = document.getElementById('primeOnlyContainer');
    const show6kLinesToggle = document.getElementById('show6kLinesToggle');
    const showGhostToggle = document.getElementById('showGhostToggle');
    const resonanceContainer = document.getElementById('resonanceContainer');
    const resonancePrimeInput = document.getElementById('resonancePrimeInput');
    const addResonanceBtn = document.getElementById('addResonanceBtn');
    const resonanceList = document.getElementById('resonanceList');
    const helpModal = document.getElementById('helpModal');
    const closeButton = helpModal.querySelector(".close-button");

    // --- GLOBAL STATE ---
    let isRunning = false, maxPoints = 15000, targetN = null, spiralPoints = [], factors = new Set();
    let currentStartP = 1, isChunking = false;
    const MIN_SCALE_TO_SHIFT = 0.8, MAX_SCALE_TO_SHIFT = 15.0;
    
    let scale = 4.0, offsetX = 0, offsetY = 0;
    let isDragging = false, lastMouseX, lastMouseY, lastTouchDistance = null; 
    let tapStart = null; 
    let tooltipTimeout = null;
    let resonanceFilters = [];
    const RESONANCE_COLORS = ['#ff0000', '#00ff00', '#0000ff'];
    let COLORS = {}; // Object to store resolved CSS variable colors
    
    // --- WEB WORKER INITIALIZATION ---
    // The worker handles heavy calculations (sieving, modular exponentiation) off the main thread.
    const worker = new Worker(URL.createObjectURL(new Blob([`
        // Modular exponentiation: (b^e) mod m. Handles BigInts.
        function powMod(b,e,m){let r=1n;b%=m;while(e>0n){if((e&1n)===1n)r=(r*b)%m;e>>=1n;b=(b*b)%m}return r}
        
        // Sieve of Eratosthenes to find primes in a given range [min, max].
        function sieve(min, max) {
            const minNum=Number(min), maxNum=Number(max);
            // Sieve cannot handle unsafe integers directly, but the main logic can.
            if (minNum > Number.MAX_SAFE_INTEGER || maxNum > Number.MAX_SAFE_INTEGER) return [];
            const sqrtMax=Math.floor(Math.sqrt(maxNum)), smallPrimes=[], isSmallPrime=new Array(sqrtMax+1).fill(!0);
            isSmallPrime[0]=isSmallPrime[1]=!1;
            for(let i=2;i*i<=sqrtMax;i++)if(isSmallPrime[i])for(let j=i*i;j<=sqrtMax;j+=i)isSmallPrime[j]=!1;
            for(let i=2;i<=sqrtMax;i++)isSmallPrime[i]&&smallPrimes.push(i);
            const isPrimeInRange=new Array(maxNum-minNum+1).fill(!0);
            if(minNum===1&&isPrimeInRange.length>0) isPrimeInRange[0]=!1;
            for(const p of smallPrimes){let s=Math.max(p*p,Math.ceil(minNum/p)*p);for(let j=s;j<=maxNum;j+=p)j>=minNum&&(isPrimeInRange[j-minNum]=!1)}
            const primes=[];
            for(let i=0;i<isPrimeInRange.length;i++)if(isPrimeInRange[i]){const c=minNum+i;c>1&&primes.push(c)}
            return primes;
        }

        onmessage=function(ev){
            let{allPoints:p,targetN:t,primesOnly:po,rangeStart:rs,rangeEnd:re,resFilters:rf}=ev.data;
            const pointsToTest=po?sieve(rs,re):p;
            const a=BigInt(t.a),b=BigInt(t.b),c=BigInt(t.c),results=[],factorsFound=[];
            const filterPrimes = rf.map(filt => BigInt(filt.p));

            for(let num of new Set(pointsToTest)){
                if(1===num)continue;
                let testVal=BigInt(num);
                let remainder=(powMod(a,b,testVal)+(c%testVal+testVal)%testVal)%testVal;
                const isFactor = 0n===remainder;
                
                // For Harmonic mode, calculate remainder ratio if possible.
                let remRatio = -1; // Default for very large numbers
                if (testVal < Number.MAX_SAFE_INTEGER) {
                    remRatio = isFactor ? 0 : Number(remainder) / Number(testVal);
                }
                if(isFactor) factorsFound.push(num);
                
                // For Resonance Sieve mode, determine color channels.
                let resonanceColor = [0, 0, 0];
                if (rf.length > 0) {
                    filterPrimes.forEach((fp, i) => {
                        if (testVal % fp === 0n) resonanceColor[i] = 255;
                    });
                }
                results.push({p:num,isFactor,remainderRatio:remRatio,resonanceColor});
            }
            postMessage({results, factorsFound});
        };
    `], { type: 'application/javascript' })));
    
    worker.onmessage = e => {
        isChunking = false; // The chunking process is now complete.
        isRunning = false; 
        startButton.textContent = "RE-RUN";
        startButton.disabled = false;
        
        const pointMap = new Map();
        // Generate base geometric points first.
        spiralPoints = generatePointsBatch(e.data.results.map(r => r.p), currentStartP);
        spiralPoints.forEach(p => pointMap.set(p.p, p));

        // Augment points with calculation results from the worker.
        e.data.results.forEach(res => { 
            const pObj = pointMap.get(res.p);
            if (pObj) { Object.assign(pObj, res); }
        });
        
        e.data.factorsFound.forEach(f => factors.add(f));
        document.getElementById('info_factors').textContent = `Factors: ${factors.size} (${Array.from(factors).join(', ')})`;
        drawSpiral(); 
    };
    
    // --- GEOMETRY & DRAWING ---

    // Calculates the (x, y) coordinate for a number `n` on the logarithmic spiral.
    const getSpiralPoint = (n, startN) => {
        const num = n - startN;
        if (num < 0) return { x: 0, y: 0 };
        // These constants define the "tightness" and "growth" of the spiral.
        const angle = 0.2 * Math.sqrt(num) * Math.PI;
        const radius = 0.8 * Math.sqrt(num);
        return { x: radius * Math.cos(angle), y: radius * Math.sin(angle) };
    };

    // Creates an array of point objects with their geometric locations.
    const generatePointsBatch = (pointsArray, startP) => pointsArray.map((p) => ({ p, ...getSpiralPoint(p, startP), isFactor: false, remainderRatio: -1, resonanceColor: [0,0,0] }));

    // Gets the device pixel ratio for sharp rendering on HiDPI displays.
    function getDPR() { return window.devicePixelRatio || 1; }

    function drawGhostSpiral() {
        ctx.strokeStyle = COLORS.ghost;
        ctx.lineWidth = 1; // Always 1 backing pixel wide for faintness
        ctx.beginPath();
        const sampleRate = Math.max(1, Math.floor(maxPoints / 2000));
        let first = true;
        for (let i = 0; i < maxPoints; i += sampleRate) {
            const p = currentStartP + i;
            const { x, y } = getSpiralPoint(p, currentStartP);
            const px = x * scale + offsetX; const py = y * scale + offsetY;
            if (first) { ctx.moveTo(px, py); first = false; } else { ctx.lineTo(px, py); }
        }
        ctx.stroke();
    }

    function draw6kLines() {
        ctx.strokeStyle = COLORS.structure;
        ctx.lineWidth = 2; // Always 2 backing pixels
        ctx.setLineDash([5, 10]);
        const maxRadius = Math.max(canvas.width, canvas.height);
        // The lines correspond to where primes of the form 6kÂ±1 tend to appear on this specific spiral.
        for (let k = 1; k < 30; k++) {
             const n_plus_1 = 6 * k * k * 100 + 1, n_minus_1 = 6 * k * k * 100 - 1;
             const {x: x_plus, y: y_plus} = getSpiralPoint(n_plus_1, 1);
             const {x: x_minus, y: y_minus} = getSpiralPoint(n_minus_1, 1);
             const angle_plus = Math.atan2(y_plus, x_plus);
             const angle_minus = Math.atan2(y_minus, x_minus);

             ctx.beginPath(); ctx.moveTo(offsetX, offsetY); ctx.lineTo(offsetX + maxRadius * Math.cos(angle_plus), offsetY + maxRadius * Math.sin(angle_plus)); ctx.stroke();
             ctx.beginPath(); ctx.moveTo(offsetX, offsetY); ctx.lineTo(offsetX + maxRadius * Math.cos(angle_minus), offsetY + maxRadius * Math.sin(angle_minus)); ctx.stroke();
        }
        ctx.setLineDash([]);
    }

    // Main render loop
    function drawSpiral() {
        if (isChunking) return;
        ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset transform
        ctx.fillStyle = COLORS.bg;
        ctx.fillRect(0, 0, canvas.width, canvas.height); 

        // Draw structural guides first
        if (show6kLinesToggle.checked) draw6kLines();
        if (showGhostToggle.checked) drawGhostSpiral();
        
        const dotRadius = Math.max(0.5, Math.min(2.5, 0.7 * scale));
        const currentMode = displayModeSelect.value;
        
        // Main loop to draw each point based on the selected display mode
        for (const point of spiralPoints) {
            const px = point.x * scale + offsetX; const py = point.y * scale + offsetY;
            // Culling: Don't draw points that are off-screen
            if (px + dotRadius < 0 || px - dotRadius > canvas.width || py + dotRadius < 0 || py - dotRadius > canvas.height) continue;
            
            if (point.isFactor) {
                ctx.fillStyle = COLORS.factor;
            } else {
                 switch (currentMode) {
                    case 'resonance':
                        const [r, g, b] = point.resonanceColor;
                        if (r > 0 || g > 0 || b > 0) ctx.fillStyle = `rgb(${r},${g},${b})`;
                        else ctx.fillStyle = 'rgba(100, 100, 100, 0.2)'; // Faint grey for non-multiples
                        break;
                    case 'distribution':
                         ctx.fillStyle = primeOnlyToggle.checked ? COLORS.prime : 'rgba(0, 255, 0, 0.5)';
                         break;
                    case 'harmonic':
                    default:
                        if (point.remainderRatio < 0) {
                             ctx.fillStyle = 'rgba(128, 128, 128, 0.5)'; // Grey for large nums
                        } else {
                            const hue = 240 - (240 * point.remainderRatio); // Blue (large rem) to Red (small rem)
                            ctx.fillStyle = `hsl(${hue}, 100%, 50%)`;
                        }
                        break;
                }
            }
            ctx.beginPath(); ctx.arc(px, py, dotRadius, 0, Math.PI * 2); ctx.fill();
        }

        // Highlight factors with lines to the center for emphasis
        const factorPoints = spiralPoints.filter(p => p.isFactor);
        if (factorPoints.length > 0) {
             ctx.strokeStyle = 'rgba(255, 255, 0, 0.7)';
             ctx.lineWidth = Math.max(1.5, 4 / scale);
             ctx.shadowColor = 'yellow'; ctx.shadowBlur = 8;
             for (const point of factorPoints) {
                 const px = point.x * scale + offsetX; const py = point.y * scale + offsetY;
                 ctx.beginPath(); ctx.moveTo(offsetX, offsetY); ctx.lineTo(px, py); ctx.stroke();
             }
             ctx.shadowBlur = 0;
        }
        
        // Draw the center point
        ctx.fillStyle = "red";
        ctx.beginPath(); ctx.arc(offsetX, offsetY, Math.max(1, dotRadius * 1.5), 0, Math.PI * 2); ctx.fill();
    }

    // --- UI & APPLICATION LOGIC ---

    const updateStatus = (message) => document.getElementById('info_status').textContent = `Status: ${message}`;
    
    // Handles seamless paging to the next/previous block of numbers when zooming
    const generateNextChunk = direction => {
        if (isChunking) return;
        isChunking = true;
        let newStartP = currentStartP;
        if (direction === 'forward') newStartP += maxPoints;
        else if (direction === 'backward' && currentStartP > 1) newStartP = Math.max(1, currentStartP - maxPoints);
        else { isChunking = false; return; }
        currentStartP = newStartP;

        canvas.style.opacity = 0;
        setTimeout(() => {
            scale = 4.0; // Reset zoom to a sensible default
            resizeCanvas(); 
            updateAndRun(true); 
            canvas.style.opacity = 1;
            // No longer using a timer to manage the isChunking state.
        }, 300);
    };
    
    function resizeCanvas() {
        const dpr = getDPR();
        const rect = canvas.getBoundingClientRect();
        canvas.width = Math.max(1, Math.floor(rect.width * dpr));
        canvas.height = Math.max(1, Math.floor(rect.height * dpr));
        offsetX = canvas.width / 2;
        offsetY = canvas.height / 2;
        drawSpiral();
    }
    
    function parseTargetInput() {
        try {
            const a=baseAInput.value, b=expBInput.value, c=addCInput.value;
            // Test if they are valid BigInts
            BigInt(a); BigInt(b); BigInt(c);
            document.getElementById('info_target').textContent = `N: ${a}^${b} + ${c}`;
            return { a, b, c };
        } catch(e) { updateStatus(`Invalid number input.`); return null; }
    }

    // Main function to start/restart the calculation
    function updateAndRun(isChunkingCall = false) {
        if (isRunning) return;
        if (!isChunkingCall) {
            targetN = parseTargetInput();
            if (!targetN) return;
            maxPoints = parseInt(maxPointsInput.value, 10);
            if (isNaN(maxPoints) || maxPoints <= 0) { updateStatus('Invalid Range.'); return; }
            currentStartP = 1; factors.clear();
            document.getElementById('info_factors').textContent = `Factors: 0`;
        } else {
            // This path is for chunking OR filter/mode changes. Re-parse inputs just in case they changed.
            const newTargetN = parseTargetInput();
            if (!newTargetN) return;
            // If the core number N changed, any previously found factors are invalid.
            if(JSON.stringify(newTargetN) !== JSON.stringify(targetN)) {
                factors.clear();
                document.getElementById('info_factors').textContent = `Factors: 0`;
            }
            targetN = newTargetN;
            maxPoints = parseInt(maxPointsInput.value, 10);
            if (isNaN(maxPoints) || maxPoints <= 0) { updateStatus('Invalid Range.'); return; }
        }
        const rangeStart = currentStartP, rangeEnd = currentStartP + maxPoints - 1;
        const allPoints = Array.from({length: rangeEnd - rangeStart + 1}, (_, i) => rangeStart + i);
        
        isRunning = true; 
        startButton.textContent = "RUNNING..."; 
        startButton.disabled = true;
        updateStatus("Sieving & Testing...");
        
        document.getElementById('info_range').textContent = `Range: ${rangeStart} to ${rangeEnd}`;
        const resFilters = displayModeSelect.value === 'resonance' ? resonanceFilters : [];
        const primesOnly = displayModeSelect.value !== 'resonance' && primeOnlyToggle.checked;
        worker.postMessage({ allPoints, targetN, primesOnly, rangeStart, rangeEnd, resFilters });
    }

    function showTooltip(text, x, y) {
        clearTimeout(tooltipTimeout);
        tooltip.textContent = text;
        tooltip.style.left = `${x + 15}px`;
        tooltip.style.top = `${y + 15}px`;
        tooltip.style.display = 'block';
        requestAnimationFrame(() => { tooltip.style.opacity = 1; });
        tooltipTimeout = setTimeout(() => {
            tooltip.style.opacity = 0;
            setTimeout(() => { tooltip.style.display = 'none'; }, 200);
        }, 2500);
    }
    
    // --- INTERACTION HANDLERS ---
    
    // Converts mouse/touch coordinates to canvas backing store coordinates.
    function clientToBacking(clientX, clientY) {
        const rect = canvas.getBoundingClientRect();
        const dpr = getDPR();
        return {
            x: (clientX - rect.left) * dpr,
            y: (clientY - rect.top) * dpr,
        };
    }

    function handleCanvasTap(e) {
        const clientX = e.clientX ?? e.changedTouches?.[0]?.clientX;
        const clientY = e.clientY ?? e.changedTouches?.[0]?.clientY;
        if (clientX == null || clientY == null) return;

        const { x: screenX, y: screenY } = clientToBacking(clientX, clientY);
        const worldX = (screenX - offsetX) / scale;
        const worldY = (screenY - offsetY) / scale;

        let closestPoint = null;
        let minDistance = Infinity;
        const clickThresholdSq = (10 / scale) ** 2;

        for (const point of spiralPoints) {
            const dx = point.x - worldX;
            const dy = point.y - worldY;
            const distSq = dx * dx + dy * dy;
            if (distSq < minDistance) {
                minDistance = distSq;
                closestPoint = point;
            }
        }

        if (closestPoint && minDistance < clickThresholdSq) {
            let tooltipText = closestPoint.p.toLocaleString();
            if (displayModeSelect.value === 'harmonic' && !closestPoint.isFactor) {
                if (closestPoint.remainderRatio < 0) tooltipText += ` (rem: too large)`;
                else tooltipText += ` (rem: ${Math.round(closestPoint.remainderRatio * closestPoint.p)})`;
            }
            if (displayModeSelect.value === 'resonance' && (closestPoint.resonanceColor.some(c => c > 0))) {
                const resonancePrimes = resonanceFilters.filter((f, i) => closestPoint.resonanceColor[i]).map(f => f.p);
                tooltipText += ` (mult of: ${resonancePrimes.join(', ')})`;
            }
            showTooltip(tooltipText, clientX, clientY);
        }
    }

    function renderResonanceFilters() {
        resonanceList.innerHTML = '';
        resonanceFilters.forEach((filter, i) => {
            const item = document.createElement('div');
            item.className = 'resonance-item';
            const color = RESONANCE_COLORS[i];
            item.innerHTML = `<div class="color-swatch" style="background-color: ${color};"></div>
                <span>Multiple of ${filter.p} (${['R','G','B'][i]})</span>
                <button data-p="${filter.p}">X</button>`;
            resonanceList.appendChild(item);
        });
        addResonanceBtn.disabled = resonanceFilters.length >= 3;
    }
    
    function handleZoom(zoomFactor, screenX, screenY) {
        const oldScale = scale;
        scale = Math.max(0.1, Math.min(scale * zoomFactor, 500));
        offsetX = screenX - (screenX - offsetX) * (scale / oldScale);
        offsetY = screenY - (screenY - offsetY) * (scale / oldScale);
        requestAnimationFrame(drawSpiral);
    }

    // --- EVENT LISTENERS ---
    
    // UI Controls
    startButton.addEventListener('click', () => updateAndRun(false));
    helpButton.addEventListener('click', () => { helpModal.style.display = "flex"; });
    closeButton.addEventListener('click', () => { helpModal.style.display = "none"; });
    window.addEventListener('click', e => { if (e.target == helpModal) helpModal.style.display = "none"; });
    
    displayModeSelect.addEventListener('change', () => {
        const isResonance = displayModeSelect.value === 'resonance';
        resonanceContainer.classList.toggle('active', isResonance);
        primeOnlyContainer.style.visibility = isResonance ? 'hidden' : 'visible';
        // Switching modes requires a re-calculation as the worker computes different data for each mode.
        if (!isRunning) {
            updateAndRun(true); // Re-run current view with new mode settings
        }
    });
    
    // Add Enter key functionality to main input fields
    [baseAInput, expBInput, addCInput, maxPointsInput].forEach(input => {
        input.addEventListener('keydown', e => {
            if (e.key === 'Enter') {
                e.preventDefault();
                startButton.click(); // Simulate clicking the run button
            }
        });
    });
    
    const redrawOnChange = () => { if (!isRunning) requestAnimationFrame(drawSpiral); };
    primeOnlyToggle.addEventListener('change', () => { if (!isRunning && displayModeSelect.value !== 'resonance') updateAndRun(false) });
    show6kLinesToggle.addEventListener('change', redrawOnChange);
    showGhostToggle.addEventListener('change', redrawOnChange);

    // Resonance Sieve UI
    addResonanceBtn.addEventListener('click', () => {
        if (resonanceFilters.length >= 3) return;
        const p = resonancePrimeInput.value;
        if (p && !isNaN(p) && !resonanceFilters.some(f => f.p === p)) {
            resonanceFilters.push({ p });
            renderResonanceFilters();
            resonancePrimeInput.value = '';
            // If in resonance mode, re-run the calculation to apply the new filter.
            if (displayModeSelect.value === 'resonance' && !isRunning) {
                updateAndRun(true);
            }
        }
    });

    resonancePrimeInput.addEventListener('keydown', e => {
        if (e.key === 'Enter') {
            e.preventDefault();
            addResonanceBtn.click();
        }
    });

    resonanceList.addEventListener('click', (e) => {
        if (e.target.tagName === 'BUTTON') {
            const pToRemove = e.target.dataset.p;
            resonanceFilters = resonanceFilters.filter(f => f.p !== pToRemove);
            renderResonanceFilters();
            // If in resonance mode, re-run the calculation to apply the filter change.
            if (displayModeSelect.value === 'resonance' && !isRunning) {
                updateAndRun(true);
            }
        }
    });
    
    // Keyboard Interaction
    window.addEventListener('keydown', e => {
        const panAmount = 50;
        switch (e.key) {
            case 'ArrowUp': offsetY += panAmount; requestAnimationFrame(drawSpiral); break;
            case 'ArrowDown': offsetY -= panAmount; requestAnimationFrame(drawSpiral); break;
            case 'ArrowLeft': offsetX += panAmount; requestAnimationFrame(drawSpiral); break;
            case 'ArrowRight': offsetX -= panAmount; requestAnimationFrame(drawSpiral); break;
            case '=': case '+': handleZoom(1.25, canvas.width / 2, canvas.height / 2); break;
            case '-': handleZoom(1 / 1.25, canvas.width / 2, canvas.height / 2); break;
        }
    });

    // Mouse Interaction
    canvas.addEventListener('mousedown', e => { 
        isDragging = false;
        tapStart = { x: e.clientX, y: e.clientY, time: Date.now() };
    });
    canvas.addEventListener('mouseup', e => { 
        if (tapStart && (Date.now() - tapStart.time < 250) && !isDragging) handleCanvasTap(e);
        isDragging = false; 
        tapStart = null;
    });
    canvas.addEventListener('mouseleave', () => { isDragging = false; tapStart = null; });
    canvas.addEventListener('mousemove', e => {
        if (tapStart && (Math.hypot(e.clientX - tapStart.x, e.clientY - tapStart.y) > 10)) {
            isDragging = true; lastMouseX = e.clientX; lastMouseY = e.clientY;
            tapStart = null;
        }
        if (isDragging) {
            const {x: newX, y: newY} = clientToBacking(e.clientX, e.clientY);
            const {x: oldX, y: oldY} = clientToBacking(lastMouseX, lastMouseY);
            offsetX += newX - oldX;
            offsetY += newY - oldY;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            requestAnimationFrame(drawSpiral);
        }
    });
    canvas.addEventListener('wheel', e => {
        e.preventDefault();
        const {x, y} = clientToBacking(e.clientX, e.clientY);
        handleZoom(e.deltaY < 0 ? 1.15 : 1 / 1.15, x, y);
        if (!isChunking && (scale < MIN_SCALE_TO_SHIFT || scale > MAX_SCALE_TO_SHIFT)) {
            setTimeout(() => {
                if (scale < MIN_SCALE_TO_SHIFT) generateNextChunk('forward');
                else if (scale > MAX_SCALE_TO_SHIFT) generateNextChunk('backward');
            }, 50);
        }
    }, { passive: false });

    // Touch Interaction
    canvas.addEventListener('touchstart', e => {
        if (e.touches.length === 1) { 
            const touch = e.touches[0];
            isDragging = false;
            tapStart = { x: touch.clientX, y: touch.clientY, time: Date.now() };
        } else if (e.touches.length === 2) { 
            isDragging = false; tapStart = null;
            lastTouchDistance = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY); 
        }
    });
    canvas.addEventListener('touchmove', e => {
        e.preventDefault();
        if (e.touches.length === 1) {
            const touch = e.touches[0];
            if (tapStart && (Math.hypot(touch.clientX - tapStart.x, touch.clientY - tapStart.y) > 10)) {
                isDragging = true; lastMouseX = touch.clientX; lastMouseY = touch.clientY;
                tapStart = null; 
            }
            if (isDragging) {
                const {x: newX, y: newY} = clientToBacking(touch.clientX, touch.clientY);
                const {x: oldX, y: oldY} = clientToBacking(lastMouseX, lastMouseY);
                offsetX += newX - oldX; offsetY += newY - oldY;
                lastMouseX = touch.clientX; lastMouseY = touch.clientY;
                requestAnimationFrame(drawSpiral);
            }
        } else if (e.touches.length === 2 && lastTouchDistance) {
            const dist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
            const {x, y} = clientToBacking((e.touches[0].clientX + e.touches[1].clientX) / 2, (e.touches[0].clientY + e.touches[1].clientY) / 2);
            handleZoom(dist / lastTouchDistance, x, y);
            lastTouchDistance = dist;
        }
    }, { passive: false });
    canvas.addEventListener('touchend', e => {
        if (tapStart && (Date.now() - tapStart.time < 250) && !isDragging) handleCanvasTap(e);
        isDragging = false; lastTouchDistance = null; tapStart = null;
        if (!isChunking && (scale < MIN_SCALE_TO_SHIFT || scale > MAX_SCALE_TO_SHIFT)) {
            setTimeout(() => {
                if (scale < MIN_SCALE_TO_SHIFT) generateNextChunk('forward');
                else if (scale > MAX_SCALE_TO_SHIFT) generateNextChunk('backward');
            }, 50);
        }
    });
    
    // --- INITIALIZATION ---
    document.addEventListener('DOMContentLoaded', () => { 
        // Cache CSS variable colors for performance and correctness
        const style = getComputedStyle(document.body);
        COLORS = {
            bg: style.getPropertyValue('--bg-color').trim(),
            factor: style.getPropertyValue('--factor-color').trim(),
            prime: style.getPropertyValue('--prime-color').trim(),
            structure: style.getPropertyValue('--structure-line-color').trim(),
            ghost: style.getPropertyValue('--ghost-spiral-color').trim()
        };

        // Render the math formula using KaTeX
        katex.render("N = a^b + c", document.getElementById('math-formula'), { throwOnError: false });
        resizeCanvas(); 
        updateAndRun(false); 
    });
    window.addEventListener('resize', resizeCanvas);
</script>
</body>
</html>






