<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Spiral Sieve v2.0: Harmonic Explorer</title>
    <!-- KaTeX for beautiful math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');
        :root {
            --bg-color: #05080a; --text-color: #00ff00; --input-bg: #222;
            --border-color: #004400; --button-bg: #008800; --button-hover: #00cc00;
            --factor-color: #ffff00; --modal-bg: #0a0a0a; --prime-color: #66ff66;
            --structure-line-color: rgba(75, 0, 130, 0.4);
            --ghost-spiral-color: rgba(0, 255, 0, 0.15);
        }
        html, body {
            font-family: 'VT323', monospace; background: var(--bg-color); color: var(--text-color);
            margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden;
        }
        .main-container {
            width: 100%; height: 100%; display: flex; flex-direction: column;
            padding: 10px; box-sizing: border-box;
        }
        .header-content { flex-shrink: 0; max-width: 1200px; width: 100%; margin: 0 auto; }
        h1, p { margin: 0 0 10px 0; }
        .katex { font-size: 1.1em; } /* Style for rendered math formula */
        canvas {
            background-color: var(--bg-color); display: block; touch-action: none;
            width: 100%; flex-grow: 1; border-radius: 4px;
            border: 1px solid var(--border-color); margin-top: 10px;
            transition: opacity 0.3s ease-in-out;
        }
        .controls {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
            gap: 8px; margin-bottom: 10px; align-items: end;
        }
        .controls-row { display: contents; }
        @media (min-width: 1200px) { .controls { grid-template-columns: repeat(6, 1fr); } }
        .controls label { display: block; font-size: 0.9em; margin-bottom: 2px; }
        .controls input, .controls button, .controls select, .controls .checkbox-container { height: 36px; box-sizing: border-box; }
        .controls input, .controls select {
            width: 100%; padding: 4px; background: var(--input-bg);
            border: 1px solid var(--border-color); color: var(--text-color);
            font-family: 'VT323', monospace; font-size: 1.1em;
        }
        .controls button {
            background: var(--button-bg); color: var(--bg-color); border: none; padding: 8px 10px;
            cursor: pointer; transition: background 0.2s, transform 0.1s; font-family: 'VT323', monospace;
            font-size: 1em; box-shadow: 0 0 5px var(--button-bg);
        }
        .controls button:hover { background: var(--button-hover); }
        .controls button:active { transform: scale(0.97); }
        .controls button:disabled { background: #555; cursor: not-allowed; opacity: 0.7; transform: none; }
        .checkbox-container { display: flex; align-items: center; justify-content: center; gap: 5px; font-size: 0.9em; white-space: nowrap;}

        .resonance-container {
            grid-column: 1 / -1; border: 1px solid var(--border-color);
            border-radius: 4px; padding: 8px; margin-top: 10px; display: none;
        }
        .resonance-container.active { display: block; }
        .resonance-header h3 { margin: 0; font-size: 1.2em; }
        .resonance-input-row { display: flex; gap: 8px; margin-bottom: 8px; }
        .resonance-input-row input { flex-grow: 1; }
        .resonance-list { font-size: 1em; display: flex; flex-direction: column; gap: 6px; }
        .resonance-item { display: flex; align-items: center; gap: 8px; }
        .resonance-item .color-swatch { width: 16px; height: 16px; border: 1px solid #555; flex-shrink: 0;}
        .resonance-item button { background: #aa0000; font-size: 0.8em; padding: 2px 6px; height: auto; }

        #info-box {
            position: fixed; bottom: 15px; right: 15px; background: rgba(0, 0, 0, 0.9);
            padding: 8px; border: 1px solid var(--text-color); z-index: 10;
            font-size: 0.9em; min-width: 160px; max-width: 50vw; border-radius: 4px;
        }
        .modal {
            display: none; position: fixed; z-index: 100; left: 0; top: 0; width: 100%; height: 100%;
            overflow: hidden; /* We'll handle scroll on the content */ background-color: rgba(0, 0, 0, 0.8);
            display: flex; /* Use flexbox for easy centering */
            justify-content: center; align-items: center;
        }
        .modal-content {
            background-color: var(--modal-bg); color: var(--text-color); margin: auto;
            padding: 20px; border: 2px solid var(--text-color); width: 90%; max-width: 600px;
            box-shadow: 0 0 15px var(--text-color);
            max-height: 90vh; /* Limit the height to 90% of the viewport */
            overflow-y: auto; /* Add a scrollbar if content overflows */
        }
        .close-button { color: var(--text-color); float: right; font-size: 28px; font-weight: bold; cursor: pointer; }
        #tooltip {
            position: fixed; display: none; background: var(--factor-color); color: var(--bg-color);
            padding: 5px 10px; border-radius: 4px; font-size: 1.2em; pointer-events: none;
            z-index: 101; box-shadow: 0 0 10px var(--factor-color); opacity: 0; transition: opacity 0.2s;
        }
    </style>
</head>
<body>

<div class="main-container">
    <div class="header-content">
        <h1>Spiral Sieve v2.0</h1>
        <p>Explore factors of <span id="math-formula">N = a^b + c</span> by visualizing their harmonic signature on a logarithmic spiral.</p>
        <p style="font-size:0.9em;">Controls: Pan (Drag), Zoom (Scroll/Pinch), Identify (Tap), Keyboard (Arrows/+-)</p>
        <div class="controls">
            <div class="controls-row">
                <div><label for="baseA">Base (a)</label><input type="text" id="baseA" value="10"></div>
                <div><label for="expB">Exponent (b)</label><input type="text" id="expB" value="1000000000"></div>
                <div><label for="addC">Addend (c)</label><input type="text" id="addC" value="19"></div>
                <div><label for="maxPoints">Range to Test</label><input type="text" id="maxPoints" value="15000"></div>
                <div><label for="displayMode">Display Mode</label>
                    <select id="displayMode">
                        <option value="harmonic" selected>Harmonic Signature</option>
                        <option value="resonance">Resonance Sieve (CRT)</option>
                        <option value="distribution">Prime Distribution</option>
                    </select>
                </div>
                <button id="startButton">RUN</button>
            </div>
             <div class="controls-row">
                 <div class="checkbox-container"><input type="checkbox" id="heatmapToggle"><label for="heatmapToggle">Heatmap Grid</label></div>
                 <div class="checkbox-container"><input type="checkbox" id="show6kLinesToggle" checked><label for="show6kLinesToggle">Show 6k Lines</label></div>
                 <div class="checkbox-container"><input type="checkbox" id="showGhostToggle" checked><label for="showGhostToggle">Show Ghost Spiral</label></div>
                 <div class="checkbox-container" id="primeOnlyContainer"><input type="checkbox" id="primeOnlyToggle" checked><label for="primeOnlyToggle">Primes Only</label></div>
                 <div></div>
                <button id="helpButton">HELP [ ? ]</button>
            </div>
            <div id="resonanceContainer" class="resonance-container">
                <h3>Resonance Sieve (Chinese Remainder Theorem)</h3>
                <div class="resonance-input-row">
                    <input type="text" id="resonancePrimeInput" placeholder="Add prime filter (max 3)">
                    <button id="addResonanceBtn">Add Filter</button>
                </div>
                <div id="resonanceList" class="resonance-list"></div>
            </div>
        </div>
    </div>
    <canvas id="spiralCanvas"></canvas>
    <div id="info-box">
        <span class="info-header">STATUS:</span>
        <span id="info_target" class="info-line">N: 10^1000000000 + 19</span>
        <span id="info_status" class="info-line">Status: Idle</span>
        <span id="info_factors" class="info-line">Factors: 0</span>
        <span id="info_range" class="info-line">Range: 1 to 15000</span>
    </div>
    <div id="tooltip"></div>
</div>

<div id="helpModal" class="modal">
  <div class="modal-content">
    <span class="close-button">&times;</span>
    <h2>Spiral Sieve v2.0 - Full Guide</h2>
    <p>This program transforms a complex number theory problem into an interactive visual exploration. It helps you find potential factors for very large numbers of the form <strong>N = a^b + c</strong> by plotting them on a logarithmic spiral and coloring them based on their mathematical properties.</p>

    <h3>The Controls</h3>
    <ul>
        <li><strong>Base, Exponent, Addend:</strong> These define the number N you want to investigate. You can use very large numbers.</li>
        <li><strong>Range to Test:</strong> How many numbers to test at once. Larger ranges are better visualized with the Heatmap Grid.</li>
        <li><strong>Display Mode:</strong> This is the core of the visualization. See the "Display Modes" section below for a full explanation.</li>
        <li><strong>RUN / RE-RUN:</strong> Starts the calculation for the defined number and range. It automatically re-runs when you change display modes or Resonance Sieve filters.</li>
    </ul>

    <h3>Display Modes Explained</h3>
    <p>This dropdown changes what the colors on the spiral represent:</p>
    <ul>
        <li><strong>Harmonic Signature:</strong> This is the primary analysis mode. Each point is colored by the size of its remainder when dividing N. It's like a thermal map for factors:
            <ul>
                <li><strong style="color: #66f;">Blue (Cold):</strong> The remainder is very small. These are your best candidates for factors.</li>
                <li><strong style="color: #0f0;">Green (Warm):</strong> The remainder is a medium size.</li>
                <li><strong style="color: #f66;">Red (Hot):</strong> The remainder is very large. These are the worst candidates.</li>
                <li><strong style="color: #ff0;">Bright Yellow:</strong> A direct hit! The remainder is zero and you've found a factor.</li>
                <li><strong style="color: #888;">Grey:</strong> For extremely large target numbers, the remainder can't be precisely calculated in the browser. The factor check (remainder = 0) still works perfectly, however.</li>
            </ul>
        </li>
        <li><strong>Resonance Sieve (CRT):</strong> A tool for visualizing the Chinese Remainder Theorem. It's best used with small prime filters (e.g., 3, 5, 7) to see how their multiples interact.
            <ul>
                <li>The first filter colors its multiples <strong style="color: #f00;">Red</strong>.</li>
                <li>The second filter colors its multiples <strong style="color: #0f0;">Green</strong>.</li>
                <li>The third filter colors its multiples <strong style="color: #00f;">Blue</strong>.</li>
                <li>Where they overlap, colors combine: Red + Green = <strong style="color: #ff0;">Yellow</strong>, Green + Blue = <strong style="color: #0ff;">Cyan</strong>, etc. This makes it easy to find numbers divisible by multiple primes at once.</li>
            </ul>
        </li>
        <li><strong>Prime Distribution:</strong> A classic view showing the location of numbers being tested. They appear <strong style="color: #6f6;">green</strong>. Useful for seeing the raw structure of the spiral.</li>
    </ul>

    <h3>Display Options (Checkboxes)</h3>
    <ul>
        <li><strong>Heatmap Grid:</strong> Toggles a high-performance grid view instead of drawing individual dots. This is essential for visualizing large ranges. The color of each square represents the average value of all the points inside it, according to the currently selected Display Mode.</li>
        <li><strong>Show 6k Lines:</strong> Draws guide lines for where prime numbers greater than 3 (which are always of the form 6k ± 1) are most likely to appear. Think of them as "prime highways."</li>
        <li><strong>Show Ghost Spiral:</strong> Draws a faint outline of the spiral's path. This is very useful for getting your bearings, especially when in Heatmap mode.</li>
        <li><strong>Primes Only:</strong> A powerful optimization. When checked, the program will only test prime numbers in the selected range, dramatically speeding up the search for prime factors. This is automatically disabled for the Resonance Sieve mode.</li>
    </ul>

    <h3>Interaction</h3>
    <ul>
        <li><strong>Mouse:</strong> Drag to Pan, Scroll Wheel to Zoom, Click to Identify a point.</li>
        <li><strong>Touch:</strong> One finger to Pan, Pinch to Zoom, Tap to Identify a point.</li>
        <li><strong>Keyboard:</strong> Arrow Keys to Pan, Plus (+) and Minus (-) keys to Zoom.</li>
        <li><strong>Range Shifting:</strong> Zooming far out will automatically load the next range of numbers. Zooming far in will load the previous range.</li>
    </ul>
  </div>
</div>

<script>
    // --- DOM ELEMENT SELECTION ---
    const canvas = document.getElementById('spiralCanvas');
    const ctx = canvas.getContext('2d', { alpha: false });
    const tooltip = document.getElementById('tooltip');
    const maxPointsInput = document.getElementById('maxPoints');
    const baseAInput = document.getElementById('baseA');
    const expBInput = document.getElementById('expB');
    const addCInput = document.getElementById('addC');
    const startButton = document.getElementById('startButton');
    const helpButton = document.getElementById('helpButton');
    const displayModeSelect = document.getElementById('displayMode');
    const primeOnlyToggle = document.getElementById('primeOnlyToggle');
    const primeOnlyContainer = document.getElementById('primeOnlyContainer');
    const show6kLinesToggle = document.getElementById('show6kLinesToggle');
    const showGhostToggle = document.getElementById('showGhostToggle');
    const heatmapToggle = document.getElementById('heatmapToggle');
    const resonanceContainer = document.getElementById('resonanceContainer');
    const resonancePrimeInput = document.getElementById('resonancePrimeInput');
    const addResonanceBtn = document.getElementById('addResonanceBtn');
    const resonanceList = document.getElementById('resonanceList');
    const helpModal = document.getElementById('helpModal');
    const closeButton = helpModal.querySelector(".close-button");

    // --- GLOBAL STATE ---
    let isRunning = false, maxPoints = 15000, targetN = null, spiralPoints = [], factors = new Set();
    let currentStartP = 1, isChunking = false;
    const MIN_SCALE_TO_SHIFT = 0.8, MAX_SCALE_TO_SHIFT = 15.0;

    let scale = 4.0, offsetX = 0, offsetY = 0;
    let isDragging = false, lastMouseX, lastMouseY, lastTouchDistance = null;
    let tapStart = null;
    let tooltipTimeout = null;
    let resonanceFilters = [];
    const RESONANCE_COLORS = ['#ff0000', '#00ff00', '#0000ff'];
    let COLORS = {}; // Object to store resolved CSS variable colors
    let heatmapData = null; // To store the generated heatmap

    // --- WEB WORKER INITIALIZATION ---
    // The worker handles heavy calculations (sieving, modular exponentiation) off the main thread.
    const worker = new Worker(URL.createObjectURL(new Blob([`
        // Modular exponentiation: (b^e) mod m. Handles BigInts.
        function powMod(b,e,m){let r=1n;b%=m;while(e>0n){if((e&1n)===1n)r=(r*b)%m;e>>=1n;b=(b*b)%m}return r}

        // Sieve of Eratosthenes to find primes in a given range [min, max].
        function sieve(min, max) {
            const minNum=Number(min), maxNum=Number(max);
            // Sieve cannot handle unsafe integers directly, but the main logic can.
            if (minNum > Number.MAX_SAFE_INTEGER || maxNum > Number.MAX_SAFE_INTEGER) return [];
            const sqrtMax=Math.floor(Math.sqrt(maxNum)), smallPrimes=[], isSmallPrime=new Array(sqrtMax+1).fill(!0);
            isSmallPrime[0]=isSmallPrime[1]=!1;
            for(let i=2;i*i<=sqrtMax;i++)if(isSmallPrime[i])for(let j=i*i;j<=sqrtMax;j+=i)isSmallPrime[j]=!1;
            for(let i=2;i<=sqrtMax;i++)isSmallPrime[i]&&smallPrimes.push(i);
            const isPrimeInRange=new Array(maxNum-minNum+1).fill(!0);
            if(minNum===1&&isPrimeInRange.length>0) isPrimeInRange[0]=!1;
            for(const p of smallPrimes){let s=Math.max(p*p,Math.ceil(minNum/p)*p);for(let j=s;j<=maxNum;j+=p)j>=minNum&&(isPrimeInRange[j-minNum]=!1)}
            const primes=[];
            for(let i=0;i<isPrimeInRange.length;i++)if(isPrimeInRange[i]){const c=minNum+i;c>1&&primes.push(c)}
            return primes;
        }

        onmessage=function(ev){
            let{allPoints:p,targetN:t,primesOnly:po,rangeStart:rs,rangeEnd:re,resFilters:rf}=ev.data;
            const pointsToTest=po?sieve(rs,re):p;
            const a=BigInt(t.a),b=BigInt(t.b),c=BigInt(t.c),results=[],factorsFound=[];
            const filterPrimes = rf.map(filt => BigInt(filt.p));

            for(let num of new Set(pointsToTest)){
                if(1===num)continue;
                let testVal=BigInt(num);
                let remainder=(powMod(a,b,testVal)+(c%testVal+testVal)%testVal)%testVal;
                const isFactor = 0n===remainder;

                // For Harmonic mode, calculate remainder ratio if possible.
                let remRatio = -1; // Default for very large numbers
                if (testVal < Number.MAX_SAFE_INTEGER) {
                    remRatio = isFactor ? 0 : Number(remainder) / Number(testVal);
                }
                if(isFactor) factorsFound.push(num);

                // For Resonance Sieve mode, determine color channels.
                let resonanceColor = [0, 0, 0];
                if (rf.length > 0) {
                    filterPrimes.forEach((fp, i) => {
                        if (testVal % fp === 0n) resonanceColor[i] = 255;
                    });
                }
                results.push({p:num,isFactor,remainderRatio:remRatio,resonanceColor});
            }
            postMessage({results, factorsFound});
        };
    `], { type: 'application/javascript' })));

    worker.onmessage = e => {
        isChunking = false; // The chunking process is now complete.
        isRunning = false;
        startButton.textContent = "RE-RUN";
        startButton.disabled = false;

        const pointMap = new Map();
        // Generate base geometric points first.
        spiralPoints = generatePointsBatch(e.data.results.map(r => r.p), currentStartP);
        spiralPoints.forEach(p => pointMap.set(p.p, p));

        // Augment points with calculation results from the worker.
        e.data.results.forEach(res => {
            const pObj = pointMap.get(res.p);
            if (pObj) { Object.assign(pObj, res); }
        });

        // After all points are processed, generate the heatmap data.
        heatmapData = createHeatmap(spiralPoints);

        e.data.factorsFound.forEach(f => factors.add(f));
        document.getElementById('info_factors').textContent = `Factors: ${factors.size} (${Array.from(factors).join(', ')})`;
        drawSpiral();
    };

    // --- GEOMETRY & DRAWING ---

    // Calculates the (x, y) coordinate for a number `n` on the logarithmic spiral.
    const getSpiralPoint = (n, startN) => {
        const num = n - startN;
        if (num < 0) return { x: 0, y: 0 };
        // These constants define the "tightness" and "growth" of the spiral.
        const angle = 0.2 * Math.sqrt(num) * Math.PI;
        const radius = 0.8 * Math.sqrt(num);
        return { x: radius * Math.cos(angle), y: radius * Math.sin(angle) };
    };

    // Creates an array of point objects with their geometric locations.
    const generatePointsBatch = (pointsArray, startP) => pointsArray.map((p) => ({ p, ...getSpiralPoint(p, startP), isFactor: false, remainderRatio: -1, resonanceColor: [0,0,0] }));

    // Gets the device pixel ratio for sharp rendering on HiDPI displays.
    function getDPR() { return window.devicePixelRatio || 1; }

    function createHeatmap(points) {
        const gridSize = 100; // Resolution of the heatmap
        const densityGrid = Array(gridSize).fill(0).map(() => Array(gridSize).fill(0));
        const harmonicGrid = Array(gridSize).fill(0).map(() => Array(gridSize).fill(0));
        let maxDensity = 0;
        if (points.length === 0) return null;

        // First, find the geometric bounds of all points.
        const bounds = points.reduce((b, p) => ({
            minX: Math.min(b.minX, p.x), maxX: Math.max(b.maxX, p.x),
            minY: Math.min(b.minY, p.y), maxY: Math.max(b.maxY, p.y)
        }), { minX: Infinity, maxX: -Infinity, minY: Infinity, maxY: -Infinity });

        const rangeX = bounds.maxX - bounds.minX;
        const rangeY = bounds.maxY - bounds.minY;

        // Don't create a map for a single point.
        if (rangeX === 0 || rangeY === 0) return null;

        // Populate the grids.
        for (const p of points) {
            const gridX = Math.floor(((p.x - bounds.minX) / rangeX) * (gridSize - 1));
            const gridY = Math.floor(((p.y - bounds.minY) / rangeY) * (gridSize - 1));
            if (gridX >= 0 && gridX < gridSize && gridY >= 0 && gridY < gridSize) {
                densityGrid[gridY][gridX]++;
                // Only add to harmonic sum if the ratio is valid
                if (p.remainderRatio >= 0) {
                    harmonicGrid[gridY][gridX] += p.remainderRatio;
                }
                if (densityGrid[gridY][gridX] > maxDensity) maxDensity = densityGrid[gridY][gridX];
            }
        }
        return { densityGrid, harmonicGrid, maxDensity, bounds };
    }

    function drawHeatmap() {
        if (!heatmapData || !heatmapData.maxDensity) return;
        const { densityGrid, harmonicGrid, maxDensity, bounds } = heatmapData;
        const cellWidth = (bounds.maxX - bounds.minX) / densityGrid[0].length;
        const cellHeight = (bounds.maxY - bounds.minY) / densityGrid.length;
        const currentMode = displayModeSelect.value;

        for (let y = 0; y < densityGrid.length; y++) {
            for (let x = 0; x < densityGrid[y].length; x++) {
                const density = densityGrid[y][x];
                if (density > 0) {
                    const opacity = Math.log1p(density) / Math.log1p(maxDensity);
                    let hue, saturation = '100%', lightness = '50%';

                    switch (currentMode) {
                        case 'harmonic':
                            const avgHarmonic = harmonicGrid[y][x] / density;
                            hue = 240 - (240 * avgHarmonic); // Blue to Red
                            break;
                        case 'distribution':
                            hue = 120 - (120 * opacity); // Green (low density) to Red (high)
                            break;
                        case 'resonance':
                            // Resonance heatmap just shows density.
                            hue = 120 - (120 * opacity);
                            break;
                    }

                    ctx.fillStyle = `hsla(${hue}, ${saturation}, ${lightness}, ${0.1 + opacity * 0.8})`;

                    const px = (bounds.minX + x * cellWidth) * scale + offsetX;
                    const py = (bounds.minY + y * cellHeight) * scale + offsetY;
                    // Add 1 to prevent gaps between cells
                    ctx.fillRect(px, py, cellWidth * scale + 1, cellHeight * scale + 1);
                }
            }
        }
    }

    function drawGhostSpiral() {
        ctx.strokeStyle = COLORS.ghost;
        ctx.lineWidth = 1; // Always 1 backing pixel wide for faintness
        ctx.beginPath();
        const sampleRate = Math.max(1, Math.floor(maxPoints / 2000));
        let first = true;
        for (let i = 0; i < maxPoints; i += sampleRate) {
            const p = currentStartP + i;
            const { x, y } = getSpiralPoint(p, currentStartP);
            const px = x * scale + offsetX; const py = y * scale + offsetY;
            if (first) { ctx.moveTo(px, py); first = false; } else { ctx.lineTo(px, py); }
        }
        ctx.stroke();
    }

    function draw6kLines() {
        ctx.strokeStyle = COLORS.structure;
        ctx.lineWidth = 2; // Always 2 backing pixels
        ctx.setLineDash([5, 10]);
        const maxRadius = Math.max(canvas.width, canvas.height);
        // The lines correspond to where primes of the form 6k±1 tend to appear on this specific spiral.
        for (let k = 1; k < 30; k++) {
             const n_plus_1 = 6 * k * k * 100 + 1, n_minus_1 = 6 * k * k * 100 - 1;
             const {x: x_plus, y: y_plus} = getSpiralPoint(n_plus_1, 1);
             const {x: x_minus, y: y_minus} = getSpiralPoint(n_minus_1, 1);
             const angle_plus = Math.atan2(y_plus, x_plus);
             const angle_minus = Math.atan2(y_minus, x_minus);

             ctx.beginPath(); ctx.moveTo(offsetX, offsetY); ctx.lineTo(offsetX + maxRadius * Math.cos(angle_plus), offsetY + maxRadius * Math.sin(angle_plus)); ctx.stroke();
             ctx.beginPath(); ctx.moveTo(offsetX, offsetY); ctx.lineTo(offsetX + maxRadius * Math.cos(angle_minus), offsetY + maxRadius * Math.sin(angle_minus)); ctx.stroke();
        }
        ctx.setLineDash([]);
    }

    // Main render loop
    function drawSpiral() {
        if (isChunking) return;
        ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset transform
        ctx.fillStyle = COLORS.bg;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Draw structural guides first
        if (show6kLinesToggle.checked) draw6kLines();
        if (showGhostToggle.checked) drawGhostSpiral();

        const dotRadius = Math.max(0.5, Math.min(2.5, 0.7 * scale));

        if (heatmapToggle.checked) {
            drawHeatmap();
        } else {
            const currentMode = displayModeSelect.value;
            // Main loop to draw each point based on the selected display mode
            for (const point of spiralPoints) {
                const px = point.x * scale + offsetX; const py = point.y * scale + offsetY;
                // Culling: Don't draw points that are off-screen
                if (px + dotRadius < 0 || px - dotRadius > canvas.width || py + dotRadius < 0 || py - dotRadius > canvas.height) continue;

                if (point.isFactor) {
                    ctx.fillStyle = COLORS.factor;
                } else {
                     switch (currentMode) {
                        case 'resonance':
                            const [r, g, b] = point.resonanceColor;
                            if (r > 0 || g > 0 || b > 0) ctx.fillStyle = `rgb(${r},${g},${b})`;
                            else ctx.fillStyle = 'rgba(100, 100, 100, 0.2)'; // Faint grey for non-multiples
                            break;
                        case 'distribution':
                             ctx.fillStyle = primeOnlyToggle.checked ? COLORS.prime : 'rgba(0, 255, 0, 0.5)';
                             break;
                        case 'harmonic':
                        default:
                            if (point.remainderRatio < 0) {
                                 ctx.fillStyle = 'rgba(128, 128, 128, 0.5)'; // Grey for large nums
                            } else {
                                const hue = 240 - (240 * point.remainderRatio); // Blue (large rem) to Red (small rem)
                                ctx.fillStyle = `hsl(${hue}, 100%, 50%)`;
                            }
                            break;
                    }
                }
                ctx.beginPath(); ctx.arc(px, py, dotRadius, 0, Math.PI * 2); ctx.fill();
            }
        }


        // Highlight factors with lines to the center for emphasis
        const factorPoints = spiralPoints.filter(p => p.isFactor);
        if (factorPoints.length > 0) {
             ctx.strokeStyle = 'rgba(255, 255, 0, 0.7)';
             ctx.lineWidth = Math.max(1.5, 4 / scale);
             ctx.shadowColor = 'yellow'; ctx.shadowBlur = 8;
             for (const point of factorPoints) {
                 const px = point.x * scale + offsetX; const py = point.y * scale + offsetY;
                 ctx.beginPath(); ctx.moveTo(offsetX, offsetY); ctx.lineTo(px, py); ctx.stroke();
             }
             ctx.shadowBlur = 0;
             // Also draw the dots themselves so they appear on top of the heatmap.
             ctx.fillStyle = COLORS.factor;
             const factorDotRadius = Math.max(1, dotRadius * 1.5);
             for (const point of factorPoints) {
                const px = point.x * scale + offsetX; const py = point.y * scale + offsetY;
                ctx.beginPath(); ctx.arc(px, py, factorDotRadius, 0, Math.PI * 2); ctx.fill();
             }
        }

        // Draw the center point
        ctx.fillStyle = "red";
        ctx.beginPath(); ctx.arc(offsetX, offsetY, Math.max(1, dotRadius * 1.5), 0, Math.PI * 2); ctx.fill();
    }

    // --- UI & APPLICATION LOGIC ---

    const updateStatus = (message) => document.getElementById('info_status').textContent = `Status: ${message}`;

    // Handles seamless paging to the next/previous block of numbers when zooming
    const generateNextChunk = direction => {
        if (isChunking) return;
        isChunking = true;
        let newStartP = currentStartP;
        if (direction === 'forward') newStartP += maxPoints;
        else if (direction === 'backward' && currentStartP > 1) newStartP = Math.max(1, currentStartP - maxPoints);
        else { isChunking = false; return; }
        currentStartP = newStartP;

        canvas.style.opacity = 0;
        setTimeout(() => {
            scale = 4.0; // Reset zoom to a sensible default
            resizeCanvas();
            updateAndRun(true);
            canvas.style.opacity = 1;
        }, 300);
    };

    function resizeCanvas() {
        const dpr = getDPR();
        const rect = canvas.getBoundingClientRect();
        canvas.width = Math.max(1, Math.floor(rect.width * dpr));
        canvas.height = Math.max(1, Math.floor(rect.height * dpr));
        offsetX = canvas.width / 2;
        offsetY = canvas.height / 2;
        drawSpiral();
    }

    function parseTargetInput() {
        try {
            const a=baseAInput.value, b=expBInput.value, c=addCInput.value;
            // Test if they are valid BigInts
            BigInt(a); BigInt(b); BigInt(c);
            document.getElementById('info_target').textContent = `N: ${a}^${b} + ${c}`;
            return { a, b, c };
        } catch(e) { updateStatus(`Invalid number input.`); return null; }
    }

    // Main function to start/restart the calculation
    function updateAndRun(isChunkingCall = false) {
        if (isRunning) return;
        if (!isChunkingCall) {
            targetN = parseTargetInput();
            if (!targetN) return;
            maxPoints = parseInt(maxPointsInput.value, 10);
            if (isNaN(maxPoints) || maxPoints <= 0) { updateStatus('Invalid Range.'); return; }
            currentStartP = 1; factors.clear();
            document.getElementById('info_factors').textContent = `Factors: 0`;
        } else {
            // This path is for chunking OR filter/mode changes. Re-parse inputs just in case they changed.
            const newTargetN = parseTargetInput();
            if (!newTargetN) return;
            // If the core number N changed, any previously found factors are invalid.
            if(JSON.stringify(newTargetN) !== JSON.stringify(targetN)) {
                factors.clear();
                document.getElementById('info_factors').textContent = `Factors: 0`;
            }
            targetN = newTargetN;
            maxPoints = parseInt(maxPointsInput.value, 10);
            if (isNaN(maxPoints) || maxPoints <= 0) { updateStatus('Invalid Range.'); return; }
        }
        const rangeStart = currentStartP, rangeEnd = currentStartP + maxPoints - 1;
        const allPoints = Array.from({length: rangeEnd - rangeStart + 1}, (_, i) => rangeStart + i);

        isRunning = true;
        startButton.textContent = "RUNNING...";
        startButton.disabled = true;
        updateStatus("Sieving & Testing...");

        document.getElementById('info_range').textContent = `Range: ${rangeStart} to ${rangeEnd}`;
        const resFilters = displayModeSelect.value === 'resonance' ? resonanceFilters : [];
        const primesOnly = displayModeSelect.value !== 'resonance' && primeOnlyToggle.checked;
        worker.postMessage({ allPoints, targetN, primesOnly, rangeStart, rangeEnd, resFilters });
    }

    function showTooltip(text, x, y) {
        clearTimeout(tooltipTimeout);
        tooltip.textContent = text;
        tooltip.style.left = `${x + 15}px`;
        tooltip.style.top = `${y + 15}px`;
        tooltip.style.display = 'block';
        requestAnimationFrame(() => { tooltip.style.opacity = 1; });
        tooltipTimeout = setTimeout(() => {
            tooltip.style.opacity = 0;
            setTimeout(() => { tooltip.style.display = 'none'; }, 200);
        }, 2500);
    }

    // --- INTERACTION HANDLERS ---

    // Converts mouse/touch coordinates to canvas backing store coordinates.
    function clientToBacking(clientX, clientY) {
        const rect = canvas.getBoundingClientRect();
        const dpr = getDPR();
        return {
            x: (clientX - rect.left) * dpr,
            y: (clientY - rect.top) * dpr,
        };
    }

    function handleCanvasTap(e) {
        const clientX = e.clientX ?? e.changedTouches?.[0]?.clientX;
        const clientY = e.clientY ?? e.changedTouches?.[0]?.clientY;
        if (clientX == null || clientY == null) return;

        const { x: screenX, y: screenY } = clientToBacking(clientX, clientY);
        const worldX = (screenX - offsetX) / scale;
        const worldY = (screenY - offsetY) / scale;

        // If in heatmap mode, estimate the number based on position
        if (heatmapToggle.checked) {
            const radius = Math.hypot(worldX, worldY);
            const numOffset = (radius / 0.8) ** 2;
            const estimatedNumber = Math.round(numOffset + currentStartP);

            if (estimatedNumber >= currentStartP && estimatedNumber < currentStartP + maxPoints) {
                 showTooltip(`~ ${estimatedNumber.toLocaleString()}`, clientX, clientY);
            }
            return; // End here for heatmap mode
        }


        let closestPoint = null;
        let minDistance = Infinity;
        const clickThresholdSq = (10 / scale) ** 2;

        for (const point of spiralPoints) {
            const dx = point.x - worldX;
            const dy = point.y - worldY;
            const distSq = dx * dx + dy * dy;
            if (distSq < minDistance) {
                minDistance = distSq;
                closestPoint = point;
            }
        }

        if (closestPoint && minDistance < clickThresholdSq) {
            let tooltipText = closestPoint.p.toLocaleString();
            if (displayModeSelect.value === 'harmonic' && !closestPoint.isFactor) {
                if (closestPoint.remainderRatio < 0) tooltipText += ` (rem: too large)`;
                else tooltipText += ` (rem: ${Math.round(closestPoint.remainderRatio * closestPoint.p)})`;
            }
            if (displayModeSelect.value === 'resonance' && (closestPoint.resonanceColor.some(c => c > 0))) {
                const resonancePrimes = resonanceFilters.filter((f, i) => closestPoint.resonanceColor[i]).map(f => f.p);
                tooltipText += ` (mult of: ${resonancePrimes.join(', ')})`;
            }
            showTooltip(tooltipText, clientX, clientY);
        }
    }

    function renderResonanceFilters() {
        resonanceList.innerHTML = '';
        resonanceFilters.forEach((filter, i) => {
            const item = document.createElement('div');
            item.className = 'resonance-item';
            const color = RESONANCE_COLORS[i];
            item.innerHTML = `<div class="color-swatch" style="background-color: ${color};"></div>
                <span>Multiple of ${filter.p} (${['R','G','B'][i]})</span>
                <button data-p="${filter.p}">X</button>`;
            resonanceList.appendChild(item);
        });
        addResonanceBtn.disabled = resonanceFilters.length >= 3;
    }

    function handleZoom(zoomFactor, screenX, screenY) {
        const oldScale = scale;
        scale = Math.max(0.1, Math.min(scale * zoomFactor, 500));
        offsetX = screenX - (screenX - offsetX) * (scale / oldScale);
        offsetY = screenY - (screenY - offsetY) * (scale / oldScale);
        requestAnimationFrame(drawSpiral);
    }

    // --- EVENT LISTENERS ---

    // UI Controls
    startButton.addEventListener('click', () => updateAndRun(false));
    helpButton.addEventListener('click', () => { helpModal.style.display = "flex"; });
    closeButton.addEventListener('click', () => { helpModal.style.display = "none"; });
    window.addEventListener('click', e => { if (e.target == helpModal) helpModal.style.display = "none"; });

    displayModeSelect.addEventListener('change', () => {
        const isResonance = displayModeSelect.value === 'resonance';
        resonanceContainer.classList.toggle('active', isResonance);
        primeOnlyContainer.style.visibility = isResonance ? 'hidden' : 'visible';
        // Switching modes requires a re-calculation as the worker computes different data for each mode.
        if (!isRunning) {
            updateAndRun(true); // Re-run current view with new mode settings
        }
    });

    // Add Enter key functionality to main input fields
    [baseAInput, expBInput, addCInput, maxPointsInput].forEach(input => {
        input.addEventListener('keydown', e => {
            if (e.key === 'Enter') {
                e.preventDefault();
                startButton.click(); // Simulate clicking the run button
            }
        });
    });

    const redrawOnChange = () => { if (!isRunning) requestAnimationFrame(drawSpiral); };
    primeOnlyToggle.addEventListener('change', () => { if (!isRunning && displayModeSelect.value !== 'resonance') updateAndRun(false) });
    show6kLinesToggle.addEventListener('change', redrawOnChange);
    showGhostToggle.addEventListener('change', redrawOnChange);
    heatmapToggle.addEventListener('change', redrawOnChange);


    // Resonance Sieve UI
    addResonanceBtn.addEventListener('click', () => {
        if (resonanceFilters.length >= 3) return;
        const p = resonancePrimeInput.value;
        if (p && !isNaN(p) && !resonanceFilters.some(f => f.p === p)) {
            resonanceFilters.push({ p });
            renderResonanceFilters();
            resonancePrimeInput.value = '';
            // If in resonance mode, re-run the calculation to apply the new filter.
            if (displayModeSelect.value === 'resonance' && !isRunning) {
                updateAndRun(true);
            }
        }
    });

    resonancePrimeInput.addEventListener('keydown', e => {
        if (e.key === 'Enter') {
            e.preventDefault();
            addResonanceBtn.click();
        }
    });

    resonanceList.addEventListener('click', (e) => {
        if (e.target.tagName === 'BUTTON') {
            const pToRemove = e.target.dataset.p;
            resonanceFilters = resonanceFilters.filter(f => f.p !== pToRemove);
            renderResonanceFilters();
            // If in resonance mode, re-run the calculation to apply the filter change.
            if (displayModeSelect.value === 'resonance' && !isRunning) {
                updateAndRun(true);
            }
        }
    });

    // Keyboard Interaction
    window.addEventListener('keydown', e => {
        const panAmount = 50;
        switch (e.key) {
            case 'ArrowUp': offsetY += panAmount; requestAnimationFrame(drawSpiral); break;
            case 'ArrowDown': offsetY -= panAmount; requestAnimationFrame(drawSpiral); break;
            case 'ArrowLeft': offsetX += panAmount; requestAnimationFrame(drawSpiral); break;
            case 'ArrowRight': offsetX -= panAmount; requestAnimationFrame(drawSpiral); break;
            case '=': case '+': handleZoom(1.25, canvas.width / 2, canvas.height / 2); break;
            case '-': handleZoom(1 / 1.25, canvas.width / 2, canvas.height / 2); break;
        }
    });

    // Mouse Interaction
    canvas.addEventListener('mousedown', e => {
        isDragging = false;
        tapStart = { x: e.clientX, y: e.clientY, time: Date.now() };
    });
    canvas.addEventListener('mouseup', e => {
        if (tapStart && (Date.now() - tapStart.time < 250) && !isDragging) handleCanvasTap(e);
        isDragging = false;
        tapStart = null;
    });
    canvas.addEventListener('mouseleave', () => { isDragging = false; tapStart = null; });
    canvas.addEventListener('mousemove', e => {
        if (tapStart && (Math.hypot(e.clientX - tapStart.x, e.clientY - tapStart.y) > 10)) {
            isDragging = true; lastMouseX = e.clientX; lastMouseY = e.clientY;
            tapStart = null;
        }
        if (isDragging) {
            const {x: newX, y: newY} = clientToBacking(e.clientX, e.clientY);
            const {x: oldX, y: oldY} = clientToBacking(lastMouseX, lastMouseY);
            offsetX += newX - oldX;
            offsetY += newY - oldY;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            requestAnimationFrame(drawSpiral);
        }
    });
    canvas.addEventListener('wheel', e => {
        e.preventDefault();
        const {x, y} = clientToBacking(e.clientX, e.clientY);
        handleZoom(e.deltaY < 0 ? 1.15 : 1 / 1.15, x, y);
        if (!isChunking && (scale < MIN_SCALE_TO_SHIFT || scale > MAX_SCALE_TO_SHIFT)) {
            setTimeout(() => {
                if (scale < MIN_SCALE_TO_SHIFT) generateNextChunk('forward');
                else if (scale > MAX_SCALE_TO_SHIFT) generateNextChunk('backward');
            }, 50);
        }
    }, { passive: false });

    // Touch Interaction
    canvas.addEventListener('touchstart', e => {
        if (e.touches.length === 1) {
            const touch = e.touches[0];
            isDragging = false;
            tapStart = { x: touch.clientX, y: touch.clientY, time: Date.now() };
        } else if (e.touches.length === 2) {
            isDragging = false; tapStart = null;
            lastTouchDistance = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
        }
    });
    canvas.addEventListener('touchmove', e => {
        e.preventDefault();
        if (e.touches.length === 1) {
            const touch = e.touches[0];
            if (tapStart && (Math.hypot(touch.clientX - tapStart.x, touch.clientY - tapStart.y) > 10)) {
                isDragging = true; lastMouseX = touch.clientX; lastMouseY = touch.clientY;
                tapStart = null;
            }
            if (isDragging) {
                const {x: newX, y: newY} = clientToBacking(touch.clientX, touch.clientY);
                const {x: oldX, y: oldY} = clientToBacking(lastMouseX, lastMouseY);
                offsetX += newX - oldX; offsetY += newY - oldY;
                lastMouseX = touch.clientX; lastMouseY = touch.clientY;
                requestAnimationFrame(drawSpiral);
            }
        } else if (e.touches.length === 2 && lastTouchDistance) {
            const dist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
            const {x, y} = clientToBacking((e.touches[0].clientX + e.touches[1].clientX) / 2, (e.touches[0].clientY + e.touches[1].clientY) / 2);
            handleZoom(dist / lastTouchDistance, x, y);
            lastTouchDistance = dist;
        }
    }, { passive: false });
    canvas.addEventListener('touchend', e => {
        if (tapStart && (Date.now() - tapStart.time < 250) && !isDragging) handleCanvasTap(e);
        isDragging = false; lastTouchDistance = null; tapStart = null;
        if (!isChunking && (scale < MIN_SCALE_TO_SHIFT || scale > MAX_SCALE_TO_SHIFT)) {
            setTimeout(() => {
                if (scale < MIN_SCALE_TO_SHIFT) generateNextChunk('forward');
                else if (scale > MAX_SCALE_TO_SHIFT) generateNextChunk('backward');
            }, 50);
        }
    });

    // --- INITIALIZATION ---
    document.addEventListener('DOMContentLoaded', () => {
        // Cache CSS variable colors for performance and correctness
        const style = getComputedStyle(document.body);
        COLORS = {
            bg: style.getPropertyValue('--bg-color').trim(),
            factor: style.getPropertyValue('--factor-color').trim(),
            prime: style.getPropertyValue('--prime-color').trim(),
            structure: style.getPropertyValue('--structure-line-color').trim(),
            ghost: style.getPropertyValue('--ghost-spiral-color').trim()
        };

        // Render the math formula using KaTeX
        katex.render("N = a^b + c", document.getElementById('math-formula'), { throwOnError: false });
        resizeCanvas();
        updateAndRun(false);
    });
    window.addEventListener('resize', resizeCanvas);
</script>
</body>
</html>



