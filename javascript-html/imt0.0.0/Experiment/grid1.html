<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
    <title>Codex Gnomonicus v23: Infinite Navigator</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Caveat:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/big-integer@1.6.48/BigInteger.min.js"></script>

    <style>
        body { 
            margin: 0; overflow: hidden; height: 100vh; width: 100vw; 
            touch-action: none;
            background-color: #f3e5ab;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)' opacity='0.1'/%3E%3C/svg%3E");
            font-family: 'Caveat', cursive, sans-serif;
        }

        #hud {
            position: absolute; top: 0; left: 0; width: 100%; 
            padding: 15px; box-sizing: border-box; pointer-events: none;
            display: flex; justify-content: space-between;
            color: #5d4037; font-weight: bold; z-index: 10;
        }
        .ink-stat { font-size: 1.8rem; }
        .ink-label { font-size: 1rem; text-transform: uppercase; letter-spacing: 2px; opacity: 0.7; }

        #nav-dash {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 90%; max-width: 400px; padding: 25px;
            background: #fdfbf7; border: 3px solid #5d4037;
            box-shadow: 10px 10px 0px rgba(93, 64, 55, 0.3);
            display: none; z-index: 30;
        }
        .nav-input-group { margin-bottom: 15px; }
        .nav-input-group label { display: block; margin-bottom: 5px; color: #5d4037; font-weight: bold; }
        .nav-input-group input { width: 100%; padding: 10px; border: 2px solid #5d4037; background: #f3e5ab; font-family: monospace; font-size: 1.1rem; box-sizing: border-box; }

        #detail-dock {
            position: absolute; top: 15px; right: 15px;
            width: 320px; padding: 20px;
            background: rgba(253, 251, 247, 0.95);
            border: 3px solid #5d4037;
            border-radius: 4px;
            box-shadow: 5px 5px 15px rgba(93, 64, 55, 0.2);
            color: #5d4037;
            display: none;
            z-index: 20;
            pointer-events: auto;
            max-height: 80vh;
            overflow-y: auto;
        }
        .dock-title { font-size: 1.8rem; border-bottom: 2px solid #5d4037; margin-bottom: 10px; color: #c62828; }
        .dock-val { font-family: monospace; font-size: 1.1rem; word-break: break-all; margin-bottom: 10px; background: rgba(0,0,0,0.05); padding: 5px; }

        #controls {
            position: absolute; bottom: 30px; left: 20px;
            display: flex; gap: 15px; pointer-events: auto; z-index: 10;
        }
        
        .ink-btn {
            background: rgba(253, 251, 247, 0.9);
            border: 3px solid #5d4037;
            color: #5d4037;
            padding: 10px 20px;
            font-family: 'Caveat', cursive;
            font-size: 1.4rem;
            font-weight: 700;
            border-radius: 255px 15px 225px 15px / 15px 225px 15px 255px;
            cursor: pointer;
            user-select: none;
        }
    </style>
</head>
<body>

    <canvas id="gridCanvas"></canvas>

    <div id="hud">
        <div>
            <div class="ink-label">Row (k)</div>
            <div id="disp-k" class="ink-stat">0</div>
        </div>
        <div style="text-align:right;">
            <div class="ink-label">Scale</div>
            <div id="disp-zoom" class="ink-stat">1.0x</div>
        </div>
    </div>

    <div id="nav-dash">
        <div class="dock-title">Navigate Codex</div>
        
        <div class="nav-input-group">
            <label>By Row (k) & Col (c)</label>
            <div style="display:flex; gap:10px;">
                <input type="text" id="jump-k" placeholder="Row">
                <input type="text" id="jump-c" placeholder="Col">
            </div>
        </div>

        <div class="nav-input-group">
            <label>By Phase ID (a.q.r)</label>
            <input type="text" id="jump-aqr" placeholder="543.18.4">
        </div>

        <div class="nav-input-group">
            <label>By Tape ID (Linear Index)</label>
            <input type="text" id="jump-tape" placeholder="12345">
        </div>

        <div class="nav-input-group">
            <label>By Cargo Value (Search)</label>
            <input type="text" id="jump-cargo" placeholder="1007">
        </div>

        <div style="display:flex; gap:10px; margin-top:20px;">
            <button class="ink-btn" style="flex:1;" onclick="executeJump()">Execute</button>
            <button class="ink-btn" style="flex:1;" onclick="toggleNav()">Cancel</button>
        </div>
    </div>

    <div id="detail-dock">
        <div id="dock-gnomon" class="dock-title">Gnomon #--</div>
        <div class="ink-label">Full Cargo Value:</div>
        <div id="dock-full-val" class="dock-val">--</div>
        <div class="dock-meta" id="dock-id" style="color: #2e7d32; font-size: 1.4rem;">ID: --</div>
        <div id="dock-factors" style="color: #d32f2f; font-weight: bold;"></div>
        <hr style="border: 0; border-top: 1px dashed #5d4037; margin: 15px 0;">
        <div style="color: #c62828;">
            <div>Row Σ: <span id="dock-row-sum">--</span></div>
            <div>Col Σ: <span id="dock-col-sum">--</span></div>
            <div style="font-size: 1.4rem; margin-top: 5px;">Total Σ: <span id="dock-total-sum">--</span></div>
        </div>
        <button class="ink-btn" style="width: 100%; margin-top: 15px;" onclick="closeDock()">Clear</button>
    </div>

    <div id="controls">
        <button class="ink-btn" onclick="resetView()">Origin</button>
        <button class="ink-btn" onclick="toggleNav()">Jump</button>
    </div>

    <script>
        const canvas = document.getElementById("gridCanvas");
        const ctx = canvas.getContext("2d", { alpha: false });

        const CELL_W = 120, CELL_H = 70;
        const C_PAPER = "#f3e5ab", C_INK = "#5d4037", C_GOLD = "#b45309", C_TRACE = "#c62828";

        let scale = 1.0, offsetX = 0, offsetY = 150;
        let activeTool = null, lastPan = null, lastTouchDist = 0, selectedCell = null;

        function init() {
            window.addEventListener('resize', onResize);
            onResize();
            resetView();
            requestAnimationFrame(draw);
        }

        function onResize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            draw();
        }

        function resetView() {
            scale = 1.0;
            offsetX = canvas.width / 2;
            offsetY = 150;
            selectedCell = null;
            closeDock();
            draw();
        }

        function customSqrt(n) { 
            if (n.isNegative()) return bigInt(-1); 
            if (n.lesserOrEquals(1)) return n; 
            let x = n.shiftRight(1), y; 
            while (true) { 
                y = x.add(n.divide(x)).shiftRight(1); 
                if (y.geq(x)) return x; 
                x = y; 
            }
        }

        function toggleNav() {
            const dash = document.getElementById('nav-dash');
            dash.style.display = dash.style.display === 'block' ? 'none' : 'block';
        }

        // --- OPTIMIZED JUMP LOGIC ---
        function executeJump() {
            const kVal = document.getElementById('jump-k').value;
            const cVal = document.getElementById('jump-c').value;
            const aqrVal = document.getElementById('jump-aqr').value;
            const tapeVal = document.getElementById('jump-tape').value;
            const cargoVal = document.getElementById('jump-cargo').value;

            let targetK = null, targetC = 0n;

            try {
                if (kVal !== "") {
                    targetK = bigInt(kVal);
                    targetC = cVal !== "" ? bigInt(cVal) : 0n;
                } else if (aqrVal !== "") {
                    const parts = aqrVal.split('.');
                    if (parts.length === 3) {
                        const a = bigInt(parts[0]);
                        const q = bigInt(parts[1]);
                        const r = bigInt(parts[2]);
                        const G = q.multiply(8).plus(r);
                        targetK = a.minus(1).divide(2);
                        const A = targetK.multiply(2).plus(1);
                        targetC = G.divide(A.multiply(2));
                    }
                } else if (tapeVal !== "") {
                    let T = bigInt(tapeVal);
                    let inner = T.minus(1).multiply(8).plus(1);
                    let root = customSqrt(inner);
                    targetK = root.minus(1).divide(2);
                    let rowStartTape = targetK.multiply(targetK.plus(1)).divide(2).plus(1);
                    targetC = T.minus(rowStartTape);
                } else if (cargoVal !== "") {
                    let N = bigInt(cargoVal).abs();
                    let a = customSqrt(N);
                    if (a.square().lesser(N)) a = a.plus(1);
                    if (a.isEven()) a = a.plus(1);
                    targetK = a.minus(1).divide(2);
                    targetC = a.square().minus(N).divide(a.multiply(2));
                }

                if (targetK !== null) {
                    offsetX = (canvas.width / 2) - (Number(targetC.toString()) * CELL_W * scale);
                    offsetY = (canvas.height / 2) - (Number(targetK.toString()) * CELL_H * scale);
                    selectedCell = { c: Number(targetC.toString()), k: Number(targetK.toString()) };
                    updateDock(selectedCell.c, selectedCell.k);
                    toggleNav();
                    draw();
                }
            } catch (err) { alert("Invalid Address"); }
        }

        function formatGridValue(val) {
            let str = val.toString();
            return str.length > 7 ? str.substring(0, 3) + ".." + str.substring(str.length - 2) : str;
        }

        function draw() {
            if (!Number.isFinite(scale) || scale <= 0) scale = 1.0;
            ctx.fillStyle = C_PAPER;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            let minX = (0 - offsetX) / scale, maxX = (canvas.width - offsetX) / scale;
            let minY = (0 - offsetY) / scale, maxY = (canvas.height - offsetY) / scale;
            let minK = Math.max(0, Math.floor(minY / CELL_H)), maxK = Math.floor(maxY / CELL_H) + 1;

            document.getElementById('disp-k').innerText = Math.max(0, Math.floor((minK + maxK) / 2));
            document.getElementById('disp-zoom').innerText = scale.toFixed(2) + "x";

            ctx.save();
            ctx.translate(offsetX, offsetY);
            ctx.scale(scale, scale);

            ctx.strokeStyle = "#3e2723"; ctx.lineWidth = 4 / Math.sqrt(scale); ctx.lineCap = "round";
            let drawK = Math.min(maxK + 100, minK + 5000);
            ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(-drawK * CELL_W, drawK * CELL_H); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(drawK * CELL_W, drawK * CELL_H); ctx.stroke();
            ctx.strokeStyle = "rgba(180, 83, 9, 0.2)"; ctx.lineWidth = 2 / scale;
            ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(0, drawK * CELL_H); ctx.stroke();

            if (scale > 0.35) {
                ctx.font = "bold 36px 'Caveat', monospace"; ctx.textAlign = "center"; ctx.textBaseline = "middle";
                for (let k = minK; k <= maxK; k++) {
                    let rowY = k * CELL_H, bigK = bigInt(k), A = bigK.multiply(2).plus(1);
                    let spineVal = A.square(), step = A.multiply(2);
                    let startC = Math.max(Math.floor(minX / CELL_W), -k), endC = Math.min(Math.ceil(maxX / CELL_W), k);
                    for (let c = startC; c <= endC; c++) {
                        let val = c === 0 ? spineVal : (c > 0 ? spineVal.minus(bigInt(c).multiply(step)) : spineVal.minus(bigInt(-c).multiply(step)).multiply(-1));
                        ctx.fillStyle = c === 0 ? C_GOLD : C_INK;
                        ctx.fillText(formatGridValue(val), c * CELL_W, rowY);
                    }
                }
            } else {
                ctx.fillStyle = "rgba(93, 64, 55, 0.3)";
                let stride = Math.ceil(1/scale/2);
                for (let k = minK; k <= maxK; k += stride) {
                    for (let c = -k; c <= k; c += stride) {
                        ctx.beginPath(); ctx.arc(c * CELL_W, k * CELL_H, 4/scale, 0, Math.PI*2); ctx.fill();
                    }
                }
            }

            if (selectedCell) {
                let rowY = selectedCell.k * CELL_H, targetX = selectedCell.c * CELL_W;
                ctx.strokeStyle = C_TRACE; ctx.lineWidth = 4 / scale;
                ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(0, rowY); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(0, rowY); ctx.lineTo((selectedCell.c >= 0 ? selectedCell.k : -selectedCell.k) * CELL_W, rowY); ctx.stroke();
                ctx.beginPath(); ctx.arc(targetX, rowY, 30/scale, 0, Math.PI*2); ctx.stroke();
            }
            ctx.restore();
        }

        function updateDock(c, k) {
            let bigK = bigInt(k), A = bigK.multiply(2).plus(1), spineVal = A.square(), step = A.multiply(2), absC = bigInt(Math.abs(c));
            let valRaw = spineVal.minus(absC.multiply(step)), val = c >= 0 ? valRaw : valRaw.multiply(-1);
            let phaseN = val.abs();
            let anchor = customSqrt(phaseN); if (anchor.square().lesser(phaseN)) anchor = anchor.plus(1);
            let gap = anchor.square().minus(phaseN), q = gap.divide(8), r = gap.mod(8);
            let gapRoot = customSqrt(gap), factors = (gapRoot.square().equals(gap) && gap.greater(0)) ? `Factors: ${anchor.minus(gapRoot)} × ${anchor.plus(gapRoot)}` : "";
            let n = bigK, vSum = n.plus(1).multiply(n.multiply(2).plus(1)).multiply(n.multiply(2).plus(3)).divide(3);
            let hSum = absC.plus(1).multiply(spineVal.plus(valRaw)).divide(2);

            document.getElementById('dock-gnomon').innerText = `Gnomon #${k}`;
            document.getElementById('dock-full-val').innerText = val.toString();
            document.getElementById('dock-id').innerText = `ID: ${anchor}.${q}.${r}`;
            document.getElementById('dock-factors').innerText = factors;
            document.getElementById('dock-row-sum').innerText = vSum.toString();
            document.getElementById('dock-col-sum').innerText = hSum.toString();
            document.getElementById('dock-total-sum').innerText = vSum.plus(hSum).minus(spineVal).toString();
            document.getElementById('detail-dock').style.display = 'block';
        }

        function closeDock() { selectedCell = null; document.getElementById('detail-dock').style.display = 'none'; draw(); }

        canvas.addEventListener('mousedown', e => { activeTool = 'pan'; lastPan = { x: e.clientX, y: e.clientY }; });
        window.addEventListener('mousemove', e => { if (activeTool === 'pan') { offsetX += e.clientX - lastPan.x; offsetY += e.clientY - lastPan.y; lastPan = { x: e.clientX, y: e.clientY }; requestAnimationFrame(draw); } });
        window.addEventListener('mouseup', () => activeTool = null);
        canvas.addEventListener('wheel', e => { e.preventDefault(); let f = Math.pow(1.001, -e.deltaY); offsetX = e.clientX - (e.clientX - offsetX) * f; offsetY = e.clientY - (e.clientY - offsetY) * f; scale *= f; requestAnimationFrame(draw); }, { passive: false });
        canvas.addEventListener('touchstart', e => { if (e.touches.length === 1) { activeTool = 'pan'; lastPan = { x: e.touches[0].clientX, y: e.touches[0].clientY }; } else if (e.touches.length === 2) { activeTool = 'zoom'; lastTouchDist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY); lastPan = { x: (e.touches[0].clientX + e.touches[1].clientX)/2, y: (e.touches[0].clientY + e.touches[1].clientY)/2 }; } }, {passive:false});
        canvas.addEventListener('touchmove', e => { e.preventDefault(); if (activeTool === 'pan' && e.touches.length === 1) { offsetX += e.touches[0].clientX - lastPan.x; offsetY += e.touches[0].clientY - lastPan.y; lastPan = { x: e.touches[0].clientX, y: e.touches[0].clientY }; requestAnimationFrame(draw); } else if (activeTool === 'zoom' && e.touches.length === 2) { let d = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY); let mid = { x: (e.touches[0].clientX + e.touches[1].clientX)/2, y: (e.touches[0].clientY + e.touches[1].clientY)/2 }; let f = d / lastTouchDist; offsetX = mid.x - (mid.x - offsetX) * f; offsetY = mid.y - (mid.y - offsetY) * f; scale *= f; lastTouchDist = d; lastPan = mid; requestAnimationFrame(draw); } }, {passive:false});
        canvas.addEventListener('touchend', () => activeTool = null);
        canvas.addEventListener('click', e => {
            if (activeTool) return;
            let wx = (e.clientX - offsetX) / scale, wy = (e.clientY - offsetY) / scale;
            let c = Math.round(wx / CELL_W), k = Math.round(wy / CELL_H);
            if (k >= 0 && Math.abs(c) <= k) { selectedCell = { c, k }; updateDock(c, k); } else { closeDock(); }
            draw();
        });

        init();
    </script>
</body>
</html>
