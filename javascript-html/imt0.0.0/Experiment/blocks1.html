<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Tablet Block Lab</title>
    <style>
        /* FORCE LOCK THE PAGE */
        html, body {
            margin: 0; padding: 0;
            width: 100%; height: 100%;
            overflow: hidden;
            background-color: #ffffff;
            font-family: monospace;
            touch-action: none; /* Crucial for Android */
            user-select: none;
            -webkit-user-select: none;
        }

        #ui-layer {
            position: fixed; top: 0; left: 0; width: 100%; height: 0; z-index: 999;
        }

        #controls {
            margin: 10px;
            background: rgba(255, 255, 255, 0.95);
            padding: 10px;
            border: 2px solid #333;
            border-radius: 8px;
            display: inline-flex;
            gap: 10px;
            align-items: center;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        /* Debug info to help you see if it detects fingers */
        #debug-info {
            position: fixed; bottom: 10px; right: 10px;
            background: rgba(0,0,0,0.5); color: #fff;
            padding: 4px 8px; font-size: 10px;
            pointer-events: none; z-index: 1000;
        }

        input { width: 50px; padding: 5px; text-align: center; border: 1px solid #ccc; font-size: 16px; }
        button { padding: 8px 16px; background: #333; color: white; border: none; border-radius: 4px; font-size: 16px; }
        button.clear { background: #d9534f; }

        /* THE STAGE */
        #viewport {
            width: 100%; height: 100%;
            position: relative;
            background-color: #f4f4f4;
            touch-action: none;
        }

        #world {
            position: absolute;
            top: 0; left: 0;
            width: 0; height: 0;
            transform-origin: 0 0;
            will-change: transform;
        }

        .grid-bg {
            position: absolute;
            left: -5000px; top: -5000px;
            width: 10000px; height: 10000px;
            background-image: 
                linear-gradient(#ccc 1px, transparent 1px),
                linear-gradient(90deg, #ccc 1px, transparent 1px);
            background-size: 50px 50px;
        }
        
        /* Stronger lines every 5 blocks (250px) */
        .grid-bg::after {
            content: ''; position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background-image: 
                linear-gradient(rgba(0, 0, 0, 0.2) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 0, 0, 0.2) 1px, transparent 1px);
            background-size: 250px 250px;
            pointer-events: none;
        }

        .block {
            position: absolute;
            width: 50px; height: 50px;
            background-color: #FFD700;
            border: 1px solid #333;
            box-sizing: border-box;
            display: flex; justify-content: center; align-items: center;
            font-size: 14px; font-weight: bold;
            box-shadow: 2px 2px 4px rgba(0,0,0,0.2);
            touch-action: none; 
        }

        .block.dragging {
            z-index: 1000;
            background-color: #ffeeb0;
            box-shadow: 10px 10px 20px rgba(0,0,0,0.3);
            transform: scale(1.05);
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div id="controls">
            <input type="number" id="blockCount" value="21">
            <button id="spawnBtn">Add</button>
            <button class="clear" id="clearBtn">Reset</button>
        </div>
    </div>
    
    <div id="debug-info">Ready</div>

    <div id="viewport">
        <div id="world">
            <div class="grid-bg"></div>
        </div>
    </div>

    <script>
        const GRID_SIZE = 50;
        const viewport = document.getElementById('viewport');
        const world = document.getElementById('world');
        const debug = document.getElementById('debug-info');

        // STATE
        let scale = 1;
        let panX = 0;
        let panY = 0;

        // POINTER CACHE (Multi-touch handling)
        let evCache = [];
        let prevDiff = -1;

        // BLOCK DRAG STATE
        let activeBlock = null;
        let blockOffset = { x: 0, y: 0 };
        let isBlockDragging = false;
        let blockStartX = 0;
        let blockStartY = 0;
        let blockHasMoved = false;

        // --- MATH HELPERS ---
        function updateTransform() {
            world.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
            // visual debug of grid center
            debug.innerText = `Pan: ${Math.round(panX)},${Math.round(panY)} Scale: ${scale.toFixed(2)}`;
        }

        function toWorld(sx, sy) {
            return { x: (sx - panX) / scale, y: (sy - panY) / scale };
        }

        // --- POINTER EVENTS (THE FIX) ---
        // Pointer events work for Mouse, Touch, and Pen uniformly

        function ptrDown(e) {
            // Check if we hit a block first
            if(e.target.classList.contains('block')) {
                startBlockDrag(e);
                return;
            }

            // Otherwise, viewport interaction
            evCache.push(e);
            viewport.setPointerCapture(e.pointerId);
        }

        function ptrMove(e) {
            // 1. Handle Block Drag
            if (activeBlock) {
                handleBlockDrag(e);
                return;
            }

            // 2. Handle Viewport Pan/Zoom
            // Find this event in the cache and update it
            const index = evCache.findIndex(ev => ev.pointerId === e.pointerId);
            if (index > -1) {
                evCache[index] = e;
            } else {
                return; // Not tracking this pointer
            }

            // If 1 pointer -> PAN
            if (evCache.length === 1) {
                const dx = e.movementX; 
                const dy = e.movementY;
                // movementX is modern API, much easier than tracking lastX manually
                panX += dx;
                panY += dy;
                updateTransform();
            }
            // If 2 pointers -> PINCH ZOOM
            else if (evCache.length === 2) {
                // Calculate distance between two fingers
                const curDiff = Math.hypot(
                    evCache[0].clientX - evCache[1].clientX,
                    evCache[0].clientY - evCache[1].clientY
                );

                // Calculate center point between fingers
                const midX = (evCache[0].clientX + evCache[1].clientX) / 2;
                const midY = (evCache[0].clientY + evCache[1].clientY) / 2;

                if (prevDiff > 0) {
                    // Determine change in zoom
                    const zoomStep = curDiff / prevDiff;
                    const newScale = Math.min(Math.max(scale * zoomStep, 0.2), 4.0);

                    // Math to zoom towards the midpoint (the fingers)
                    // The world point under the midpoint must stay under the midpoint
                    // worldPoint = (mid - pan) / scale
                    // NewPan = mid - worldPoint * newScale
                    
                    const worldPointX = (midX - panX) / scale;
                    const worldPointY = (midY - panY) / scale;

                    panX = midX - worldPointX * newScale;
                    panY = midY - worldPointY * newScale;
                    scale = newScale;

                    updateTransform();
                }
                prevDiff = curDiff;
            }
        }

        function ptrUp(e) {
            // Remove from cache
            const index = evCache.findIndex(ev => ev.pointerId === e.pointerId);
            if (index > -1) {
                evCache.splice(index, 1);
            }
            
            // Reset pinch math if we drop to < 2 fingers
            if (evCache.length < 2) prevDiff = -1;

            if (activeBlock && activeBlock.pointerId === e.pointerId) {
                endBlockDrag(e);
            }
        }

        // --- BLOCK LOGIC ---
        function startBlockDrag(e) {
            activeBlock = e.target;
            activeBlock.pointerId = e.pointerId; // Remember which finger grabbed it
            activeBlock.setPointerCapture(e.pointerId);

            isBlockDragging = true;
            blockHasMoved = false;
            
            blockStartX = e.clientX;
            blockStartY = e.clientY;

            const worldPos = toWorld(e.clientX, e.clientY);
            const bx = parseFloat(activeBlock.style.left);
            const by = parseFloat(activeBlock.style.top);

            blockOffset.x = worldPos.x - bx;
            blockOffset.y = worldPos.y - by;
        }

        function handleBlockDrag(e) {
            if(!activeBlock) return;
            
            // Check threshold for "Tap vs Drag"
            if (!blockHasMoved) {
                const dist = Math.hypot(e.clientX - blockStartX, e.clientY - blockStartY);
                if (dist > 5) {
                    blockHasMoved = true;
                    activeBlock.classList.add('dragging');
                }
            }

            const worldPos = toWorld(e.clientX, e.clientY);
            activeBlock.style.left = (worldPos.x - blockOffset.x) + 'px';
            activeBlock.style.top = (worldPos.y - blockOffset.y) + 'px';
        }

        function endBlockDrag(e) {
            if (!activeBlock) return;

            activeBlock.classList.remove('dragging');
            activeBlock.releasePointerCapture(e.pointerId);

            if (!blockHasMoved) {
                // IT WAS A TAP
                const currentVal = activeBlock.textContent;
                const newVal = prompt("Change Block Number:", currentVal);
                if (newVal) activeBlock.textContent = newVal;
            } else {
                // IT WAS A DRAG -> SNAP
                const rawX = parseFloat(activeBlock.style.left);
                const rawY = parseFloat(activeBlock.style.top);
                const snapX = Math.round(rawX / GRID_SIZE) * GRID_SIZE;
                const snapY = Math.round(rawY / GRID_SIZE) * GRID_SIZE;
                activeBlock.style.left = snapX + 'px';
                activeBlock.style.top = snapY + 'px';
            }

            activeBlock = null;
            isBlockDragging = false;
        }


        // --- SETUP LISTENERS ---
        // We attach pointer events to the Viewport
        viewport.addEventListener('pointerdown', ptrDown);
        viewport.addEventListener('pointermove', ptrMove);
        viewport.addEventListener('pointerup', ptrUp);
        viewport.addEventListener('pointercancel', ptrUp);
        viewport.addEventListener('pointerleave', ptrUp);

        // Prevent standard touch gestures (zooming the whole browser)
        document.addEventListener('gesturestart', function(e) { e.preventDefault(); });


        // --- UI ---
        document.getElementById('spawnBtn').addEventListener('click', () => {
            const count = parseInt(document.getElementById('blockCount').value);
            const current = document.querySelectorAll('.block').length;
            for(let i=0; i<count; i++) createBlock(current + i + 1);
        });

        document.getElementById('clearBtn').addEventListener('click', () => {
            document.querySelectorAll('.block').forEach(b => b.remove());
            // Center View
            panX = window.innerWidth/2 - 200;
            panY = window.innerHeight/2 - 200;
            scale = 1.0;
            updateTransform();
        });

        function createBlock(id) {
            const b = document.createElement('div');
            b.className = 'block';
            b.textContent = id;
            b.id = 'b'+id;
            
            // Spawn near center
            const cx = 150 + ( (id%10) * GRID_SIZE );
            const cy = 150 + ( Math.floor(id/10) * GRID_SIZE );
            
            b.style.left = cx + 'px';
            b.style.top = cy + 'px';
            world.appendChild(b);
        }

        // INIT
        window.onload = () => {
            panX = window.innerWidth/2 - 250;
            panY = window.innerHeight/2 - 250;
            updateTransform();
            for(let i=1; i<=21; i++) createBlock(i);
        };

    </script>
</body>
</html>
