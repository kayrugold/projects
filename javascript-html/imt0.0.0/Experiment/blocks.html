<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Precision Block Lab</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #ffffff; /* White Background */
            font-family: monospace;
            touch-action: none; 
        }

        #ui-layer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 0;
            z-index: 999;
        }

        #controls {
            margin: 10px;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border: 2px solid #333;
            border-radius: 8px;
            display: inline-flex;
            gap: 10px;
            align-items: center;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        input { width: 50px; padding: 5px; text-align: center; border: 1px solid #ccc; }
        button { padding: 6px 12px; background: #333; color: white; border: none; cursor: pointer; }
        button.clear { background: #d9534f; }

        /* The Viewport */
        #viewport {
            width: 100%;
            height: 100%;
            position: relative;
            overflow: hidden;
            background-color: #f0f0f0;
        }

        /* The World */
        #world {
            position: absolute;
            top: 0;
            left: 0;
            width: 0; 
            height: 0;
            transform-origin: 0 0;
            will-change: transform;
        }

        .grid-bg {
            position: absolute;
            left: -5000px;
            top: -5000px;
            width: 10000px;
            height: 10000px;
            background-color: #ffffff;
            background-image: 
                linear-gradient(#e0e0e0 1px, transparent 1px),
                linear-gradient(90deg, #e0e0e0 1px, transparent 1px);
            background-size: 50px 50px;
        }
        
        .grid-bg::after {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background-image: 
                linear-gradient(rgba(100, 149, 237, 0.3) 1px, transparent 1px),
                linear-gradient(90deg, rgba(100, 149, 237, 0.3) 1px, transparent 1px);
            background-size: 250px 250px;
            pointer-events: none;
        }

        .block {
            position: absolute;
            width: 50px;
            height: 50px;
            background-color: #FFD700;
            border: 1px solid #333;
            box-sizing: border-box;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 14px;
            font-weight: bold;
            user-select: none;
            box-shadow: 2px 2px 4px rgba(0,0,0,0.2);
            touch-action: none; 
        }

        .block.dragging {
            z-index: 1000;
            background-color: #ffeeb0;
            box-shadow: 5px 5px 15px rgba(0,0,0,0.4);
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div id="controls">
            <input type="number" id="blockCount" value="21">
            <button id="spawnBtn">Add</button>
            <button class="clear" id="clearBtn">Reset</button>
        </div>
    </div>

    <div id="viewport">
        <div id="world">
            <div class="grid-bg"></div>
        </div>
    </div>

    <script>
        const GRID_SIZE = 50;
        const viewport = document.getElementById('viewport');
        const world = document.getElementById('world');
        
        let scale = 1;
        let panX = 0;
        let panY = 0;

        // BLOCK INTERACTION STATE
        let isInteractingBlock = false;
        let activeBlock = null;
        let blockOffset = { x: 0, y: 0 };
        
        // JITTER FIX STATE
        let blockStartX = 0; // Where finger started on screen
        let blockStartY = 0;
        let hasMovedBeyondThreshold = false; // The key flag
        
        // VIEWPORT STATE
        let isPanning = false;
        let lastPanPoint = { x: 0, y: 0 };
        let initialPinchDist = 0;
        let initialScale = 1;
        let pinchCenterWorldStart = { x: 0, y: 0 };

        function updateTransform() {
            world.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
        }

        function toWorld(sx, sy) {
            return {
                x: (sx - panX) / scale,
                y: (sy - panY) / scale
            };
        }

        // --- VIEWPORT HANDLERS ---
        viewport.addEventListener('touchstart', (e) => {
            if (e.target.classList.contains('block')) return;
            e.preventDefault();

            if (e.touches.length === 1) {
                isPanning = true;
                lastPanPoint = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            } 
            else if (e.touches.length === 2) {
                isPanning = false;
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                initialPinchDist = Math.hypot(dx, dy);
                initialScale = scale;

                const cx = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                const cy = (e.touches[0].clientY + e.touches[1].clientY) / 2;
                pinchCenterWorldStart = toWorld(cx, cy);
            }
        }, { passive: false });

        viewport.addEventListener('touchmove', (e) => {
            if (e.target.classList.contains('block') && isInteractingBlock) return;
            e.preventDefault();

            if (isPanning && e.touches.length === 1) {
                const currentX = e.touches[0].clientX;
                const currentY = e.touches[0].clientY;
                const dx = currentX - lastPanPoint.x;
                const dy = currentY - lastPanPoint.y;
                panX += dx;
                panY += dy;
                lastPanPoint = { x: currentX, y: currentY };
                updateTransform();
            } 
            else if (e.touches.length === 2) {
                const t1 = e.touches[0];
                const t2 = e.touches[1];
                const dx = t1.clientX - t2.clientX;
                const dy = t1.clientY - t2.clientY;
                const dist = Math.hypot(dx, dy);
                const zoomFactor = dist / initialPinchDist;
                const newScale = Math.min(Math.max(initialScale * zoomFactor, 0.2), 4.0);
                
                const cx = (t1.clientX + t2.clientX) / 2;
                const cy = (t1.clientY + t2.clientY) / 2;

                panX = cx - (pinchCenterWorldStart.x * newScale);
                panY = cy - (pinchCenterWorldStart.y * newScale);
                scale = newScale;
                updateTransform();
            }
        }, { passive: false });

        viewport.addEventListener('touchend', () => { isPanning = false; });

        // --- BLOCK HANDLERS ---
        function createBlock(id) {
            const el = document.createElement('div');
            el.className = 'block';
            el.textContent = id;
            el.id = 'blk-' + id;
            
            const cols = 10;
            const r = Math.floor((id-1) / cols);
            const c = (id-1) % cols;
            const wx = 200 + (c * GRID_SIZE);
            const wy = 200 + (r * GRID_SIZE);

            el.style.left = wx + 'px';
            el.style.top = wy + 'px';

            el.addEventListener('touchstart', onBlockTouchStart, { passive: false });
            world.appendChild(el);
        }

        function onBlockTouchStart(e) {
            e.preventDefault(); 
            e.stopPropagation();
            
            const touch = e.touches[0];
            activeBlock = e.target;
            
            // RESET FLAGS
            isInteractingBlock = true;
            hasMovedBeyondThreshold = false;
            
            // Record where the finger started (Screen Coordinates)
            blockStartX = touch.clientX;
            blockStartY = touch.clientY;

            // Calculate Offset
            const worldTouch = toWorld(touch.clientX, touch.clientY);
            const blockX = parseFloat(activeBlock.style.left);
            const blockY = parseFloat(activeBlock.style.top);
            blockOffset.x = worldTouch.x - blockX;
            blockOffset.y = worldTouch.y - blockY;

            // We do NOT add the 'dragging' class yet. We wait until it moves.
            
            window.addEventListener('touchmove', onBlockTouchMove, { passive: false });
            window.addEventListener('touchend', onBlockTouchEnd);
        }

        function onBlockTouchMove(e) {
            if (!isInteractingBlock) return;
            e.preventDefault();
            const touch = e.touches[0];
            
            // 1. Check if we moved enough to call it a "Drag"
            if (!hasMovedBeyondThreshold) {
                const dist = Math.hypot(touch.clientX - blockStartX, touch.clientY - blockStartY);
                if (dist > 5) { // 5 pixel threshold
                    hasMovedBeyondThreshold = true;
                    activeBlock.classList.add('dragging'); // Now it looks like dragging
                } else {
                    return; // Ignore tiny jitters
                }
            }

            // 2. Perform the Drag
            const worldPos = toWorld(touch.clientX, touch.clientY);
            activeBlock.style.left = (worldPos.x - blockOffset.x) + 'px';
            activeBlock.style.top = (worldPos.y - blockOffset.y) + 'px';
        }

        function onBlockTouchEnd(e) {
            if (!isInteractingBlock) return;
            
            activeBlock.classList.remove('dragging');
            
            // DECISION: TAP OR DRAG?
            if (!hasMovedBeyondThreshold) {
                // IT WAS A TAP (Movement < 5px)
                const currentVal = activeBlock.textContent;
                const newVal = prompt("Change Block Number:", currentVal);
                if (newVal !== null && newVal !== "") {
                    activeBlock.textContent = newVal;
                }
            } else {
                // IT WAS A DRAG -> SNAP
                const rawX = parseFloat(activeBlock.style.left);
                const rawY = parseFloat(activeBlock.style.top);
                const snappedX = Math.round(rawX / GRID_SIZE) * GRID_SIZE;
                const snappedY = Math.round(rawY / GRID_SIZE) * GRID_SIZE;
                activeBlock.style.left = snappedX + 'px';
                activeBlock.style.top = snappedY + 'px';
            }

            isInteractingBlock = false;
            activeBlock = null;

            window.removeEventListener('touchmove', onBlockTouchMove);
            window.removeEventListener('touchend', onBlockTouchEnd);
        }

        // --- UI ---
        document.getElementById('spawnBtn').addEventListener('click', () => {
            const count = parseInt(document.getElementById('blockCount').value);
            const currentTotal = document.querySelectorAll('.block').length;
            for(let i = 0; i < count; i++) createBlock(currentTotal + i + 1);
        });

        document.getElementById('clearBtn').addEventListener('click', () => {
            document.querySelectorAll('.block').forEach(b => b.remove());
            panX = window.innerWidth / 2 - 350;
            panY = window.innerHeight / 2 - 300;
            scale = 1;
            updateTransform();
        });

        window.onload = () => {
             panX = window.innerWidth / 2 - 350;
             panY = window.innerHeight / 2 - 300;
             updateTransform();
             for(let i=0; i<21; i++) createBlock(i+1);
        };
    </script>
</body>
</html>
