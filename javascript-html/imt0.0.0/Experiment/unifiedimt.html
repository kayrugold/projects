<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>CODEX GNOMONICUS</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Caveat:wght@400;700&display=swap" rel="stylesheet">

    <style>
        /* PARCHMENT TEXTURE */
        body { 
            margin: 0; overflow: hidden; height: 100vh; width: 100vw; 
            touch-action: none;
            background-color: #f3e5ab;
            background-image: 
                radial-gradient(circle at 50% 50%, #fdfbf7 0%, #f3e5ab 60%, #e6d295 100%),
                url("data:image/svg+xml,%3Csvg width='200' height='200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)' opacity='0.05'/%3E%3C/svg%3E");
            font-family: 'Caveat', cursive;
        }

        /* INK UI */
        #hud {
            position: absolute; top: 0; left: 0; width: 100%; 
            padding: 15px; box-sizing: border-box; pointer-events: none;
            display: flex; justify-content: space-between;
            color: #5d4037; opacity: 0.8;
        }
        .ink-stat { font-size: 1.5rem; font-weight: bold; }
        .ink-label { font-size: 1rem; text-transform: uppercase; letter-spacing: 2px; }

        #controls {
            position: absolute; bottom: 20px; right: 20px;
            display: flex; flex-direction: column; gap: 10px; pointer-events: auto;
        }
        
        .ink-btn {
            background: transparent;
            border: 2px solid #5d4037;
            color: #5d4037;
            padding: 8px 15px;
            font-family: 'Caveat', cursive;
            font-size: 1.2rem;
            font-weight: bold;
            border-radius: 255px 15px 225px 15px / 15px 225px 15px 255px; /* Hand-drawn shape */
            cursor: pointer;
            transition: all 0.2s;
        }
        .ink-btn:active { background: #5d4037; color: #f3e5ab; transform: scale(0.95); }

        /* HOLOGRAPHIC INK CARD */
        #holo-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(93, 64, 55, 0.4); backdrop-filter: blur(2px);
            display: none; justify-content: center; align-items: center; pointer-events: auto;
        }
        #holo-card {
            background: #fdfbf7; 
            border: 2px solid #5d4037;
            width: 80%; max-width: 350px;
            padding: 30px; 
            box-shadow: 10px 10px 0px rgba(93, 64, 55, 0.2);
            color: #5d4037;
            position: relative;
        }
        .hand-title { font-size: 2rem; border-bottom: 2px solid #5d4037; margin-bottom: 15px; text-align: center; }
        .hand-row { display: flex; justify-content: space-between; font-size: 1.5rem; margin-bottom: 5px; }
        .hand-note { font-size: 1rem; color: #8d6e63; margin-top: 15px; font-style: italic; }

    </style>
</head>
<body>

    <canvas id="codexCanvas"></canvas>

    <div id="hud">
        <div>
            <div class="ink-label">Row Index (k)</div>
            <div id="disp-k" class="ink-stat">0</div>
        </div>
        <div style="text-align:right;">
            <div class="ink-label">Scale</div>
            <div id="disp-zoom" class="ink-stat">1.0x</div>
        </div>
    </div>

    <div id="controls">
        <button class="ink-btn" onclick="resetCam()">Return to Origin</button>
        <button class="ink-btn" onclick="jump()">Jump to Row</button>
    </div>

    <div id="holo-overlay" onclick="closeHolo()">
        <div id="holo-card" onclick="event.stopPropagation()">
            <div class="hand-title" id="h-val">--</div>
            
            <div class="hand-row">
                <span>Address:</span>
                <span id="h-addr" style="font-weight:bold">--</span>
            </div>
            <div class="hand-row">
                <span>Tape ID:</span>
                <span id="h-tape" style="color:#b45309">--</span>
            </div>
            
            <div class="hand-note" id="h-calc">
                Calculations...
            </div>
            
            <button class="ink-btn" style="width:100%; margin-top:20px;" onclick="closeHolo()">Close Journal</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('codexCanvas');
        const ctx = canvas.getContext('2d', { alpha: false });

        // INK COLORS
        const C_INK = "#5d4037";       // Main Text
        const C_INK_LIGHT = "#a1887f"; // Addresses
        const C_GOLD = "#b45309";      // Spine / Highlights
        const C_PAPER = "#f3e5ab";     // Background override

        // CONFIG
        const CELL_W = 120;
        const CELL_H = 70;

        // CAMERA
        let cam = { x: 0, y: 150, scale: 1.0 };
        let input = { dragging: false, lastX: 0, lastY: 0, lastDist: 0 };

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            render();
        }
        window.addEventListener('resize', resize);
        
        // --- RENDER LOOP ---
        function render() {
            // Clear to Parchment
            ctx.fillStyle = C_PAPER;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Viewport Calcs
            let cx = canvas.width / 2;
            let cy = canvas.height / 2;
            
            // Bounds
            let viewL = -cx / cam.scale - cam.x;
            let viewR = cx / cam.scale - cam.x;
            let viewT = -cy / cam.scale - cam.y;
            let viewB = cy / cam.scale - cam.y;

            let minK = Math.floor(viewT / CELL_H);
            let maxK = Math.floor(viewB / CELL_H) + 1;
            if (minK < 0) minK = 0;

            document.getElementById('disp-k').innerText = Math.floor((minK + maxK)/2);
            document.getElementById('disp-zoom').innerText = cam.scale.toFixed(2) + "x";

            // Transform
            ctx.save();
            ctx.translate(cx, cy);
            ctx.scale(cam.scale, cam.scale);
            ctx.translate(cam.x, cam.y);

            // Draw Spine Line (Faint Pencil Line)
            ctx.strokeStyle = "rgba(93, 64, 55, 0.2)";
            ctx.lineWidth = 2 / cam.scale;
            ctx.beginPath();
            ctx.moveTo(0, minK * CELL_H);
            ctx.lineTo(0, maxK * CELL_H);
            ctx.stroke();

            // Font Config
            let fontSize = 28;
            ctx.font = `${fontSize}px 'Caveat'`;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";

            for (let k = minK; k <= maxK; k++) {
                let bigK = BigInt(k);
                
                // Gnomon Data
                let A = (bigK << 1n) | 1n; // 2k+1
                let spine = A * A;
                let step = A << 1n; // 2A
                let tapeStart = ((bigK * (bigK + 1n)) >> 1n) + 1n;
                
                let rowY = k * CELL_H;
                
                // Calc Col Range
                let minCol = Math.floor(viewL / CELL_W);
                let maxCol = Math.floor(viewR / CELL_W) + 1;

                for (let c = minCol; c <= maxCol; c++) {
                    let cellX = c * CELL_W;
                    let val, addr, tapeText = null;
                    let isSpine = (c === 0);

                    if (isSpine) {
                        // CENTER: SPINE
                        val = spine;
                        addr = `${A}`;
                        // Tape ID applies to spine? Usually yes, it's the start.
                        tapeText = tapeStart.toString();
                        ctx.fillStyle = C_GOLD; 
                    } else if (c > 0) {
                        // RIGHT SIDE: SUBTRACTION (Positive Gnomon)
                        let gap = BigInt(c);
                        val = spine - (gap * step);
                        addr = `${A}.${gap}`;
                        // Tape ID applies here
                        tapeText = (tapeStart + gap).toString();
                        ctx.fillStyle = C_INK;
                    } else {
                        // LEFT SIDE: WRAP AROUND (Negative Gnomon)
                        // Logic: Continue the subtraction past the right side
                        // Left Col 1 (c=-1) corresponds to Gap k+1
                        let posC = -c;
                        let gap = BigInt(k) + BigInt(posC);
                        val = spine - (gap * step);
                        addr = `${A}.${gap}`; // Show true gap
                        // No Tape ID for left side
                        tapeText = null;
                        ctx.fillStyle = C_INK; // Standard ink for negatives
                    }

                    // DRAW VALUE
                    ctx.fillText(val.toString(), cellX, rowY);

                    // DRAW TAPE ID (Top Left, Small, Gold)
                    if (tapeText && cam.scale > 0.6) {
                        ctx.save();
                        ctx.font = `bold 16px 'Caveat'`;
                        ctx.fillStyle = C_GOLD;
                        ctx.textAlign = "right";
                        ctx.fillText(tapeText, cellX - 25, rowY - 20);
                        ctx.restore();
                    }

                    // DRAW DOT (Decoration)
                    ctx.beginPath();
                    ctx.arc(cellX + 40, rowY, 2, 0, Math.PI*2);
                    ctx.fillStyle = "rgba(93, 64, 55, 0.3)";
                    ctx.fill();

                }
            }
            ctx.restore();
        }

        // --- INPUTS ---
        canvas.addEventListener('mousedown', e => {
            input.dragging = true; input.lastX = e.clientX; input.lastY = e.clientY; input.dragDist = 0;
        });
        window.addEventListener('mousemove', e => {
            if(!input.dragging) return;
            let dx = e.clientX - input.lastX; let dy = e.clientY - input.lastY;
            cam.x += dx/cam.scale; cam.y += dy/cam.scale;
            input.lastX = e.clientX; input.lastY = e.clientY;
            input.dragDist += Math.abs(dx) + Math.abs(dy);
            requestAnimationFrame(render);
        });
        window.addEventListener('mouseup', e => {
            input.dragging = false;
            if(input.dragDist < 5) handleClick(e.clientX, e.clientY);
        });
        
        // Touch
        canvas.addEventListener('touchstart', e => {
            if(e.touches.length === 1) {
                input.dragging = true; input.lastX = e.touches[0].clientX; input.lastY = e.touches[0].clientY; input.dragDist=0;
            } else if(e.touches.length === 2) {
                input.lastDist = getDist(e.touches);
            }
        }, {passive:true}); // Passive true for better scroll perf if needed, but we preventDefault inside move
        
        canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            if(e.touches.length === 1 && input.dragging) {
                let dx = e.touches[0].clientX - input.lastX; let dy = e.touches[0].clientY - input.lastY;
                cam.x += dx/cam.scale; cam.y += dy/cam.scale;
                input.lastX = e.touches[0].clientX; input.lastY = e.touches[0].clientY;
                requestAnimationFrame(render);
            } else if(e.touches.length === 2) {
                let dist = getDist(e.touches);
                let delta = dist - input.lastDist;
                let newScale = cam.scale * (1 + delta*0.005);
                if(newScale < 0.1) newScale = 0.1; if(newScale > 5) newScale = 5;
                cam.scale = newScale; input.lastDist = dist;
                requestAnimationFrame(render);
            }
        }, {passive:false});

        function getDist(ts) { return Math.sqrt(Math.pow(ts[0].clientX-ts[1].clientX,2) + Math.pow(ts[0].clientY-ts[1].clientY,2)); }

        // --- RAYCAST ---
        function handleClick(sx, sy) {
            let cx = canvas.width/2; let cy = canvas.height/2;
            let wx = (sx - cx)/cam.scale - cam.x;
            let wy = (sy - cy)/cam.scale - cam.y;
            
            let c = Math.round(wx / CELL_W);
            let k = Math.round(wy / CELL_H);
            if(k < 0) k = 0;

            let bigK = BigInt(k);
            let A = (bigK << 1n) | 1n;
            let spine = A * A;
            let step = A << 1n;
            let tapeStart = ((bigK * (bigK + 1n)) >> 1n) + 1n;
            
            let val, addr, tapeStr="None";
            
            if(c === 0) {
                val = spine; addr = `Anchor ${A}`;
                tapeStr = tapeStart.toString();
            } else if (c > 0) {
                let gap = BigInt(c);
                val = spine - (gap*step);
                addr = `Anchor ${A}, Gap ${gap}`;
                tapeStr = (tapeStart + gap).toString();
            } else {
                let gap = BigInt(k) + BigInt(-c);
                val = spine - (gap*step);
                addr = `Anchor ${A}, Gap ${gap}`;
                tapeStr = "Void";
            }
            
            document.getElementById('h-val').innerText = val.toString();
            document.getElementById('h-addr').innerText = addr;
            document.getElementById('h-tape').innerText = tapeStr;
            document.getElementById('h-calc').innerText = `${spine} - (${addr.split('Gap ')[1]||0} Ã— ${step}) = ${val}`;
            document.getElementById('holo-overlay').style.display = 'flex';
        }

        function closeHolo() { document.getElementById('holo-overlay').style.display = 'none'; }
        function resetCam() { cam.x=0; cam.y=150; cam.scale=1.0; render(); }
        function jump() {
            let val = prompt("Enter Row:");
            if(val) { cam.y = -(Number(val) * CELL_H); cam.x=0; render(); }
        }

        resize(); // Start
    </script>
</body>
</html>
