<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>GNOMON NAVIGATOR v0.0.17 (Core Reset)</title>
<style>
    :root {
        --bg: #020617; --panel: #0f172a; --border: #1e293b;
        --cyan: #22d3ee; --text: #e2e8f0; --pink: #f472b6; --green: #34d399;
    }
    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
    body { 
        background: var(--bg); color: var(--text); font-family: 'Courier New', monospace; 
        height: 100dvh; margin: 0; display: flex; flex-direction: column; overflow: hidden; 
    }

    /* --- TOP SECTION --- */
    .top-section { background: var(--panel); border-bottom: 2px solid var(--cyan); padding: 8px; flex-shrink: 0; z-index: 200; }
    .controls { display: flex; justify-content: space-between; align-items: center; gap: 8px; margin-bottom: 8px; }
    
    .toggle-btn { 
        background: #334155; color: #94a3b8; padding: 0 12px; height: 36px; border-radius: 4px; border:none; 
        cursor: pointer; font-weight:bold; font-size:0.7rem;
    }
    .toggle-btn.active { background: var(--cyan); color: #000; box-shadow: 0 0 5px var(--cyan); }

    .search-row { display: flex; gap: 6px; }
    #inpFind { background: #1e293b; border: 1px solid #334155; color: #fff; padding: 10px; flex: 1; font-weight: bold; border-radius: 4px; font-size: 1rem; }
    #btnFind { background: var(--cyan); color: #000; border: none; border-radius: 4px; font-weight: bold; padding: 0 20px; }

    /* --- CANVAS --- */
    .layout { flex: 1; position: relative; background: #000; touch-action: none; overflow: hidden; }
    canvas { display: block; width: 100%; height: 100%; }

    /* --- DECODER PANEL --- */
    .decoder { background: #0f172a; border-top: 3px solid var(--pink); padding: 10px; flex-shrink: 0; z-index: 150; }
    .data-row { display: flex; justify-content: space-between; align-items: flex-end; margin-bottom: 10px; }
    .val-main { font-size: 1.2rem; font-weight: 900; color: #fff; }
    .val-sub { font-size: 0.8rem; color: var(--pink); font-weight: bold; }

    .grid-inputs { display: grid; grid-template-columns: repeat(4, 1fr); gap: 5px; }
    .input-box { background: rgba(0,0,0,0.3); border: 1px solid #334155; padding: 5px; border-radius: 4px; text-align: center; }
    .input-box label { display: block; font-size: 0.5rem; color: #64748b; margin-bottom: 2px; }
    .input-box input { width: 100%; background: transparent; border: none; color: #fff; text-align: center; font-size: 0.8rem; outline: none; }

    #toast {
        position: fixed; top: 100px; left: 50%; transform: translateX(-50%);
        background: var(--cyan); color: #000; padding: 8px 16px; border-radius: 20px;
        font-size: 0.8rem; font-weight: bold; opacity: 0; transition: opacity 0.3s; z-index: 1000;
    }
    #toast.show { opacity: 1; }
</style>
</head>
<body>

<div id="toast">ID LOCATED</div>

<div class="top-section">
    <div class="controls">
        <button class="toggle-btn active" id="btnMirror">MIRROR</button>
        <button class="toggle-btn" id="btnLayout">SPINE</button>
        <div style="flex:1; padding: 0 10px;"><input id="inpZoom" type="range" min="30" max="150" value="70" style="width:100%"></div>
        <button class="toggle-btn" id="btnHelp">?</button>
    </div>
    <div class="search-row">
        <input id="inpFind" type="text" inputmode="numeric" placeholder="Tape ID Search">
        <button id="btnFind">FIND</button>
    </div>
</div>

<div class="layout" id="canvasWrap">
    <canvas id="gridCanvas"></canvas>
</div>

<div class="decoder">
    <div class="data-row">
        <div><div style="font-size:0.6rem; color:#64748b">SMART ID (a.b)</div><div id="dispComp" class="val-main">0.0</div></div>
        <div style="text-align:right"><div style="font-size:0.6rem; color:#64748b">CARGO (N)</div><div id="dispVal" class="val-main">0</div><div id="dispFactors" class="val-sub">0 x 0</div></div>
    </div>
    <div class="grid-inputs">
        <div class="input-box"><label>GNOMON</label><input id="inpGnomon" readonly></div>
        <div class="input-box"><label>GAP (b)</label><input id="inpCol" onchange="manualJump()"></div>
        <div class="input-box"><label>ANCHOR (a)</label><input id="inpA" onchange="manualJump()"></div>
        <div class="input-box"><label>ROW (k)</label><input id="inpK" onchange="manualJump()"></div>
    </div>
</div>

<script>
const canvas = document.getElementById('gridCanvas');
const ctx = canvas.getContext('2d', {alpha: false});
const wrap = document.getElementById('canvasWrap');

let DPR = window.devicePixelRatio || 1;
let cellS = 70; 
let viewAnchor = { r: 0n, c: 0n }; 
let scrollX = 0, scrollY = 0; 
let highlight = { r: 0n, c: 0n };
let hideMirror = true;
let layoutMode = 'spine';
let cellCache = new Map();

// --- WORKER (RESTORED v0.0.5) ---
const workerCode = `
self.onmessage = (ev) => {
    const { cmd, items, mode, r, c } = ev.data;
    const process = (r_in, c_in, m) => {
        const rr = BigInt(r_in); const cc = BigInt(c_in);
        let P2, P1, k, a, b, isSq;
        if (m === 'spine') {
            k = rr; b = cc; P2 = (k * 2n) + 1n; P1 = P2 - (b * 2n); a = P2 - b; isSq = (cc === 0n);
        } else {
            if (rr >= cc) { P2 = (rr * 2n) + 1n; P1 = (cc * 2n) + 1n; k = rr; } 
            else { P2 = (cc * 2n) + 1n; P1 = (rr * 2n) + 1n; k = cc; }
            b = (P2 - P1) / 2n; a = (P2 + P1) / 2n; isSq = (rr === cc);
        }
        if (P1 <= 0n) return null;
        return { r: r_in, c: c_in, k: k.toString(), a: a.toString(), b: b.toString(), tapeID: ((k*(k+1n))/2n + b).toString(), g: (k+1n).toString(), val: (P2*P1).toString(), isSq, P2: P2.toString(), P1: P1.toString() };
    };
    if (cmd === 'batch') self.postMessage({ type: 'batch', payload: items.map(it => process(it.r, it.c, mode)).filter(x=>x) });
    if (cmd === 'cell') self.postMessage({ type: 'cell', payload: process(r, c, mode) });
};`;
const worker = new Worker(URL.createObjectURL(new Blob([workerCode], {type:'application/javascript'})));

worker.onmessage = (ev) => {
    if (ev.data.type === 'batch') { ev.data.payload.forEach(p => cellCache.set(`${p.r}|${p.c}`, p)); draw(); }
    if (ev.data.type === 'cell') { 
        const p = ev.data.payload; cellCache.set(`${p.r}|${p.c}`, p); 
        if(highlight.r.toString() === p.r && highlight.c.toString() === p.c) updateDecoder(p);
        draw(); 
    }
};

function draw() {
    const w = canvas.width / DPR; const h = canvas.height / DPR;
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
    ctx.fillStyle = '#020617'; ctx.fillRect(0, 0, w, h);

    while (scrollX > 0) { scrollX -= cellS; viewAnchor.c -= 1n; }
    while (scrollX <= -cellS) { scrollX += cellS; viewAnchor.c += 1n; }
    while (scrollY > 0) { scrollY -= cellS; viewAnchor.r -= 1n; }
    while (scrollY <= -cellS) { scrollY += cellS; viewAnchor.r += 1n; }

    ctx.save();
    ctx.translate(scrollX, scrollY);

    for (let r = -1; r < (h/cellS)+1; r++) {
        for (let c = -1; c < (w/cellS)+1; c++) {
            const gr = viewAnchor.r + BigInt(r); const gc = viewAnchor.c + BigInt(c);
            if (gr < 0n || gc < 0n || (layoutMode === 'diag' && hideMirror && gc > gr) || (layoutMode === 'spine' && gc > gr)) continue;

            const x = c * cellS; const y = r * cellS;
            const cell = cellCache.get(`${gr}|${gc}`);
            const isSel = (gr === highlight.r && gc === highlight.c);

            ctx.fillStyle = (cell && cell.isSq) ? 'rgba(59, 130, 246, 0.1)' : '#0f172a';
            if (isSel) ctx.fillStyle = 'rgba(34, 211, 238, 0.2)';
            ctx.fillRect(x + 1, y + 1, cellS - 2, cellS - 2);
            if (isSel) { ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.strokeRect(x+1, y+1, cellS-2, cellS-2); }

            if (cell) {
                ctx.fillStyle = isSel ? '#fff' : '#64748b'; ctx.font = 'bold 10px monospace'; ctx.textAlign = 'center';
                ctx.fillText(`${cell.a.slice(0,5)}.${cell.b.slice(-3)}`, x + cellS/2, y + cellS/2 - 5);
                ctx.fillStyle = isSel ? '#22d3ee' : '#334155'; ctx.font = '8px monospace';
                ctx.fillText(cell.val.length > 8 ? ".." + cell.val.slice(-6) : cell.val, x + cellS/2, y + cellS/2 + 10);
            }
        }
    }
    ctx.restore();
    requestBatch();
}

function requestBatch() {
    const items = [];
    for (let r = -1; r < (canvas.height/DPR/cellS)+1; r++) {
        for (let c = -1; c < (canvas.width/DPR/cellS)+1; c++) {
            const gr = viewAnchor.r + BigInt(r); const gc = viewAnchor.c + BigInt(c);
            if (gr >= 0n && gc >= 0n && !cellCache.has(`${gr}|${gc}`)) items.push({r: gr.toString(), c: gc.toString()});
        }
    }
    if (items.length) worker.postMessage({cmd: 'batch', items, mode: layoutMode});
}

// --- TOUCH ENGINE ---
let lx = 0, ly = 0, isDrag = false;
wrap.addEventListener('touchstart', e => { 
    isDrag = false; lx = e.touches[0].clientX; ly = e.touches[0].clientY; 
}, {passive: false});

wrap.addEventListener('touchmove', e => {
    e.preventDefault();
    const dx = e.touches[0].clientX - lx; const dy = e.touches[0].clientY - ly;
    if (Math.hypot(dx, dy) > 5) isDrag = true;
    scrollX += dx; scrollY += dy;
    lx = e.touches[0].clientX; ly = e.touches[0].clientY;
    draw();
}, {passive: false});

wrap.addEventListener('touchend', e => {
    if (!isDrag) {
        const rect = canvas.getBoundingClientRect();
        const tx = e.changedTouches[0].clientX - rect.left;
        const ty = e.changedTouches[0].clientY - rect.top;
        highlight = { r: viewAnchor.r + BigInt(Math.floor((ty - scrollY) / cellS)), c: viewAnchor.c + BigInt(Math.floor((tx - scrollX) / cellS)) };
        worker.postMessage({cmd: 'cell', r: highlight.r.toString(), c: highlight.c.toString(), mode: layoutMode});
        draw();
    }
});

function jumpTo(r, c) {
    viewAnchor = { r: BigInt(r), c: BigInt(c) }; scrollX = 0; scrollY = 0; highlight = { r: BigInt(r), c: BigInt(c) };
    cellCache.clear(); worker.postMessage({cmd: 'cell', r: highlight.r.toString(), c: highlight.c.toString(), mode: layoutMode}); draw();
}

function updateDecoder(p) {
    document.getElementById('dispComp').innerText = `${p.a.slice(0,10)}...${p.b.slice(-5)}`;
    document.getElementById('dispVal').innerText = p.val.length > 15 ? p.val.slice(0,10) + "..." : p.val;
    document.getElementById('dispFactors').innerText = `${p.P2} x ${p.P1}`;
    document.getElementById('inpK').value = p.k; document.getElementById('inpCol').value = p.b;
    document.getElementById('inpA').value = p.a; document.getElementById('inpGnomon').value = p.g;
}

function manualJump() { try { jumpTo(document.getElementById('inpK').value, document.getElementById('inpCol').value); } catch(e) {} }

// --- SEARCH ENGINE ---
function sqrtBigInt(n) { if(n<2n) return n; let x=n, y=(x+1n)/2n; while(y<x){x=y;y=(x+n/x)/2n;} return x; }
document.getElementById('btnFind').onclick = () => {
    const v = BigInt(document.getElementById('inpFind').value);
    const k = (sqrtBigInt(8n*v + 1n) - 1n) / 2n;
    jumpTo(k, v - (k*(k+1n))/2n);
    const t = document.getElementById('toast'); t.classList.add('show'); setTimeout(()=>t.classList.remove('show'), 2000);
};

document.getElementById('btnMirror').onclick = (e) => { hideMirror = !hideMirror; e.target.classList.toggle('active'); cellCache.clear(); draw(); };
document.getElementById('btnLayout').onclick = (e) => { layoutMode = layoutMode === 'spine' ? 'diag' : 'spine'; e.target.innerText = layoutMode.toUpperCase(); cellCache.clear(); draw(); };
document.getElementById('inpZoom').oninput = (e) => { cellS = parseInt(e.target.value); draw(); };

window.onresize = () => { canvas.width = wrap.clientWidth * DPR; canvas.height = wrap.clientHeight * DPR; draw(); };
window.onload = () => { window.onresize(); jumpTo(0n, 0n); };
</script>
</body>
</html>
