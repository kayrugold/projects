<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Logarithmic Spiral Factor Filter (v0.7.0 - Ghost Spiral)</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');
        :root {
            --bg-color: #05080a; --text-color: #00ff00; --input-bg: #222;
            --border-color: #004400; --button-bg: #008800; --button-hover: #00cc00;
            --factor-color: #ffff00; --modal-bg: #0a0a0a; --prime-color: #66ff66;
            --structure-line-color: rgba(75, 0, 130, 0.4); /* Indigo for 6k lines */
            --ghost-spiral-color: rgba(0, 255, 0, 0.15); /* Faint green for the ghost spiral */
        }
        html, body {
            font-family: 'VT323', monospace; background: var(--bg-color); color: var(--text-color);
            margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden;
        }
        .main-container {
            width: 100%; height: 100%; display: flex; flex-direction: column;
            padding: 10px; box-sizing: border-box;
        }
        .header-content { flex-shrink: 0; max-width: 1200px; width: 100%; margin: 0 auto; }
        canvas {
            background-color: var(--bg-color); display: block; touch-action: none; 
            width: 100%; flex-grow: 1; border-radius: 4px;
            border: 1px solid var(--border-color); margin-top: 10px;
        }
        .controls {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(130px, 1fr)); 
            gap: 8px; margin-bottom: 10px; align-items: end;
        }
        .controls-row {
            display: contents; /* Allows direct grid layout of children */
        }
        @media (min-width: 1024px) {
            .controls {
                grid-template-columns: repeat(5, 1fr); /* 5 columns for wider screens */
            }
        }
        .controls label { display: block; font-size: 0.9em; margin-bottom: 2px; }
        .controls input, .controls button, .controls .checkbox-container { height: 36px; box-sizing: border-box; }
        .controls input {
            width: 100%; padding: 4px; background: var(--input-bg);
            border: 1px solid var(--border-color); color: var(--text-color);
            font-family: 'VT323', monospace; font-size: 1.1em;
        }
        .controls button {
            background: var(--button-bg); color: var(--bg-color); border: none; padding: 8px 10px;
            cursor: pointer; transition: background 0.2s; font-family: 'VT323', monospace;
            font-size: 1em; box-shadow: 0 0 5px var(--button-bg);
        }
        .controls button:disabled { background: #555; cursor: not-allowed; opacity: 0.7; }
        .checkbox-container { display: flex; align-items: center; justify-content: center; gap: 5px; font-size: 0.9em; white-space: nowrap;}
        #info-box {
            position: fixed; bottom: 15px; right: 15px; background: rgba(0, 0, 0, 0.9);
            padding: 8px; border: 1px solid var(--text-color); z-index: 10;
            font-size: 0.9em; min-width: 160px; max-width: 50vw; border-radius: 4px;
        }
        .info-header { color: var(--factor-color); margin-bottom: 5px; border-bottom: 1px solid var(--border-color); }
        .info-line { display: block; }
        .status-ready { color: var(--factor-color); font-weight: bold; } 
        .modal {
            display: none; position: fixed; z-index: 100; left: 0; top: 0; width: 100%; height: 100%;
            overflow: auto; background-color: rgba(0, 0, 0, 0.8); justify-content: center; align-items: center;
        }
        .modal-content {
            background-color: var(--modal-bg); color: var(--text-color); margin: 10% auto;
            padding: 20px; border: 2px solid var(--text-color); width: 90%; max-width: 500px;
            box-shadow: 0 0 15px var(--text-color);
        }
        .close-button { color: var(--text-color); float: right; font-size: 28px; font-weight: bold; cursor: pointer; }
        #tooltip {
            position: fixed; display: none; background: var(--factor-color); color: var(--bg-color);
            padding: 5px 10px; border-radius: 4px; font-size: 1.2em; pointer-events: none;
            z-index: 101; box-shadow: 0 0 10px var(--factor-color); transition: opacity 0.3s;
        }
    </style>
</head>
<body>

<div class="main-container">
    <div class="header-content">
        <h1>Spiral Factor Filter</h1>
        <p>Target $N = a^b + c$. Two fingers to **Zoom**. Single finger to **Pan**. Tap to **Identify**.</p>
        <div class="controls">
            <div class="controls-row">
                <div><label for="baseA">Base (a)</label><input type="text" id="baseA" value="10"></div>
                <div><label for="expB">Exponent (b)</label><input type="text" id="expB" value="3"></div>
                <div><label for="addC">Addend (c)</label><input type="text" id="addC" value="7"></div>
                <div><label for="maxPoints">Range to Sieve</label><input type="text" id="maxPoints" value="150000"></div>
                <button id="startButton">RUN</button>
            </div>
             <div class="controls-row">
                <div class="checkbox-container"><input type="checkbox" id="primeOnlyToggle" checked><label for="primeOnlyToggle">Primes Only</label></div>
                <div class="checkbox-container"><input type="checkbox" id="forceDensityToggle"><label for="forceDensityToggle">Force Heatmap</label></div>
                <div class="checkbox-container"><input type="checkbox" id="show6kLinesToggle" checked><label for="show6kLinesToggle">Show 6k Lines</label></div>
                <div class="checkbox-container"><input type="checkbox" id="showGhostToggle" checked><label for="showGhostToggle">Show Ghost Spiral</label></div>
                <button id="helpButton">HELP [ ? ]</button>
            </div>
        </div>
    </div>
    <canvas id="spiralCanvas"></canvas>
    <div id="info-box">
        <span class="info-header">STATUS:</span>
        <span id="info_target" class="info-line">N: 10^3 + 7</span>
        <span id="info_status" class="info-line">Status: Idle</span>
        <span id="info_factors" class="info-line">Factors: 0</span>
        <span id="info_range" class="info-line">Range: 1 to 150000</span>
    </div>
    <div id="tooltip"></div>
</div>

<div id="helpModal" class="modal">
  <div class="modal-content">
    <span class="close-button">&times;</span>
    <h2>Interactive Guide (v0.7)</h2>
    <p>This version introduces the "Ghost Spiral" for better high-range visualization.</p>
    <ul>
        <li><strong>Show Ghost Spiral:</strong> When checked, this draws a faint outline of the spiral's path. This is especially useful in Heatmap mode, allowing you to see the spiral's shape and the prime density patterns at the same time without sacrificing performance.</li>
        <li><strong>Tap to Identify:</strong> Tap any point on the canvas. In Detailed Mode, it shows the exact number of the nearest dot. In Heatmap Mode, it shows the <em>approximate</em> number for that geometric location.</li>
        <li><strong>Show 6k Lines:</strong> Displays faint indigo lines showing the "highways" where prime numbers of the form `6k Â± 1` are most likely to appear.</li>
    </ul>
     <p><strong style="color:var(--factor-color);">Factors are Always Visible:</strong> Any factors found will always be drawn as bright yellow dots with lines to the center, regardless of the active display mode.</p>
  </div>
</div>

<script>
    const canvas = document.getElementById('spiralCanvas');
    const ctx = canvas.getContext('2d', { alpha: false });
    const tooltip = document.getElementById('tooltip');
    const maxPointsInput = document.getElementById('maxPoints');
    const baseAInput = document.getElementById('baseA');
    const expBInput = document.getElementById('expB');
    const addCInput = document.getElementById('addC');
    const startButton = document.getElementById('startButton');
    const helpButton = document.getElementById('helpButton');
    const primeOnlyToggle = document.getElementById('primeOnlyToggle');
    const forceDensityToggle = document.getElementById('forceDensityToggle');
    const show6kLinesToggle = document.getElementById('show6kLinesToggle');
    const showGhostToggle = document.getElementById('showGhostToggle');
    const helpModal = document.getElementById('helpModal');
    const closeButton = helpModal.querySelector(".close-button");

    let isRunning = false, maxPoints = 50000, targetN = null, spiralPoints = [], factors = new Set();
    let currentStartP = 1, isChunking = false;
    const MIN_SCALE_TO_SHIFT = 1.2, MAX_SCALE_TO_SHIFT = 9.0;
    
    let scale = 4.0, offsetX = 0, offsetY = 0;
    let isDragging = false, lastMouseX, lastMouseY, lastTouchDistance = null; 
    let tapStart = null; // For distinguishing taps from drags
    let tooltipTimeout = null;
    
    const RENDER_THRESHOLD = 5000;
    let isDensityMode = false;
    let densityMap = { grid: [], max: 0, bounds: {} };

    const worker = new Worker(URL.createObjectURL(new Blob([`
        function powMod(b,e,m){let r=1n;b%=m;while(e>0n){if((e&1n)===1n)r=(r*b)%m;e>>=1n;b=(b*b)%m}return r}
        function sieve(min, max) {
            const minNum = Number(min), maxNum = Number(max);
            const sqrtMax = Math.floor(Math.sqrt(maxNum));
            const smallPrimes = [];
            const isSmallPrime = new Array(sqrtMax + 1).fill(true);
            isSmallPrime[0] = isSmallPrime[1] = false;
            for (let i = 2; i * i <= sqrtMax; i++) {
                if (isSmallPrime[i]) { for (let j = i * i; j <= sqrtMax; j += i) isSmallPrime[j] = false; }
            }
            for (let i = 2; i <= sqrtMax; i++) if (isSmallPrime[i]) smallPrimes.push(i);
            const isPrimeInRange = new Array(maxNum - minNum + 1).fill(true);
            if (minNum === 1 && isPrimeInRange.length > 0) isPrimeInRange[0] = false;
            for (const p of smallPrimes) {
                let start = Math.max(p * p, Math.ceil(minNum / p) * p);
                for (let j = start; j <= maxNum; j += p) {
                     if (j >= minNum) isPrimeInRange[j - minNum] = false;
                }
            }
            const primes = [];
            for (let i = 0; i < isPrimeInRange.length; i++) {
                if (isPrimeInRange[i]) {
                    const currentNum = minNum + i;
                    if(currentNum > 1) primes.push(currentNum);
                }
            }
            return primes;
        }
        onmessage=function(ev){
            let{allPoints:p,targetN:t,primesOnly:po,rangeStart:rs,rangeEnd:re}=ev.data;
            const pointsToTest = po ? sieve(rs, re) : p;
            let a=BigInt(t.a),b=BigInt(t.b),c=BigInt(t.c),s=[],f=[];
            const testedSet = new Set(pointsToTest);
            for(let o of testedSet){
                if(1===o) continue;
                let l=BigInt(o),n=(powMod(a,b,l)+(c%l+l)%l)%l;
                const isFactor=0n===n;
                isFactor&&f.push(o);
                s.push({p:o,isFactor});
            }
            postMessage({results:s,factorsFound:f, testedPrimes: po ? pointsToTest : null});
        };
    `], { type: 'application/javascript' })));
    
    worker.onmessage = e => {
        if (!isRunning) return;
        const primes = e.data.testedPrimes;
        isDensityMode = primeOnlyToggle.checked && (forceDensityToggle.checked || (primes && primes.length > RENDER_THRESHOLD));
        spiralPoints = generatePointsBatch(primes || Array.from({length: maxPoints}, (_,i) => currentStartP + i), currentStartP);
        if (isDensityMode) densityMap = createDensityMap(spiralPoints);
        e.data.results.forEach(res => { 
            const p = spiralPoints.find(pt => pt.p === res.p); 
            if (p) p.isFactor = res.isFactor; 
        });
        e.data.factorsFound.forEach(f => factors.add(f));
        document.getElementById('info_factors').textContent = `Factors: ${factors.size} (${Array.from(factors).join(', ')})`;
        requestAnimationFrame(drawSpiral); 
    };
    
    const getSpiralPoint = (n, startN) => {
        const num = n - startN;
        if (num < 0) return { x: 0, y: 0 };
        const angle = 0.2 * Math.sqrt(num) * Math.PI, radius = 0.8 * Math.sqrt(num);
        return { x: radius * Math.cos(angle), y: radius * Math.sin(angle) };
    };

    const generatePointsBatch = (pointsArray, startP) => pointsArray.map((p) => ({ p, ...getSpiralPoint(p, startP), isFactor: false }));

    const updateStatus = (message, isAlert = false) => {
        const statusEl = document.getElementById('info_status');
        statusEl.textContent = `Status: ${message}`;
        statusEl.classList.toggle('status-ready', isAlert);
    };

    function createDensityMap(points) {
        const gridSize = 100;
        const grid = Array(gridSize).fill(0).map(() => Array(gridSize).fill(0));
        let maxDensity = 0;
        if (points.length === 0) return { grid, max: 0, bounds: {} };
        const bounds = points.reduce((b, p) => ({
            minX: Math.min(b.minX, p.x), maxX: Math.max(b.maxX, p.x),
            minY: Math.min(b.minY, p.y), maxY: Math.max(b.maxY, p.y)
        }), { minX: Infinity, maxX: -Infinity, minY: Infinity, maxY: -Infinity });
        const rangeX = bounds.maxX - bounds.minX;
        const rangeY = bounds.maxY - bounds.minY;
        for (const p of points) {
            const gridX = Math.floor(((p.x - bounds.minX) / rangeX) * (gridSize - 1));
            const gridY = Math.floor(((p.y - bounds.minY) / rangeY) * (gridSize - 1));
            if (gridX >= 0 && gridX < gridSize && gridY >= 0 && gridY < gridSize) {
                grid[gridY][gridX]++;
                if (grid[gridY][gridX] > maxDensity) maxDensity = grid[gridY][gridX];
            }
        }
        return { grid, max: maxDensity, bounds };
    }

    function drawGhostSpiral() {
        ctx.strokeStyle = 'var(--ghost-spiral-color)';
        ctx.lineWidth = 1 / scale;
        ctx.beginPath();
        const sampleRate = Math.max(1, Math.floor(maxPoints / 2000));
        let first = true;
        for (let i = 0; i < maxPoints; i += sampleRate) {
            const p = currentStartP + i;
            const { x, y } = getSpiralPoint(p, currentStartP);
            const px = x * scale + offsetX;
            const py = y * scale + offsetY;
            if (first) {
                ctx.moveTo(px, py);
                first = false;
            } else {
                ctx.lineTo(px, py);
            }
        }
        ctx.stroke();
    }

    function draw6kLines() {
        ctx.strokeStyle = 'var(--structure-line-color)';
        ctx.lineWidth = Math.max(0.5, 2 / scale);
        ctx.setLineDash([5 / scale, 10 / scale]);
        const maxRadius = Math.max(canvas.width, canvas.height) * 1.5;
        for (let k = 1; k < 30; k++) {
             const n_plus_1 = 6 * k * k * 100 + 1;
             const n_minus_1 = 6 * k * k * 100 - 1;
             const angle_plus = 0.2 * Math.sqrt(n_plus_1) * Math.PI;
             const angle_minus = 0.2 * Math.sqrt(n_minus_1) * Math.PI;
             ctx.beginPath();
             ctx.moveTo(offsetX, offsetY);
             ctx.lineTo(offsetX + maxRadius * Math.cos(angle_plus), offsetY + maxRadius * Math.sin(angle_plus));
             ctx.stroke();
             ctx.beginPath();
             ctx.moveTo(offsetX, offsetY);
             ctx.lineTo(offsetX + maxRadius * Math.sin(angle_minus), offsetY + maxRadius * Math.sin(angle_minus));
             ctx.stroke();
        }
        ctx.setLineDash([]);
    }

    function drawDensityMap() {
        if (densityMap.max === 0) return;
        const { grid, max, bounds } = densityMap;
        const cellWidth = (bounds.maxX - bounds.minX) / grid[0].length;
        const cellHeight = (bounds.maxY - bounds.minY) / grid.length;
        for (let y = 0; y < grid.length; y++) {
            for (let x = 0; x < grid[y].length; x++) {
                if (grid[y][x] > 0) {
                    const density = Math.log1p(grid[y][x]) / Math.log1p(max);
                    const hue = 240 - (240 * density);
                    ctx.fillStyle = `hsla(${hue}, 100%, 50%, ${0.2 + density * 0.7})`;
                    const px = (bounds.minX + x * cellWidth) * scale + offsetX;
                    const py = (bounds.minY + y * cellHeight) * scale + offsetY;
                    ctx.fillRect(px, py, cellWidth * scale + 1, cellHeight * scale + 1);
                }
            }
        }
    }

    function drawSpiral() {
        if (isChunking) return;
        const dpr = window.devicePixelRatio || 1;
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0); 
        ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--bg-color');
        ctx.fillRect(0, 0, canvas.width, canvas.height); 

        if(show6kLinesToggle.checked) draw6kLines();
        if(showGhostToggle.checked && isDensityMode) drawGhostSpiral();

        if (scale < MIN_SCALE_TO_SHIFT) updateStatus("Zoom Out to Shift FWD", true);
        else if (scale > MAX_SCALE_TO_SHIFT) updateStatus("Zoom In to Shift BACK", true);
        else if (isRunning && isDensityMode) updateStatus("Heatmap Mode (many primes)");
        else if (isRunning) updateStatus("Sieving & Testing...");
        else updateStatus("Idle. Press RUN.");
        
        const factorPoints = spiralPoints.filter(p => p.isFactor);
        const dotRadius = Math.max(0.5, Math.min(2.5, 0.7 * scale));
        
        if (isDensityMode) {
            drawDensityMap();
        } else {
            const otherPoints = spiralPoints.filter(p => !p.isFactor);
            ctx.fillStyle = primeOnlyToggle.checked ? 'var(--prime-color)' : 'rgba(0, 255, 0, 0.5)';
            for (const point of otherPoints) {
                const px = point.x * scale + offsetX; const py = point.y * scale + offsetY;
                if (px + dotRadius < 0 || px - dotRadius > canvas.clientWidth || py + dotRadius < 0 || py - dotRadius > canvas.clientHeight) continue;
                ctx.beginPath(); ctx.arc(px, py, dotRadius, 0, Math.PI * 2); ctx.fill();
            }
        }

        if (factorPoints.length > 0) {
            ctx.strokeStyle = 'rgba(255, 255, 0, 0.7)'; ctx.lineWidth = Math.max(1.5, 4 / scale);
            ctx.shadowColor = 'yellow'; ctx.shadowBlur = 8;
            for (const point of factorPoints) {
                const px = point.x * scale + offsetX; const py = point.y * scale + offsetY;
                ctx.beginPath(); ctx.moveTo(offsetX, offsetY); ctx.lineTo(px, py); ctx.stroke();
            }
            ctx.shadowBlur = 0;
            ctx.fillStyle = 'var(--factor-color)';
            for (const point of factorPoints) {
                const px = point.x * scale + offsetX; const py = point.y * scale + offsetY;
                ctx.beginPath(); ctx.arc(px, py, dotRadius * 1.5, 0, Math.PI * 2); ctx.fill();
            }
        }
        
        ctx.fillStyle = "red";
        ctx.beginPath(); ctx.arc(offsetX, offsetY, dotRadius * 1.5, 0, Math.PI * 2); ctx.fill();
    }

    const generateNextChunk = direction => {
        if (!isRunning || isChunking) return;
        isChunking = true;
        let newStartP = currentStartP;
        if (direction === 'forward') newStartP += maxPoints;
        else if (direction === 'backward' && currentStartP > 1) newStartP = Math.max(1, currentStartP - maxPoints);
        else { isChunking = false; return; }
        currentStartP = newStartP;

        canvas.style.opacity = 0;
        setTimeout(() => {
            scale = 4.0; offsetX = (canvas.clientWidth / 2); offsetY = (canvas.clientHeight / 2);
            updateAndRun(true); 
            canvas.style.opacity = 1;
            setTimeout(() => isChunking = false, 50); 
        }, 150);
    };

    function resizeCanvas() {
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width * dpr; canvas.height = rect.height * dpr;
        offsetX = (canvas.clientWidth / 2); offsetY = (canvas.clientHeight / 2);
        requestAnimationFrame(drawSpiral);
    }
    
    const parseTargetInput = () => {
        try {
            const a=BigInt(baseAInput.value), b=BigInt(expBInput.value), c=BigInt(addCInput.value);
            document.getElementById('info_target').textContent = `N: ${a}^${b} + ${c}`;
            return { a: a.toString(), b: b.toString(), c: c.toString() };
        } catch(e) { updateStatus(`Invalid number input.`, true); return null; }
    };

    function updateAndRun(isChunkingCall = false) {
        if (!isChunkingCall) {
            targetN = parseTargetInput();
            if (!targetN) return;
            const pMax = parseInt(maxPointsInput.value);
            if (isNaN(pMax) || pMax <= 0) { updateStatus('Invalid Range.', true); return; }
            maxPoints = pMax;
            currentStartP = 1; factors.clear();
            document.getElementById('info_factors').textContent = `Factors: 0`;
        }
        const rangeStart = currentStartP, rangeEnd = currentStartP + maxPoints - 1;
        const allPoints = Array.from({length: rangeEnd - rangeStart + 1}, (_, i) => rangeStart + i);
        spiralPoints = []; isDensityMode = false;
        isRunning = true;
        startButton.textContent = "RUNNING..."; startButton.disabled = true;
        document.getElementById('info_range').textContent = `Range: ${rangeStart} to ${rangeEnd}`;
        worker.postMessage({ allPoints: allPoints, targetN: targetN, primesOnly: primeOnlyToggle.checked, rangeStart: rangeStart, rangeEnd: rangeEnd });
        requestAnimationFrame(drawSpiral);
        setTimeout(() => { startButton.textContent = "RE-RUN"; startButton.disabled = false; }, 2000); 
    }

    function showTooltip(text, x, y) {
        clearTimeout(tooltipTimeout);
        tooltip.textContent = text;
        tooltip.style.left = `${x + 15}px`;
        tooltip.style.top = `${y + 15}px`;
        tooltip.style.display = 'block';
        tooltip.style.opacity = 1;
        tooltipTimeout = setTimeout(() => {
            tooltip.style.opacity = 0;
            setTimeout(() => { tooltip.style.display = 'none'; }, 300);
        }, 2500);
    }

    function handleCanvasTap(e) {
        const rect = canvas.getBoundingClientRect();
        const clientX = e.clientX || e.changedTouches[0].clientX;
        const clientY = e.clientY || e.changedTouches[0].clientY;
        const screenX = clientX - rect.left;
        const screenY = clientY - rect.top;

        const worldX = (screenX - offsetX) / scale;
        const worldY = (screenY - offsetY) / scale;
        
        if (isDensityMode) {
            const radius = Math.hypot(worldX, worldY);
            const numOffset = (radius / 0.8) ** 2;
            const estimatedNumber = Math.round(numOffset + currentStartP);
            
            if (estimatedNumber >= currentStartP && estimatedNumber < currentStartP + maxPoints) {
                 showTooltip(`~ ${estimatedNumber.toLocaleString()}`, clientX, clientY);
            }
            return;
        }

        let closestPoint = null;
        let minDistance = Infinity;
        const clickThreshold = (10 / scale) ** 2; 

        for (const point of spiralPoints) {
            const dx = point.x - worldX;
            const dy = point.y - worldY;
            const distSq = dx * dx + dy * dy;
            if (distSq < minDistance) {
                minDistance = distSq;
                closestPoint = point;
            }
        }

        if (closestPoint && minDistance < clickThreshold) {
            showTooltip(closestPoint.p.toLocaleString(), clientX, clientY);
        }
    }

    helpButton.addEventListener('click', () => { helpModal.style.display = "flex"; });
    closeButton.addEventListener('click', () => { helpModal.style.display = "none"; });
    window.addEventListener('click', e => { if (e.target === helpModal) helpModal.style.display = "none"; });
    startButton.addEventListener('click', () => updateAndRun(false));
    forceDensityToggle.addEventListener('change', () => updateAndRun(false));
    primeOnlyToggle.addEventListener('change', () => updateAndRun(false));
    show6kLinesToggle.addEventListener('change', () => requestAnimationFrame(drawSpiral));
    showGhostToggle.addEventListener('change', () => requestAnimationFrame(drawSpiral));

    function handleZoom(zoomFactor, screenX, screenY) {
        const oldScale = scale;
        scale = Math.max(0.1, Math.min(scale * zoomFactor, 500));
        offsetX = screenX - (screenX - offsetX) * (scale / oldScale);
        offsetY = screenY - (screenY - offsetY) * (scale / oldScale);
        requestAnimationFrame(drawSpiral);
    }
    
    canvas.addEventListener('mousedown', e => { 
        isDragging = false;
        tapStart = { x: e.clientX, y: e.clientY, time: Date.now() };
    });
    canvas.addEventListener('mouseup', e => { 
        if (tapStart && (Date.now() - tapStart.time < 250) && !isDragging) {
            handleCanvasTap(e);
        }
        isDragging = false; 
        tapStart = null;
    });
    canvas.addEventListener('mouseleave', () => { isDragging = false; tapStart = null; });
    canvas.addEventListener('mousemove', e => {
        if (tapStart && (Math.hypot(e.clientX - tapStart.x, e.clientY - tapStart.y) > 5)) {
            isDragging = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            tapStart = null; // It's a drag, not a tap
        }
        if (isDragging) {
            offsetX += e.clientX - lastMouseX; offsetY += e.clientY - lastMouseY;
            lastMouseX = e.clientX; lastMouseY = e.clientY;
            requestAnimationFrame(drawSpiral);
        }
    });
    canvas.addEventListener('wheel', e => {
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        handleZoom(e.deltaY < 0 ? 1.15 : 1 / 1.15, e.clientX - rect.left, e.clientY - rect.top);
        if (!isChunking && (scale < MIN_SCALE_TO_SHIFT || scale > MAX_SCALE_TO_SHIFT)) {
            setTimeout(() => {
                if (scale < MIN_SCALE_TO_SHIFT) generateNextChunk('forward');
                else if (scale > MAX_SCALE_TO_SHIFT) generateNextChunk('backward');
            }, 50);
        }
    }, { passive: false });
    canvas.addEventListener('touchstart', e => {
        if (e.touches.length === 1) { 
            const touch = e.touches[0];
            isDragging = false;
            tapStart = { x: touch.clientX, y: touch.clientY, time: Date.now() };
        } else if (e.touches.length === 2) { 
            isDragging = false; 
            tapStart = null;
            lastTouchDistance = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY); 
        }
    });
    canvas.addEventListener('touchmove', e => {
        e.preventDefault();
        if (e.touches.length === 1) {
            const touch = e.touches[0];
            if (tapStart && (Math.hypot(touch.clientX - tapStart.x, touch.clientY - tapStart.y) > 10)) {
                isDragging = true;
                lastMouseX = touch.clientX;
                lastMouseY = touch.clientY;
                tapStart = null; // It's a drag
            }
            if (isDragging) {
                offsetX += touch.clientX - lastMouseX;
                offsetY += touch.clientY - lastMouseY;
                lastMouseX = touch.clientX;
                lastMouseY = touch.clientY;
                requestAnimationFrame(drawSpiral);
            }
        } else if (e.touches.length === 2 && lastTouchDistance) {
            const dist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
            const rect = canvas.getBoundingClientRect();
            const pinchX = (e.touches[0].clientX + e.touches[1].clientX) / 2 - rect.left;
            const pinchY = (e.touches[0].clientY + e.touches[1].clientY) / 2 - rect.top;
            handleZoom(dist / lastTouchDistance, pinchX, pinchY);
            lastTouchDistance = dist;
        }
    }, { passive: false });
    canvas.addEventListener('touchend', e => {
        if (tapStart && (Date.now() - tapStart.time < 250) && !isDragging) {
            handleCanvasTap(e);
        }
        isDragging = false; lastTouchDistance = null; tapStart = null;
        if (scale < MIN_SCALE_TO_SHIFT) generateNextChunk('forward');
        else if (scale > MAX_SCALE_TO_SHIFT) generateNextChunk('backward');
    });

    document.addEventListener('DOMContentLoaded', () => { resizeCanvas(); updateAndRun(false); });
    window.addEventListener('resize', resizeCanvas);
</script>
</body>
</html>

