<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Spiral Factor Filter (v1.2.0 - Core Fixes Implemented)</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');
        :root {
            --bg-color: #05080a; --text-color: #00ff00; --input-bg: #222;
            --border-color: #004400; --button-bg: #008800; --button-hover: #00cc00;
            --factor-color: #ffff00; --modal-bg: #0a0a0a; --prime-color: #66ff66;
            --structure-line-color: rgba(75, 0, 130, 0.4); 
            --ghost-spiral-color: rgba(0, 255, 0, 0.15); 
        }
        html, body {
            font-family: 'VT323', monospace; background: var(--bg-color); color: var(--text-color);
            margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden;
        }
        .main-container {
            width: 100%; height: 100%; display: flex; flex-direction: column;
            padding: 10px; box-sizing: border-box;
        }
        .header-content { flex-shrink: 0; max-width: 1200px; width: 100%; margin: 0 auto; }
        canvas {
            background-color: var(--bg-color); display: block; touch-action: none; 
            width: 100%; flex-grow: 1; border-radius: 4px;
            border: 1px solid var(--border-color); margin-top: 10px;
        }
        .controls {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(130px, 1fr)); 
            gap: 8px; margin-bottom: 10px; align-items: end;
        }
        .controls-row { display: contents; }
        @media (min-width: 1200px) { .controls { grid-template-columns: repeat(6, 1fr); } }
        @media (min-width: 1024px) and (max-width: 1199px) { .controls { grid-template-columns: repeat(5, 1fr); } }
        .controls label { display: block; font-size: 0.9em; margin-bottom: 2px; }
        .controls input, .controls button, .controls .checkbox-container { height: 36px; box-sizing: border-box; }
        .controls input {
            width: 100%; padding: 4px; background: var(--input-bg);
            border: 1px solid var(--border-color); color: var(--text-color);
            font-family: 'VT323', monospace; font-size: 1.1em;
        }
        .controls button {
            background: var(--button-bg); color: var(--bg-color); border: none; padding: 8px 10px;
            cursor: pointer; transition: background 0.2s; font-family: 'VT323', monospace;
            font-size: 1em; box-shadow: 0 0 5px var(--button-bg);
        }
        .controls button:disabled { background: #555; cursor: not-allowed; opacity: 0.7; }
        .checkbox-container { display: flex; align-items: center; justify-content: center; gap: 5px; font-size: 0.9em; white-space: nowrap;}
        
        .resonance-container {
            grid-column: 1 / -1; border: 1px solid var(--border-color);
            border-radius: 4px; padding: 8px; margin-top: 10px; display: none;
        }
        .resonance-container.active { display: block; }
        .resonance-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;}
        .resonance-header h3 { margin: 0; font-size: 1.2em; }
        .resonance-input-row { display: flex; gap: 8px; margin-bottom: 8px; }
        .resonance-input-row input { flex-grow: 1; }
        .resonance-list { font-size: 1em; display: flex; flex-direction: column; gap: 6px; }
        .resonance-item { display: flex; align-items: center; gap: 8px; }
        .resonance-item span { flex-grow: 1; }
        .resonance-item .color-swatch { width: 16px; height: 16px; border: 1px solid #555; flex-shrink: 0;}
        .resonance-item button { background: #aa0000; font-size: 0.8em; padding: 2px 6px; height: auto; }

        #info-box, .modal, .modal-content, .close-button, #tooltip { /* Unchanged styles */ }
        #info-box {
            position: fixed; bottom: 15px; right: 15px; background: rgba(0, 0, 0, 0.9);
            padding: 8px; border: 1px solid var(--text-color); z-index: 10;
            font-size: 0.9em; min-width: 160px; max-width: 50vw; border-radius: 4px;
        }
        .modal {
            display: none; position: fixed; z-index: 100; left: 0; top: 0; width: 100%; height: 100%;
            overflow: auto; background-color: rgba(0, 0, 0, 0.8); justify-content: center; align-items: center;
        }
        .modal-content {
            background-color: var(--modal-bg); color: var(--text-color); margin: 10% auto;
            padding: 20px; border: 2px solid var(--text-color); width: 90%; max-width: 600px;
            box-shadow: 0 0 15px var(--text-color);
        }
        .close-button { color: var(--text-color); float: right; font-size: 28px; font-weight: bold; cursor: pointer; }
        #tooltip {
            position: fixed; display: none; background: var(--factor-color); color: var(--bg-color);
            padding: 5px 10px; border-radius: 4px; font-size: 1.2em; pointer-events: none;
            z-index: 101; box-shadow: 0 0 10px var(--factor-color); transition: opacity 0.3s;
        }
    </style>
</head>
<body>

<div class="main-container">
    <div class="header-content">
        <h1>Spiral Factor Filter</h1>
        <p>Target $N = a^b + c$. Two fingers to **Zoom**. Single finger to **Pan**. Tap to **Identify**.</p>
        <div class="controls">
            <div class="controls-row">
                <div><label for="baseA">Base (a)</label><input type="text" id="baseA" value="10"></div>
                <div><label for="expB">Exponent (b)</label><input type="text" id="expB" value="1000000000"></div>
                <div><label for="addC">Addend (c)</label><input type="text" id="addC" value="19"></div>
                <div><label for="maxPoints">Range to Test</label><input type="text" id="maxPoints" value="15000"></div>
                <button id="startButton">RUN</button>
            </div>
             <div class="controls-row">
                <div class="checkbox-container"><input type="checkbox" id="primeOnlyToggle" checked><label for="primeOnlyToggle">Primes Only</label></div>
                <div class="checkbox-container"><input type="checkbox" id="resonanceToggle"><label for="resonanceToggle">Resonance Sieve</label></div>
                <div class="checkbox-container"><input type="checkbox" id="harmonicModeToggle" checked><label for="harmonicModeToggle">Harmonic Mode</label></div>
                <div class="checkbox-container"><input type="checkbox" id="show6kLinesToggle" checked><label for="show6kLinesToggle">Show 6k Lines</label></div>
                <div class="checkbox-container"><input type="checkbox" id="showGhostToggle" checked><label for="showGhostToggle">Show Ghost Spiral</label></div>
                <button id="helpButton">HELP [ ? ]</button>
            </div>
            <div id="resonanceContainer" class="resonance-container">
                <h3>Resonance Sieve (CRT)</h3>
                <div class="resonance-input-row">
                    <input type="text" id="resonancePrimeInput" placeholder="Add prime (max 3)">
                    <button id="addResonanceBtn">Add Filter</button>
                </div>
                <div id="resonanceList" class="resonance-list"></div>
            </div>
        </div>
    </div>
    <canvas id="spiralCanvas"></canvas>
    <div id="info-box">
        <span class="info-header">STATUS:</span>
        <span id="info_target" class="info-line">N: 10^1000000000 + 19</span>
        <span id="info_status" class="info-line">Status: Idle</span>
        <span id="info_factors" class="info-line">Factors: 0</span>
        <span id="info_range" class="info-line">Range: 1 to 15000</span>
    </div>
    <div id="tooltip"></div>
</div>

<div id="helpModal" class="modal">
  <div class="modal-content">
    <span class="close-button">&times;</span>
    <h2>Interactive Guide (v1.2.0)</h2>
    <p>This version implements major bug fixes for interaction and rendering, and handles extremely large numbers more gracefully.</p>
    <ul>
        <li><strong>Interaction Fixed:</strong> Clicking/tapping to identify numbers, panning, and zooming now work correctly and reliably across all devices. The initial view also renders all elements correctly on first load.</li>
        <li><strong>Large Number Support:</strong> When testing very large numbers (like 10^1,000,000,000 + 19), Harmonic Mode will show grey dots. This indicates that the numbers being tested are too large for precise remainder calculations in the browser, but the factor check (for remainder 0) still works perfectly.</li>
        <li><strong>RGB Resonance Sieve:</strong> A powerful tool for visualizing the Chinese Remainder Theorem (CRT). Add up to 3 prime filters to color the spiral by multiples, making intersections (common multiples) easy to spot by looking for combined colors (Red+Green=Yellow, etc.).</li>
    </ul>
  </div>
</div>


<script>
    const canvas = document.getElementById('spiralCanvas');
    const ctx = canvas.getContext('2d', { alpha: false });
    const tooltip = document.getElementById('tooltip');
    const maxPointsInput = document.getElementById('maxPoints');
    const baseAInput = document.getElementById('baseA');
    const expBInput = document.getElementById('expB');
    const addCInput = document.getElementById('addC');
    const startButton = document.getElementById('startButton');
    const helpButton = document.getElementById('helpButton');
    const primeOnlyToggle = document.getElementById('primeOnlyToggle');
    const harmonicModeToggle = document.getElementById('harmonicModeToggle');
    const show6kLinesToggle = document.getElementById('show6kLinesToggle');
    const showGhostToggle = document.getElementById('showGhostToggle');
    const resonanceToggle = document.getElementById('resonanceToggle');
    const resonanceContainer = document.getElementById('resonanceContainer');
    const resonancePrimeInput = document.getElementById('resonancePrimeInput');
    const addResonanceBtn = document.getElementById('addResonanceBtn');
    const resonanceList = document.getElementById('resonanceList');
    const helpModal = document.getElementById('helpModal');
    const closeButton = helpModal.querySelector(".close-button");

    let isRunning = false, maxPoints = 15000, targetN = null, spiralPoints = [], factors = new Set();
    let currentStartP = 1, isChunking = false;
    const MIN_SCALE_TO_SHIFT = 1.2, MAX_SCALE_TO_SHIFT = 9.0;
    
    let scale = 4.0, offsetX = 0, offsetY = 0;
    let isDragging = false, lastMouseX, lastMouseY, lastTouchDistance = null; 
    let tapStart = null; 
    let tooltipTimeout = null;
    let resonanceFilters = [];
    const RESONANCE_COLORS = ['#ff0000', '#00ff00', '#0000ff'];
    
    const worker = new Worker(URL.createObjectURL(new Blob([`
        function powMod(b,e,m){let r=1n;b%=m;while(e>0n){if((e&1n)===1n)r=(r*b)%m;e>>=1n;b=(b*b)%m}return r}
        function sieve(min, max) {
            const minNum=Number(min), maxNum=Number(max);
            if (minNum > Number.MAX_SAFE_INTEGER || maxNum > Number.MAX_SAFE_INTEGER) return []; // Sieve cannot handle unsafe integers
            const sqrtMax=Math.floor(Math.sqrt(maxNum)), smallPrimes=[], isSmallPrime=new Array(sqrtMax+1).fill(!0);
            isSmallPrime[0]=isSmallPrime[1]=!1;
            for(let i=2;i*i<=sqrtMax;i++)if(isSmallPrime[i])for(let j=i*i;j<=sqrtMax;j+=i)isSmallPrime[j]=!1;
            for(let i=2;i<=sqrtMax;i++)isSmallPrime[i]&&smallPrimes.push(i);
            const isPrimeInRange=new Array(maxNum-minNum+1).fill(!0);
            if(minNum===1&&isPrimeInRange.length>0) isPrimeInRange[0]=!1;
            for(const p of smallPrimes){let s=Math.max(p*p,Math.ceil(minNum/p)*p);for(let j=s;j<=maxNum;j+=p)j>=minNum&&(isPrimeInRange[j-minNum]=!1)}
            const primes=[];
            for(let i=0;i<isPrimeInRange.length;i++)if(isPrimeInRange[i]){const c=minNum+i;c>1&&primes.push(c)}
            return primes;
        }
        onmessage=function(ev){
            let{allPoints:p,targetN:t,primesOnly:po,rangeStart:rs,rangeEnd:re,resFilters:rf}=ev.data;
            const pointsToTest=po?sieve(rs,re):p, a=BigInt(t.a),b=BigInt(t.b),c=BigInt(t.c),s=[],f=[];
            const filterPrimes = rf.map(filt => BigInt(filt.p));
            for(let o of new Set(pointsToTest)){
                if(1===o)continue;
                let l=BigInt(o),n=(powMod(a,b,l)+(c%l+l)%l)%l;
                const isFactor=0n===n;
                let remRatio = -1; // Default for very large numbers
                if (l < Number.MAX_SAFE_INTEGER) {
                    remRatio = isFactor ? 0 : Number(n) / Number(l);
                }
                isFactor&&f.push(o);
                let resonanceColor = [0, 0, 0];
                if (rf.length > 0) {
                    filterPrimes.forEach((fp, i) => {
                        if (l % fp === 0n) resonanceColor[i] = 255;
                    });
                }
                s.push({p:o,isFactor,remainderRatio:remRatio,resonanceColor});
            }
            postMessage({results:s,factorsFound:f});
        };
    `], { type: 'application/javascript' })));
    
    worker.onmessage = e => {
        isRunning = false; 
        startButton.textContent = "RE-RUN";
        startButton.disabled = false;
        
        const pointMap = new Map();
        spiralPoints = generatePointsBatch(e.data.results.map(r => r.p), currentStartP);
        spiralPoints.forEach(p => pointMap.set(p.p, p));

        e.data.results.forEach(res => { 
            const pObj = pointMap.get(res.p);
            if (pObj) { Object.assign(pObj, res); }
        });
        
        e.data.factorsFound.forEach(f => factors.add(f));
        document.getElementById('info_factors').textContent = `Factors: ${factors.size} (${Array.from(factors).join(', ')})`;
        drawSpiral(); 
    };
    
    const getSpiralPoint = (n, startN) => {
        const num = n - startN;
        if (num < 0) return { x: 0, y: 0 };
        const angle = 0.2 * Math.sqrt(num) * Math.PI, radius = 0.8 * Math.sqrt(num);
        return { x: radius * Math.cos(angle), y: radius * Math.sin(angle) };
    };

    const generatePointsBatch = (pointsArray, startP) => pointsArray.map((p) => ({ p, ...getSpiralPoint(p, startP), isFactor: false, remainderRatio: -1, resonanceColor: [0,0,0] }));

    const updateStatus = (message, isAlert = false) => {
        const el = document.getElementById('info_status');
        if (el) {
            el.textContent = `Status: ${message}`;
            el.classList.toggle('status-ready', isAlert);
        }
    };

    function getDPR() { return window.devicePixelRatio || 1; }

    function drawGhostSpiral() {
        ctx.strokeStyle = 'var(--ghost-spiral-color)';
        ctx.lineWidth = 1; // Always 1 backing pixel
        ctx.beginPath();
        const sampleRate = Math.max(1, Math.floor(maxPoints / 2000));
        let first = true;
        for (let i = 0; i < maxPoints; i += sampleRate) {
            const p = currentStartP + i;
            const { x, y } = getSpiralPoint(p, currentStartP);
            const px = x * scale + offsetX; const py = y * scale + offsetY;
            if (first) { ctx.moveTo(px, py); first = false; } else { ctx.lineTo(px, py); }
        }
        ctx.stroke();
    }

    function draw6kLines() {
        ctx.strokeStyle = 'var(--structure-line-color)';
        ctx.lineWidth = 2; // Always 2 backing pixels
        ctx.setLineDash([5, 10]);
        const maxRadius = Math.max(canvas.width, canvas.height);
        for (let k = 1; k < 30; k++) {
             const n_plus_1 = 6 * k * k * 100 + 1, n_minus_1 = 6 * k * k * 100 - 1;
             const {x: x_plus, y: y_plus} = getSpiralPoint(n_plus_1, 1);
             const {x: x_minus, y: y_minus} = getSpiralPoint(n_minus_1, 1);
             
             const angle_plus = Math.atan2(y_plus, x_plus);
             const angle_minus = Math.atan2(y_minus, x_minus);

             ctx.beginPath(); ctx.moveTo(offsetX, offsetY); ctx.lineTo(offsetX + maxRadius * Math.cos(angle_plus), offsetY + maxRadius * Math.sin(angle_plus)); ctx.stroke();
             ctx.beginPath(); ctx.moveTo(offsetX, offsetY); ctx.lineTo(offsetX + maxRadius * Math.cos(angle_minus), offsetY + maxRadius * Math.sin(angle_minus)); ctx.stroke();
        }
        ctx.setLineDash([]);
    }

    function drawSpiral() {
        if (isChunking) return;
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--bg-color');
        ctx.fillRect(0, 0, canvas.width, canvas.height); 

        if (show6kLinesToggle.checked) draw6kLines();
        if (showGhostToggle.checked && maxPoints > 5000) drawGhostSpiral();

        updateStatus(isRunning ? "Sieving & Testing..." : "Idle. Press RUN.");
        
        const dotRadius = Math.max(0.5, Math.min(2.5, 0.7 * scale));
        
        for (const point of spiralPoints) {
            const px = point.x * scale + offsetX; const py = point.y * scale + offsetY;
            if (px + dotRadius < 0 || px - dotRadius > canvas.width || py + dotRadius < 0 || py - dotRadius > canvas.height) continue;
            
            if (point.isFactor) {
                ctx.fillStyle = 'var(--factor-color)';
            } else if (resonanceToggle.checked) {
                const [r, g, b] = point.resonanceColor;
                if (r > 0 || g > 0 || b > 0) ctx.fillStyle = `rgb(${r},${g},${b})`;
                else ctx.fillStyle = 'rgba(100, 100, 100, 0.2)';
            } else if (harmonicModeToggle.checked) {
                if (point.remainderRatio < 0) {
                     ctx.fillStyle = 'rgba(128, 128, 128, 0.5)'; // Grey for large nums
                } else {
                    const hue = 240 - (240 * point.remainderRatio);
                    ctx.fillStyle = `hsl(${hue}, 100%, 50%)`;
                }
            } else { 
                ctx.fillStyle = primeOnlyToggle.checked ? 'var(--prime-color)' : 'rgba(0, 255, 0, 0.5)';
            }
            ctx.beginPath(); ctx.arc(px, py, dotRadius, 0, Math.PI * 2); ctx.fill();
        }

        const factorPoints = spiralPoints.filter(p => p.isFactor);
        if (factorPoints.length > 0) {
             ctx.strokeStyle = 'rgba(255, 255, 0, 0.7)';
             ctx.lineWidth = Math.max(1.5, 4 / scale);
             ctx.shadowColor = 'yellow'; ctx.shadowBlur = 8;
             for (const point of factorPoints) {
                 const px = point.x * scale + offsetX; const py = point.y * scale + offsetY;
                 ctx.beginPath(); ctx.moveTo(offsetX, offsetY); ctx.lineTo(px, py); ctx.stroke();
             }
             ctx.shadowBlur = 0;
        }
        
        ctx.fillStyle = "red";
        ctx.beginPath(); ctx.arc(offsetX, offsetY, Math.max(1, dotRadius * 1.5), 0, Math.PI * 2); ctx.fill();
    }

    const generateNextChunk = direction => {
        if (isChunking) return;
        isChunking = true;
        let newStartP = currentStartP;
        if (direction === 'forward') newStartP += maxPoints;
        else if (direction === 'backward' && currentStartP > 1) newStartP = Math.max(1, currentStartP - maxPoints);
        else { isChunking = false; return; }
        currentStartP = newStartP;

        canvas.style.opacity = 0;
        setTimeout(() => {
            scale = 4.0;
            resizeCanvas(); 
            updateAndRun(true); 
            canvas.style.opacity = 1;
            setTimeout(() => isChunking = false, 50); 
        }, 150);
    };
    
    function resizeCanvas() {
        const dpr = getDPR();
        const rect = canvas.getBoundingClientRect();
        canvas.width = Math.max(1, Math.floor(rect.width * dpr));
        canvas.height = Math.max(1, Math.floor(rect.height * dpr));
        offsetX = canvas.width / 2;
        offsetY = canvas.height / 2;
        drawSpiral();
    }
    
    function parseTargetInput() {
        try {
            const a=BigInt(baseAInput.value), b=BigInt(expBInput.value), c=BigInt(addCInput.value);
            document.getElementById('info_target').textContent = `N: ${a}^${b} + ${c}`;
            return { a: a.toString(), b: b.toString(), c: c.toString() };
        } catch(e) { updateStatus(`Invalid number input.`, true); return null; }
    }

    function updateAndRun(isChunkingCall = false) {
        if (isRunning) return;
        if (!isChunkingCall) {
            targetN = parseTargetInput();
            if (!targetN) return;
            maxPoints = parseInt(maxPointsInput.value, 10);
            if (isNaN(maxPoints) || maxPoints <= 0) { updateStatus('Invalid Range.', true); return; }
            currentStartP = 1; factors.clear();
            document.getElementById('info_factors').textContent = `Factors: 0`;
        }
        const rangeStart = currentStartP, rangeEnd = currentStartP + maxPoints - 1;
        const allPoints = Array.from({length: rangeEnd - rangeStart + 1}, (_, i) => rangeStart + i);
        
        isRunning = true; 
        startButton.textContent = "RUNNING..."; 
        startButton.disabled = true;
        updateStatus("Sieving & Testing...");
        
        document.getElementById('info_range').textContent = `Range: ${rangeStart} to ${rangeEnd}`;
        const resFilters = resonanceToggle.checked ? resonanceFilters : [];
        const primesOnly = !resonanceToggle.checked && primeOnlyToggle.checked;
        worker.postMessage({ allPoints, targetN, primesOnly, rangeStart, rangeEnd, resFilters });
    }

    function showTooltip(text, x, y) {
        clearTimeout(tooltipTimeout);
        tooltip.textContent = text;
        tooltip.style.left = `${x + 15}px`;
        tooltip.style.top = `${y + 15}px`;
        tooltip.style.display = 'block';
        tooltip.style.opacity = 1;
        tooltipTimeout = setTimeout(() => {
            tooltip.style.opacity = 0;
            setTimeout(() => { tooltip.style.display = 'none'; }, 300);
        }, 2500);
    }
    
    function clientToBacking(clientX, clientY) {
        const rect = canvas.getBoundingClientRect();
        const dpr = getDPR();
        return {
            x: (clientX - rect.left) * dpr,
            y: (clientY - rect.top) * dpr,
        };
    }

    function handleCanvasTap(e) {
        const clientX = e.clientX !== undefined ? e.clientX : (e.changedTouches && e.changedTouches[0] && e.changedTouches[0].clientX);
        const clientY = e.clientY !== undefined ? e.clientY : (e.changedTouches && e.changedTouches[0] && e.changedTouches[0].clientY);
        if (clientX == null || clientY == null) return;

        const { x: screenX, y: screenY } = clientToBacking(clientX, clientY);
        const worldX = (screenX - offsetX) / scale;
        const worldY = (screenY - offsetY) / scale;

        let closestPoint = null;
        let minDistance = Infinity;
        const clickThreshold = (10 / scale) ** 2;

        for (const point of spiralPoints) {
            const dx = point.x - worldX;
            const dy = point.y - worldY;
            const distSq = dx * dx + dy * dy;
            if (distSq < minDistance) {
                minDistance = distSq;
                closestPoint = point;
            }
        }

        if (closestPoint && minDistance < clickThreshold) {
            let tooltipText = closestPoint.p.toLocaleString();
            if (harmonicModeToggle.checked && !closestPoint.isFactor) {
                if (closestPoint.remainderRatio < 0) {
                    tooltipText += ` (rem: too large)`;
                } else {
                    const remainder = Math.round(closestPoint.remainderRatio * closestPoint.p);
                    tooltipText += ` (rem: ${remainder})`;
                }
            }
            if (resonanceToggle.checked && (closestPoint.resonanceColor[0] || closestPoint.resonanceColor[1] || closestPoint.resonanceColor[2])) {
                const resonancePrimes = resonanceFilters.filter((f, i) => closestPoint.resonanceColor[i]).map(f => f.p);
                tooltipText += ` (mult of: ${resonancePrimes.join(', ')})`;
            }
            showTooltip(tooltipText, clientX, clientY);
        }
    }

    function renderResonanceFilters() {
        resonanceList.innerHTML = '';
        resonanceFilters.forEach((filter, i) => {
            const item = document.createElement('div');
            item.className = 'resonance-item';
            const color = RESONANCE_COLORS[i];
            item.innerHTML = `
                <div class="color-swatch" style="background-color: ${color};"></div>
                <span>Multiple of ${filter.p} (${['R','G','B'][i]})</span>
                <button data-p="${filter.p}">X</button>
            `;
            resonanceList.appendChild(item);
        });
        addResonanceBtn.disabled = resonanceFilters.length >= 3;
    }

    addResonanceBtn.addEventListener('click', () => {
        if (resonanceFilters.length >= 3) return;
        const p = resonancePrimeInput.value;
        if (p && !isNaN(p) && !resonanceFilters.some(f => f.p === p)) {
            resonanceFilters.push({ p });
            renderResonanceFilters();
            resonancePrimeInput.value = '';
        }
    });

    resonanceList.addEventListener('click', (e) => {
        if (e.target.tagName === 'BUTTON') {
            const pToRemove = e.target.dataset.p;
            resonanceFilters = resonanceFilters.filter(f => f.p !== pToRemove);
            renderResonanceFilters();
        }
    });
    
    resonanceToggle.addEventListener('change', (e) => {
        resonanceContainer.classList.toggle('active', e.target.checked);
        if (e.target.checked) {
            primeOnlyToggle.checked = false;
            primeOnlyToggle.disabled = true;
        } else {
            primeOnlyToggle.disabled = false;
        }
    });
    
    helpButton.addEventListener('click', () => { helpModal.style.display = "flex"; });
    closeButton.addEventListener('click', () => { helpModal.style.display = "none"; });
    window.addEventListener('click', e => { if (e.target == helpModal) helpModal.style.display = "none"; });
    
    startButton.addEventListener('click', () => updateAndRun(false));
    
    const redrawOnChange = () => { if (!isRunning) requestAnimationFrame(drawSpiral); };
    primeOnlyToggle.addEventListener('change', () => { if (!isRunning && !resonanceToggle.checked) updateAndRun(false) });
    harmonicModeToggle.addEventListener('change', redrawOnChange);
    show6kLinesToggle.addEventListener('change', redrawOnChange);
    showGhostToggle.addEventListener('change', redrawOnChange);

    function handleZoom(zoomFactor, screenX, screenY) {
        const oldScale = scale;
        scale = Math.max(0.1, Math.min(scale * zoomFactor, 500));
        offsetX = screenX - (screenX - offsetX) * (scale / oldScale);
        offsetY = screenY - (screenY - offsetY) * (scale / oldScale);
        requestAnimationFrame(drawSpiral);
    }

    canvas.addEventListener('mousedown', e => { 
        isDragging = false;
        tapStart = { x: e.clientX, y: e.clientY, time: Date.now() };
    });
    canvas.addEventListener('mouseup', e => { 
        if (tapStart && (Date.now() - tapStart.time < 250) && !isDragging) {
            handleCanvasTap(e);
        }
        isDragging = false; 
        tapStart = null;
    });
    canvas.addEventListener('mouseleave', () => { isDragging = false; tapStart = null; });
    canvas.addEventListener('mousemove', e => {
        if (tapStart && (Math.hypot(e.clientX - tapStart.x, e.clientY - tapStart.y) > 10)) {
            isDragging = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            tapStart = null;
        }
        if (isDragging) {
            const {x: newX, y: newY} = clientToBacking(e.clientX, e.clientY);
            const {x: oldX, y: oldY} = clientToBacking(lastMouseX, lastMouseY);
            offsetX += newX - oldX;
            offsetY += newY - oldY;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            requestAnimationFrame(drawSpiral);
        }
    });
    canvas.addEventListener('wheel', e => {
        e.preventDefault();
        const {x, y} = clientToBacking(e.clientX, e.clientY);
        handleZoom(e.deltaY < 0 ? 1.15 : 1 / 1.15, x, y);
        if (!isChunking && (scale < MIN_SCALE_TO_SHIFT || scale > MAX_SCALE_TO_SHIFT)) {
            setTimeout(() => {
                if (scale < MIN_SCALE_TO_SHIFT) generateNextChunk('forward');
                else if (scale > MAX_SCALE_TO_SHIFT) generateNextChunk('backward');
            }, 50);
        }
    }, { passive: false });
    canvas.addEventListener('touchstart', e => {
        if (e.touches.length === 1) { 
            const touch = e.touches[0];
            isDragging = false;
            tapStart = { x: touch.clientX, y: touch.clientY, time: Date.now() };
        } else if (e.touches.length === 2) { 
            isDragging = false; 
            tapStart = null;
            lastTouchDistance = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY); 
        }
    });
    canvas.addEventListener('touchmove', e => {
        e.preventDefault();
        if (e.touches.length === 1) {
            const touch = e.touches[0];
            if (tapStart && (Math.hypot(touch.clientX - tapStart.x, touch.clientY - tapStart.y) > 10)) {
                isDragging = true;
                lastMouseX = touch.clientX;
                lastMouseY = touch.clientY;
                tapStart = null; 
            }
            if (isDragging) {
                const {x: newX, y: newY} = clientToBacking(touch.clientX, touch.clientY);
                const {x: oldX, y: oldY} = clientToBacking(lastMouseX, lastMouseY);
                offsetX += newX - oldX;
                offsetY += newY - oldY;
                lastMouseX = touch.clientX;
                lastMouseY = touch.clientY;
                requestAnimationFrame(drawSpiral);
            }
        } else if (e.touches.length === 2 && lastTouchDistance) {
            const dist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
            const {x, y} = clientToBacking(
                (e.touches[0].clientX + e.touches[1].clientX) / 2,
                (e.touches[0].clientY + e.touches[1].clientY) / 2
            );
            handleZoom(dist / lastTouchDistance, x, y);
            lastTouchDistance = dist;
        }
    }, { passive: false });
    canvas.addEventListener('touchend', e => {
        if (tapStart && (Date.now() - tapStart.time < 250) && !isDragging) {
            handleCanvasTap(e);
        }
        isDragging = false; lastTouchDistance = null; tapStart = null;
        if (!isChunking && (scale < MIN_SCALE_TO_SHIFT || scale > MAX_SCALE_TO_SHIFT)) {
            setTimeout(() => {
                if (scale < MIN_SCALE_TO_SHIFT) generateNextChunk('forward');
                else if (scale > MAX_SCALE_TO_SHIFT) generateNextChunk('backward');
            }, 50);
        }
    });
    
    document.addEventListener('DOMContentLoaded', () => { 
        resizeCanvas(); 
        harmonicModeToggle.checked = true;
        updateAndRun(false); 
    });
    window.addEventListener('resize', resizeCanvas);
</script>
</body>
</html>

