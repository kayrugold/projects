<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Prime Builder — Pan, Pinch, Move</title>
<script src="https://unpkg.com/big-integer@1.6.48/BigInteger.min.js"></script>
<style>
  :root { --bg: #071011; --grid: #152428; --cell: #00ff66; --cell-border: #00331a; --ui-bg: rgba(255,255,255,0.92); }
  html,body{height:100%;margin:0;font-family:system-ui,Arial,Helvetica; overflow: hidden;}
  canvas{display:block; width:100vw; height:100vh; touch-action:none; position: fixed; top: 0; left: 0; background-color: var(--bg);}

  .ui-panel {
    background:var(--ui-bg);
    padding:8px 12px;
    border-radius:8px;
    z-index:41;
    display: flex;
    flex-direction: column;
    gap: 6px;
    position: absolute;
    transition: all 0.3s ease;
    box-shadow: 0 2px 10px rgba(0,0,0,0.2);
  }

  #info{ left:12px; top:12px; }
  #patternTester { right: 12px; top: 12px; width: 450px; max-width: 90vw; }
  #primePanelContainer{ bottom:12px; left:50%; transform:translateX(-50%); width:auto; max-width:90vw; }

  .panel-header { display: flex; justify-content: space-between; align-items: center; width: 100%; margin-bottom: 4px; }
  .panel-header h4 { margin: 0; font-size: 14px; }
  .panel-toggle-btn { background: none; border: none; cursor: pointer; padding: 2px; line-height: 1; color: #555; }
  .panel-toggle-btn:hover { color: #000; }

  /* Collapsed States */
  .ui-panel.collapsed .panel-content, .ui-panel.collapsed .panel-header h4 { display: none; }

  #info.collapsed {
    width: 44px; height: 44px; padding: 0; left: 0; top: 12px; border-radius: 0 8px 8px 0; justify-content: center; align-items: center;
  }
  #patternTester.collapsed {
    width: 44px; height: 44px; padding: 0; right: 0; top: 12px; border-radius: 8px 0 0 8px; justify-content: center; align-items: center;
  }
   #primePanelContainer.collapsed {
    width: 180px; height: 44px; padding: 0; bottom: 0; border-radius: 8px 8px 0 0; justify-content: center; align-items: center;
  }
  .ui-panel.collapsed .panel-toggle-btn { display: block; } /* Ensure button is always visible */


  #targetContainer { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; }
  #panelRow {display: flex; justify-content: center; align-items: center; gap: 8px; flex-wrap: wrap;}
  .prime-block{width:40px;height:26px;background:var(--cell);border:2px solid var(--cell-border);border-radius:6px;display:inline-flex;align-items:center;justify-content:center;font-weight:700;cursor:pointer;touch-action:none;flex-shrink:0;}
  label{font-size:12px;margin-right:6px}
  input[type="text"]{font-size:13px;padding:4px 6px;width:88px; border: 1px solid #ccc; border-radius: 4px;}
  input[readonly] { background-color: #eee; }
  .small{font-size:12px;color:#444;margin-top:6px}
  #trashCan { position: absolute; bottom: 12px; right: 12px; width: 50px; height: 50px; background-color: var(--ui-bg); border-radius: 50%; display: flex; align-items: center; justify-content: center; z-index: 50; cursor: pointer; transition: background-color 0.2s, transform 0.2s; }
  #trashCan svg { width: 24px; height: 24px; color: #333; }
  #trashCan.over-trash { background-color: #ffdddd; transform: scale(1.1); }
  #trashCan.over-trash svg { color: #c00; }
  .action-btn { padding: 4px 12px; font-size: 13px; border-radius: 4px; border: 1px solid #aaa; background-color: #f0f0f0; cursor: pointer; }
  .action-btn:hover { background-color: #e0e0e0; }
  .action-btn:disabled { background-color: #ccc; cursor: not-allowed; }
  .checkbox-container { display: flex; align-items: center; gap: 6px; font-size: 12px; }
  .checkbox-container input { margin: 0; }
  #shareModal { display: none; position: fixed; left: 50%; top: 50%; transform: translate(-50%, -50%); background: var(--ui-bg); padding: 20px; border-radius: 8px; z-index: 100; box-shadow: 0 5px 15px rgba(0,0,0,0.3); width: 90%; max-width: 400px; }
  #shareModal p { margin: 0 0 10px 0; font-size: 14px; font-weight: bold; }
  #shareModal input { width: 100%; padding: 8px; font-size: 13px; box-sizing: border-box; margin-bottom: 12px; }
  #shareModal button { float: right; }
  .share-url-container { display: flex; align-items: center; gap: 6px; margin-top: 4px; flex-wrap: wrap; }
  .share-url-container input { flex-grow: 1; width: auto; min-width: 150px; transition: border-color 0.2s; }
  .share-url-container input.error { border-color: red; }
  #numberInfo { font-size: 12px; color: #333; margin-top: 4px; padding-top: 4px; border-top: 1px solid #ddd; }
  .info-prop { font-weight: bold; }
  .pattern-input-row { display: flex; gap: 10px; align-items: center; width: 100%; flex-wrap: wrap; }
  .pattern-input-row input { flex-grow: 1; }
  #patternResults { margin-top: 10px; width: 100%; max-height: 150px; overflow-y: auto; background: rgba(0,0,0,0.02); border-radius: 4px; padding: 6px; font-size: 12px; font-family: monospace; }
  .result-line { display: flex; justify-content: space-between; align-items: center; padding: 2px 4px; border-bottom: 1px solid #eee; }
  .result-line > span:last-child { display: flex; align-items: center; gap: 8px; }
  .result-prime { color: #090; }
  .result-composite { color: #900; }
  .add-to-grid-btn {
    padding: 0;
    width: 20px;
    height: 20px;
    line-height: 18px; /* adjust for vertical centering */
    text-align: center;
    font-size: 16px;
    border-radius: 50%;
    flex-shrink: 0;
  }
</style>
</head>
<body>
<canvas id="grid"></canvas>

<div id="info" class="ui-panel">
    <div class="panel-header">
        <h4>Controls</h4>
        <button class="panel-toggle-btn" data-icon="controls"></button>
    </div>
    <div class="panel-content">
      <div id="targetContainer">
        <label for="target" style="margin:0;">Target:</label>
        <input id="target" type="text" value="100" />
        <button id="autoFactorBtn" class="action-btn">Auto-Factor</button>
        <button id="clearAllBtn" class="action-btn">Clear All</button>
        <button id="shareBtn" class="action-btn">Share</button>
        <button id="newChallengeBtn" class="action-btn" style="display: none;">New Challenge</button>
      </div>
      <div><strong id="composite">Composite: 1</strong></div>
      <div id="numberInfo"></div>
      <div style="display: flex; flex-wrap: wrap; gap: 12px;">
        <div class="checkbox-container">
          <input type="checkbox" id="colorCodeToggle" />
          <label for="colorCodeToggle" style="margin:0;">Color-code primes</label>
        </div>
        <div class="checkbox-container">
          <input type="checkbox" id="challengeModeToggle" />
          <label for="challengeModeToggle" style="margin:0;">Challenge Mode</label>
        </div>
        <div class="checkbox-container">
            <input type="checkbox" id="arrangeFactorsToggle" />
            <label for="arrangeFactorsToggle" style="margin:0;">Arrange Factors</label>
        </div>
      </div>
       <div class="share-url-container">
          <label for="shareBaseUrlInput" style="margin:0; font-size: 12px;">Share/Load URL:</label>
          <input type="text" id="shareBaseUrlInput" placeholder="Paste full link and press Enter to load">
      </div>
      <div class="small">Pan, pinch/wheel zoom, drag blocks, tap to rotate.</div>
    </div>
</div>

<div id="patternTester" class="ui-panel collapsed">
    <div class="panel-header">
        <h4>Pattern Explorer</h4>
        <button class="panel-toggle-btn" data-icon="pattern"></button>
    </div>
    <div class="panel-content">
        <div class="pattern-input-row">
            <label for="patternInput" style="margin:0;">f(n) =</label>
            <input type="text" id="patternInput" value="n^2 ± (n-1)">
            <label for="nStart">from n =</label>
            <input type="number" id="nStart" value="2" style="width: 40px;">
            <label for="nEnd">to</label>
            <input type="number" id="nEnd" value="20" style="width: 40px;">
            <button id="testPatternBtn" class="action-btn">Run</button>
        </div>
        <div id="patternResults"></div>
    </div>
</div>

<div id="primePanelContainer" class="ui-panel">
    <div class="panel-header">
        <h4>Prime Blocks</h4>
        <button class="panel-toggle-btn" data-icon="blocks"></button>
    </div>
    <div class="panel-content">
      <div id="primeSelectorContainer">
        <label for="primeSelectorInput" style="margin:0;">Primes around:</label>
        <input type="text" id="primeSelectorInput" value="13" style="width: 60px;">
        <button id="getPrimesBtn" class="action-btn">Go</button>
      </div>
      <div id="panelRow"></div>
    </div>
</div>


<div id="trashCan">
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg>
</div>

<div id="shareModal">
  <p>Share URL</p>
  <input type="text" id="shareUrlInput" readonly>
  <button id="closeShareModalBtn" class="action-btn">Close</button>
</div>

<script>
/* CONFIG */
const GRID_SIZE = 36;

/* CANVAS SETUP */
const canvas = document.getElementById('grid');
const ctx = canvas.getContext('2d');

function resizeCanvas(){
  const dpr = window.devicePixelRatio || 1;
  canvas.width = Math.round(window.innerWidth * dpr);
  canvas.height = Math.round(window.innerHeight * dpr);
  canvas.style.width = window.innerWidth + 'px';
  canvas.style.height = window.innerHeight + 'px';
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

/* STATE */
let placedBlocks = [];
let pointerMap = new Map();
let offsetX = 0, offsetY = 0;
let scale = 1;
let draggingFromPanel = null;
let movingBlockState = null;
let lastTapCandidate = null;

/* UI refs */
const panelRow = document.getElementById('panelRow');
const compositeEl = document.getElementById('composite');
const numberInfoEl = document.getElementById('numberInfo');
const targetInput = document.getElementById('target');
const autoFactorBtn = document.getElementById('autoFactorBtn');
const clearAllBtn = document.getElementById('clearAllBtn');
const shareBtn = document.getElementById('shareBtn');
const newChallengeBtn = document.getElementById('newChallengeBtn');
const primeSelectorInput = document.getElementById('primeSelectorInput');
const getPrimesBtn = document.getElementById('getPrimesBtn');
const trashCan = document.getElementById('trashCan');
const colorCodeToggle = document.getElementById('colorCodeToggle');
const challengeModeToggle = document.getElementById('challengeModeToggle');
const arrangeFactorsToggle = document.getElementById('arrangeFactorsToggle');
const shareModal = document.getElementById('shareModal');
const shareUrlInput = document.getElementById('shareUrlInput');
const closeShareModalBtn = document.getElementById('closeShareModalBtn');
const shareBaseUrlInput = document.getElementById('shareBaseUrlInput');
const patternInput = document.getElementById('patternInput');
const nStartInput = document.getElementById('nStart');
const nEndInput = document.getElementById('nEnd');
const testPatternBtn = document.getElementById('testPatternBtn');
const patternResultsEl = document.getElementById('patternResults');

/* COLOR HELPERS */
const PREDEFINED_COLORS = {
    '1': { bg: '#dbe4f0', border: '#b2bdd1' },
    '2': { bg: '#ff8787', border: '#e06a6a' },
    '3': { bg: '#74c0fc', border: '#5d9ad9' },
    '5': { bg: '#ffd43b', border: '#c8a62d' },
    '7': { bg: '#da77f2', border: '#b561cc' },
    '11': { bg: '#69db7c', border: '#52a960' },
    '13': { bg: '#ff922b', border: '#c87121' },
    '17': { bg: '#20c997', border: '#19a179' },
    '19': { bg: '#91a7ff', border: '#7486cc' },
};

function getColorForPrime(prime) {
    const pStr = prime.toString();
    if (PREDEFINED_COLORS[pStr]) {
        return PREDEFINED_COLORS[pStr];
    }
    const hue = (Number(prime.mod(360).valueOf()) * 37) % 360;
    return {
        bg: `hsl(${hue}, 70%, 70%)`,
        border: `hsl(${hue}, 60%, 50%)`
    };
}


/* HELPERS: cell shapes and rebuild */
function makeRowShape(prime, anchorX, anchorY){
  const n = Number(prime.valueOf());
  const cells = [];
  for(let i=0;i<n;i++) cells.push({x: anchorX + i, y: anchorY});
  return { prime: bigInt(prime), orientation: 'h', anchor:{x:anchorX,y:anchorY}, cells };
}
function rebuildCellsForBlock(block){
  const n = block.cells.length;
  const ax = block.anchor.x, ay = block.anchor.y;
  const arr = [];
  if(block.orientation === 'h'){
    for(let i=0;i<n;i++) arr.push({x: ax + i, y: ay});
  } else {
    for(let i=0;i<n;i++) arr.push({x: ax, y: ay + i});
  }
  block.cells = arr;
}
function rotateBlock(block){
  block.orientation = (block.orientation === 'h') ? 'v' : 'h';
  rebuildCellsForBlock(block);
}

/* PRIME NUMBER HELPERS */
function isPrime(n) {
    n = bigInt(n);
    if (n.leq(1)) return false;
    if (n.leq(3)) return true;
    if (n.isEven() || n.mod(3).isZero()) return false;
    let i = bigInt(5);
    while (i.multiply(i).leq(n)) {
        if (n.mod(i).isZero() || n.mod(i.add(2)).isZero()) return false;
        i = i.add(6);
    }
    return true;
}

function getPrimeFactors(num) {
    let n = bigInt(num);
    const factors = [];
    if (n.leq(1)) return factors;
    while (n.isEven()) {
        factors.push(bigInt(2));
        n = n.divide(2);
    }
    for (let i = bigInt(3); i.multiply(i).leq(n); i = i.add(2)) {
        while (n.mod(i).isZero()) {
            factors.push(i);
            n = n.divide(i);
        }
    }
    if (n.gt(1)) {
        factors.push(n);
    }
    return factors;
}


/* PANEL: create prime block buttons based on target */
function renderPrimePanel(target) {
    let targetNum;
    try {
        targetNum = bigInt(String(target).trim());
        if (targetNum.lt(2)) targetNum = bigInt(2);
    } catch (e) {
        targetNum = bigInt(13);
    }

    const primesToShow = new Set();
    const NUM_PRIMES_BEFORE = 2;
    const NUM_PRIMES_AFTER = 4;

    if(isPrime(targetNum)) {
        primesToShow.add(targetNum.toString());
    }

    let current = targetNum.prev();
    let foundBefore = 0;
    while (foundBefore < NUM_PRIMES_BEFORE && current.greater(1)) {
        if (isPrime(current)) {
            primesToShow.add(current.toString());
            foundBefore++;
        }
        current = current.prev();
    }

    current = targetNum.next();
    let foundAfter = 0;
    const searchLimit = current.add(500);
    while (foundAfter < NUM_PRIMES_AFTER && current.lt(searchLimit)) {
        if (isPrime(current)) {
            primesToShow.add(current.toString());
            foundAfter++;
        }
        current = current.next();
    }

    const finalPrimes = Array.from(new Set([ "1", "2", ...primesToShow ])).map(s => bigInt(s)).sort((a,b) => a.compareTo(b));

    panelRow.innerHTML = '';
    const useColors = colorCodeToggle.checked;
    finalPrimes.forEach(p => {
        const el = document.createElement('div');
        el.className = 'prime-block';
        el.textContent = String(p);
        el.dataset.prime = String(p);

        if (useColors) {
            const colors = getColorForPrime(p);
            el.style.backgroundColor = colors.bg;
            el.style.borderColor = colors.border;
        } else {
            el.style.backgroundColor = '';
            el.style.borderColor = '';
        }

        panelRow.appendChild(el);

        el.addEventListener('pointerdown', (ev) => {
            ev.preventDefault();
            if (arrangeFactorsToggle.checked) return;
            const pid = ev.pointerId;
            draggingFromPanel = {
                pointerId: pid,
                prime: bigInt(String(p)),
                clientX: ev.clientX,
                clientY: ev.clientY,
                gridX: 0,
                gridY: 0,
                overCanvas: false
            };
            window.addEventListener('pointermove', panelPointerMove);
            window.addEventListener('pointerup', panelPointerUp);
        });
    });
}

/* TRASH CAN HELPER */
function isOverTrash(clientX, clientY) {
    const rect = trashCan.getBoundingClientRect();
    return ( clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom );
}

/* PANEL drag move & up handlers */
function panelPointerMove(e){
  if(!draggingFromPanel || e.pointerId !== draggingFromPanel.pointerId) return;
  draggingFromPanel.clientX = e.clientX;
  draggingFromPanel.clientY = e.clientY;
  const rect = canvas.getBoundingClientRect();
  const inside = (e.clientX >= rect.left && e.clientX <= rect.right && e.clientY >= rect.top && e.clientY <= rect.bottom);
  draggingFromPanel.overCanvas = inside;
  if(inside){
    const cssX = e.clientX - rect.left - offsetX;
    const cssY = e.clientY - rect.top - offsetY;
    draggingFromPanel.gridX = Math.round(cssX / (GRID_SIZE * scale));
    draggingFromPanel.gridY = Math.round(cssY / (GRID_SIZE * scale));
  }
  trashCan.classList.toggle('over-trash', isOverTrash(e.clientX, e.clientY));
  e.preventDefault();
}

function panelPointerUp(e){
  if(!draggingFromPanel || e.pointerId !== draggingFromPanel.pointerId) return;

  if (draggingFromPanel.overCanvas && !isOverTrash(e.clientX, e.clientY)) {
    const newBlock = makeRowShape(draggingFromPanel.prime, draggingFromPanel.gridX, draggingFromPanel.gridY);
    placedBlocks.push(newBlock);
    updateComposite();
  }

  trashCan.classList.remove('over-trash');
  draggingFromPanel = null;
  window.removeEventListener('pointermove', panelPointerMove);
  window.removeEventListener('pointerup', panelPointerUp);
}

/* COORD TRANSFORMS */
function clientToGrid(clientX, clientY){
  const rect = canvas.getBoundingClientRect();
  const cssX = clientX - rect.left - offsetX;
  const cssY = clientY - rect.top - offsetY;
  const gx = Math.floor(cssX / (GRID_SIZE * scale));
  const gy = Math.floor(cssY / (GRID_SIZE * scale));
  return { gx, gy, cssX, cssY };
}

/* POINTER TRACKING */
canvas.addEventListener('pointerdown', (ev) => {
  pointerMap.set(ev.pointerId, { clientX: ev.clientX, clientY: ev.clientY });
  if(draggingFromPanel && ev.pointerId === draggingFromPanel.pointerId) return;

  const { gx, gy } = clientToGrid(ev.clientX, ev.clientY);
  for(let i = placedBlocks.length - 1; i >= 0; i--){
    const block = placedBlocks[i];
    if(block.cells.some(c => c.x === gx && c.y === gy)){
      if (arrangeFactorsToggle.checked) {
          // Allow tap-to-rotate in arrange mode, but no drag.
          lastTapCandidate = { pointerId: ev.pointerId, clientX: ev.clientX, clientY: ev.clientY, time: Date.now(), block: block };
      } else {
          movingBlockState = {
            pointerId: ev.pointerId, block: block, originalIndex: i,
            offsetCellX: gx - block.anchor.x, offsetCellY: gy - block.anchor.y
          };
          placedBlocks.splice(i, 1);
          lastTapCandidate = { pointerId: ev.pointerId, clientX: ev.clientX, clientY: ev.clientY, time: Date.now() };
      }
      try{ canvas.setPointerCapture(ev.pointerId); }catch(e){}
      return;
    }
  }

  lastTapCandidate = { pointerId: ev.pointerId, clientX: ev.clientX, clientY: ev.clientY, time: Date.now() };
  try{ canvas.setPointerCapture(ev.pointerId); }catch(e){}
});

canvas.addEventListener('pointermove', (ev) => {
  if(pointerMap.has(ev.pointerId)) pointerMap.set(ev.pointerId, { clientX: ev.clientX, clientY: ev.clientY });
  if(draggingFromPanel && ev.pointerId === draggingFromPanel.pointerId) return;
  if(movingBlockState && ev.pointerId === movingBlockState.pointerId){
    const { gx, gy } = clientToGrid(ev.clientX, ev.clientY);
    movingBlockState.block.anchor.x = gx - movingBlockState.offsetCellX;
    movingBlockState.block.anchor.y = gy - movingBlockState.offsetCellY;
    rebuildCellsForBlock(movingBlockState.block);
    updateComposite();
    trashCan.classList.toggle('over-trash', isOverTrash(ev.clientX, ev.clientY));
    return;
  }

  if(pointerMap.size >= 2){
    const pts = Array.from(pointerMap.values());
    if(!canvas._pinchPrev) {
      const [a,b] = pts;
      canvas._pinchPrev = { dist: Math.hypot(a.clientX - b.clientX, a.clientY - b.clientY), midX: (a.clientX + b.clientX)/2, midY: (a.clientY + b.clientY)/2 };
      return;
    } else {
      const [a,b] = pts;
      const newDist = Math.hypot(a.clientX - b.clientX, a.clientY - b.clientY);
      const factor = newDist / canvas._pinchPrev.dist;
      if(!isFinite(factor) || factor <= 0) return;
      const midX = (a.clientX + b.clientX)/2;
      const midY = (a.clientY + b.clientY)/2;
      const rect = canvas.getBoundingClientRect();
      const cssMidX = midX - rect.left;
      const cssMidY = midY - rect.top;
      offsetX = cssMidX - ( (cssMidX - offsetX) * factor );
      offsetY = cssMidY - ( (cssMidY - offsetY) * factor );
      scale = scale * factor;
      canvas._pinchPrev.dist = newDist;
      canvas._pinchPrev.midX = midX;
      canvas._pinchPrev.midY = midY;
      return;
    }
  } else {
    canvas._pinchPrev = null;
  }

  if(pointerMap.size === 1 && !movingBlockState){
    const p = pointerMap.values().next().value;
    if(!canvas._lastPan) {
      canvas._lastPan = { x: p.clientX, y: p.clientY };
    } else {
      const dx = p.clientX - canvas._lastPan.x;
      const dy = p.clientY - canvas._lastPan.y;
      offsetX += dx;
      offsetY += dy;
      canvas._lastPan = { x: p.clientX, y: p.clientY };
    }
    return;
  }
});

canvas.addEventListener('pointerup', (ev) => {
  pointerMap.delete(ev.pointerId);
  try{ canvas.releasePointerCapture(ev.pointerId); }catch(e){}

  if(movingBlockState && lastTapCandidate && movingBlockState.pointerId === ev.pointerId && lastTapCandidate.pointerId === ev.pointerId){
    const wasMoving = movingBlockState;
    movingBlockState = null;

    const dt = Date.now() - lastTapCandidate.time;
    const dx = Math.abs(ev.clientX - lastTapCandidate.clientX);
    const dy = Math.abs(ev.clientY - lastTapCandidate.clientY);
    const isTap = dt < 350 && (dx <= 8 && dy <= 8);

    if (isTap && !arrangeFactorsToggle.checked) {
        placedBlocks.push(wasMoving.block);
        rotateBlock(wasMoving.block);
    } else {
        if (isOverTrash(ev.clientX, ev.clientY)) {
            // Block is removed
        } else {
            if (!arrangeFactorsToggle.checked) {
                wasMoving.block.anchor.x = Math.round(wasMoving.block.anchor.x);
                wasMoving.block.anchor.y = Math.round(wasMoving.block.anchor.y);
                rebuildCellsForBlock(wasMoving.block);
            }
            placedBlocks.push(wasMoving.block);
        }
    }

    trashCan.classList.remove('over-trash');
    updateComposite();
    lastTapCandidate = null;
    return;
  }

  if(lastTapCandidate && lastTapCandidate.pointerId === ev.pointerId && arrangeFactorsToggle.checked){
      const dt = Date.now() - lastTapCandidate.time;
      const dx = Math.abs(ev.clientX - lastTapCandidate.clientX);
      const dy = Math.abs(ev.clientY - lastTapCandidate.clientY);
      const isTap = dt < 350 && (dx <= 8 && dy <= 8);
      if(isTap && lastTapCandidate.block) {
        rotateBlock(lastTapCandidate.block);
        updateComposite();
      }
  }

  if(pointerMap.size === 0){
    canvas._lastPan = null;
    canvas._pinchPrev = null;
  }
  lastTapCandidate = null;
});


canvas.addEventListener('wheel', (ev) => {
    ev.preventDefault();

    const zoomIntensity = 0.1;
    const scroll = ev.deltaY < 0 ? 1 : -1;
    const factor = 1 + scroll * zoomIntensity;

    const rect = canvas.getBoundingClientRect();
    const cssX = ev.clientX - rect.left;
    const cssY = ev.clientY - rect.top;

    offsetX = cssX - ((cssX - offsetX) * factor);
    offsetY = cssY - ((cssY - offsetY) * factor);

    scale *= factor;
});

/* DATA ANALYSIS & UPDATE */
function getNumberProperties(factors) {
    if (factors.length === 0) {
        return {
            totalFactors: 0,
            uniqueFactors: 0,
            classifications: []
        };
    }

    const counts = new Map();
    for (const p of factors) {
        const pStr = p.toString();
        counts.set(pStr, (counts.get(pStr) || 0) + 1);
    }

    const classifications = [];
    const exponents = Array.from(counts.values());

    // Check for Perfect Square
    if (exponents.every(e => e % 2 === 0)) {
        classifications.push('Perfect Square');
    }

    // Check for Perfect Cube
    if (exponents.every(e => e % 3 === 0)) {
        classifications.push('Perfect Cube');
    }

    return {
        totalFactors: factors.length,
        uniqueFactors: counts.size,
        classifications: classifications
    };
}

function getDivisors(n) {
    const divisors = [];
    for (let i = 1; i * i <= n; i++) {
        if (n % i === 0) {
            divisors.push(i);
            if (i * i !== n) {
                divisors.push(n / i);
            }
        }
    }
    return divisors;
}


function arrangeFactors() {
    if (!arrangeFactorsToggle.checked || placedBlocks.length === 0) return;

    let totalCells = 0;
    placedBlocks.forEach(b => totalCells += b.cells.length);

    const divisors = getDivisors(totalCells);
    let bestFit = { w: totalCells, h: 1, diff: totalCells - 1 };
    divisors.forEach(d => {
        const other = totalCells / d;
        if (Math.abs(d - other) < bestFit.diff) {
            bestFit = { w: Math.max(d, other), h: Math.min(d, other), diff: Math.abs(d-other) };
        }
    });

    const { w, h } = bestFit;
    const grid = Array(h).fill().map(() => Array(w).fill(false));

    placedBlocks.sort((a, b) => b.prime.compareTo(a.prime));

    let allPlaced = true;
    for (const block of placedBlocks) {
        let placed = false;
        for (let r = 0; r < h; r++) {
            for (let c = 0; c < w; c++) {
                if (grid[r][c]) continue;

                // Try horizontal
                block.orientation = 'h';
                rebuildCellsForBlock(block);
                let canPlaceH = (c + block.cells.length <= w);
                if (canPlaceH) {
                    for(let i=0; i<block.cells.length; i++) {
                        if (grid[r][c+i]) { canPlaceH = false; break; }
                    }
                }

                if (canPlaceH) {
                    block.anchor.x = c;
                    block.anchor.y = r;
                    rebuildCellsForBlock(block);
                    for(let i=0; i<block.cells.length; i++) grid[r][c+i] = true;
                    placed = true;
                    break;
                }

                // Try vertical
                block.orientation = 'v';
                rebuildCellsForBlock(block);
                let canPlaceV = (r + block.cells.length <= h);
                 if (canPlaceV) {
                    for(let i=0; i<block.cells.length; i++) {
                        if (grid[r+i][c]) { canPlaceV = false; break; }
                    }
                }

                if (canPlaceV) {
                    block.anchor.x = c;
                    block.anchor.y = r;
                    rebuildCellsForBlock(block);
                    for(let i=0; i<block.cells.length; i++) grid[r+i][c] = true;
                    placed = true;
                    break;
                }
            }
            if(placed) break;
        }
         if (!placed) {
            allPlaced = false;
            // Fallback for blocks that couldn't be placed
            block.anchor.x = 0; block.anchor.y = 0;
            rebuildCellsForBlock(block);
        }
    }
}


function updateComposite(){
  if (arrangeFactorsToggle.checked) {
    arrangeFactors();
  }

  let prod = bigInt(1);
  let sum = bigInt(0);
  const primeFactors = [];
  placedBlocks.forEach(b => {
      prod = prod.multiply(b.prime);
      sum = sum.add(b.prime);
      primeFactors.push(b.prime);
  });

  compositeEl.innerHTML = `Composite: ${prod.toString()} <span style="font-weight: normal; color: #555;">[Sum: ${sum.toString()}]</span>`;

  const properties = getNumberProperties(primeFactors);
  let infoHtml = `<div><span class="info-prop">Total Factors:</span> ${properties.totalFactors} | <span class="info-prop">Unique:</span> ${properties.uniqueFactors}</div>`;
  if (properties.classifications.length > 0) {
      infoHtml += `<div><span class="info-prop">Classification:</span> ${properties.classifications.join(', ')}</div>`;
  }
  numberInfoEl.innerHTML = infoHtml;

  const target = bigInt(String(targetInput.value.trim() || "0"));
  document.body.style.background = (!target.isZero() && prod.equals(target)) ? '#043' : '';
}

/* STATE SHARING */
function serializeState() {
    return placedBlocks.map(b => {
        return `${b.prime.toString()},${b.anchor.x},${b.anchor.y},${b.orientation}`;
    }).join(';');
}

function deserializeAndLoadState(stateString) {
    if (typeof stateString !== 'string' || !stateString) return false;
    try {
        const newBlocks = [];
        const blockStrings = stateString.split(';');
        for (const blockStr of blockStrings) {
            if (!blockStr) continue;
            const parts = blockStr.split(',');
            if (parts.length !== 4) continue; // Basic validation
            const prime = bigInt(parts[0]);
            const x = parseInt(parts[1], 10);
            const y = parseInt(parts[2], 10);
            const orientation = parts[3];

            const newBlock = makeRowShape(prime, x, y);
            if (orientation === 'v') {
                rotateBlock(newBlock);
            }
            newBlocks.push(newBlock);
        }
        placedBlocks = newBlocks; // Only replace if successful
    } catch(e) {
        console.error("Failed to parse state string:", e);
        return false;
    }
    updateComposite();
    return true;
}

function loadStateFromURL() {
    if (window.location.hash) {
        try {
            const encoded = window.location.hash.substring(1);
            const decoded = atob(encoded);
            deserializeAndLoadState(decoded);
        } catch (e) {
            console.error("Failed to load state from URL hash:", e);
            window.location.hash = '';
        }
    }
}

/* EVENT LISTENERS */
targetInput.addEventListener('input', updateComposite);

function handleAutoFactor() {
    if (challengeModeToggle.checked) return;
    try {
        const targetNum = bigInt(String(targetInput.value.trim()));
        if (targetNum.lt(2)) {
            placedBlocks = [];
            updateComposite();
            return;
        };
        const factors = getPrimeFactors(targetNum);
        placedBlocks = [];
        for (const factor of factors) {
            // The arrangement will be handled by updateComposite
            placedBlocks.push(makeRowShape(factor, 0, 0));
        }
        updateComposite();
    } catch(e) { console.error("Invalid number for auto-factoring:", e); }
}
autoFactorBtn.addEventListener('click', handleAutoFactor);

function handleClearAll() {
    placedBlocks = [];
    updateComposite();
    if (!challengeModeToggle.checked) {
       window.location.hash = '';
    }
}
clearAllBtn.addEventListener('click', handleClearAll);

function handleShare() {
    const serialized = serializeState();
    const encoded = btoa(serialized);

    let baseUrl = shareBaseUrlInput.value.trim().split('#')[0]; // Use the input but remove any hash it might have
    if (!baseUrl) {
        baseUrl = window.location.href.split('#')[0];
    }

    const finalUrl = baseUrl + '#' + encoded;

    shareUrlInput.value = finalUrl;
    shareModal.style.display = 'block';
    shareUrlInput.select();
    shareUrlInput.setSelectionRange(0, 99999);

    try {
        document.execCommand('copy');
        shareBtn.textContent = 'Copied!';
        setTimeout(() => { shareBtn.textContent = 'Share'; }, 2000);
    } catch (err) {
        console.error('Could not copy text: ', err);
    }
}
shareBtn.addEventListener('click', handleShare);

function closeShareModal() {
    shareModal.style.display = 'none';
}
closeShareModalBtn.addEventListener('click', closeShareModal);

shareBaseUrlInput.addEventListener('keyup', (ev) => {
    if (ev.key === 'Enter') {
        const url = shareBaseUrlInput.value;
        const parts = url.split('#');
        if (parts.length > 1 && parts[1]) {
            try {
                const encoded = parts[1];
                const decoded = atob(encoded);
                const success = deserializeAndLoadState(decoded);
                if (success) {
                    window.location.hash = encoded; // Update the URL bar for consistency
                    shareBaseUrlInput.value = ''; // Clear on success
                    shareBaseUrlInput.classList.remove('error');
                } else {
                    shareBaseUrlInput.classList.add('error');
                    setTimeout(() => shareBaseUrlInput.classList.remove('error'), 1000);
                }
            } catch (e) {
                shareBaseUrlInput.classList.add('error');
                setTimeout(() => shareBaseUrlInput.classList.remove('error'), 1000);
            }
        }
    }
});

function generateNewPrimes() {
    renderPrimePanel(primeSelectorInput.value);
}
getPrimesBtn.addEventListener('click', generateNewPrimes);
primeSelectorInput.addEventListener('keyup', (ev) => {
    if (ev.key === 'Enter') generateNewPrimes();
});

colorCodeToggle.addEventListener('change', () => {
    renderPrimePanel(primeSelectorInput.value);
});

/* CHALLENGE MODE */
function startNewChallenge() {
    const primes = [2, 3, 5, 7, 11, 13, 2, 3, 5]; // Skew towards smaller numbers
    const factor1 = primes[Math.floor(Math.random() * primes.length)];
    const factor2 = primes[Math.floor(Math.random() * primes.length)];
    let challengeNumber = factor1 * factor2;
    // Add a third factor sometimes for more variety
    if (Math.random() > 0.6) {
        const factor3 = primes[Math.floor(Math.random() * primes.length)];
        challengeNumber *= factor3;
    }

    targetInput.value = challengeNumber;
    handleClearAll();
    updateComposite();
}
newChallengeBtn.addEventListener('click', startNewChallenge);

challengeModeToggle.addEventListener('change', (ev) => {
    const isEnabled = ev.target.checked;
    targetInput.readOnly = isEnabled;
    autoFactorBtn.disabled = isEnabled;
    newChallengeBtn.style.display = isEnabled ? 'inline-block' : 'none';
    if (isEnabled) {
        startNewChallenge();
    } else {
        targetInput.value = '100'; // Reset to a default
        handleClearAll();
        updateComposite();
    }
});
arrangeFactorsToggle.addEventListener('change', updateComposite);

/* PATTERN EXPLORER */
function safeCalculate(expression, n) {
    // Sanitize by only allowing specific characters.
    const sanitized = expression.replace(/[^0-9n\+\-\*\/\^\(\)\s]/g, '');
    // Replace ^ with JavaScript's ** for exponentiation.
    const jsExpression = sanitized.replace(/\^/g, '**');
    try {
        // Use the Function constructor for safer evaluation than eval().
        const func = new Function('n', 'return ' + jsExpression);
        const result = func(bigInt(n));
        return bigInt(result);
    } catch (e) {
        console.error("Pattern evaluation error:", e);
        return null; // Return null on error
    }
}

function handlePatternTest() {
    patternResultsEl.innerHTML = '';
    const formula = patternInput.value;
    const nStart = parseInt(nStartInput.value, 10);
    const nEnd = parseInt(nEndInput.value, 10);

    if (isNaN(nStart) || isNaN(nEnd) || nStart > nEnd) {
        patternResultsEl.textContent = 'Invalid range for n.';
        return;
    }

    const formulas = formula.includes('±')
        ? [formula.replace('±', '+'), formula.replace('±', '-')]
        : [formula];

    for (let i = nStart; i <= nEnd; i++) {
        const n = bigInt(i);
        formulas.forEach((f, idx) => {
            const result = safeCalculate(f, n);
            if (result !== null && result.gt(0)) {
                const isP = isPrime(result);
                const line = document.createElement('div');
                line.className = 'result-line';

                let formulaPart = `f(${n})`
                if(formulas.length > 1) {
                   formulaPart += (idx === 0) ? ` (+) = ${result}` : ` (-) = ${result}`;
                } else {
                   formulaPart += ` = ${result}`;
                }

                const formulaSpan = document.createElement('span');
                formulaSpan.textContent = formulaPart;

                const statusSpan = document.createElement('span');

                const statusText = document.createElement('span');
                statusText.className = isP ? 'result-prime' : 'result-composite';
                statusText.textContent = isP ? 'Prime' : 'Composite';
                statusSpan.appendChild(statusText);

                if (isP && result.lt(100)) {
                    const addButton = document.createElement('button');
                    addButton.innerHTML = `+`;
                    addButton.className = 'action-btn add-to-grid-btn';
                    addButton.title = 'Add this prime to the grid';
                    addButton.onclick = (e) => {
                        e.stopPropagation();
                        if (arrangeFactorsToggle.checked) {
                            placedBlocks.push(makeRowShape(result, 0, 0));
                        } else {
                           const center = clientToGrid(canvas.clientWidth / 2, canvas.clientHeight / 2);
                           placedBlocks.push(makeRowShape(result, center.gx, center.gy));
                        }
                        updateComposite();
                    };
                    statusSpan.appendChild(addButton);
                }

                line.appendChild(formulaSpan);
                line.appendChild(statusSpan);
                patternResultsEl.appendChild(line);
            }
        });
    }
}
testPatternBtn.addEventListener('click', handlePatternTest);


/* PANEL TOGGLING */
const ICONS = {
    controls: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg>`,
    pattern: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M13.02 5.02a8 8 0 0 0-9.04 9.04"></path><path d="M18.98 18.98a8 8 0 0 0-9.04-9.04"></path><path d="M12 2v2"></path><path d="M12 20v2"></path><path d="m4.93 4.93 1.41 1.41"></path><path d="m17.66 17.66 1.41 1.41"></path><path d="M2 12h2"></path><path d="M20 12h2"></path><path d="m6.34 17.66-1.41 1.41"></path><path d="m19.07 4.93-1.41 1.41"></path></svg>`,
    blocks: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="7" height="7"></rect><rect x="14" y="3" width="7" height="7"></rect><rect x="14" y="14" width="7" height="7"></rect><rect x="3" y="14" width="7" height="7"></rect></svg>`,
    minimize: `<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="12" x2="19" y2="12"></line></svg>`
};

document.querySelectorAll('.panel-toggle-btn').forEach(btn => {
    const panel = btn.closest('.ui-panel');
    const iconType = btn.dataset.icon;

    // Set initial icon based on initial state
    if (panel.classList.contains('collapsed')) {
        btn.innerHTML = ICONS[iconType];
    } else {
        btn.innerHTML = ICONS.minimize;
    }

    btn.addEventListener('click', () => {
        const isCollapsed = panel.classList.toggle('collapsed');
        btn.innerHTML = isCollapsed ? ICONS[iconType] : ICONS.minimize;
    });
});


/* DRAW LOOP */
function draw(){
  ctx.clearRect(0,0,canvas.clientWidth, canvas.clientHeight);
  ctx.save();
  ctx.translate(offsetX, offsetY);
  ctx.scale(scale, scale);

  const cssW = canvas.clientWidth, cssH = canvas.clientHeight;
  const startCol = Math.floor((-offsetX) / (GRID_SIZE * scale)) - 2;
  const endCol = Math.ceil((cssW - offsetX) / (GRID_SIZE * scale)) + 2;
  const startRow = Math.floor((-offsetY) / (GRID_SIZE * scale)) - 2;
  const endRow = Math.ceil((cssH - offsetY) / (GRID_SIZE * scale)) + 2;

  ctx.lineWidth = 1 / scale;
  ctx.strokeStyle = '#123233';
  for(let c = startCol; c <= endCol; c++){
    const x = c * GRID_SIZE;
    ctx.beginPath(); ctx.moveTo(x + 0.5/scale, startRow*GRID_SIZE); ctx.lineTo(x + 0.5/scale, endRow*GRID_SIZE); ctx.stroke();
  }
  for(let r = startRow; r <= endRow; r++){
    const y = r * GRID_SIZE;
    ctx.beginPath(); ctx.moveTo(startCol*GRID_SIZE, y + 0.5/scale); ctx.lineTo(endCol*GRID_SIZE, y + 0.5/scale); ctx.stroke();
  }

  const useColors = colorCodeToggle.checked;

  for(const block of placedBlocks){
    if (useColors) {
        const colors = getColorForPrime(block.prime);
        ctx.fillStyle = colors.bg;
        ctx.strokeStyle = colors.border;
    } else {
        ctx.fillStyle = 'rgba(0,255,102,1)';
        ctx.strokeStyle = 'rgba(0,34,12,1)';
    }

    for(const cell of block.cells){
      const x = cell.x * GRID_SIZE;
      const y = cell.y * GRID_SIZE;
      ctx.fillRect(x, y, GRID_SIZE, GRID_SIZE);
      ctx.strokeRect(x, y, GRID_SIZE, GRID_SIZE);
    }
    const mid = Math.floor(block.cells.length/2);
    const mc = block.cells[mid];
    ctx.fillStyle = '#000';
    ctx.font = `${Math.max(12, GRID_SIZE*0.38)}px system-ui`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    if (block.orientation === 'h') {
        ctx.fillText(block.prime.toString(), (mc.x + 0.5) * GRID_SIZE, (mc.y + 0.5) * GRID_SIZE);
    } else {
        ctx.save();
        ctx.translate((mc.x + 0.5) * GRID_SIZE, (mc.y + 0.5) * GRID_SIZE);
        ctx.rotate(-Math.PI / 2);
        ctx.fillText(block.prime.toString(), 0, 0);
        ctx.restore();
    }
  }

  // Draw the block currently being moved so it's visible during drag
  if (movingBlockState) {
    const block = movingBlockState.block;
    if (useColors) {
        const colors = getColorForPrime(block.prime);
        ctx.fillStyle = colors.bg;
        ctx.strokeStyle = colors.border;
    } else {
        ctx.fillStyle = 'rgba(0,255,102,1)';
        ctx.strokeStyle = 'rgba(0,34,12,1)';
    }

    ctx.globalAlpha = 0.75; // Make it slightly transparent

    for(const cell of block.cells){
      const x = cell.x * GRID_SIZE;
      const y = cell.y * GRID_SIZE;
      ctx.fillRect(x + 1, y + 1, GRID_SIZE - 2, GRID_SIZE - 2);
      ctx.strokeRect(x + 1, y + 1, GRID_SIZE - 2, GRID_SIZE - 2);
    }
    const mid = Math.floor(block.cells.length/2);
    const mc = block.cells[mid];
    ctx.fillStyle = '#000';
    ctx.font = `${Math.max(12, GRID_SIZE*0.38)}px system-ui`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(block.prime.toString(), (mc.x + 0.5) * GRID_SIZE, (mc.y + 0.5) * GRID_SIZE);

    ctx.globalAlpha = 1.0; // Reset alpha
  }

  if(draggingFromPanel && draggingFromPanel.overCanvas){
    const n = Number(draggingFromPanel.prime.valueOf());
    const ax = draggingFromPanel.gridX, ay = draggingFromPanel.gridY;
    ctx.globalAlpha = isOverTrash(draggingFromPanel.clientX, draggingFromPanel.clientY) ? 0.2 : 0.65;

    if (useColors) {
        const colors = getColorForPrime(draggingFromPanel.prime);
        ctx.fillStyle = colors.bg;
        ctx.strokeStyle = colors.border;
    } else {
        ctx.fillStyle = 'rgba(0,200,120,0.95)';
        ctx.strokeStyle = 'rgba(0,36,12,0.95)';
    }

    for(let i=0;i<n;i++){
      const cx = (ax + i) * GRID_SIZE;
      const cy = ay * GRID_SIZE;
      ctx.fillRect(cx + 1, cy + 1, GRID_SIZE - 2, GRID_SIZE - 2);
      ctx.strokeRect(cx + 1, cy + 1, GRID_SIZE - 2, GRID_SIZE - 2);
    }
    ctx.globalAlpha = 1;
    ctx.fillStyle = '#000';
    ctx.font = `${Math.max(12,GRID_SIZE*0.36)}px system-ui`;
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    const midCell = { x: ax + Math.floor(n/2), y: ay };
    ctx.fillText(draggingFromPanel.prime.toString(), (midCell.x + 0.5) * GRID_SIZE, (midCell.y + 0.5) * GRID_SIZE);
  }

  ctx.restore();
  requestAnimationFrame(draw);
}

/* INITIAL SETUP */
loadStateFromURL();
renderPrimePanel(primeSelectorInput.value);
if (placedBlocks.length === 0) { // To avoid double-counting if loaded from URL
    updateComposite();
}
requestAnimationFrame(draw);
window.addEventListener('resize', updateComposite);

</script>
</body>
</html>


