<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, interactive-widget=resizes-content, viewport-fit=cover">
<title>Architect v10.4 (Mobile Fix)</title>
<script src="https://cdn.tailwindcss.com"></script>
<style>
    :root { --col-count: 30; --tile-size: 24px; }
    
    body { 
        background-color: #020617; 
        color: #e2e8f0; 
        font-family: 'Courier New', monospace; 
        margin: 0; 
        /* CHANGED: 100dvh ensures the app fits inside the visible browser area (accounting for URL bars) */
        height: 100dvh; 
        display: flex; 
        flex-direction: column; 
        overflow: hidden; 
    }
    
    .grid-viewport { 
        flex-grow: 1; 
        overflow-y: auto; /* Changed to auto for native scrolling momentum */
        background: #020617; 
        position: relative; 
        display: flex; 
        justify-content: center; 
        align-items: start;
        padding: 10px;
        -webkit-overflow-scrolling: touch;
    }
    
    .sector-grid { 
        display: grid; 
        grid-template-columns: repeat(var(--col-count), var(--tile-size)); 
        gap: 2px; 
        padding-bottom: 20px;
    }
    
    .tile { 
        width: var(--tile-size); height: var(--tile-size);
        background: #0f172a; border: 1px solid #1e293b; 
        display: flex; align-items: center; justify-content: center; 
        font-size: calc(var(--tile-size) * 0.35); color: #475569; 
        cursor: pointer; border-radius: 2px; user-select: none;
    }
    .tile.survivor { background: #059669; border-color: #10b981; color: #ccfbf1; font-weight: bold; }
    .tile.wall { background: #1e293b; opacity: 0.4; }
    .tile.killed { background: #ef4444; border-color: #f87171; color: #fff; z-index:20; box-shadow: 0 0 15px #ef4444; }
    .tile.selected { border: 2px solid #fff; z-index: 50; transform: scale(1.15); box-shadow: 0 0 15px rgba(255,255,255,0.5); }

    /* HUD */
    .hud-bar {
        background: #0f172a; border-top: 1px solid #1e293b;
        padding: 8px; 
        /* CHANGED: Added dynamic bottom padding for gesture bars */
        padding-bottom: max(12px, env(safe-area-inset-bottom));
        display: flex; flex-direction: column; gap: 6px;
        box-shadow: 0 -4px 20px rgba(0,0,0,0.5); z-index: 40;
        width: 100%; flex-shrink: 0;
    }
    
    .core-dashboard {
        display: grid; grid-template-columns: repeat(4, 1fr); gap: 4px;
        background: #020617; padding: 4px; border-radius: 6px; border: 1px solid #1e293b;
    }
    .core-stat { font-size: 0.6rem; color: #64748b; display: flex; flex-direction: column; gap: 1px; }
    
    .core-header { display: flex; justify-content: space-between; align-items: center; }
    .core-pct { color: #34d399; font-weight: bold; }

    .prog-track { height: 4px; background: #1e293b; width: 100%; border-radius: 2px; overflow: hidden; }
    .prog-fill { height: 100%; background: #3b82f6; width: 0%; transition: width 0.2s; }
    
    .tools-row { display: flex; gap: 8px; align-items: center; overflow-x: auto; padding-bottom: 2px; scrollbar-width: none; }
    .tools-row::-webkit-scrollbar { display: none; }

    .tool-group { display: flex; gap: 2px; background: #1e293b; padding: 3px; border-radius: 6px; flex-shrink: 0; }

    .icon-btn { 
        width: 28px; height: 28px; display: flex; align-items: center; justify-content: center;
        background: transparent; border-radius: 4px; cursor: pointer; color: #94a3b8; font-weight: bold;
        font-size: 0.75rem;
    }
    .icon-btn.active { background: #334155; color: #fbbf24; }
    
    .toggle-btn {
        padding: 0 8px; height: 28px; display: flex; align-items: center; 
        font-size: 0.7rem; color: #64748b; cursor: pointer; background: transparent; border-radius: 4px;
        font-weight: bold; border: 1px solid transparent; white-space: nowrap;
    }
    .toggle-btn.active { color: #34d399; background: #064e3b; border-color: #059669; }

    .input-row { display: flex; gap: 6px; width: 100%; align-items: stretch; }
    
    .main-input { 
        background: #1e293b; color: #fff; padding: 0 10px; border-radius: 6px; 
        font-family: monospace; font-weight: bold; border: 1px solid #334155; 
        flex-grow: 1; outline: none; font-size: 0.85rem; height: 40px; min-width: 0;
    }
    
    .range-group {
        display: flex; gap: 2px; background: #1e293b; padding: 2px; border-radius: 6px; border: 1px solid #334155;
    }
    .limit-input {
        background: transparent; color: #fbbf24; padding: 0 5px; 
        font-family: monospace; font-weight: bold; border: none; 
        width: 60px; text-align: center; outline: none; font-size: 0.85rem; height: 34px;
    }
    .limit-input:first-child { border-right: 1px solid #334155; }
    
    .action-btn {
        background: #3b82f6; color: #fff; border: none; padding: 0 15px;
        border-radius: 6px; font-weight: 900; cursor: pointer;
        font-size: 0.9rem; height: 40px; flex-shrink: 0;
    }

    /* INSPECTOR */
    .inspector {
        position: absolute; bottom: 180px; left: 50%; transform: translateX(-50%) translateY(20px);
        width: 95%; max-width: 600px;
        background: rgba(15, 23, 42, 0.98); backdrop-filter: blur(12px);
        border: 1px solid #3b82f6; border-radius: 8px;
        padding: 15px; display: none; opacity: 0; pointer-events: none;
        transition: all 0.2s; z-index: 100; box-shadow: 0 10px 40px rgba(0,0,0,0.9);
    }
    .inspector.visible { display: block; opacity: 1; transform: translateX(-50%) translateY(0); pointer-events: auto; }
    .stat-row { display: grid; grid-template-columns: 1fr 2fr; gap: 10px; margin-bottom: 8px; align-items: center; }
    .stat-label { font-size: 0.65rem; color: #64748b; text-transform: uppercase; text-align: right; }
    .formula-box {
        background: #020617; padding: 8px; border-radius: 4px; border: 1px solid #1e293b;
        font-size: 0.8rem; color: #e2e8f0; font-family: monospace; overflow-x: auto; white-space: nowrap;
    }
    .val-highlight { color: #fbbf24; }
    .val-dim { color: #94a3b8; }
    .poly-term { color: #34d399; }
    .hit-alert { color: #ef4444; font-weight: bold; border-color: #ef4444; }
    .prime-success { color: #34d399; font-weight: bold; border-color: #10b981; }

</style>
</head>
<body>

<div class="grid-viewport">
    <div id="grid" class="sector-grid">
        <div style="grid-column: span 30; text-align: center; color: #475569; margin-top: 50px;">
            ARCHITECT v10.4<br>MOBILE FIX
        </div>
    </div>
</div>

<div id="inspector" class="inspector">
    <div class="stat-row">
        <div class="stat-label">GNOMON (N)</div>
        <div id="dispGnomon" class="formula-box val-highlight">--</div>
    </div>
    <div class="stat-row">
        <div class="stat-label">INDEX (I)</div>
        <div id="dispIndex" class="formula-box">--</div>
    </div>
    <div class="stat-row">
        <div class="stat-label">ALGEBRAIC SQUARE</div>
        <div id="dispSquare" class="formula-box val-dim">--</div>
    </div>
    <div class="stat-row">
        <div class="stat-label">STATUS</div>
        <div id="dispStatus" class="formula-box val-dim">--</div>
    </div>
    <div style="text-align:center; margin-top:10px;">
        <button onclick="closeInspector()" style="background:#334155; color:#fff; border:none; padding:5px 15px; border-radius:4px; font-size:0.7rem; cursor:pointer;">CLOSE</button>
    </div>
</div>

<div class="hud-bar">
    <div id="coreDash" class="core-dashboard"></div>

    <div class="tools-row">
        <div class="tool-group">
            <div class="icon-btn" onclick="setCols(6)">6</div>
            <div class="icon-btn" onclick="setCols(12)">12</div>
            <div class="icon-btn active" onclick="setCols(30)" id="btn30">30</div>
        </div>
        <div class="tool-group">
            <div class="icon-btn" style="width:auto; padding:0 6px; font-size:0.65rem;">CORES:</div>
            <select id="workerCount" style="background:#1e293b; color:#34d399; border:none; outline:none; font-size:0.8rem;" onchange="initDashboard()">
                <option value="4" selected>4</option>
                <option value="6">6</option>
                <option value="8">8</option>
            </select>
        </div>
        <div class="tool-group">
            <div class="icon-btn" onclick="adjustZoom(-4)">-</div>
            <div class="icon-btn" onclick="adjustZoom(4)">+</div>
        </div>
        <div class="tool-group">
            <div id="btnAlg" class="toggle-btn" onclick="toggleForceAlgebra()">ƒ(x)</div>
        </div>
    </div>
    
    <div class="input-row">
        <input id="inpCoord" class="main-input" value="10^1000000000 + 61" placeholder="Coord">
        <div class="range-group">
            <input id="inpStart" class="limit-input" value="0" placeholder="Start" inputmode="decimal">
            <input id="inpLimit" class="limit-input" value="200M" placeholder="End" inputmode="decimal">
        </div>
        <button id="scanBtn" class="action-btn" onclick="deployFleet()">SCAN</button>
    </div>
</div>

<script>
let CONFIG = { zoom: 24, cols: 30, base: 10n, exp: 1000n, add: 61n, isMassive: true, forceAlgebra: false };
let activeWorkers = [];
let mergedRuler = null;
let killerMap = {}; 
let maxScanned = 0;

const workerScript = `
self.onmessage = function(e) {
    const { baseStr, expStr, addStr, isMassive, pStart, pEnd, id } = e.data;
    const size = 1500;
    const ruler = new Uint8Array(size);
    const killer = {}; 
    const BASE = BigInt(baseStr);
    const EXP = BigInt(expStr);
    const ADD = BigInt(addStr);
    
    function powMod(b, e, m) {
        let res = 1n; b %= m;
        while (e > 0n) { if (e & 1n) res = (res * b) % m; b = (b * b) % m; e >>= 1n; }
        return res;
    }

    const seedLimit = Math.floor(Math.sqrt(pEnd)) + 1;
    const seedSieve = new Uint8Array(seedLimit).fill(1);
    const seeds = [];
    for(let i=3; i<seedLimit; i+=2) {
        if(seedSieve[i]) {
            seeds.push(i);
            for(let j=i*i; j<seedLimit; j+=(2*i)) seedSieve[j] = 0;
        }
    }

    const CACHE_SIZE = 500000;
    let low = Math.max(3, pStart);
    if(low % 2 === 0) low++; 

    let progressCounter = 0;
    const totalWork = pEnd - low;
    let worked = 0;

    while (low <= pEnd) {
        let high = Math.min(low + CACHE_SIZE, pEnd);
        let len = high - low + 1;
        const segment = new Uint8Array(len).fill(1); 
        
        for(let i=0; i<seeds.length; i++) {
            let p = seeds[i];
            let start = Math.floor((low + p - 1) / p) * p;
            if (start < p*p) start = p*p;
            if (start % 2 === 0) start += p; 
            for(let j=start; j<=high; j+=(2*p)) if(j >= low) segment[j - low] = 0;
        }
        
        for(let i=0; i<len; i+=2) { 
            if(segment[i]) {
                const P_val = low + i;
                if(P_val > pEnd) break;
                
                const P = BigInt(P_val);
                let currentMod = 0n;
                let fullI = 0n;

                if (isMassive) {
                    const inv2 = (P + 1n) / 2n;
                    const term1 = powMod(BASE, EXP, P);
                    const num = (term1 + ADD + 1n) % P;
                    currentMod = (num * inv2) % P;
                } else {
                    const fullN = BASE ** EXP + ADD;
                    fullI = (fullN + 1n) / 2n;
                    currentMod = fullI % P;
                }

                const targetMod = (P + 1n) / 2n; 
                let offset = targetMod - currentMod;
                if (offset < 0n) offset += P;
                
                for (let k = Number(offset); k < size; k += P_val) {
                    
                    if (!isMassive) {
                        const tileIndex = fullI + BigInt(k);
                        const primeIndex = (P + 1n) / 2n;
                        if (tileIndex === primeIndex) continue;
                    }

                    if (ruler[k] === 0) {
                        ruler[k] = 1; 
                        killer[k] = P_val; 
                    }
                }
            }
        }
        
        worked += len;
        low = high + 1;
        progressCounter += len;
        
        if(progressCounter > 200000) {
            self.postMessage({ type: 'progress', pct: (worked/totalWork)*100, id: id });
            progressCounter = 0;
        }
    }
    self.postMessage({ type: 'done', ruler, killer, id: id });
};
`;

const blob = new Blob([workerScript], {type: 'application/javascript'});
const workerUrl = URL.createObjectURL(blob);

function parseLimit(str) {
    str = str.toString().toUpperCase().replace(/\s/g, '');
    if(!str) return 0;
    let mul = 1;
    if(str.endsWith('K')) { mul = 1000; str = str.slice(0,-1); }
    else if(str.endsWith('M')) { mul = 1000000; str = str.slice(0,-1); }
    else if(str.endsWith('B')) { mul = 1000000000; str = str.slice(0,-1); }
    const val = parseFloat(str);
    return Math.floor(val * mul);
}

function parseInput() {
    let raw = document.getElementById('inpCoord').value.toLowerCase().replace(/\s/g, '');
    try {
        if (raw.includes('^')) {
            let core = raw;
            let add = 0n;
            if (raw.includes('+')) { const p = raw.split('+'); core = p[0]; add = BigInt(p[1]); }
            else if (raw.includes('-')) { const p = raw.split('-'); core = p[0]; add = -BigInt(p[1]); }
            const p = core.split('^');
            CONFIG.base = BigInt(p[0]); CONFIG.exp = BigInt(p[1]); CONFIG.add = add;
        } else {
            CONFIG.base = BigInt(raw); CONFIG.exp = 1n; CONFIG.add = 0n;
        }
        CONFIG.isMassive = (CONFIG.exp > 15n);
        return true;
    } catch(e) { alert("Invalid Coord"); return false; }
}

function initDashboard() {
    const c = parseInt(document.getElementById('workerCount').value);
    const d = document.getElementById('coreDash');
    d.innerHTML = '';
    d.style.gridTemplateColumns = `repeat(${Math.min(c, 4)}, 1fr)`;
    for(let i=0; i<c; i++) {
        const div = document.createElement('div');
        div.className = 'core-stat';
        div.innerHTML = `
            <div class="core-header">
                <span>CORE ${i+1}</span>
                <span id="pct${i}" class="core-pct">0%</span>
            </div>
            <div class="prog-track"><div id="prog${i}" class="prog-fill"></div></div>
        `;
        d.appendChild(div);
    }
}

function deployFleet() {
    if(!parseInput()) return;
    const startRange = parseLimit(document.getElementById('inpStart').value);
    const endRange = parseLimit(document.getElementById('inpLimit').value);
    if (endRange <= startRange) { alert("End must be > Start"); return; }

    document.getElementById('grid').innerHTML = '<div style="color:#3b82f6; text-align:center; padding:50px;">INITIALIZING FLEET...</div>';
    activeWorkers.forEach(w => w.terminate());
    activeWorkers = [];
    mergedRuler = new Uint8Array(1500);
    killerMap = {};
    
    const workerCount = parseInt(document.getElementById('workerCount').value);
    const totalSpan = endRange - startRange;
    const chunkSize = Math.ceil(totalSpan / workerCount);
    
    initDashboard();

    for(let i=0; i<workerCount; i++) {
        const w = new Worker(workerUrl);
        const pStart = startRange + (i * chunkSize);
        const pEnd = Math.min(startRange + ((i+1) * chunkSize), endRange);
        
        w.postMessage({
            baseStr: CONFIG.base.toString(),
            expStr: CONFIG.exp.toString(),
            addStr: CONFIG.add.toString(),
            isMassive: CONFIG.isMassive,
            pStart: pStart,
            pEnd: pEnd,
            id: i
        });
        
        w.onmessage = function(e) {
            if(e.data.type === 'progress') {
                document.getElementById(`prog${e.data.id}`).style.width = e.data.pct + "%";
                document.getElementById(`pct${e.data.id}`).innerText = Math.round(e.data.pct) + "%";
            }
            if(e.data.type === 'done') {
                handleResult(e.data.ruler, e.data.killer);
                document.getElementById(`prog${e.data.id}`).style.backgroundColor = "#10b981";
                document.getElementById(`pct${e.data.id}`).innerText = "OK";
                w.terminate();
            }
        };
        activeWorkers.push(w);
    }
}

function handleResult(r, k) {
    for(let i=0; i<mergedRuler.length; i++) if(r[i] === 1) mergedRuler[i] = 1;
    for(let key in k) {
        if (!killerMap[key]) killerMap[key] = k[key];
        else killerMap[key] = Math.min(killerMap[key], k[key]);
    }
    renderGrid();
}

function renderGrid() {
    const g = document.getElementById('grid');
    g.innerHTML = '';
    const frag = document.createDocumentFragment();
    let literalStart = 0n;
    if (!CONFIG.isMassive) literalStart = (CONFIG.base ** CONFIG.exp) + CONFIG.add;

    for(let i=0; i<mergedRuler.length; i++) {
        const div = document.createElement('div');
        const isHit = mergedRuler[i] === 1;
        div.className = isHit ? (i===0 ? 'tile killed' : 'tile wall') : 'tile survivor';
        
        if (!isHit) div.textContent = CONFIG.isMassive ? `+${i}` : (literalStart + BigInt(i*2)).toString();
        else if (i===0) div.textContent = "X";
        else if (!CONFIG.isMassive) div.style.fontSize="8px";
        
        div.onclick = () => inspect(i);
        frag.appendChild(div);
    }
    g.appendChild(frag);
    applyLayout();
    if(mergedRuler[0]===1 && document.getElementById('inspector').style.opacity === '0') inspect(0);
}

function inspect(offset) {
    document.querySelectorAll('.tile').forEach(t => t.classList.remove('selected'));
    const tiles = document.querySelectorAll('.tile');
    if(tiles[offset]) tiles[offset].classList.add('selected');
    document.getElementById('inspector').classList.add('visible');
    
    const offBig = BigInt(offset);
    const dGnomon = document.getElementById('dispGnomon');
    const dIndex = document.getElementById('dispIndex');
    const dSquare = document.getElementById('dispSquare');
    const dStatus = document.getElementById('dispStatus');

    if (mergedRuler[offset] === 1) {
        dStatus.className = 'formula-box hit-alert';
        dStatus.innerText = `COMPOSITE (Factor: ${killerMap[offset] || 'Unknown'})`;
    } else {
        dStatus.className = 'formula-box prime-success';
        dStatus.innerText = "PRIME / SURVIVOR (Sector Clean)";
    }

    if (CONFIG.isMassive || CONFIG.forceAlgebra) {
        const realAdd = CONFIG.add + (offBig * 2n);
        dGnomon.innerHTML = `10^${CONFIG.exp} + ${realAdd}`;
        dIndex.innerHTML = `(10^${CONFIG.exp} + ${realAdd} + 1) / 2`;
        
        const exp2 = CONFIG.exp * 2n;
        const K = realAdd + 1n; // Index Offset Term
        const termMid = (K % 2n === 0n) ? (K/2n).toString() : (Number(K)/2).toFixed(1);
        const termConst = (K * K) / 4n; // Approximate constant
        
        dSquare.innerHTML = `<span class="poly-term">0.25 × 10^${exp2}</span> + <span class="poly-term">${termMid} × 10^${CONFIG.exp}</span> + <span class="poly-term">${termConst}</span>`;
    } else {
        const startN = (CONFIG.base ** CONFIG.exp) + CONFIG.add;
        const currentN = startN + (offBig * 2n);
        const currentIndex = (currentN + 1n) / 2n;
        dGnomon.innerText = currentN.toString();
        dIndex.innerText = currentIndex.toString();
        dSquare.innerText = (currentIndex * currentIndex).toString();
    }
}

function toggleForceAlgebra() {
    CONFIG.forceAlgebra = !CONFIG.forceAlgebra;
    const btn = document.getElementById('btnAlg');
    if(CONFIG.forceAlgebra) btn.classList.add('active'); else btn.classList.remove('active');
    const sel = document.querySelector('.tile.selected');
    if(sel) sel.click(); 
}

function closeInspector() { document.getElementById('inspector').classList.remove('visible'); }
function setCols(n) { CONFIG.cols = n; applyLayout(); document.querySelectorAll('.icon-btn').forEach(b=>b.classList.remove('active')); if(n===30)document.getElementById('btn30').classList.add('active'); }
function adjustZoom(d) { CONFIG.zoom = Math.max(10, Math.min(60, CONFIG.zoom + d)); applyLayout(); }
function applyLayout() { document.documentElement.style.setProperty('--col-count', CONFIG.cols); document.documentElement.style.setProperty('--tile-size', CONFIG.zoom + 'px'); }

initDashboard();
setCols(30);

</script>
</body>
</html>
