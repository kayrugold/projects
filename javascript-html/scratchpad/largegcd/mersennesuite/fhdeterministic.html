<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Factor Hunter: Integrated Workflow (Final Resolution)</title>
<script src="https://unpkg.com/big-integer@1.6.48/BigInteger.min.js"></script>
<style>
:root { 
    --bg-color: #f3f4f6; --text-color: #1f2937; --card-bg: #fff; --smin-bg: #10b981; --filter-bg: #f59e0b; 
    --resolve-bg: #1d4ed8; --header-color: #1d4ed8; --log-bg: #e2e8f0; --candidate-bg: #f9fafb;
}
body { font-family: system-ui, sans-serif; background: var(--bg-color); color: var(--text-color); padding: 1rem; }
.container { max-width: 900px; width: 100%; background: var(--card-bg); border-radius: .5rem; box-shadow: 0 5px 10px rgba(0,0,0,.1); padding: 1.5rem; margin-top: 1rem; }
h2 { text-align:center; color: var(--header-color); margin-bottom: 1.5rem; font-size:1.5rem; font-weight:700; }
h3 { margin-top: 1rem; font-size: 1.1rem; }
.grid { display:grid; grid-template-columns: repeat(auto-fit, minmax(150px,1fr)); gap: 1rem; }
.input-group { display:flex; flex-direction:column; }
label { font-size: 0.9rem; font-weight: 600; margin-bottom: 0.2rem; }
input[type="text"] { padding: 0.5rem; border: 1px solid #d1d5db; border-radius: .25rem; }
#logOutput, #sCandidatesOutput, #factorsOutput { 
    min-height:100px; overflow-y:auto; background: var(--log-bg); padding:0.8rem; font-family: monospace; white-space:pre-wrap; margin-top:0.5rem; border-radius:.25rem; font-size: 0.85rem;
}
#sCandidatesOutput { background: var(--candidate-bg); color: #333; }
#progressBar { height:25px; width:0%; background: #4caf50; transition: width 0.3s; }
.button-style { padding:.75rem 1rem; border:none; border-radius:.25rem; color:#fff; font-weight:600; cursor:pointer; font-size: 0.9rem; transition: background-color 0.2s; }
.button-style:disabled { background-color: #9ca3af; cursor: not-allowed; }
.results-box { border: 1px solid #ccc; padding: 10px; margin-top: 10px; border-radius: 4px; }
.factor-display { color: #f97316; font-weight: bold; }
</style>
</head>
<body>
<div class="container">
    <h2>Factor Hunter: Deterministic Workflow</h2>

    <h3>Target Number ($\mathbf{N = a^b + c}$)</h3>
    <div class="grid">
        <div class="input-group"><label for="baseInput">Base (a)</label><input type="text" id="baseInput" value="10"></div>
        <div class="input-group"><label for="exponentInput">Exponent (b)</label><input type="text" id="exponentInput" value="50000"></div>
        <div class="input-group"><label for="addendInput">Addend (c)</label><input type="text" id="addendInput" value="19"></div>
    </div>
    <div class="input-group mt-3"><label for="nDisplayOutput">N (Approx)</label><input type="text" id="nDisplayOutput" readonly placeholder="N = a^b + c"></div>

    <hr>

    <h3>Deterministic Search Phases</h3>
    <div class="grid">
        <div class="input-group">
            <label for="sMinInput">1. $\mathbf{S_{\min}} \approx 2\sqrt{N}$ (Streaming Sqrt)</label>
            <input type="text" id="sMinInput" readonly placeholder="Calculated S_min">
            <button id="findSMinButton" class="mt-2 button-style" style="background-color: var(--smin-bg);">Calculate $S_{\min}$</button>
        </div>

        <div class="input-group">
            <label for="filterEndInput">2. SGS Filter Range (Max)</label>
            <input type="text" id="filterEndInput" placeholder="S_min + Range (Auto-Populated)">
            <button id="runFilterButton" class="mt-2 button-style" style="background-color: var(--filter-bg);" disabled>Run SGS Filter</button>
        </div>

        <div class="input-group">
            <label for="resolveButton">3. Resolve S-Candidates ($\mathbf{S^2 - 4N = k^2}$)</label>
            <input type="text" readonly placeholder="Resolving Factor instantly...">
            <button id="resolveButton" class="mt-2 button-style" style="background-color: var(--resolve-bg);" disabled>Resolve S-List</button>
        </div>
    </div>
    
    <div id="progressBarContainer" class="mt-4"><div id="progressBar">0%</div></div>
    <div id="results" class="mt-2">Status: Ready.</div>

    <h3>S-Candidates Found (Sampled List)</h3>
    <pre id="sCandidatesOutput">List is empty. Run SGS Filter to populate.</pre>

    <h3>Factors Found</h3>
    <pre id="factorsOutput">No factors found yet.</pre>

    <h3>Main Log</h3>
    <pre id="logOutput">Log: Worker initialized. Ready for Step 1.</pre>
</div>

<script>
// --- GLOBAL STATE AND CONFIGURATION ---
const baseInput = document.getElementById('baseInput');
const exponentInput = document.getElementById('exponentInput');
const addendInput = document.getElementById('addendInput');
const nDisplayOutput = document.getElementById('nDisplayOutput');
const sMinInput = document.getElementById('sMinInput');
const filterEndInput = document.getElementById('filterEndInput');
const findSMinButton = document.getElementById('findSMinButton');
const runFilterButton = document.getElementById('runFilterButton');
const resolveButton = document.getElementById('resolveButton');
const progressBar = document.getElementById('progressBar');
const resultsDiv = document.getElementById('results');
const logOutput = document.getElementById('logOutput');
const sCandidatesOutput = document.getElementById('sCandidatesOutput');
const factorsOutput = document.getElementById('factorsOutput');

const EXPONENT_SAFE_LIMIT = 20000n;
let worker = null;
const QR_SCREEN_PRIMES = [3n, 5n, 7n, 11n, 13n, 17n, 19n, 23n, 29n];
let N_MODS_CACHE = {};
let sCandidateList = []; 
const FILTER_SAMPLE_RATE = 1000n; 
let N_BIG_INT_STR = ""; 
let N_BIG_INT_EXPONENT = "";

// --- UTILITY FUNCTIONS ---
function parseBigInt(str) {
    if (!str) return 0n;
    str = String(str).replace(/,/g, '').replace(/\s/g, '');
    if (str.includes('e') || str.includes('E')) {
        const parts = str.toLowerCase().split('e');
        return BigInt(parts[0]) * 10n ** BigInt(parts[1]);
    }
    return BigInt(str);
}
function log(msg) { logOutput.textContent += msg + '\n'; logOutput.scrollTop = logOutput.scrollHeight; }
function setStatus(t) { resultsDiv.textContent = 'Status: ' + t; }
function setProgress(p) {
    const percent = Math.min(100, Math.max(0, p)).toFixed(2);
    progressBar.style.width = percent + '%';
    progressBar.textContent = percent + '%';
}
function displayN(a, b, c) {
    const bBig = parseBigInt(b);
    N_BIG_INT_EXPONENT = bBig.toString();
    if (bBig < EXPONENT_SAFE_LIMIT) {
        try {
            const N = parseBigInt(a) ** bBig + parseBigInt(c);
            N_BIG_INT_STR = N.toString();
            nDisplayOutput.value = N.toString().length > 50 ? `${N.toString().slice(0, 50)}... (${N.toString().length} digits)` : N.toString();
        } catch (e) { nDisplayOutput.value = `Error calculating N: ${e.message}`; N_BIG_INT_STR = ""; }
    } else { nDisplayOutput.value = `${a}^${b} + ${c} (approx ${Number(b) + 1} digits)`; N_BIG_INT_STR = ""; }
}
function powMod(base, exp, mod) {
    let result = 1n; base %= mod;
    while (exp > 0n) { if ((exp & 1n) === 1n) result = (result * base) % mod; exp >>= 1n; base = (base * base) % mod; } return result;
}
function calculateNMods(a, b, c) {
    const aBig = parseBigInt(a), bBig = parseBigInt(b), cBig = parseBigInt(c);
    const N_mods = {};
    for (const p of QR_SCREEN_PRIMES) {
         const remPow = powMod(aBig, bBig, p);
         const remC = cBig % p;
         let remN = (remPow + remC) % p;
         if (remN < 0n) remN += p;
         N_mods[p.toString()] = Number(remN);
    }
    return N_mods;
}
function customSqrt(n) { if (n.isNegative()) return self.bigInt(-1); if (n.lesserOrEquals(1)) return n; let x = n.shiftRight(self.bigInt(1)), y; while (true) { y = x.add(n.divide(x)).shiftRight(self.bigInt(1)); if (y.geq(x)) return x; x = y; }}
function stopWorker(reEnableFilter = false) { 
    if (worker) { worker.terminate(); worker = null; } 
    findSMinButton.disabled = false;
    runFilterButton.disabled = !reEnableFilter;
    resolveButton.disabled = (sCandidateList.length === 0);
}

// --- STREAMING SQR WORKER CODE (from previous response) ---
const streamingSqrtWorkerCode = `
    const chunk_size = 9; const BASE = 10 ** chunk_size;
    function trim(c) { let i = 0; while (i < c.length - 1 && c[i] === 0) i++; return c.slice(i); }
    function cmp(a, b) { a = trim(a); b = trim(b); if (a.length !== b.length) return a.length > b.length ? 1 : -1; for (let i = 0; i < a.length; i++) { if (a[i] !== b[i]) return a[i] > b[i] ? 1 : -1; } return 0; }
    function add(a, b) { let a_rev = a.slice().reverse(); let b_rev = b.slice().reverse(); let n = Math.max(a_rev.length, b_rev.length), carry = 0, out = []; for (let i = 0; i < n; i++) { let s = (a_rev[i] || 0) + (b_rev[i] || 0) + carry; out.push(s % BASE); carry = Math.floor(s / BASE); } if (carry) out.push(carry); return out.reverse(); }
    function sub(a, b) { let a_rev = a.slice().reverse(); let b_rev = b.slice().reverse(); let n = a_rev.length, borrow = 0, out = []; for (let i = 0; i < n; i++) { let v = a_rev[i] - (b_rev[i] || 0) - borrow; if (v < 0) { v += BASE; borrow = 1; } else { borrow = 0; } out.push(v); } return trim(out.reverse()); }
    function mulSmall(a, s) { if (s === 0) return [0]; let a_rev = a.slice().reverse(), carry = 0, out = []; for (const d of a_rev) { let p = d * s + carry; out.push(p % BASE); carry = Math.floor(p / BASE); } while (carry > 0) { out.push(carry % BASE); carry = Math.floor(carry / BASE); } return out.reverse(); }
    function chunksToString(chunks) { if (!chunks || chunks.length === 0) return "0"; let s = chunks[0].toString(); for (let i = 1; i < chunks.length; i++) { s += chunks[i].toString().padStart(chunk_size, '0'); } return s; }
    
    function calculateStreamingSqrt(aStr, bStr, cStr) {
        const b = BigInt(bStr); const c = BigInt(cStr); const cLen = c.toString().length;
        if (b < cLen) return (BigInt(aStr)**b + c).toString();
        const numZeros = b - BigInt(cLen); let nStr = '1'; 
        const zerosToRepeat = numZeros < 5000000n ? numZeros : 5000000n;
        if (zerosToRepeat > 0) nStr += '0'.repeat(Number(zerosToRepeat));
        nStr += c.toString().padStart(cLen, '0');
        
        const groupDigits = 2 * chunk_size; let padLength = nStr.length % groupDigits;
        if (padLength !== 0) padLength = groupDigits - padLength;
        const paddedNStr = '0'.repeat(padLength) + nStr;
        const groups = []; for (let i = 0; i < paddedNStr.length; i += groupDigits) groups.push(paddedNStr.substring(i, i + groupDigits));
        let root = [0]; let remainder = [0]; const totalGroups = groups.length;
        
        groups.forEach((group, index) => {
            remainder.push(0, 0); const groupChunks = [parseInt(group.substring(0, chunk_size), 10), parseInt(group.substring(chunk_size), 10)]; remainder = add(remainder, groupChunks);
            let prefix = mulSmall(root, 2); prefix.push(0);
            let lo = 0, hi = BASE - 1, chosen = 0;
            while (lo <= hi) { let mid = Math.floor((lo + hi) / 2); let t = add(prefix, [mid]); let trial = mulSmall(t, mid); if (cmp(trial, remainder) <= 0) { chosen = mid; lo = mid + 1; } else { hi = mid - 1; } }
            let t_chosen = add(prefix, [chosen]); let trial_chosen = mulSmall(t_chosen, chosen); remainder = sub(remainder, trial_chosen);
            root.push(chosen); root = trim(root);
            if (index % 100 === 0) self.postMessage({ type: 'progress', value: ((index + 1) / totalGroups) * 100 });
        });
        self.postMessage({ type: 'progress', value: 100 });
        self.postMessage({ type: 'sqrtResult', root: chunksToString(root), remainder: chunksToString(remainder) });
    }

    self.onmessage = function(e) {
        const { a, b, c } = e.data;
        calculateStreamingSqrt(a, b, c);
    };
`;
const streamingSqrtWorkerDataURI = URL.createObjectURL(new Blob([streamingSqrtWorkerCode], { type: 'application/javascript' }));


// --- SGS FILTER WORKER CODE (SAMPLED AND FIXED) ---
const sgsFilterWorkerCode = `
    self.importScripts('https://unpkg.com/big-integer@1.6.48/BigInteger.min.js');

    function powMod(base, exp, mod) { let result = self.bigInt.one; base = base.mod(mod); while (exp.greater(0)) { if (exp.isOdd()) result = result.multiply(base).mod(mod); exp = exp.shiftRight(1); base = base.square().mod(mod); } return result; }
    function legendreSymbol(a, p) { if (p.equals(2)) return 1; a = a.mod(p).add(p).mod(p); const ls = powMod(a, p.subtract(1).shiftRight(1), p); if (ls.equals(p.subtract(1))) return -1; return 1; }
    
    self.onmessage = e => {
        let { min, max, N_mods, sampleRate } = e.data;
        let min_bi = self.bigInt(min), max_bi = self.bigInt(max);
        const QR_SCREEN_PRIMES = [3n, 5n, 7n, 11n, 13n, 17n, 19n, 23n, 29n].map(p => self.bigInt(p));
        let candidatesFound = [];
        const rangeInChunk = max_bi.subtract(min_bi);
        let lastProgress = -1;
        let stepsProcessed = self.bigInt.zero;

        for (let S = min_bi; S.leq(max_bi); S = S.add(1)) {
            stepsProcessed = stepsProcessed.add(1);

            if (S.mod(sampleRate).isZero() || S.equals(min_bi) || S.equals(max_bi)) { 
                let passes = true;
                for (const p of QR_SCREEN_PRIMES) {
                    const N_mod_p = self.bigInt(N_mods[p.toString()]);
                    const S_sq_mod_p = S.square().mod(p);
                    const fourN_mod_p = N_mod_p.multiply(4).mod(p);
                    let D_mod_p = S_sq_mod_p.subtract(fourN_mod_p).mod(p);
                    if (D_mod_p.lesser(0)) D_mod_p = D_mod_p.add(p);
                    
                    if (legendreSymbol(D_mod_p, p) === -1) { 
                        passes = false; 
                        break; 
                    }
                }
                if (passes) {
                    candidatesFound.push(S.toString());
                }
            }


            if (rangeInChunk.greater(0)) {
                if (stepsProcessed.mod(100000).isZero() || S.equals(max_bi)) {
                    const progress = stepsProcessed.multiply(100).divide(rangeInChunk).toJSNumber();
                    if (Math.floor(progress) > lastProgress) {
                        self.postMessage({ type: 'progress', progress: Math.floor(progress) });
                        lastProgress = Math.floor(progress);
                    }
                }
            }
        }
        self.postMessage({ type: 'done', candidates: candidatesFound });
    };
`;
const sgsFilterWorkerDataURI = URL.createObjectURL(new Blob([sgsFilterWorkerCode], { type: 'application/javascript' }));


// --- SAS RESOLUTION WORKER CODE (Final Factor Check) ---
const sasResolverWorkerCode = `
    self.importScripts('https://unpkg.com/big-integer@1.6.48/BigInteger.min.js');

    function customSqrt(n) { 
        if (n.isNegative()) return self.bigInt(-1); 
        if (n.lesserOrEquals(1)) return n; 
        let x = n.shiftRight(self.bigInt(1)), y; 
        while (true) { 
            y = x.add(n.divide(x)).shiftRight(self.bigInt(1)); 
            if (y.geq(x)) return x; 
            x = y; 
        } 
    }

    self.onmessage = e => {
        const { N_str, S_candidates } = e.data;
        const N = self.bigInt(N_str);
        const fourN = N.multiply(4);
        let factorsFound = [];
        let checkedCount = 0;
        const totalCandidates = S_candidates.length;

        for (const S_str of S_candidates) {
            const S = self.bigInt(S_str);
            const S_sq = S.square();

            // S^2 - 4N = D (must be non-negative)
            if (S_sq.lesser(fourN)) continue; 

            const D = S_sq.subtract(fourN);
            
            // Check: Is D a perfect square (k^2)?
            const k = customSqrt(D);

            if (k.square().equals(D)) {
                // If D is a perfect square, we found it!
                const P = S.add(k).shiftRight(1); // (S + k) / 2
                const Q = S.subtract(k).shiftRight(1); // (S - k) / 2

                // Final sanity check: P * Q must equal N and Q must be > 1
                if (Q.greater(1) && P.multiply(Q).equals(N)) {
                    factorsFound.push({ P: P.toString(), Q: Q.toString() });
                }
            }

            checkedCount++;
            if (checkedCount % 100 === 0) {
                 self.postMessage({ type: 'progress', progress: Math.floor(checkedCount * 100 / totalCandidates) });
            }
        }

        self.postMessage({ type: 'done', factors: factorsFound });
    };
`;
const sasResolverWorkerDataURI = URL.createObjectURL(new Blob([sasResolverWorkerCode], { type: 'application/javascript' }));


// --- STEP 1: CALCULATE S_MIN (Streaming Sqrt) ---
function startSMinCalc() {
    stopWorker(false);
    const aStr = baseInput.value, bStr = exponentInput.value, cStr = addendInput.value;

    logOutput.textContent = 'Log:\n';
    setStatus('Initializing Streaming Sqrt Worker...'); setProgress(0);
    findSMinButton.disabled = true;

    worker = new Worker(streamingSqrtWorkerDataURI);

    worker.onmessage = (e) => {
        if (e.data.type === 'log') log(e.data.message);
        else if (e.data.type === 'progress') { setStatus(`Calculating sqrt(N)... ${e.data.value.toFixed(2)}%`); setProgress(e.data.value); }
        else if (e.data.type === 'sqrtResult') {
            const { root, remainder } = e.data;
            const floor_sqrt = bigInt(root);
            const rem = bigInt(remainder);
            let s_min = floor_sqrt.multiply(2);
            if (rem.greater(0)) s_min = s_min.add(1);

            const s_min_str = s_min.toString();
            sMinInput.value = s_min_str;
            log(`Streaming Sqrt Complete. N has ${root.length} digits.`);
            log(`Deterministic S_min = ${s_min_str.slice(0, 60)}...`);
            
            // --- AUTO-POPULATE FIX (S_min + 1,000,000) ---
            const SEARCH_STEPS = bigInt(1000000); 
            const searchMax = s_min.add(SEARCH_STEPS);
            filterEndInput.value = searchMax.toString();
            
            // CRITICAL: Cache N_BIG_INT_STR for final resolution
            N_BIG_INT_STR = floor_sqrt.multiply(floor_sqrt).add(rem).toString();

            // CRITICAL: Pre-calculate the modular fingerprint of N 
            N_MODS_CACHE = calculateNMods(baseInput.value, exponentInput.value, addendInput.value);

            stopWorker(true);
            runFilterButton.disabled = false;
        } else if (e.data.type === 'error') { 
            log(`[CRITICAL ERROR] Worker failed: ${e.data.message}`); 
            setStatus('Error. Worker terminated.'); 
            stopWorker(false); 
        }
    };

    worker.postMessage({ a: aStr, b: bStr, c: cStr });
}

// --- STEP 2: RUN SGS FILTER (CRT) ---
function startFilterScan() {
    stopWorker(false);
    sCandidateList = []; // Clear previous list
    sCandidatesOutput.textContent = 'Filtering in progress... (Sampled)';

    const sMinStr = sMinInput.value;
    const filterEndStr = filterEndInput.value;
    
    let minVal, maxVal;
    try { 
        minVal = bigInt(sMinStr); 
        maxVal = bigInt(filterEndStr); 
    } catch (e) { 
        setStatus('Error: Invalid range input (must be integer).'); 
        return; 
    }
    
    if (Object.keys(N_MODS_CACHE).length === 0) {
        setStatus('Error: Modular data for N missing. Recalculate S_min.');
        return;
    }

    log(`\n--- Starting SGS Filter (Sampled CRT) ---`);
    log(`Sample Rate: 1 out of every ${FILTER_SAMPLE_RATE} numbers.`);
    runFilterButton.disabled = true;
    worker = new Worker(sgsFilterWorkerDataURI);
    
    worker.onmessage = (e) => {
        if (e.data.type === 'progress') { 
            setStatus(`CRT Filter progress: ${e.data.progress}%`); 
            setProgress(e.data.progress); 
        } else if (e.data.type === 'done') {
            sCandidateList = e.data.candidates;
            sCandidatesOutput.textContent = sCandidateList.join('\n');
            log(`Filter complete. Found ${sCandidateList.length} S-Candidates.`);
            setStatus(`Filter complete. Found ${sCandidateList.length} candidates.`);
            stopWorker(true);
            resolveButton.disabled = (sCandidateList.length === 0);
        } else if (e.data.type === 'error') { 
            log(`[CRITICAL ERROR] Filter failed: ${e.data.message}`); 
            setStatus('Error. Filter terminated.'); 
            stopWorker(false); 
        }
    };
    worker.onerror = (e) => { log(`[CRITICAL ERROR] Filter failed: ${e.message}`); setStatus('Error. Filter terminated.'); stopWorker(false); };

    worker.postMessage({ min: minVal.toString(), max: maxVal.toString(), N_mods: N_MODS_CACHE, sampleRate: FILTER_SAMPLE_RATE });
}


// --- STEP 3: RESOLVE SGS LIST (Instant Factor) ---
function startResolution() {
    if (sCandidateList.length === 0) {
        setStatus("Error: No S-Candidates found. Run the filter first.");
        return;
    }
    if (!N_BIG_INT_STR) {
        setStatus("Error: Target number N not fully calculated or too large to store for final resolution.");
        return;
    }

    stopWorker(false);
    factorsOutput.textContent = 'Resolving list...';
    resolveButton.disabled = true;
    log(`\n--- Starting SAS Resolution (Instant Factor Check) ---`);
    log(`Checking ${sCandidateList.length} candidates.`);

    worker = new Worker(sasResolverWorkerDataURI);

    worker.onmessage = (e) => {
        if (e.data.type === 'progress') {
             setStatus(`Resolution Progress: ${e.data.progress}%`);
             setProgress(e.data.progress);
        } else if (e.data.type === 'done') {
            const factorsFound = e.data.factors;
            if (factorsFound.length > 0) {
                const f = factorsFound[0];
                factorsOutput.innerHTML = `Factor P: <span class="factor-display">${f.P}</span>\nFactor Q: <span class="factor-display">${f.Q}</span>`;
                log(`SUCCESS! Factors found: P=${f.P}, Q=${f.Q}`);
                setStatus('SUCCESS! Factors found.');
            } else {
                factorsOutput.textContent = 'Resolution Complete. No factors found in the sampled list.';
                log('Resolution complete. No factors found.');
                setStatus('Resolution complete.');
            }
            stopWorker(true);
            resolveButton.disabled = true;
        }
    };

    worker.postMessage({ N_str: N_BIG_INT_STR, S_candidates: sCandidateList });
}


// --- INITIALIZATION ---
window.onload = function() {
    [baseInput, exponentInput, addendInput].forEach(input => {
        input.addEventListener('input', () => displayN(baseInput.value, exponentInput.value, addendInput.value));
    });
    displayN(baseInput.value, exponentInput.value, addendInput.value);
    
    findSMinButton.addEventListener('click', startSMinCalc);
    runFilterButton.addEventListener('click', startFilterScan);
    resolveButton.addEventListener('click', startResolution);
};
</script>
</body>
</html>

