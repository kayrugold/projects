<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Factor Hunter: Pro</title>
    <style>
        :root {
            /* PRO THEME */
            --bg-deep: #050a14;
            --panel-bg: #0f172a;
            --grid-line: #1e293b;
            
            /* Logic Colors */
            --wall: #020617;        /* Void */
            --type1: #1e3a8a;       /* Blue */
            --type2: #7f1d1d;       /* Red */
            
            /* UI Colors */
            --accent: #f59e0b;      /* Orange */
            --text-main: #e2e8f0;
            --text-dim: #64748b;
        }

        body {
            background-color: var(--bg-deep);
            color: var(--text-main);
            font-family: 'Courier New', Courier, monospace;
            margin: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            touch-action: none; 
        }

        /* --- TOP CONTROL BAR --- */
        #top-bar {
            height: 60px;
            background: var(--panel-bg);
            border-bottom: 2px solid var(--accent);
            display: flex;
            align-items: center;
            padding: 0 10px;
            gap: 10px;
            z-index: 20;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
        }

        .input-group {
            display: flex;
            align-items: center;
            background: #1e293b;
            border-radius: 4px;
            padding: 4px 8px;
            border: 1px solid #334155;
            flex-grow: 1;
        }
        .input-group span { color: var(--text-dim); font-weight: bold; font-size: 0.8rem; margin-right: 5px; }
        
        input {
            background: transparent;
            border: none;
            color: var(--accent);
            font-family: inherit;
            font-size: 1.1rem;
            width: 100%;
            font-weight: bold;
            outline: none;
        }

        /* BUTTONS */
        .btn {
            border: none;
            padding: 0 16px;
            height: 36px;
            font-weight: 800;
            border-radius: 4px;
            cursor: pointer;
            text-transform: uppercase;
            font-size: 0.85rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #btn-teleport {
            background: var(--accent);
            color: #000;
            box-shadow: 0 0 10px rgba(245, 158, 11, 0.3);
        }

        #btn-view {
            background: #334155;
            color: white;
            border: 1px solid #475569;
            min-width: 80px;
        }

        /* --- MAIN VIEWPORT --- */
        #viewport {
            flex-grow: 1;
            position: relative;
            background: var(--bg-deep);
            overflow: hidden;
        }
        canvas { display: block; width: 100%; height: 100%; }

        /* --- BOTTOM STATUS BAR (NO BLOCKING!) --- */
        #bottom-bar {
            height: 50px;
            background: rgba(2, 6, 23, 0.95);
            border-top: 1px solid var(--grid-line);
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 15px;
            font-size: 0.8rem;
            z-index: 20;
        }

        .status-block {
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
        .label { color: var(--text-dim); font-size: 0.7rem; text-transform: uppercase; margin-bottom: 2px; }
        .val { color: var(--accent); font-weight: bold; font-size: 1rem; }

        /* SELECTION HIGHLIGHT INFO */
        #selection-hud {
            position: absolute;
            bottom: 60px; /* Above bottom bar */
            left: 10px;
            background: rgba(15, 23, 42, 0.9);
            border: 1px solid var(--accent);
            padding: 8px 12px;
            border-radius: 6px;
            pointer-events: none;
            opacity: 0; /* Hidden by default */
            transition: opacity 0.2s;
        }

    </style>
</head>
<body>

<div id="top-bar">
    <div class="input-group" style="flex: 2;">
        <span>10^</span>
        <input type="number" id="inp-exp" value="100">
    </div>
    <div class="input-group" style="flex: 1;">
        <span>+</span>
        <input type="number" id="inp-off" value="19">
    </div>
    <button id="btn-view" class="btn">TAIL</button>
    <button id="btn-teleport" class="btn">GO</button>
</div>

<div id="viewport">
    <canvas id="gridCanvas"></canvas>
    
    <div id="selection-hud">
        <div class="label" style="color:white">SELECTED BLOCK</div>
        <div id="sel-detail" style="color:var(--accent); font-weight:bold;">--</div>
    </div>
</div>

<div id="bottom-bar">
    <div class="status-block">
        <div class="label">OCEAN ANCHOR</div>
        <div class="val" id="val-anchor">Shoreline</div>
    </div>
    
    <div class="status-block" style="text-align: right;">
        <div class="label">TARGET GEOMETRY</div>
        <div class="val" id="val-target" style="color: var(--type2)">TYPE 2</div>
    </div>
</div>

<script>
    // --- CONFIG ---
    const COLORS = {
        bg: '#050a14',
        header: '#0f172a',
        headerText: '#64748b',
        headerHighlight: '#e2e8f0',
        wall: '#020617',
        type1: '#1e3a8a',
        type2: '#7f1d1d',
        highlight: '#f59e0b',
        grid: '#1e293b'
    };

    const MODES = ['TAIL', 'GEO', 'FULL']; 
    // TAIL = Last 4 digits
    // GEO = Colors only (clean)
    // FULL = Scientific Notation

    // --- STATE ---
    let state = {
        viewMode: 0, // Index of MODES
        
        startRow: 3n, 
        startCol: 3n,
        
        anchorExp: 0, // For display
        
        panX: 0,
        panY: 0,
        zoom: 1.0,
        
        targetMod: 2,
        
        baseCellSize: 60,
        headerSize: 50,
        
        selected: null // {r, c}
    };

    const canvas = document.getElementById('gridCanvas');
    const ctx = canvas.getContext('2d', { alpha: false });

    // --- HELPERS ---
    function getMod3(n) { return Number(n % 3n); }

    // THE FORMATTER: Changes based on View Mode
    function fmtNum(n) {
        let mode = MODES[state.viewMode];
        let s = n.toString();

        if (mode === 'GEO') return ""; // Clean view
        
        if (n < 10000n) return s; // Always show small numbers fully

        if (mode === 'TAIL') {
            // Show "..3391"
            return ".." + s.slice(-4);
        }
        
        if (mode === 'FULL') {
            // Scientific "3.33e100"
            let exp = s.length - 1;
            let man = s.substring(0, 3);
            return `${man[0]}.${man.slice(1)}e${exp}`;
        }
        return "";
    }

    // --- RENDERER ---
    function render() {
        const w = canvas.width;
        const h = canvas.height;
        const cs = state.baseCellSize * state.zoom;
        const hs = state.headerSize;

        // 1. Clear
        ctx.fillStyle = COLORS.bg;
        ctx.fillRect(0, 0, w, h);

        // 2. Grid Geometry
        const startX = state.panX;
        const startY = state.panY;
        const cols = Math.ceil((w - hs) / cs) + 1;
        const rows = Math.ceil((h - hs) / cs) + 1;

        ctx.font = `${Math.max(10, 14 * state.zoom)}px monospace`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";

        // --- DRAW CELLS ---
        for (let r = 0; r < rows; r++) {
            let rowVal = state.startRow + BigInt(r * 2);
            let rowMod = getMod3(rowVal);
            let y = hs + startY + (r * cs);
            if (y < hs - cs) continue;

            for (let c = 0; c < cols; c++) {
                let colVal = state.startCol + BigInt(c * 2);
                let colMod = getMod3(colVal);
                let x = hs + startX + (c * cs);
                if (x < hs - cs) continue;

                // LOGIC
                let fill = COLORS.wall;
                let alpha = 0.3;
                let prodMod = (rowMod * colMod) % 3;
                let isHit = (prodMod === state.targetMod);

                if (rowMod !== 0 && colMod !== 0) {
                    alpha = 1.0;
                    fill = (rowMod === colMod) ? COLORS.type1 : COLORS.type2;
                }

                // DRAW BODY
                ctx.globalAlpha = alpha;
                ctx.fillStyle = fill;
                ctx.fillRect(x + 1, y + 1, cs - 2, cs - 2);

                // HIGHLIGHT HIT
                ctx.globalAlpha = 1.0;
                if (rowMod !== 0 && colMod !== 0 && isHit) {
                    ctx.strokeStyle = COLORS.highlight;
                    ctx.lineWidth = 3 * state.zoom;
                    ctx.strokeRect(x + 2, y + 2, cs - 4, cs - 4);
                }

                // TEXT (Based on Mode)
                if (state.zoom > 0.6) {
                    ctx.fillStyle = COLORS.highlight;
                    
                    if (MODES[state.viewMode] === 'TAIL') {
                        // Only show text on HITs in deep ocean to reduce noise
                        // Or show all if user wants? Let's show hits + walls
                        if (isHit || (rowVal < 1000n && colVal < 1000n)) {
                             let prod = (rowVal * colVal).toString();
                             ctx.fillStyle = "#fff";
                             ctx.fillText(".." + prod.slice(-4), x + cs/2, y + cs/2);
                        }
                    } 
                    else if (MODES[state.viewMode] === 'GEO') {
                        // Minimalist: Only a star for hits
                        if (isHit) {
                             ctx.fillStyle = COLORS.highlight;
                             ctx.fillText("â˜…", x + cs/2, y + cs/2);
                        }
                    }
                    else if (MODES[state.viewMode] === 'FULL') {
                        if (isHit) ctx.fillText("HIT", x + cs/2, y + cs/2);
                    }
                }
                
                // SELECTION OUTLINE
                if (state.selected && state.selected.r === rowVal && state.selected.c === colVal) {
                    ctx.strokeStyle = "white";
                    ctx.lineWidth = 2;
                    ctx.setLineDash([4, 4]);
                    ctx.strokeRect(x, y, cs, cs);
                    ctx.setLineDash([]);
                }
            }
        }

        // --- DRAW HEADERS ---
        // Header Backgrounds
        ctx.fillStyle = COLORS.header;
        ctx.fillRect(hs, 0, w, hs);
        ctx.fillRect(0, hs, hs, h);
        ctx.fillStyle = COLORS.bg;
        ctx.fillRect(0, 0, hs, hs);

        // Corner
        ctx.fillStyle = COLORS.highlight;
        ctx.font = "bold 12px monospace";
        ctx.fillText("TAIL", hs/2, hs/2);

        // TOP HEADERS (B)
        ctx.font = "12px monospace";
        for (let c = 0; c < cols; c++) {
            let colVal = state.startCol + BigInt(c * 2);
            let x = hs + startX + (c * cs);
            if (x < hs) continue;
            
            let mod = getMod3(colVal);
            ctx.fillStyle = (mod !== 0) ? COLORS.headerHighlight : COLORS.headerText;
            
            // USE THE FORMATTER
            ctx.fillText(fmtNum(colVal), x + cs/2, hs/2);
            
            if (mod !== 0) {
                ctx.fillStyle = (mod === 1) ? COLORS.type1 : COLORS.type2;
                ctx.fillRect(x + 2, hs - 4, cs - 4, 3);
            }
        }

        // LEFT HEADERS (A)
        for (let r = 0; r < rows; r++) {
            let rowVal = state.startRow + BigInt(r * 2);
            let y = hs + startY + (r * cs);
            if (y < hs) continue;
            
            let mod = getMod3(rowVal);
            ctx.fillStyle = (mod !== 0) ? COLORS.headerHighlight : COLORS.headerText;
            
            ctx.fillText(fmtNum(rowVal), hs/2, y + cs/2);
        }

        // Borders
        ctx.strokeStyle = COLORS.highlight;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(hs, 0); ctx.lineTo(hs, h);
        ctx.moveTo(0, hs); ctx.lineTo(w, hs);
        ctx.stroke();
    }

    // --- INFINITE SCROLL LOGIC ---
    function updateScroll() {
        const cs = state.baseCellSize * state.zoom;
        while(state.panX > 0) { state.startCol -= 2n; state.panX -= cs; }
        while(state.panX < -cs) { state.startCol += 2n; state.panX += cs; }
        while(state.panY > 0) { state.startRow -= 2n; state.panY -= cs; }
        while(state.panY < -cs) { state.startRow += 2n; state.panY += cs; }
        
        if (state.startRow < 3n) { state.startRow = 3n; state.panY = Math.min(0, state.panY); }
        if (state.startCol < 3n) { state.startCol = 3n; state.panX = Math.min(0, state.panX); }
    }

    // --- INPUTS ---
    let isDrag = false;
    let lastX=0, lastY=0;
    let tapStartX=0, tapStartY=0;

    canvas.addEventListener('pointerdown', e => {
        isDrag = true; lastX = e.clientX; lastY = e.clientY;
        tapStartX = e.clientX; tapStartY = e.clientY;
        canvas.setPointerCapture(e.pointerId);
    });

    canvas.addEventListener('pointerup', e => {
        isDrag = false; canvas.releasePointerCapture(e.pointerId);
        if (Math.hypot(e.clientX - tapStartX, e.clientY - tapStartY) < 5) handleTap(e.clientX, e.clientY);
    });

    canvas.addEventListener('pointermove', e => {
        if(!isDrag) return;
        let dx = e.clientX - lastX;
        let dy = e.clientY - lastY;
        lastX = e.clientX; lastY = e.clientY;
        state.panX += dx; state.panY += dy;
        updateScroll();
        requestAnimationFrame(render);
    });

    canvas.addEventListener('wheel', e => {
        e.preventDefault();
        let s = e.deltaY > 0 ? 0.9 : 1.1;
        state.zoom = Math.max(0.4, Math.min(state.zoom, 2.5));
        requestAnimationFrame(render);
    }, {passive:false});

    // --- LOGIC ---
    function handleTap(x, y) {
        if (x < state.headerSize || y < state.headerSize) return;
        
        const cs = state.baseCellSize * state.zoom;
        const cIdx = Math.floor((x - state.headerSize - state.panX) / cs);
        const rIdx = Math.floor((y - state.headerSize - state.panY) / cs);
        
        const rVal = state.startRow + BigInt(rIdx * 2);
        const cVal = state.startCol + BigInt(cIdx * 2);
        
        state.selected = { r: rVal, c: cVal };
        
        // Show selection HUD
        const selHud = document.getElementById('selection-hud');
        selHud.style.opacity = 1;
        
        // Calculate nice tail display
        let rTail = rVal.toString().slice(-6);
        let cTail = cVal.toString().slice(-6);
        
        document.getElementById('sel-detail').innerText = `..${rTail} x ..${cTail}`;
        
        requestAnimationFrame(render);
    }

    // --- ACTIONS ---
    document.getElementById('btn-view').addEventListener('click', () => {
        state.viewMode = (state.viewMode + 1) % MODES.length;
        document.getElementById('btn-view').innerText = MODES[state.viewMode];
        requestAnimationFrame(render);
    });

    document.getElementById('btn-teleport').addEventListener('click', () => {
        let exp = parseInt(document.getElementById('inp-exp').value) || 0;
        let off = parseInt(document.getElementById('inp-off').value) || 0;

        state.anchorExp = exp;
        state.targetMod = (1 + off) % 3;

        // Update Bottom Bar
        let typeStr = state.targetMod === 0 ? "DIV 3" : (state.targetMod === 1 ? "TYPE 1 (MATCH)" : "TYPE 2 (MIX)");
        let tElem = document.getElementById('val-target');
        tElem.innerText = typeStr;
        tElem.style.color = state.targetMod === 1 ? COLORS.type1 : COLORS.highlight;

        document.getElementById('val-anchor').innerText = exp < 6 ? "Shoreline" : `1.0e${exp}`;

        // Jump to Ocean
        if (exp < 6) state.startCol = 3n;
        else {
            state.startCol = (10n ** BigInt(exp)) / 3n;
            if (state.startCol % 2n === 0n) state.startCol += 1n;
        }
        
        state.startRow = 3n;
        state.panX = 0; state.panY = 0;
        state.selected = null;
        document.getElementById('selection-hud').style.opacity = 0;

        requestAnimationFrame(render);
    });

    // Init
    function resize() {
        canvas.width = document.getElementById('viewport').clientWidth;
        canvas.height = document.getElementById('viewport').clientHeight;
        render();
    }
    window.addEventListener('resize', resize);
    resize();

</script>
</body>
</html>
