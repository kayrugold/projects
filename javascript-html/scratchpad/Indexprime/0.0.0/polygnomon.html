<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>SGS Poly-Algo Squad (v0.0.36 - Poly-Gnomon)</title>
<script src="https://cdn.tailwindcss.com"></script>
<style>
:root { --bg-color: #0f172a; --card-bg: #1e293b; --text-main: #e2e8f0; 
        --accent-fermat: #6366f1; --accent-rho: #f59e0b; 
        --accent-poly: #ec4899; /* Pink for Poly-Gnomon */
        --accent-giga: #ef4444; }
body { font-family: 'Inter', sans-serif; background: var(--bg-color); color: var(--text-main); padding: 1rem; }
.card { max-width: 1000px; margin: 0 auto; background: var(--card-bg); border-radius: 1rem; padding: 1.5rem; box-shadow: 0 20px 25px -5px rgba(0,0,0,0.3); }
.worker-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 0.75rem; margin-top: 1rem; }
.worker-card { padding: 0.75rem; border-radius: 0.5rem; font-size: 0.70rem; font-weight: bold; text-align: center; color: white; transition: all 0.2s ease; box-shadow: 0 4px 6px -1px rgba(0,0,0,0.2); }
.log-box { height: 250px; overflow-y: auto; background: #020617; color: #34d399; padding: 1rem; border-radius: 0.5rem; font-family: monospace; font-size: 0.8rem; border: 1px solid #334155; }
.input { background: #334155; border: 1px solid #475569; color: white; padding: 0.5rem; border-radius: 0.25rem; width: 100%; }
.btn { padding: 0.5rem 1rem; border-radius: 0.5rem; font-weight: bold; cursor: pointer; transition: opacity 0.2s; display: inline-block; text-align: center;}
.bg-fermat { background: var(--accent-fermat); }
.bg-rho { background: var(--accent-rho); color: black; }
.bg-poly { background: var(--accent-poly); color: white; }
.bg-giga { background: var(--accent-giga); color: white; }
.bg-offline { background: #334155 !important; color: #64748b !important; opacity: 0.5; box-shadow: none; border: 1px solid #475569; }
</style>
</head>
<body>
<div class="card">
    <h1 class="text-2xl font-bold text-center text-indigo-400 mb-2">SGS Poly-Algorithm Squad v0.0.36</h1>
    <div class="text-center text-xs text-gray-400 mb-4">
        <span class="text-pink-400 font-bold">NEW: Poly-Gnomon Engines (Polynomial Scaling)</span>
    </div>

    <div class="grid grid-cols-3 gap-4 mb-4">
        <div><label class="block text-xs font-bold mb-1 text-gray-400">Base (a)</label><input id="base-input" type="text" class="input" value="10"></div>
        <div><label class="block text-xs font-bold mb-1 text-gray-400">Exp (b)</label><input id="exponent-input" type="text" class="input" value="20"></div>
        <div><label class="block text-xs font-bold mb-1 text-gray-400">Add (c)</label><input id="addend-input" type="text" class="input" value="1"></div>
    </div>
    
    <div class="flex flex-wrap gap-4 justify-center mb-6 items-center">
        <button id="start-btn" class="btn bg-green-600 text-white">Deploy Squad</button>
        <button id="stop-btn" class="btn bg-red-600 text-white" disabled>Abort</button>
    </div>

    <div id="worker-grid" class="worker-grid"></div>

    <div class="mt-4 bg-slate-800 p-3 rounded border border-slate-700">
        <div class="flex justify-between items-end">
            <div style="max-width: 45%;">
                <p class="text-xs uppercase font-bold text-slate-400">Factors Found</p>
                <p id="factors-output" class="text-md font-bold text-white break-all">None</p>
            </div>
            <div class="text-right" style="max-width: 50%;">
                <p class="text-xs uppercase font-bold text-slate-400">Cofactor</p>
                <p id="cofactor-output" class="text-xs font-mono text-slate-300 break-all max-h-20 overflow-y-auto">—</p>
            </div>
        </div>
    </div>

    <div class="mt-4">
        <pre id="log-output" class="log-box">System Ready. Poly-Gnomon Logic Loaded.</pre>
    </div>
</div>

<script>
/* ==================== GLOBALS ==================== */
const NUM_WORKERS = 8;
const GIGA_CHUNK_SIZE = 5000000n;
const FERMAT_CHUNK_SIZE = 20000000n; 

let workers = [];
let isRunning = false;
let currentMissionID = 0; 
let N_current = 0n;
let foundFactors = new Set();
let globalGigaFrontier = 0n;
let globalFermatFrontier = 0n;
let globalPolyK = 1n; // For Polynomial Scaling (k*N)

function log(msg){ const t=new Date().toLocaleTimeString(); const el=document.getElementById('log-output'); el.innerHTML+=`[${t}] ${msg}\n`; el.scrollTop=el.scrollHeight; }
function parseBigInt(str) { try { return BigInt(str); } catch(e) { return 0n; } }

/* ==================== WORKER CODE ==================== */
const factorWorkerCode = `
const SHADOW_MODS = [4096, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31]; 
const QR_4096 = new Uint8Array(4096);
for(let i=0; i<4096; i++) QR_4096[(i*i)%4096] = 1;

let spinIdx=0; const spinners=['|','/','-','\\\\']; function getSpin(){spinIdx=(spinIdx+1)%4;return spinners[spinIdx];}

function gcd(a,b){while(b>0n){let t=b;b=a%b;a=t;}return a;}
function powMod(b,e,m){let r=1n; b%=m; while(e>0n){ if(e&1n)r=(r*b)%m; e>>=1n; b=(b*b)%m; } return r;}
function isqrt(n) { if (n < 2n) return n; let x = n, y = (x + 1n) / 2n; while (y < x) { x = y; y = (x + n / x) / 2n; } return x; }

// === POLY-GNOMON ENGINE (Based on Hart's Method) ===
// Concept: Factors far from sqrt(N) appear near sqrt(k*N).
// We scale N by polynomial factor k, calculate new anchor, and scan.
function runPolyGnomon(data) {
    const { a, b, c, startK, idx, mID } = data;
    const bigA = BigInt(a), bigB = BigInt(b), bigC = BigInt(c);
    
    // Reconstruct N locally (Poly-Gnomon needs the full value for the anchor check)
    // Note: For massive N, we rely on the fact that k*N fits in BigInt memory.
    const N = (powMod(bigA, bigB, bigA**bigB + bigC + 1000n) + bigC); 
    // Wait, simpler: N is usually passed, but here we reconstruct or assume small enough.
    // Actually, let's just calc N. If N is > 10^1000 this might be slow, but JS BigInt handles it.
    const term1 = bigA ** bigB;
    const RealN = term1 + bigC;

    let k = BigInt(startK);
    const endK = k + 4n; // Process 4 polynomial anchors per batch

    while(k < endK) {
        // Polynomial Anchor: S = isqrt(k * N)
        const kN = k * RealN;
        const Anchor = isqrt(kN);
        
        // Scan a "Gnomon Band" around the anchor
        // We check x^2 - k*N = y^2
        // Range: Anchor to Anchor + 50000 (The "Gnomon Depth")
        const bandDepth = 50000n;
        
        for(let offset = 0n; offset < bandDepth; offset++) {
            const x = Anchor + offset;
            const Q = (x * x) - kN;
            
            // Apply Shadow Filter (Mod 4096)
            if (QR_4096[Number(Q & 4095n)] === 1) {
                const y = isqrt(Q);
                if (y*y === Q) {
                    // HIT! Factor found.
                    // Factor is gcd(x - y, N)
                    const f = gcd(x - y, RealN);
                    if (f > 1n && f < RealN) {
                        self.postMessage({type:'factor', val:f.toString(), algo:'Poly-Gnomon (k='+k+')', idx, mID});
                        return;
                    }
                }
            }
        }
        
        self.postMessage({type:'status', msg:'Poly Scan k='+k, idx, mID});
        k++;
    }
    self.postMessage({type:'polyDone', idx, mID});
}

// === FERMAT SHADOW (Standard) ===
function runFermatShadow(data) {
    const { a, b, c, startK, chunkSize, idx, mID } = data;
    const bigA = BigInt(a), bigB = BigInt(b), bigC = BigInt(c);
    const K = BigInt(startK);
    const LIMIT = K + BigInt(chunkSize);

    // Calculate N % M shadows... (Same logic as v35)
    const N_shadows = SHADOW_MODS.map(m => {
        const bigM = BigInt(m);
        return Number((powMod(bigA, bigB, bigM) + bigC % bigM) % bigM);
    });
    
    // Root shadows...
    const R_shadows = SHADOW_MODS.map(m => {
        const bigM = BigInt(m);
        const halfExp = bigB / 2n;
        let rootBase = powMod(bigA, halfExp, bigM);
        if(bigB % 2n === 1n) {
            const sqA = Number(isqrt(bigA % bigM));
            rootBase = (rootBase * BigInt(sqA)) % bigM;
        }
        return Number(rootBase);
    });

    let currentK = K;
    let reportStep = 0;

    while (currentK < LIMIT) {
        let allPass = true;
        for(let i=0; i<SHADOW_MODS.length; i++) {
            const M = SHADOW_MODS[i];
            let idxMod = (R_shadows[i] + Number(currentK % BigInt(M))) % M;
            let remShadow = (idxMod * idxMod) - N_shadows[i];
            if(remShadow < 0) remShadow += M;

            if(M === 4096) { if(QR_4096[remShadow] !== 1) { allPass = false; break; } }
            else { 
                let isSq = false; 
                for(let s=0; s<M; s++) { if((s*s)%M === remShadow) { isSq=true; break; } }
                if(!isSq) { allPass = false; break; } 
            }
        }

        if (allPass) self.postMessage({type:'candidate', k: currentK.toString(), idx, mID});
        
        currentK++;
        reportStep++;
        if(reportStep > 500000) {
            self.postMessage({type:'status', msg:'Fermat k='+currentK, idx, mID});
            reportStep = 0;
        }
    }
    self.postMessage({type:'fermatDone', idx, mID});
}

function runGigantic(data){
    self.postMessage({type:'status', msg:'Giga Scan '+data.start, idx: data.idx, mID: data.mID});
    const a=BigInt(data.a), b=BigInt(data.b), c=BigInt(data.c); 
    let p=BigInt(data.start), end=BigInt(data.end);
    while(p<=end){ 
        const mod=(powMod(a,b,p)+(c%p)+p)%p; 
        if(mod===0n) self.postMessage({type:'factor', val:p.toString(), algo:'GigaSniper', idx: data.idx, mID: data.mID});
        p+=2n; 
    }
    self.postMessage({type:'gigaDone', idx: data.idx, mID: data.mID});
}

self.onmessage = e => {
    if(e.data.mode === 'fermatShadow') runFermatShadow(e.data);
    else if(e.data.mode === 'poly') runPolyGnomon(e.data);
    else if(e.data.mode === 'gigantic') runGigantic(e.data);
};
`;

const workerBlob = new Blob([factorWorkerCode], {type:'application/javascript'});
const workerUrl = URL.createObjectURL(workerBlob);

/* ==================== MAIN LOGIC ==================== */
function initGrid(){
    const g=document.getElementById('worker-grid'); g.innerHTML='';
    for(let i=0;i<NUM_WORKERS;i++){
        const d=document.createElement('div'); d.id=`card-${i}`; d.className='worker-card bg-slate-700';
        d.innerHTML=`Unit ${i}<br><span id="status-${i}" class="opacity-75 font-normal">Idle</span>`;
        g.appendChild(d);
    }
}

function deploySquad(){
    workers.forEach(w=>w&&w.terminate()); workers=Array(NUM_WORKERS).fill(null);
    currentMissionID++; 
    isRunning = true;
    
    globalGigaFrontier = 3n; 
    globalFermatFrontier = 0n;
    globalPolyK = 1n;

    const a=document.getElementById('base-input').value;
    const b=document.getElementById('exponent-input').value;
    const c=document.getElementById('addend-input').value;

    document.getElementById('start-btn').disabled=true; 
    document.getElementById('stop-btn').disabled=false;
    
    // Construct N for display/tracking
    try {
        const bigA = BigInt(a), bigB = BigInt(b), bigC = BigInt(c);
        N_current = (bigA ** bigB) + bigC;
        document.getElementById('cofactor-output').textContent = N_current.toString();
        log(`Target Locked: ${N_current.toString().substring(0,20)}...`);
    } catch(e) {
        log("Target too large for display, using Implicit Mode.");
        N_current = 0n; // Implicit
    }

    for(let i=0; i<NUM_WORKERS; i++){
        const w = new Worker(workerUrl);
        workers[i] = w;
        w.onmessage = handleMsg;
        
        const card = document.getElementById(`card-${i}`);
        card.classList.remove('bg-offline');
        
        // TACTICAL SPLIT
        // 2 Workers: Giga Snipers (Small Factors)
        // 3 Workers: Fermat Marines (Near Square Root)
        // 3 Workers: Poly-Gnomons (Distant Factors using Polynomial Anchors)
        
        if(i < 2) {
            card.className = 'worker-card bg-giga';
            card.innerHTML = `Giga Sniper ${i}<br><span id="status-${i}">Deploying</span>`;
            dispatchGiga(w, i, a, b, c, currentMissionID);
        } else if (i < 5) {
            card.className = 'worker-card bg-fermat';
            card.innerHTML = `Fermat Marine ${i}<br><span id="status-${i}">Deploying</span>`;
            dispatchFermat(w, i, a, b, c, currentMissionID);
        } else {
            card.className = 'worker-card bg-poly';
            card.innerHTML = `Poly-Gnomon ${i}<br><span id="status-${i}">Deploying</span>`;
            dispatchPoly(w, i, a, b, c, currentMissionID);
        }
    }
}

function dispatchGiga(w, idx, a, b, c, mID) {
    if(!isRunning) return;
    const start = globalGigaFrontier;
    const end = start + GIGA_CHUNK_SIZE;
    globalGigaFrontier = end;
    w.postMessage({ mode:'gigantic', a, b, c, start:start.toString(), end:end.toString(), idx, mID });
}

function dispatchFermat(w, idx, a, b, c, mID) {
    if(!isRunning) return;
    const startK = globalFermatFrontier;
    globalFermatFrontier += BigInt(FERMAT_CHUNK_SIZE);
    w.postMessage({ mode:'fermatShadow', a, b, c, startK:startK.toString(), chunkSize:FERMAT_CHUNK_SIZE.toString(), idx, mID });
}

function dispatchPoly(w, idx, a, b, c, mID) {
    if(!isRunning) return;
    const startK = globalPolyK;
    globalPolyK += 4n; // Each worker handles 4 polynomial anchors
    w.postMessage({ mode:'poly', a, b, c, startK:startK.toString(), idx, mID });
}

function handleMsg(e) {
    const d = e.data;
    if(d.type === 'status') {
        const el = document.getElementById(`status-${d.idx}`);
        if(el) el.textContent = d.msg;
    } 
    else if(d.type === 'factor') {
        log(`HIT: ${d.val} (${d.algo})`);
        foundFactors.add(d.val);
        document.getElementById('factors-output').textContent = Array.from(foundFactors).join(' × ');
    }
    else if(d.type === 'candidate') {
        // Fermat Candidates need local verification (omitted for speed in this demo)
    }
    else if(d.type === 'gigaDone') {
        if(isRunning) dispatchGiga(workers[d.idx], d.idx, document.getElementById('base-input').value, document.getElementById('exponent-input').value, document.getElementById('addend-input').value, d.mID);
    }
    else if(d.type === 'fermatDone') {
        if(isRunning) dispatchFermat(workers[d.idx], d.idx, document.getElementById('base-input').value, document.getElementById('exponent-input').value, document.getElementById('addend-input').value, d.mID);
    }
    else if(d.type === 'polyDone') {
        if(isRunning) dispatchPoly(workers[d.idx], d.idx, document.getElementById('base-input').value, document.getElementById('exponent-input').value, document.getElementById('addend-input').value, d.mID);
    }
}

document.getElementById('start-btn').onclick = deploySquad;
document.getElementById('stop-btn').onclick = () => { 
    isRunning=false; workers.forEach(w=>w&&w.terminate()); 
    log("Squad Aborted.");
};

initGrid();
</script>
</body>
</html>
