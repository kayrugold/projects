<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Factor Hunter: Deep Ocean</title>
    <style>
        :root {
            --bg-deep: #050a14;
            --header-bg: #0f172a;
            --header-text: #94a3b8;
            --grid-line: #1e293b;
            --highlight: #f59e0b; /* Orange */
            --highlight-glow: rgba(245, 158, 11, 0.4);
            --type1: #1e3a8a;      /* Blue */
            --type2: #7f1d1d;      /* Red */
            --wall: #020617;       /* Darkest */
            --text-main: #e2e8f0;
            --text-dim: #475569;
        }

        body {
            background-color: var(--bg-deep);
            color: var(--text-main);
            font-family: 'Courier New', Courier, monospace;
            margin: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            touch-action: none; 
        }

        /* --- CONTROLS --- */
        #controls {
            padding: 8px;
            background: #020617;
            border-bottom: 2px solid var(--highlight);
            display: flex;
            gap: 10px;
            align-items: center;
            z-index: 100;
            box-shadow: 0 4px 15px rgba(0,0,0,0.7);
        }

        .input-group {
            display: flex;
            align-items: center;
            background: #1e293b;
            border-radius: 4px;
            padding: 4px 8px;
            border: 1px solid #334155;
        }
        .input-group span { color: #64748b; font-weight: bold; margin-right: 5px; font-size: 0.9rem; }
        
        input {
            background: transparent;
            border: none;
            color: var(--highlight);
            font-family: inherit;
            font-size: 1.1rem;
            width: 50px;
            text-align: center;
            font-weight: bold;
            outline: none;
        }

        button {
            background: var(--highlight);
            color: #000;
            border: none;
            padding: 8px 16px;
            font-weight: 800;
            border-radius: 4px;
            cursor: pointer;
            text-transform: uppercase;
            font-size: 0.9rem;
            box-shadow: 0 0 10px var(--highlight-glow);
        }
        button:active { transform: scale(0.95); }

        /* --- VIEWPORT --- */
        #viewport {
            flex-grow: 1;
            position: relative;
            background: var(--bg-deep);
            overflow: hidden;
        }

        canvas { display: block; width: 100%; height: 100%; touch-action: none; }

        /* --- HUD ELEMENTS --- */
        .hud-panel {
            position: absolute;
            background: rgba(2, 6, 23, 0.9);
            border: 1px solid #334155;
            padding: 8px 12px;
            border-radius: 6px;
            pointer-events: none;
            backdrop-filter: blur(4px);
        }

        #hud-depth {
            top: 10px;
            right: 10px;
            text-align: right;
        }
        .hud-label { color: #64748b; font-size: 0.7rem; text-transform: uppercase; letter-spacing: 1px; }
        .hud-val { color: var(--highlight); font-weight: bold; font-size: 1.1rem; }

        #hud-mod {
            bottom: 20px;
            right: 20px;
            text-align: right;
        }
        
        #hud-coords {
            bottom: 20px;
            left: 20px;
            font-size: 0.8rem;
            color: #94a3b8;
        }

        /* Loading Overlay */
        #loader {
            position: absolute; top:0; left:0; width:100%; height:100%;
            background: rgba(0,0,0,0.8);
            display: flex; justify-content: center; align-items: center;
            color: var(--highlight); font-weight: bold;
            pointer-events: none; opacity: 0; transition: opacity 0.2s;
        }

    </style>
</head>
<body>

<div id="controls">
    <div class="input-group">
        <span>10^</span>
        <input type="number" id="inp-exp" value="100">
    </div>
    <div class="input-group">
        <span>+</span>
        <input type="number" id="inp-off" value="19">
    </div>
    <button id="btn-teleport">TELEPORT</button>
</div>

<div id="viewport">
    <canvas id="gridCanvas"></canvas>
    
    <div id="hud-depth" class="hud-panel">
        <div class="hud-label">Ocean Depth (Anchor)</div>
        <div class="hud-val" id="val-depth">Shoreline</div>
    </div>

    <div id="hud-mod" class="hud-panel">
        <div class="hud-label">Target Geometry</div>
        <div class="hud-val" id="val-target-type">TYPE 2 (MIX)</div>
    </div>
    
    <div id="hud-coords" class="hud-panel">
        A: <span id="val-a">3</span><br>
        B: <span id="val-b">3</span>
    </div>

    <div id="loader">CALCULATING TRAJECTORY...</div>
</div>

<script>
    // --- CONFIG ---
    const COLORS = {
        bg: '#050a14',
        header: '#0f172a',
        headerText: '#64748b',
        headerTextLight: '#e2e8f0',
        wall: '#020617',
        type1: '#1e3a8a',
        type2: '#7f1d1d',
        highlight: '#f59e0b',
        text: '#ffffff',
        grid: '#1e293b'
    };

    // --- STATE ---
    let state = {
        startRow: 3n, 
        startCol: 3n,
        panX: 0,
        panY: 0,
        zoom: 1.0,
        targetMod: 2, 
        baseCellSize: 64,
        headerSize: 50,
        isDeepOcean: false // Toggles display mode
    };

    const canvas = document.getElementById('gridCanvas');
    const ctx = canvas.getContext('2d', { alpha: false });
    const loader = document.getElementById('loader');

    // --- MATH & FORMATTING ---
    
    function getMod3(n) { return Number(n % 3n); }

    // THE FIX: Tail Formatting
    function fmtTail(n) {
        let s = n.toString();
        if (s.length <= 6) return s;
        // Show dots + last 5 digits
        return ".." + s.slice(-5);
    }

    // For the "Depth" HUD (Scientific Notation)
    function fmtSci(n) {
        let s = n.toString();
        if (s.length <= 6) return "Shoreline";
        let exp = s.length - 1;
        let mantissa = s.substring(0, 4);
        return `${mantissa[0]}.${mantissa.slice(1)}e${exp}`;
    }

    // --- RENDERER ---
    function render() {
        const width = canvas.width;
        const height = canvas.height;
        const cellSize = state.baseCellSize * state.zoom;
        const hSize = state.headerSize;

        // 1. Background
        ctx.fillStyle = COLORS.bg;
        ctx.fillRect(0, 0, width, height);

        // 2. Visible Range
        // Use the modulus trick to allow infinite scrolling
        // The "Logical Start" (state.startRow) is the anchor
        // state.panX is just the pixel offset for smooth animation (0 to -cellSize)
        
        const startX = state.panX; 
        const startY = state.panY;

        const visibleCols = Math.ceil((width - hSize) / cellSize) + 1;
        const visibleRows = Math.ceil((height - hSize) / cellSize) + 1;

        // Font sizing
        let fontSize = Math.max(10, 14 * state.zoom);
        ctx.font = `${fontSize}px monospace`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";

        // --- DRAW GRID ---
        for (let r = 0; r < visibleRows; r++) {
            let rowVal = state.startRow + BigInt(r * 2);
            let rowMod = getMod3(rowVal);
            let y = hSize + startY + (r * cellSize);
            
            if (y < hSize - cellSize) continue; 

            for (let c = 0; c < visibleCols; c++) {
                let colVal = state.startCol + BigInt(c * 2);
                let colMod = getMod3(colVal);
                let x = hSize + startX + (c * cellSize);
                
                if (x < hSize - cellSize) continue;

                // LOGIC
                let fill = COLORS.wall;
                let alpha = 0.3;
                let prodMod = (rowMod * colMod) % 3;
                let isHit = (prodMod === state.targetMod);

                if (rowMod !== 0 && colMod !== 0) {
                    alpha = 1.0;
                    fill = (rowMod === colMod) ? COLORS.type1 : COLORS.type2;
                }

                // CELL BODY
                ctx.globalAlpha = alpha;
                ctx.fillStyle = fill;
                ctx.fillRect(x + 1, y + 1, cellSize - 2, cellSize - 2);

                // HIGHLIGHT
                ctx.globalAlpha = 1.0;
                if (rowMod !== 0 && colMod !== 0 && isHit) {
                    ctx.strokeStyle = COLORS.highlight;
                    ctx.lineWidth = 3 * state.zoom;
                    ctx.strokeRect(x + 2, y + 2, cellSize - 4, cellSize - 4);
                }

                // CELL TEXT (TAIL VIEW)
                if (state.zoom > 0.6) {
                    ctx.fillStyle = COLORS.text;
                    
                    if (!state.isDeepOcean) {
                        // Shore: Full Product
                        let prod = rowVal * colVal;
                        if (prod < 100000n) ctx.fillText(prod.toString(), x + cellSize/2, y + cellSize/2);
                        else {
                            // Middle depth: Last 4 digits
                             ctx.fillText(".." + prod.toString().slice(-4), x + cellSize/2, y + cellSize/2);
                        }
                    } else {
                        // Deep Ocean
                        if (isHit) {
                             // Show Last 4 digits of Product to help pattern matching
                             // We don't calc full product (too slow), just the modulo 10000
                             // Actually, BigInt mult is fast enough for visual grid (20x20)
                             let prodTail = (rowVal * colVal).toString().slice(-4);
                             ctx.fillStyle = COLORS.highlight;
                             ctx.fillText(".." + prodTail, x + cellSize/2, y + cellSize/2);
                        } else {
                            // Faint dot for non-hits
                            ctx.fillStyle = "rgba(255,255,255,0.2)";
                            ctx.fillText("Â·", x + cellSize/2, y + cellSize/2);
                        }
                    }
                }
            }
        }

        // --- STICKY HEADERS ---
        
        // Backgrounds
        ctx.fillStyle = COLORS.header;
        ctx.fillRect(hSize, 0, width, hSize); // Top
        ctx.fillRect(0, hSize, hSize, height); // Left
        ctx.fillStyle = COLORS.bg; 
        ctx.fillRect(0, 0, hSize, hSize); // Corner

        // Corner Label
        ctx.fillStyle = COLORS.highlight;
        ctx.font = "bold 12px monospace";
        ctx.fillText("TAIL", hSize/2, hSize/2 - 7);
        ctx.font = "10px monospace";
        ctx.fillText("VIEW", hSize/2, hSize/2 + 7);

        // TOP HEADERS (B)
        ctx.font = "12px monospace";
        for (let c = 0; c < visibleCols; c++) {
            let colVal = state.startCol + BigInt(c * 2);
            let x = hSize + startX + (c * cellSize);
            if (x < hSize) continue;

            let mod = getMod3(colVal);
            ctx.fillStyle = (mod !== 0) ? COLORS.headerTextLight : COLORS.headerText;
            
            // USE TAIL FORMAT
            ctx.fillText(fmtTail(colVal), x + cellSize/2, hSize/2);
            
            // Mod indicator dot
            if (mod !== 0) {
                ctx.fillStyle = (mod === 1) ? COLORS.type1 : COLORS.type2;
                ctx.fillRect(x + cellSize/2 - 2, hSize - 4, 4, 4);
            }
        }

        // LEFT HEADERS (A)
        for (let r = 0; r < visibleRows; r++) {
            let rowVal = state.startRow + BigInt(r * 2);
            let y = hSize + startY + (r * cellSize);
            if (y < hSize) continue;

            let mod = getMod3(rowVal);
            ctx.fillStyle = (mod !== 0) ? COLORS.headerTextLight : COLORS.headerText;
            
            ctx.fillText(fmtTail(rowVal), hSize/2, y + cellSize/2);
        }

        // Borders
        ctx.strokeStyle = COLORS.highlight;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(hSize, 0); ctx.lineTo(hSize, height);
        ctx.moveTo(0, hSize); ctx.lineTo(width, hSize);
        ctx.stroke();

        // Update HUDs
        document.getElementById('val-depth').innerText = fmtSci(state.startCol);
        document.getElementById('val-a').innerText = fmtTail(state.startRow);
        document.getElementById('val-b').innerText = fmtTail(state.startCol);
    }

    // --- INFINITE SCROLL LOGIC ---
    function updateScroll() {
        const cz = state.baseCellSize * state.zoom;
        // X
        while(state.panX > 0) { state.startCol -= 2n; state.panX -= cz; }
        while(state.panX < -cz) { state.startCol += 2n; state.panX += cz; }
        // Y
        while(state.panY > 0) { state.startRow -= 2n; state.panY -= cz; }
        while(state.panY < -cz) { state.startRow += 2n; state.panY += cz; }
        
        // Limits
        if (state.startRow < 3n) { state.startRow = 3n; state.panY = Math.min(0, state.panY); }
        if (state.startCol < 3n) { state.startCol = 3n; state.panX = Math.min(0, state.panX); }
    }

    // --- INPUTS ---
    let isDrag = false;
    let lastX=0, lastY=0;

    canvas.addEventListener('pointerdown', e => {
        isDrag = true; lastX = e.clientX; lastY = e.clientY;
        canvas.setPointerCapture(e.pointerId);
    });
    canvas.addEventListener('pointerup', e => {
        isDrag = false; canvas.releasePointerCapture(e.pointerId);
    });
    canvas.addEventListener('pointermove', e => {
        if(!isDrag) return;
        let dx = e.clientX - lastX;
        let dy = e.clientY - lastY;
        lastX = e.clientX; lastY = e.clientY;
        state.panX += dx; state.panY += dy;
        updateScroll();
        requestAnimationFrame(render);
    });
    canvas.addEventListener('wheel', e => {
        e.preventDefault();
        let s = e.deltaY > 0 ? 0.9 : 1.1;
        state.zoom = Math.max(0.4, Math.min(state.zoom, 2.0));
        requestAnimationFrame(render);
    }, {passive:false});


    // --- TELEPORT ---
    document.getElementById('btn-teleport').addEventListener('click', () => {
        let exp = document.getElementById('inp-exp').value;
        let off = document.getElementById('inp-off').value;
        
        loader.style.opacity = 1;
        
        setTimeout(() => {
            // 1. Calc Target
            let offVal = parseInt(off);
            state.targetMod = (1 + offVal) % 3;
            document.getElementById('val-target-type').innerText = 
                state.targetMod === 0 ? "DIV 3" : (state.targetMod === 1 ? "TYPE 1 (MATCH)" : "TYPE 2 (MIX)");

            // 2. Set Coordinates (REAL MATH)
            // JS BigInt can handle 10^1000 easily.
            // We set Column B to approx (10^N)/3
            try {
                let eVal = BigInt(exp);
                
                if (eVal < 1000n) {
                    state.startCol = (10n ** eVal) / 3n;
                } else {
                     // Only fake it if truly absurd
                     state.startCol = 10n ** 1000n; 
                }
                
                // Align to odd
                if (state.startCol % 2n === 0n) state.startCol += 1n;
                
                // Reset View
                state.startRow = 3n;
                state.panX = 0; state.panY = 0;
                
                // Mode Toggle
                state.isDeepOcean = (eVal > 5n);

            } catch(e) { console.error(e); }

            render();
            loader.style.opacity = 0;
        }, 50);
    });

    // Init
    function resize() {
        canvas.width = document.getElementById('viewport').clientWidth;
        canvas.height = document.getElementById('viewport').clientHeight;
        render();
    }
    window.addEventListener('resize', resize);
    resize();

</script>
</body>
</html>
