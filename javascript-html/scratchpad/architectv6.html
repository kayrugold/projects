<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Architect v8.0 (Sundaram + Fixed UI)</title>
<script src="https://cdn.tailwindcss.com"></script>
<style>
    :root { --col-count: 30; --tile-size: 24px; }
    body { background-color: #020617; color: #e2e8f0; font-family: 'Courier New', monospace; margin: 0; height: 100vh; display: flex; flex-direction: column; overflow: hidden; }
    
    /* CONTROL DECK */
    .control-deck {
        background: #0f172a; border-top: 1px solid #1e293b;
        padding: 10px; display: flex; flex-direction: column; gap: 10px;
        box-shadow: 0 -10px 30px rgba(0,0,0,0.5); z-index: 50;
    }
    
    .toolbar-row { display: flex; gap: 10px; align-items: center; justify-content: space-between; }
    
    .btn-group { display: flex; gap: 5px; background: #1e293b; padding: 4px; border-radius: 6px; }
    .btn-icon { 
        width: 36px; height: 36px; display: flex; align-items: center; justify-content: center;
        background: #334155; border-radius: 4px; cursor: pointer; font-weight: bold; font-size: 1.2rem;
    }
    .btn-icon:hover { background: #475569; color: #fff; }
    
    .col-select { 
        background: #334155; color: #fff; padding: 12px; border-radius: 6px; 
        font-family: monospace; font-weight: bold; border: 1px solid #475569; outline: none; font-size: 1rem;
    }

    .main-btn {
        background: #8b5cf6; color: #fff; font-weight: 900; border: none;
        padding: 12px 20px; border-radius: 6px; text-transform: uppercase;
        box-shadow: 0 4px 0 #7c3aed; font-size: 0.9rem; flex-grow: 1;
    }
    .main-btn:active { transform: translateY(2px); box-shadow: 0 0 0 #7c3aed; }

    /* GRID VIEWPORT */
    .grid-viewport { 
        flex-grow: 1; overflow-y: auto; background: #020617; 
        position: relative; cursor: crosshair;
        display: flex; justify-content: center; align-items: start;
        padding: 20px;
    }
    
    .sector-grid { 
        display: grid; 
        grid-template-columns: repeat(var(--col-count), var(--tile-size)); 
        gap: 2px; 
        transform-origin: top center;
    }
    
    .tile { 
        width: var(--tile-size); height: var(--tile-size);
        background: #0f172a; border: 1px solid #1e293b; 
        display: flex; align-items: center; justify-content: center; 
        font-size: calc(var(--tile-size) * 0.35); color: #475569; 
        cursor: pointer; border-radius: 2px; user-select: none;
    }
    .tile:hover { z-index: 10; border-color: #fff; }
    
    .tile.survivor { 
        background: #10b981; border-color: #059669; color: #022c22; 
        font-weight: bold; box-shadow: 0 0 5px rgba(16, 185, 129, 0.4); 
    }
    .tile.wall { background: #1e293b; opacity: 0.3; }
    .tile.selected { border: 2px solid #fff; z-index: 20; transform: scale(1.1); box-shadow: 0 0 15px #fff; }

    /* INSPECTOR PANEL */
    .inspector-panel {
        position: absolute; bottom: 140px; left: 50%; transform: translateX(-50%);
        width: 95%; max-width: 500px;
        background: rgba(15, 23, 42, 0.98); backdrop-filter: blur(10px);
        border: 1px solid #8b5cf6; border-radius: 12px;
        padding: 15px; display: none; z-index: 100;
        box-shadow: 0 10px 40px rgba(0,0,0,0.8);
    }
    .inspector-panel.active { display: block; animation: popUp 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
    
    .panel-header { display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #334155; padding-bottom: 8px; margin-bottom: 10px; }
    .panel-title { font-size: 0.8rem; color: #94a3b8; font-weight: bold; letter-spacing: 1px; }
    .close-btn { color: #ef4444; font-weight: bold; cursor: pointer; font-size: 1.2rem; padding: 0 10px; }
    
    .data-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
    .data-col { display: flex; flex-direction: column; }
    
    .d-lbl { font-size: 0.65rem; color: #64748b; uppercase; }
    .d-val { font-size: 0.85rem; color: #fff; font-weight: bold; font-family: monospace; white-space: nowrap; overflow-x: auto; scrollbar-width: none; }
    .d-big { color: #fbbf24; font-size: 1rem; }
    .d-dim { color: #475569; font-size: 0.8rem; }
    
    .toggle-view { 
        text-align: center; margin-top: 10px; padding-top: 10px; border-top: 1px dashed #334155; 
        color: #8b5cf6; font-size: 0.7rem; cursor: pointer; font-weight: bold; letter-spacing: 1px;
    }

    @keyframes popUp { from { transform: translate(-50%, 20px); opacity: 0; } to { transform: translate(-50%, 0); opacity: 1; } }

</style>
</head>
<body>

<div class="grid-viewport">
    <div id="grid" class="sector-grid">
        <div style="color:#475569; grid-column:span 30; text-align:center; padding-top:100px;">
            SUNDARAM MATRIX READY<br>
            TARGET: 10^1,000,000,000 + 61
        </div>
    </div>
</div>

<div id="inspector" class="inspector-panel">
    <div class="panel-header">
        <span class="panel-title">SUNDARAM ANALYSIS</span>
        <span class="close-btn" onclick="closeInspector()">Ã—</span>
    </div>
    
    <div class="data-grid">
        <div class="data-col" style="grid-column: span 2;">
            <span class="d-lbl">INDEX FORMULA (k+1)</span>
            <span id="inspIndex" class="d-val text-blue-400">--</span>
        </div>
        
        <div class="data-col" style="grid-column: span 2;">
            <span class="d-lbl">GNOMON / RIM (2k+1)</span>
            <span id="inspN" class="d-val d-big">--</span>
        </div>
    </div>
    
    <div class="toggle-view" onclick="toggleAlgebra()">ðŸ”„ SWITCH ALGEBRAIC VIEW</div>
</div>

<div class="control-deck">
    <div class="toolbar-row">
        <div class="btn-group">
            <button class="btn-icon" onclick="setCols(6)">6</button>
            <button class="btn-icon" onclick="setCols(12)">12</button>
            <button class="btn-icon" onclick="setCols(30)" style="color:#fbbf24">30</button>
        </div>
        <div class="btn-group">
            <button class="btn-icon" onclick="adjustZoom(-4)">-</button>
            <button class="btn-icon" onclick="adjustZoom(4)">+</button>
        </div>
    </div>
    <div class="toolbar-row">
        <input id="inpStart" value="1e1000000000+61" class="col-select" style="flex:2; text-align:left;">
        <button class="main-btn" onclick="fetchSector()">SOLVE MATRIX</button>
    </div>
</div>

<script>
// --- STATE ---
let currentZoom = 24; 
let currentCols = 30;
let isAlgebraic = false;
let selectedTileData = null; 
let currentConfig = null;

// --- FIXED PARSER ---
function parseVirtualInput(str) {
    str = str.toLowerCase().replace(/\s/g, '');
    
    // Default: Multiplier * 10^Exp + Add
    let mult = 1n, exp = 0n, add = 0n;
    
    try {
        if(str.includes('e')) {
            // Format: A e B + C
            let parts = str.split('e');
            mult = BigInt(parts[0] || 1);
            
            let rest = parts[1];
            if(rest.includes('+')) {
                let subParts = rest.split('+');
                exp = BigInt(subParts[0]);
                add = BigInt(subParts[1]);
            } else {
                exp = BigInt(rest);
            }
        } else if(str.includes('^')) {
            // Unsupported in this simplified parser, fallback to int
            throw new Error("Use 'e' notation");
        } else {
            // Plain Integer (e.g. "27")
            // Treat as: 27 * 10^0 + 0
            mult = BigInt(str);
            exp = 0n;
            add = 0n;
        }
    } catch(e) {
        alert("Invalid Format. Use '27' or '1e1000+61'");
        throw e;
    }
    
    return { mult, exp, add };
}

// --- SUNDARAM WORKER ---
const workerCode = `
self.onmessage = function(e) {
    const { startData, size } = e.data;
    const ruler = new Uint8Array(size);
    
    const mult = BigInt(startData.mult);
    const exp = BigInt(startData.exp);
    const add = BigInt(startData.add);
    
    // MODULAR MATH
    function powMod(b, e, m) {
        let res = 1n; b %= m;
        while (e > 0n) { if (e & 1n) res = (res * b) % m; b = (b * b) % m; e >>= 1n; }
        return res;
    }

    // Determine Magnitude for Exact vs Modular Mode
    let isSmall = false;
    let k_start_val = 0n;
    
    if (exp < 15n) {
        isSmall = true;
        // Calculate exact start Number N
        let N = (mult * (10n ** exp)) + add;
        // Adjust N to be odd if user entered even (Index logic requires odd)
        if (N % 2n === 0n) N += 1n;
        // k = (N - 1) / 2
        k_start_val = (N - 1n) / 2n;
    }

    const LIMIT_I = 2000000; 
    
    for (let i = 1; i <= LIMIT_I; i++) {
        const stride = 2*i + 1; // P = 2i+1
        const P = BigInt(stride);
        
        // We need to find the first k in our range [k_start ... k_start+size]
        // such that 2k+1 is divisible by P.
        // Condition: 2k+1 = 0 mod P.
        // 2k = -1 mod P.
        // k = (-1 * inv(2)) mod P.
        // inv(2) mod P is (P+1)/2.
        // So target_k_mod_P = (P-1) * (P+1)/2 mod P.
        // actually simpler: P divides 2k+1 means k = i + m*P.
        // The pattern of composites for P=2i+1 starts at k=i+j+2ij -> i + i(1+2i) -> i + i*P.
        // Wait, the first composite is at index k = i + j + 2ij.
        // If j=i, k = i + i + 2ii = 2i^2 + 2i.
        // Number = 2(2i^2+2i)+1 = 4i^2+4i+1 = (2i+1)^2 = P^2.
        // Correct.
        
        // So the "walls" for P appear at k indices satisfying k = i mod P.
        // (Wait, let's verify P=3 (i=1). Walls at k=4, 7, 10...
        // 4 = 1 mod 3. 7 = 1 mod 3. Yes.
        // So we need k == i (mod P).
        
        // We need to find offset 'x' such that (k_start + x) == i (mod P).
        
        let kStartMod = 0n;
        
        if (isSmall) {
            kStartMod = k_start_val % P;
        } else {
            // Modular calc for massive numbers
            // k_start = (N - 1) / 2
            // N_mod = (mult * 10^exp + add) % P
            const baseMod = powMod(10n, exp, P);
            let N_mod = (mult * baseMod + add) % P;
            
            // k_start_mod = (N_mod - 1) * inv(2)
            const inv2 = (P + 1n) / 2n;
            kStartMod = ((N_mod - 1n + P) % P * inv2) % P;
        }
        
        // We want (kStart + x) % P = i
        // x = (i - kStart) % P
        
        let offset = BigInt(i) - kStartMod;
        // Normalize offset to be positive [0, P-1]
        offset = ((offset % P) + P) % P;
        
        let localStart = Number(offset);
        
        // Optimization: The first composite for P starts at k = 2i^2 + 2i.
        // If our chunk is before that, we don't mark anything.
        if (isSmall) {
            const first_composite_k = BigInt(2*i*i + 2*i);
            if (first_composite_k >= k_start_val + BigInt(size)) {
                // Starts after our chunk
                continue;
            }
            if (first_composite_k > k_start_val) {
                // Starts inside our chunk
                // We need to advance localStart until it >= (first_composite_k - k_start_val)
                const start_offset = Number(first_composite_k - k_start_val);
                while (localStart < start_offset) localStart += stride;
            }
        }
        
        // Mark Walls
        for(let pos = localStart; pos < size; pos += stride) {
            ruler[pos] = 1;
        }
    }

    self.postMessage({ ruler: ruler });
};
`;

// --- UI FUNCTIONS ---
function setCols(n) {
    currentCols = n;
    document.documentElement.style.setProperty('--col-count', n);
}

function adjustZoom(delta) {
    currentZoom = Math.max(10, Math.min(60, currentZoom + delta));
    document.documentElement.style.setProperty('--tile-size', currentZoom + "px");
}

function closeInspector() {
    document.getElementById('inspector').classList.remove('active');
    document.querySelectorAll('.tile').forEach(t => t.classList.remove('selected'));
}

function toggleAlgebra() {
    isAlgebraic = !isAlgebraic;
    if(selectedTileData) updateInspector();
}

function fetchSector() {
    const rawStart = document.getElementById('inpStart').value;
    const limit = 2000; 
    
    try {
        currentConfig = parseVirtualInput(rawStart);
    } catch(e) { return; }

    document.getElementById('grid').innerHTML = '<div style="color:#8b5cf6; grid-column:span 30; text-align:center; padding:50px;">SOLVING MATRIX...</div>';
    closeInspector();

    const blob = new Blob([workerCode], {type: "application/javascript"});
    const worker = new Worker(URL.createObjectURL(blob));

    worker.postMessage({ startData: currentConfig, size: limit });

    worker.onmessage = function(e) {
        renderGrid(e.data.ruler);
        worker.terminate();
    };
}

function renderGrid(ruler) {
    const grid = document.getElementById('grid');
    grid.innerHTML = '';
    const frag = document.createDocumentFragment();
    
    // Determine Small Mode for Labels
    let isSmall = currentConfig.exp < 15n;
    let baseVal = 0n;
    
    if(isSmall) {
        baseVal = (currentConfig.mult * (10n ** currentConfig.exp)) + currentConfig.add;
        if(baseVal % 2n === 0n) baseVal += 1n; // Snap to Odd
    }

    for(let i=0; i<ruler.length; i++) {
        const div = document.createElement('div');
        div.className = ruler[i] === 0 ? 'tile survivor' : 'tile wall';
        
        if(ruler[i] === 0) {
            if(isSmall) {
                let val = baseVal + (BigInt(i)*2n);
                div.textContent = val.toString();
            } else {
                div.textContent = "+"+(i*2);
            }
        }
        
        div.onclick = () => selectTile(div, i, ruler[i], isSmall, baseVal);
        frag.appendChild(div);
    }
    grid.appendChild(frag);
    setCols(currentCols);
}

function selectTile(el, offset, status, isSmall, baseVal) {
    document.querySelectorAll('.tile').forEach(t => t.classList.remove('selected'));
    el.classList.add('selected');
    selectedTileData = { offset, status, isSmall, baseVal };
    updateInspector();
    document.getElementById('inspector').classList.add('active');
}

function updateInspector() {
    const { offset, status, isSmall, baseVal } = selectedTileData;
    const elIndex = document.getElementById('inspIndex');
    const elN = document.getElementById('inspN');
    
    if(isSmall) {
        const val = baseVal + (BigInt(offset)*2n);
        // k = (N-1)/2. Index I = k+1 = (N+1)/2.
        const k = (val - 1n) / 2n;
        const idx = k + 1n;
        
        elIndex.innerText = idx.toString();
        elN.innerText = val.toString();
    } else {
        const addN = currentConfig.add + BigInt(offset*2);
        const addI = addN + 1n;
        if(isAlgebraic) {
            elIndex.innerText = `(${currentConfig.mult}Â·10^${currentConfig.exp} + ${addI}) / 2`;
            elN.innerHTML = `${currentConfig.mult}Â·10^${currentConfig.exp} + <span style="color:#fbbf24">${addN}</span>`;
        } else {
            elIndex.innerText = `Start_Index + ${offset}`;
            elN.innerHTML = `Target + <span style="color:#fbbf24">${offset * 2}</span>`;
        }
    }
}

setCols(30);
adjustZoom(0);
</script>
</body>
</html>
