<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>NTT-Accelerated Lucas-Lehmer Test (NTT-LLT)</title>
<script src="https://cdn.tailwindcss.com"></script>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
  body { font-family: 'Inter', sans-serif; background-color: #f8fafc; }
  .card { background-color: white; border-radius: 0.75rem; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); padding: 1.5rem; }
  input[type="number"] { min-width: 150px; font-family: monospace; }
  .btn-primary { background-color: #be123c; }
  .btn-primary:hover:not(:disabled) { background-color: #9f1239; }
  button:disabled { background-color: #9ca3af; cursor: not-allowed; }
  #logOutput { min-height: 150px; max-height: 300px; overflow-y: auto; background-color: #e2e8f0; padding: 1rem; border-radius: 0.5rem; font-family: monospace; white-space: pre-wrap; font-size: 0.875rem; }
</style>
</head>
<body class="p-4 flex flex-col items-center">

<div class="max-w-xl w-full card my-8">
  <h2 class="text-2xl font-bold text-center text-red-700 mb-6">NTT-Accelerated Lucas-Lehmer Test (NTT-LLT)</h2>

  <p class="mb-4 text-sm text-gray-600 border-l-4 border-red-500 pl-3">
    Performs the $\mathbf{S_i = (S_{i-1}^2 - 2) \pmod{M_p}}$ sequence using $\mathbf{\mathcal{O}(N \log N)}$ multiplication for maximum speed. Only works for **Mersenne Primes** ($M_p = 2^p - 1$).
  </p>

  <!-- Input Group -->
  <div class="flex flex-col gap-4 mb-4 items-center">
    <div class="input-group flex flex-col">
      <label for="exponentP" class="font-semibold text-gray-700">Mersenne Exponent $\mathbf{P}$ (Must be Prime)</label>
      <input type="number" id="exponentP" class="w-full border rounded p-2 text-center" value="127">
      <p class="text-xs text-gray-500 mt-1 text-center">e.g., 31 (M31 is prime), 13 (M13 is prime), 127 (M127 is prime)</p>
    </div>
  </div>

  <!-- Controls -->
  <div class="flex flex-wrap gap-3 justify-center mb-6">
    <button id="startLLTButton" class="btn-primary flex-grow px-6 py-3 rounded-xl font-semibold text-white">Start NTT-LLT</button>
    <button id="stopButton" class="bg-gray-500 text-white flex-grow px-6 py-3 rounded-xl font-semibold" disabled>Stop</button>
  </div>

  <!-- Progress and Status -->
  <div id="progressBarContainer" class="w-full bg-gray-200 rounded-full h-3 mb-4 overflow-hidden">
    <div id="progressBar" class="bg-red-500 h-3 text-xs flex items-center justify-center text-white transition-all duration-300" style="width: 0%"></div>
  </div>
  <div id="results" class="text-center font-bold text-lg text-gray-700 mb-4">Status: Ready.</div>

  <!-- Log Output -->
  <div class="mt-4">
    <h3 class="text-xl font-semibold text-gray-800 mb-2 border-b pb-1">Calculation Log</h3>
    <pre id="logOutput" class="text-gray-900"></pre>
  </div>
</div>

<script>
// --- WORKER CODE (NTT-Accelerated LLT - Self Contained) ---
const workerCode = `
// --- Worker Constants ---
const BASE = 10000; // Base 10^4 (for chunking)
const CHUNK_SIZE = 4;
// Parameters for NTT: Modulus Q and Primitive Root G
const Q = 469762049; // Q = 3 * 2^28 + 1 (A good prime for 2^24 length)
const G = 3;         // Primitive root mod Q
const BASE_BI = BigInt(BASE); // BIGINT BASE constant

// --- Utility Functions (Chunking/Arithmetic) ---
function isZero(c) {
    return c.length === 1 && c[0] === 0;
}

function trim(c) {
    if (!Array.isArray(c) || c.length === 0) return [0];
    let i = 0;
    while (i < c.length - 1 && c[i] === 0) i++;
    if (i === c.length) return [0];
    return c.slice(i);
}

function cmp(a, b) {
    a = trim(a); b = trim(b);
    if (a.length !== b.length) return a.length > b.length ? 1 : -1;
    for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) return a[i] > b[i] ? 1 : -1;
    }
    return 0;
}

function add(a, b) {
    let a_rev = a.slice().reverse(); 
    let b_rev = b.slice().reverse();
    let n = Math.max(a_rev.length, b_rev.length), carry = 0, out = [];
    for (let i = 0; i < n; i++) {
        let s = (a_rev[i] || 0) + (b_rev[i] || 0) + carry;
        out.push(s % BASE);
        carry = Math.floor(s / BASE);
    }
    if (carry) out.push(carry);
    return trim(out.reverse());
}

function sub(a, b) { // a - b, assumes a >= b
    let a_rev = a.slice().reverse(); 
    let b_rev = b.slice().reverse();
    let n = a_rev.length, borrow = 0, out = [];
    for (let i = 0; i < n; i++) {
        let v = (a_rev[i] || 0) - (b_rev[i] || 0) - borrow;
        if (v < 0) { v += BASE; borrow = 1; } else { borrow = 0; }
        out.push(v);
    }
    return trim(out.reverse());
}

function chunksToString(chunks) {
    if (!chunks || isZero(chunks)) return "0";
    let trimmed = trim(chunks);
    if (trimmed.length === 0) return "0";
    let s = trimmed[0].toString();
    for (let i = 1; i < trimmed.length; i++) {
        s += trimmed[i].toString().padStart(CHUNK_SIZE, '0');
    }
    return s;
}

function stringToChunks(s) {
    if (typeof s !== 'string' || s.length === 0) return [0];
    s = s.trim().replace(/^0+/, '');
    if (s === '') return [0];

    const padLength = (CHUNK_SIZE - (s.length % CHUNK_SIZE)) % CHUNK_SIZE;
    s = '0'.repeat(padLength) + s;
    const chunks = [];
    for (let i = 0; i < s.length; i += CHUNK_SIZE) {
        const chunkStr = s.substring(i, i + CHUNK_SIZE);
        chunks.push(parseInt(chunkStr, 10));
    }
    return trim(chunks);
}

// --- NTT Core Functions ---

function power(base, exp) {
    let res = 1;
    base %= Q;
    while (exp > 0) {
        if (exp % 2 === 1) res = (res * base) % Q;
        base = (base * base) % Q;
        exp = Math.floor(exp / 2);
    }
    return res;
}

function modInverse(n) {
    return power(n, Q - 2);
}

function ntt(a, inverse, n) {
    for (let i = 1, j = 0; i < n; i++) {
        let bit = n >> 1;
        for (; j & bit; bit >>= 1) {
            j ^= bit;
        }
        j ^= bit;
        if (i < j) [a[i], a[j]] = [a[j], a[i]];
    }

    for (let len = 2; len <= n; len <<= 1) {
        let wlen = power(G, (Q - 1) / len);
        if (inverse) wlen = modInverse(wlen);

        for (let i = 0; i < n; i += len) {
            let w = 1;
            for (let j = 0; j < len / 2; j++) {
                let u = a[i + j];
                let v = (a[i + j + len / 2] * w) % Q;
                
                a[i + j] = (u + v) % Q;
                a[i + j + len / 2] = (u - v + Q) % Q;
                w = (w * wlen) % Q;
            }
        }
    }

    if (inverse) {
        let n_inv = modInverse(n);
        for (let i = 0; i < n; i++) {
            a[i] = (a[i] * n_inv) % Q;
        }
    }
}

/**
 * Performs multiplication using NTT (O(N log N)).
 * @param {number[]} a - First number chunks.
 * @param {number[]} b - Second number chunks.
 * @returns {number[]} Result chunks.
 */
function mul(a, b) {
    if (isZero(a) || isZero(b)) return [0];
    
    // Optimization: check for squaring
    const isSquare = (a === b); 

    let len = a.length + b.length - 1;
    let n = 1;
    while (n < len) n <<= 1;

    let fa = new Array(n).fill(0);
    let fb = new Array(n).fill(0);
    
    // Copy input chunks
    for (let i = 0; i < a.length; i++) fa[i] = a[i];
    if (!isSquare) {
        for (let i = 0; i < b.length; i++) fb[i] = b[i];
    }

    ntt(fa, false, n);
    if (isSquare) {
        // Square the transformed values for S^2
        for (let i = 0; i < n; i++) {
            fa[i] = (BigInt(fa[i]) * BigInt(fa[i])) % BigInt(Q);
        }
    } else {
        ntt(fb, false, n);
        for (let i = 0; i < n; i++) {
            fa[i] = (BigInt(fa[i]) * BigInt(fb[i])) % BigInt(Q);
        }
    }
    
    // We now have BigInts in fa array, but ntt expects numbers for bit operations.
    // We must ensure the inverse NTT operates on JS numbers that fit within Q.
    for (let i = 0; i < n; i++) {
        fa[i] = Number(fa[i]);
    }
    
    ntt(fa, true, n);

    let result = [];
    let carry = 0n; // CARRY MUST BE BIGINT
    // Perform reconstruction with carry propagation
    for (let i = 0; i < len; i++) {
        // All terms in this calculation MUST be BigInts
        let chunk_val = BigInt(fa[i]) + carry; 
        result.push(Number(chunk_val % BASE_BI));
        carry = chunk_val / BASE_BI;
    }
    
    while (carry > 0n) {
        result.push(Number(carry % BASE_BI));
        carry = carry / BASE_BI;
    }
    
    return trim(result.reverse());
}

/**
 * Executes the specialized Modular Reduction for Mp = 2^p - 1.
 * @param {number[]} S_sq - The result of S^2 - 2.
 * @param {number} p - The Mersenne exponent.
 * @returns {number[]} The reduced remainder.
 */
function LLT_modularReduction(S_sq, p) {
    let remainder = S_sq.slice();
    
    // Approximates p bits in chunks: log10(2^p) approx p * 0.301.
    const p_digits = Math.ceil(p * Math.log10(2));
    const p_chunks = Math.ceil(p_digits / CHUNK_SIZE);

    const low_part_length = p_chunks;
    
    let reductionSteps = 0;
    const maxReductionSteps = 3; 
    
    // Perform modular reduction until length is <= low_part_length
    while (remainder.length > low_part_length && reductionSteps < maxReductionSteps) {
        
        // Split remainder into high (R_H) and low (R_L) parts
        const R_H = remainder.slice(0, remainder.length - low_part_length);
        const R_L = remainder.slice(remainder.length - low_part_length);
        
        // New remainder = R_H + R_L (The bit-shift equivalent in chunks)
        remainder = add(R_H, R_L);

        reductionSteps++;
    }

    // Final check for M_p subtraction (remainder > M_p).
    const Mp_str = (BigInt(2)**BigInt(p) - 1n).toString(); 
    const M_p_chunks = stringToChunks(Mp_str);

    // If remainder is the same length as M_p or longer
    if (remainder.length > M_p_chunks.length || (remainder.length === M_p_chunks.length && cmp(remainder, M_p_chunks) >= 0)) {
         remainder = sub(remainder, M_p_chunks);
    }

    return remainder;
}


// --- Main LLT Sequence ---
self.onmessage = function(e) {
    const p = e.data.p; // Exponent P (number)
    
    const sequenceLength = p - 2;
    
    // S_0 = 4 (represented as chunks)
    let S = stringToChunks("4"); 
    
    let lastProgress = 0;
    const startTime = Date.now();
    let isError = false;

    // Loop S_i = (S_{i-1}^2 - 2) mod M_p for p - 2 times
    for (let i = 0; i < sequenceLength; i++) {
        
        try {
            // 1. S^2 (NTT multiplication)
            // S_sq is passed S * S, where S is the same reference, enabling the squaring optimization in mul()
            let S_sq = mul(S, S);

            // 2. S^2 - 2
            let S_minus_2 = sub(S_sq, stringToChunks("2"));

            // 3. Modular Reduction (The core LLT optimization)
            S = LLT_modularReduction(S_minus_2, p);
            
            // 4. Progress Reporting (Throttle)
            if (i % 20 === 0 && i > 0) {
                const currentProgress = Math.floor((i / sequenceLength) * 100);
                if (currentProgress > lastProgress) {
                    self.postMessage({ type: 'progress', progress: currentProgress });
                    lastProgress = currentProgress;
                }
            }
        } catch (error) {
            self.postMessage({ type: 'error', message: "LLT Calculation Error: " + error.message });
            isError = true;
            break;
        }
    }

    if (!isError) {
        // Final result check: S_{p-2} = 0
        const isPrime = isZero(S);

        // Final result
        self.postMessage({ type: 'result', isPrime: isPrime, finalS: chunksToString(S) });
    }
};
`;
// --- END WORKER CODE ---


// --- UI/MAIN THREAD LOGIC ---
const exponentPInput = document.getElementById('exponentP');
const startLLTButton = document.getElementById('startLLTButton');
const stopButton = document.getElementById('stopButton');
const progressBar = document.getElementById('progressBar');
const resultsDiv = document.getElementById('results');
const logOutput = document.getElementById('logOutput');

let lltWorker = null;
let isCalculating = false;

function log(msg) {
  logOutput.textContent += msg + '\n';
  logOutput.scrollTop = logOutput.scrollHeight;
}

function setStatus(t) { resultsDiv.textContent = 'Status: ' + t; }

function setProgress(p) {
  const percent = Math.min(100, Math.max(0, p)).toFixed(2);
  progressBar.style.width = percent + '%';
  progressBar.textContent = percent + '%';
}

function enableControls(enable) {
    isCalculating = !enable;
    startLLTButton.disabled = !enable;
    stopButton.disabled = enable;
}

function stopCalculation() {
    if (lltWorker) {
        lltWorker.terminate();
        lltWorker = null;
        log('--- Calculation Stopped ---');
    }
    enableControls(true);
    if (resultsDiv.textContent.includes('...')) {
         setStatus('Stopped by user.');
    }
}

// Simple deterministic primality test for the small exponent P
function isPrime(n) {
    if (n <= 1) return false;
    if (n <= 3) return true;
    if (n % 2 === 0 || n % 3 === 0) return false;
    for (let i = 5; i * i <= n; i = i + 6) {
        if (n % i === 0 || n % (i + 2) === 0) return false;
    }
    return true;
}

// --- Main NTT-LLT Orchestration ---
async function startNTTLLT() {
    if (isCalculating) return;

    logOutput.textContent = '';
    enableControls(false);

    try {
        const p = parseInt(exponentPInput.value);
        if (isNaN(p) || p <= 0) {
            throw new Error("Invalid exponent P.");
        }
        if (!isPrime(p)) {
             throw new Error(`Exponent P=${p} is not prime. LLT requires a prime exponent.`);
        }
        
        const mp_digits = Math.ceil(p * Math.log10(2));

        setStatus(`Testing M${p} (${mp_digits} digits)...`);
        log(`--- Starting NTT-Accelerated Lucas-Lehmer Test ---`);
        log(`Testing Mersenne Exponent P = ${p}`);
        log(`Mersenne Number M${p} has approximately ${mp_digits} decimal digits.`);

        setProgress(0);
        const startTime = performance.now();

        // Instantiate the worker using a Blob/URI for self-containment
        const workerBlob = new Blob([workerCode], { type: 'application/javascript' });
        lltWorker = new Worker(URL.createObjectURL(workerBlob));

        lltWorker.onmessage = (e) => {
            const data = e.data;
            if (data.type === 'progress') {
                setProgress(data.progress);
            } else if (data.type === 'log') {
                log(data.message);
            } else if (data.type === 'result') {
                const endTime = performance.now();
                const elapsed = (endTime - startTime).toFixed(2);
                log(`\n--- RESULT ---`);
                log(`Total Steps: ${p - 2}`);
                log(`Final S_{p-2} = ${data.isPrime ? '0' : data.finalS.substring(0, 50) + '...'}`);
                log(`Result: M${p} is **${data.isPrime ? 'PRIME' : 'COMPOSITE'}**`);
                log(`Time: ${elapsed} ms`);
                setStatus(`Test Complete in ${elapsed} ms. M${p} is ${data.isPrime ? 'PRIME' : 'COMPOSITE'}.`);
                stopCalculation();
            } else if (data.type === 'error') {
                log(`\n--- ERROR ---`);
                log(`Worker Error: ${data.message}`);
                setStatus('Error Occurred');
                stopCalculation();
            }
        };

        lltWorker.onerror = (e) => {
            log(`\n--- CRITICAL ERROR ---`);
            log(`Worker failed to start: ${e.message}`);
            setStatus('Critical Error');
            stopCalculation();
        };

        // Send the exponent P to the worker
        lltWorker.postMessage({ p });
    } catch (e) {
        log(`\n--- FAILURE ---`);
        log(e.message);
        setStatus('Input Error');
        enableControls(true);
    }
}

// --- Event Listeners ---
window.onload = () => {
    startLLTButton.addEventListener('click', startNTTLLT);
    stopButton.addEventListener('click', stopCalculation);
    log('NTT-LLT Demo Loaded. Use a known prime exponent (e.g., 31 or 127) for verification.');
};
</script>
</body>
</html>

