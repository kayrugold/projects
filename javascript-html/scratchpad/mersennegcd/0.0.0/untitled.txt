<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Karatsuba-Optimized Mersenne Factorizer</title>
<!-- Loads bigInt library for use in asynchronous workers only (Main thread uses native BigInt) -->
<script src="https://unpkg.com/big-integer@1.6.48/BigInteger.min.js"></script>
<script src="https://cdn.tailwindcss.com"></script>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
  body { font-family: 'Inter', sans-serif; background-color: #f8fafc; }
  .container { max-width: 700px; }
  .card { background-color: white; border-radius: 0.75rem; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); padding: 1.5rem; }
  .input-group label { font-weight: 600; margin-bottom: 0.25rem; }
  input[type="number"] { padding: 0.75rem; border: 1px solid #cbd5e1; border-radius: 0.5rem; transition: border-color 0.2s; }
  input[type="number"]:focus { outline: none; border-color: #2563eb; }
  .btn-primary { background-color: #16a34a; }
  .btn-primary:hover:not(:disabled) { background-color: #15803d; }
  .btn-secondary { background-color: #3b82f6; }
  .btn-secondary:hover:not(:disabled) { background-color: #2563eb; }
  .btn-danger { background-color: #ef4444; }
  .btn-danger:hover:not(:disabled) { background-color: #dc2626; }
  button:disabled { background-color: #9ca3af; cursor: not-allowed; }
  #logOutput { min-height: 200px; max-height: 400px; overflow-y: auto; background-color: #e2e8f0; padding: 1rem; border-radius: 0.5rem; font-family: monospace; white-space: pre-wrap; font-size: 0.875rem; }
  .step-card { border-left: 4px solid #3b82f6; padding-left: 1rem; margin-top: 1rem; }
</style>
</head>
<body class="p-4 flex flex-col items-center">

<div class="container card my-8">
  <h2 class="text-2xl font-bold text-center text-blue-800 mb-6">Mersenne Factorization Workflow ($\mathbf{M_p = 2^p - 1}$)</h2>

  <!-- Input Group -->
  <div class="grid grid-cols-2 gap-4 mb-6">
    <div class="input-group flex flex-col">
      <label for="exponentP">Exponent P (e.g., 31 for M31)</label>
      <input type="number" id="exponentP" value="15" min="2" class="w-full">
    </div>
    <div class="input-group flex flex-col">
      <label for="exponentQ">Compare with Exponent Q (e.g., 23 for GCD)</label>
      <input type="number" id="exponentQ" value="7" min="2" class="w-full">
    </div>
  </div>

  <!-- Controls -->
  <div class="flex flex-wrap gap-3 justify-center mb-6">
    <button id="startWorkflowButton" class="btn-primary flex-grow px-6 py-3 rounded-xl font-semibold">Start Full Mersenne Workflow</button>
    <button id="stopButton" class="btn-danger flex-grow px-6 py-3 rounded-xl font-semibold" disabled>Stop</button>
    <button id="multiGCDButton" class="btn-secondary flex-grow px-6 py-3 rounded-xl font-semibold">Run Multi-Mersenne GCD</button>
  </div>

  <!-- Progress and Status -->
  <div id="progressBarContainer" class="w-full bg-gray-200 rounded-full h-3 mb-4 overflow-hidden">
    <div id="progressBar" class="bg-blue-500 h-3 text-xs flex items-center justify-center text-white" style="width: 0%"></div>
  </div>
  <div id="results" class="text-center font-bold text-lg text-gray-700 mb-4">Status: Ready.</div>

  <!-- Log Output -->
  <div class="mt-4">
    <h3 class="text-xl font-semibold text-gray-800 mb-2 border-b pb-1">Workflow Log</h3>
    <pre id="logOutput" class="text-gray-900"></pre>
  </div>
</div>

<script>
// --- UI Element References ---
const exponentPInput = document.getElementById('exponentP');
const exponentQInput = document.getElementById('exponentQ');
const startWorkflowButton = document.getElementById('startWorkflowButton');
const multiGCDButton = document.getElementById('multiGCDButton');
const stopButton = document.getElementById('stopButton');
const progressBar = document.getElementById('progressBar');
const resultsDiv = document.getElementById('results');
const logOutput = document.getElementById('logOutput');

// --- Global State ---
let activeWorker = null;
let isCalculating = false;
const MAX_SYNC_EXPONENT = 1000n; // Threshold for running GCD/LLT in main thread

// --- Utility Functions ---
function log(msg) {
  logOutput.textContent += msg + '\n';
  logOutput.scrollTop = logOutput.scrollHeight;
}

function setStatus(t) { resultsDiv.textContent = 'Status: ' + t; }

function setProgress(p) {
  const percent = Math.min(100, Math.max(0, p)).toFixed(2);
  progressBar.style.width = percent + '%';
  progressBar.textContent = percent + '%';
}

function enableControls(enable) {
    isCalculating = !enable;
    startWorkflowButton.disabled = !enable;
    multiGCDButton.disabled = !enable;
    stopButton.disabled = enable;
}

function stopCalculation() {
    if (activeWorker) {
        activeWorker.terminate();
        activeWorker = null;
        log('[WORKER] Terminated active worker.');
    }
    enableControls(true);
    setStatus('Stopped by user.');
}

/**
 * Calculates the greatest common divisor of two native BigInts using the Euclidean algorithm.
 * @param {bigint} a 
 * @param {bigint} b 
 * @returns {bigint}
 */
function bigIntGCD(a, b) {
    a = a < 0n ? -a : a;
    b = b < 0n ? -b : b;
    while (b) {
        [a, b] = [b, a % b];
    }
    return a;
}


// --- Worker Code Embeddings (Single-File Mandate) ---

// LLT Worker: Specialized modular reduction for M_p
const LLT_WORKER_CODE = 'const self=this; self.importScripts("https://unpkg.com/big-integer@1.6.48/BigInteger.min.js"); function LLT_modularReduction(S_sq, p_bi) { const p = p_bi.toJSNumber(); let remainder = S_sq; const M_p = self.bigInt(2).pow(p).subtract(1); let reductionSteps = 0; const maxReductionSteps = 3; while (remainder.greaterOrEquals(M_p) && reductionSteps < maxReductionSteps) { const high = remainder.shiftRight(p); const low = remainder.and(M_p); remainder = high.add(low); reductionSteps++; } if (remainder.greaterOrEquals(M_p)) { remainder = remainder.subtract(M_p); } return remainder; } self.onmessage = function(e) { const pStr = e.data.p; const p = self.bigInt(pStr); const p_int = p.toJSNumber(); const sequenceLength = p.subtract(2); let S = self.bigInt(4); let lastProgress = 0; for (let i = 0; i < p_int - 2; i++) { let S_sq = S.square(); let S_minus_2 = S_sq.subtract(2); S = LLT_modularReduction(S_minus_2, p); if (i % 25 === 0) { const currentProgress = Math.floor((i / sequenceLength.toJSNumber()) * 100); if (currentProgress > lastProgress) { self.postMessage({ type: "progress", progress: currentProgress }); lastProgress = currentProgress; } } } const isPrime = S.isZero(); self.postMessage({ type: "result", isPrime: isPrime }); };';

// Mod Pow Worker: Used for Trial Division (2^p mod q)
const MOD_POW_WORKER_CODE = 'const self=this; self.importScripts("https://unpkg.com/big-integer@1.6.48/BigInteger.min.js"); function modularExponentiation(base_str, exp_str, mod_str, postMessage) { let base = self.bigInt(base_str); let exp = self.bigInt(exp_str); const mod = self.bigInt(mod_str); let result = self.bigInt.one; base = base.mod(mod); const totalBits = exp_str.length; let processedBits = 0; while (exp.greater(0)) { if (exp.isOdd()) { result = result.multiply(base).mod(mod); } exp = exp.shiftRight(1); base = base.square().mod(mod); processedBits++; if (processedBits % 100 === 0) { const progress = (processedBits / totalBits) * 100; postMessage({ type: "progress", progress: progress }); } } postMessage({ type: "progress", progress: 100 }); return result; } self.onmessage = function(e) { const { expP, modQ } = e.data; try { const result = modularExponentiation("2", expP, modQ, self.postMessage); self.postMessage({ type: "result", result: result.toString() }); } catch (error) { self.postMessage({ type: "error", message: error.message }); } };';

// GCD Worker: Optimized for Multi-Mersenne GCD
const GCD_WORKER_CODE = 'const self=this; self.importScripts("https://unpkg.com/big-integer@1.6.48/BigInteger.min.js"); function gcd(a, b) { let steps = 0; while (b.greater(0)) { [a, b] = [b, a.mod(b)]; steps++; } return { gcd: a.toString(), steps }; } self.onmessage = function(e) { const { expP, expQ } = e.data; try { const p = self.bigInt(expP); const q = self.bigInt(expQ); const expGCD = p.gcd(q); const Mp = self.bigInt(2).pow(p).subtract(1); const Mq = self.bigInt(2).pow(q).subtract(1); const result = gcd(Mp, Mq); self.postMessage({ type: "result", gcd: result.gcd, simplifiedGCD: self.bigInt(2).pow(expGCD).subtract(1).toString() }); } catch (error) { self.postMessage({ type: "error", message: error.message }); } };';

function createWorker(code, onMessage, onError) {
    const blob = new Blob([code], { type: 'application/javascript' });
    const workerUrl = URL.createObjectURL(blob);
    const worker = new Worker(workerUrl);
    worker.onmessage = onMessage;
    worker.onerror = onError;
    activeWorker = worker;
    return worker;
}

// --- Workflow Phases ---

function runLLT(exponentP) {
    return new Promise((resolve, reject) => {
        log(`\n--- Phase 2: Lucas-Lehmer Test for M${exponentP} ---`);
        setStatus(`Running LLT...`);
        setProgress(0);

        const p_val = BigInt(exponentP);
        if (p_val < MAX_SYNC_EXPONENT) {
            log(`(Note: P=${exponentP} is small. Running LLT synchronously on the main thread for reliability.)`);
            // Synchronous LLT using native BigInt (simplified version)
            try {
                let S = 4n;
                const M_p = 2n ** p_val - 1n;
                for (let i = 0n; i < p_val - 2n; i++) {
                    // S = (S^2 - 2) mod M_p
                    S = (S * S - 2n) % M_p;
                    if (i % 10n === 0n) setProgress(Number(i * 100n / (p_val - 2n)));
                }
                const isPrime = S === 0n;
                setProgress(100);
                if (isPrime) {
                    log('✅ LLT Result: M' + exponentP + ' PASSED TEST (Likely Prime).');
                    resolve(true);
                } else {
                    log('❌ LLT Result: M' + exponentP + ' FAILED TEST (Composite).');
                    resolve(false);
                }
            } catch (e) {
                log(`Synchronous LLT failed: ${e.message}`);
                reject('LLT Failed');
            }
        } else {
             // Asynchronous Worker for large exponents
             log(`(Note: P=${exponentP} is large. Running LLT asynchronously in worker.)`);
             const worker = createWorker(LLT_WORKER_CODE, (e) => {
                if (e.data.type === 'progress') {
                    setProgress(e.data.progress);
                } else if (e.data.type === 'result') {
                    activeWorker = null;
                    if (e.data.isPrime) {
                        log('✅ LLT Result: M' + exponentP + ' PASSED TEST (Likely Prime).');
                        resolve(true);
                    } else {
                        log('❌ LLT Result: M' + exponentP + ' FAILED TEST (Composite).');
                        resolve(false);
                    }
                }
            }, (e) => {
                activeWorker = null;
                log(`LLT Worker Error: ${e.message}`);
                reject('LLT Failed');
            });
            worker.postMessage({ p: exponentP.toString() });
        }
    });
}

function runTrialDivision(exponentP) {
    const TRIAL_PRIMES = [3, 5, 7, 11, 13, 17, 19, 23];
    let factorFound = false;

    return new Promise((resolve, reject) => {
        log(`\n--- Phase 1: Small Factor Trial Division for M${exponentP} ---`);
        let completedChecks = 0;

        const checkPrime = (prime) => {
            return new Promise((res, rej) => {
                const worker = createWorker(MOD_POW_WORKER_CODE, (e) => {
                    if (e.data.type === 'progress') {
                        const overallProgress = (completedChecks / TRIAL_PRIMES.length) * 100 + (e.data.progress / TRIAL_PRIMES.length);
                        setProgress(overallProgress);
                    } else if (e.data.type === 'result') {
                        activeWorker = null;
                        completedChecks++;
                        const rem = BigInt(e.data.result);
                        if (rem === 1n) {
                            log(`FACTOR FOUND: ${prime} divides M${exponentP}. (2^${exponentP} mod ${prime} = 1)`);
                            factorFound = true;
                        } else {
                            log(`Check ${prime}: No factor found. Remainder = ${rem}`);
                        }
                        res();
                    }
                }, (e) => {
                    rej(`Trial Division Worker Error: ${e.message}`);
                });
                worker.postMessage({ expP: exponentP.toString(), modQ: prime.toString() });
            });
        };

        (async () => {
            for (const prime of TRIAL_PRIMES) {
                setStatus(`Checking factor ${prime}...`);
                await checkPrime(prime);
            }
            resolve(factorFound);
        })();
    });
}

function runMultiMersenneGCD(expP, expQ) {
    return new Promise((resolve, reject) => {
        log(`\n--- Phase 3: Multi-Mersenne GCD Check: gcd(M${expP}, M${expQ}) ---`);
        setStatus(`Running Multi-Mersenne GCD...`);
        setProgress(0);

        const p = BigInt(expP);
        const q = BigInt(expQ);
        
        // --- FIX: Use native BigInt GCD ---
        const expGCD = bigIntGCD(p, q);
        
        // Always run theoretical check
        const theoreticalGCD = 2n ** expGCD - 1n;
        
        if (p < MAX_SYNC_EXPONENT && q < MAX_SYNC_EXPONENT) {
            log(`(Note: Exponents are small. Running GCD synchronously.)`);
            // Synchronous GCD calculation for small numbers
            try {
                const Mp = 2n ** p - 1n;
                const Mq = 2n ** q - 1n;
                
                // Use the correct native GCD function on the Mersenne numbers
                const actualGCD = bigIntGCD(Mp, Mq);
                
                log('✅ GCD Result: ' + actualGCD.toString());
                log('Theoretical Result: ' + actualGCD.toString() + ` which simplifies to M_{${expGCD}} = ${theoreticalGCD.toString()}`);
                resolve();
            } catch (e) {
                log(`Synchronous GCD failed: ${e.message}`);
                reject('GCD Failed');
            }
        } else {
             // Asynchronous Worker for large numbers
             log(`(Note: At least one exponent is large. Running GCD asynchronously in worker.)`);
             const worker = createWorker(GCD_WORKER_CODE, (e) => {
                if (e.data.type === 'progress') {
                    setProgress(e.data.progress);
                } else if (e.data.type === 'result') {
                    activeWorker = null;
                    const { gcd, simplifiedGCD } = e.data;
                    log('✅ GCD Result: ' + gcd);
                    log(`Theoretical Result: ${gcd} which simplifies to M_{${expGCD}} = ${simplifiedGCD}`);
                    resolve();
                }
            }, (e) => {
                activeWorker = null;
                log(`GCD Worker Error: ${e.message}`);
                reject('GCD Failed');
            });
            worker.postMessage({ expP: expP.toString(), expQ: expQ.toString() });
        }
    });
}

// --- Main Orchestration Function ---
async function startWorkflow() {
    logOutput.textContent = '';
    enableControls(false);

    try {
        const expP = BigInt(exponentPInput.value);
        const expQ = BigInt(exponentQInput.value);

        if (expP < 2n) throw new Error('Exponent P must be > 1.');

        // Step 1: Trial Division Check
        await runTrialDivision(expP);
        
        // Step 2: Lucas-Lehmer Test
        await runLLT(expP);

        // Step 3: Multi-Mersenne GCD Check
        if (expQ > 1n) {
             await runMultiMersenneGCD(expP, expQ);
        } else {
             log('\nSkipping Multi-Mersenne GCD (Exponent Q not set).');
        }
        
        setStatus('Workflow Complete.');

    } catch (e) {
        log('--- CRITICAL FAILURE ---');
        log(e.message || e.toString());
        setStatus('Failed');
    } finally {
        enableControls(true);
        setProgress(100);
    }
}

// --- Event Listeners ---
window.onload = () => {
    startWorkflowButton.addEventListener('click', startWorkflow);
    stopButton.addEventListener('click', stopCalculation);
    multiGCDButton.addEventListener('click', () => {
        logOutput.textContent = '';
        enableControls(false);
        const expP = BigInt(exponentPInput.value);
        const expQ = BigInt(exponentQInput.value);
        if (expP < 2n || expQ < 2n) {
            log('Exponents must be > 1.');
            enableControls(true);
            return;
        }
        runMultiMersenneGCD(expP, expQ)
            .catch(e => {
                log('GCD FAILED: ' + e.message);
                setStatus('GCD Failed');
            })
            .finally(() => {
                enableControls(true);
                setProgress(100);
            });
    });
    
    log('System initialized. Workflow stages are ready, with small exponent optimizations for reliability.');
};
</script>
</body>
</html>

