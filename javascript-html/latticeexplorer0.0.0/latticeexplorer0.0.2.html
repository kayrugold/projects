<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lattice & Modulus Explorer</title>
    <!-- Using big-integer.min.js -->
    <script src="https://unpkg.com/big-integer@1.6.48/BigInteger.min.js"></script>
    <!-- Using Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Simple Inter font stack */
        body {
            font-family: "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            overscroll-behavior: none; /* Prevents pull-to-refresh */
            overflow: hidden; /* Prevent body scroll */
        }

        #appContainer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #fff; /* Set background here */
        }

        /* Canvas for drawing, sits on top */
        #latticeCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: transparent; /* Make canvas transparent */
            z-index: 2; /* Canvas is above prime grid */
            cursor: grab;
            touch-action: none; /* Prevent browser touch actions */
        }
        #latticeCanvas:active {
            cursor: grabbing;
        }

        /* Controls panel, sits on top of everything */
        #controls {
            position: fixed;
            top: 1rem;
            left: 1rem;
            background-color: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            border-radius: 0.5rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            padding: 1rem;
            z-index: 10;
            max-width: calc(100vw - 2rem);
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            transition: all 0.3s ease-in-out;
        }
        /* Wrapper for collapsible content */
        #controlsContent {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            overflow-y: auto; /* Allow content to scroll */
            transition: max-height 0.3s ease-in-out, opacity 0.3s ease-in-out, padding 0.3s ease-in-out; 
            max-height: 80vh; /* Set a max-height for transition */
        }
        
        /* Collapsed state */
        #controls.collapsed {
            width: auto; /* Shrink to fit title bar */
            max-width: none; 
            gap: 0;
        }
        #controls.collapsed #controlsContent {
           max-height: 0;
           padding: 0; /* Hide padding */
           margin: 0; /* Hide gap */
           opacity: 0;
           overflow: hidden;
        }
        #toggleControls {
            transition: transform 0.3s ease;
        }
        #controls.collapsed #toggleControls {
            transform: rotate(-180deg); /* Flip arrow */
        }

        /* Coordinate Display */
        #coordDisplay {
            position: fixed;
            bottom: 1rem;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.75);
            color: white;
            padding: 0.25rem 0.75rem;
            border-radius: 0.25rem;
            font-family: monospace;
            z-index: 10;
            display: none; /* Hidden by default */
            pointer-events: none; /* Won't block clicks */
        }

        /* Styling for the list of plotted layers */
        #layerListContainer .layer-item {
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 0.25rem 0.75rem;
            align-items: center;
            padding: 0.5rem;
            border-radius: 0.25rem;
            background-color: rgba(0, 0, 0, 0.02);
            border: 1px solid rgba(0, 0, 0, 0.05);
        }

        /* Number/Info and factors */
        #layerListContainer .layer-info {
            grid-column: 1;
            grid-row: 1;
            font-weight: 600;
        }
        #layerListContainer .layer-sub-info {
            grid-column: 1;
            grid-row: 2;
            font-size: 0.75rem;
            color: #555;
            word-break: break-all;
        }
        /* Controls for visibility, offsets, and removal */
        #layerListContainer .layer-controls {
            grid-column: 1 / span 2;
            grid-row: 3;
            display: flex;
            gap: 0.75rem;
            align-items: center;
            flex-wrap: wrap;
            margin-top: 0.5rem;
        }
        /* Toggles for line types */
        #layerListContainer .layer-toggles {
            grid-column: 1 / span 2;
            grid-row: 4; /* Place on a new row */
            display: flex;
            gap: 0.75rem;
            align-items: center;
            flex-wrap: wrap;
            margin-top: 0.5rem;
        }
        #layerListContainer label, #globalToggles label { /* General label styling */
            font-size: 0.875rem;
            color: #333;
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }
        #layerListContainer .layer-controls input[type="number"] {
            width: 4rem;
            font-size: 0.875rem;
        }
        /* Style for color input */
        #layerListContainer .layer-controls input[type="color"] {
            width: 1.5rem;
            height: 1.5rem;
            padding: 0;
            border: 1px solid rgba(0,0,0,0.1);
            border-radius: 0.25rem;
            cursor: pointer;
        }
        #layerListContainer .remove-btn {
            grid-column: 2;
            grid-row: 1 / span 2;
            background: none;
            border: none;
            color: #999;
            font-weight: bold;
            cursor: pointer;
            align-self: center;
        }
        #layerListContainer .remove-btn:hover {
            color: #000;
        }
        /* Style for input groups */
        .input-group-separator {
             border-top: 1px solid #e5e7eb;
             padding-top: 0.75rem;
             margin-top: 0.75rem;
        }
        .sequence-group .flex label {
            white-space: nowrap; /* Prevent label wrapping */
        }
         /* Style for global toggles */
        #globalToggles {
            display: flex;
            gap: 0.75rem;
            flex-wrap: wrap;
            align-items: center;
        }

        /* Modulus/Auxiliary Plotter Styles */
        #modulusInputGroup {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        #modulusInputGroup input[type="number"] {
            width: 4.5rem;
            text-align: center;
        }
        #modulusInputGroup button {
            width: 2.25rem;
            font-size: 1.25rem;
            font-weight: bold;
            padding: 0;
        }
    </style>
</head>
<body class="bg-white">

    <!-- App container -->
    <div id="appContainer">
        <!-- Canvas for drawing -->
        <canvas id="latticeCanvas"></canvas>
    </div>

    <!-- UI Controls -->
    <div id="controls" class="w-full max-w-md">
        <div class="flex justify-between items-center">
            <h1 class="text-xl font-bold text-gray-800">Lattice & Modulus Explorer</h1>
            <button id="toggleControls" class="p-1 rounded-md hover:bg-gray-200 focus:outline-none focus:ring-2 focus:ring-gray-400">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
            </button>
        </div>

        <div id="controlsContent">
            <!-- Input section (LATTICE PLOTTER) -->
            <div class="flex gap-2">
                <input type="text" id="numberInput" value="1007" class="flex-grow w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="Enter a number (e.g., 1007)">
                <button id="plotButton" class="px-4 py-2 font-semibold text-white bg-blue-600 rounded-md shadow-sm hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-75">
                    Plot
                </button>
                <button id="clearButton" class="px-4 py-2 font-semibold text-gray-700 bg-gray-200 rounded-md shadow-sm hover:bg-gray-300 focus:outline-none focus:ring-2 focus:ring-gray-400">
                    Clear
                </button>
            </div>
            <p class="text-xs text-gray-500">Use Arrow Up/Down in box to inc/dec and plot.</p>

            <!-- Sequence Plotting Section -->
            <div class="sequence-group input-group-separator">
                <p class="text-sm font-medium text-gray-700 mb-2">Plot Sequence</p>
                <div class="flex gap-2 items-end">
                    <label class="flex flex-col">
                        <span class="text-xs text-gray-500">Start</span>
                        <input type="text" id="sequenceStartInput" value="7" class="w-20 px-3 py-1 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
                    </label>
                    <label class="flex flex-col">
                         <span class="text-xs text-gray-500">End</span>
                        <input type="text" id="sequenceEndInput" value="197" class="w-20 px-3 py-1 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
                    </label>
                    <button id="plotSequenceButton" class="px-4 py-1 h-fit font-semibold text-white bg-green-600 rounded-md shadow-sm hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-opacity-75">
                        Plot Sequence
                    </button>
                </div>
            </div>

            <!-- AUXILIARY PLOTTING SECTION (Modulus Only) -->
            <div class="modulus-group input-group-separator">
                <p class="text-sm font-medium text-gray-700 mb-2">Modulus Layer Controls</p>
                
                <div class="flex flex-col gap-2">
                    <div id="modulusInputGroup">
                        <label class="text-sm font-medium text-gray-700">Modulus (N):</label>
                        <button id="modulusDownButton" class="px-2 py-1 font-semibold text-gray-700 bg-gray-200 rounded-md shadow-sm hover:bg-gray-300">-</button>
                        <input type="number" id="modulusInput" value="12" min="2" class="flex-grow px-3 py-1 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
                        <button id="modulusUpButton" class="px-2 py-1 font-semibold text-gray-700 bg-gray-200 rounded-md shadow-sm hover:bg-gray-300">+</button>
                    </div>
                    <div class="flex gap-4">
                         <label class="flex items-center gap-1">
                            <span class="text-xs text-gray-500">Operation:</span>
                            <select id="modulusOperationSelect" class="text-xs rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
                                <option value="multiply">(x * y) % N</option>
                                <option value="add">(x + y) % N</option>
                                <option value="quadratic_x">(x^2) % N</option>
                                <option value="quadratic_y">(y^2) % N</option>
                            </select>
                        </label>
                         <label class="flex items-center gap-1">
                            <span class="text-xs text-gray-500">Color:</span>
                            <select id="modulusColorSelect" class="text-xs rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
                                <option value="grayscale">Grayscale</option>
                                <option value="hue">Color (Hue)</option>
                            </select>
                        </label>
                    </div>
                    <button id="plotModulusButton" class="mt-1 px-4 py-1 font-semibold text-white bg-purple-600 rounded-md shadow-sm hover:bg-purple-700 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-opacity-75">
                        Plot Modulus
                    </button>
                </div>
            </div>


            <!-- Global Toggles Section -->
            <div class="global-toggles input-group-separator">
                 <p class="text-sm font-medium text-gray-700 mb-2">Global Toggles (For Lattices)</p>
                 <div id="globalToggles">
                     <label>
                         <input type="checkbox" class="global-toggle-input" data-type="core" checked>
                         Core
                     </label>
                     <label>
                         <input type="checkbox" class="global-toggle-input" data-type="factors" checked>
                         Factors
                     </label>
                     <label>
                         <input type="checkbox" class="global-toggle-input" data-type="diamonds" checked>
                         Diamonds
                     </label>
                     <label>
                         <input type="checkbox" class="global-toggle-input" data-type="parabolas" checked>
                         Parabolas
                     </label>
                     <label>
                         <input type="checkbox" class="global-toggle-input" data-type="intersections" checked>
                         Dots
                     </label>
                 </div>
            </div>

            <!-- Container for plotted layers (lattices and modulus grids) -->
            <div id="layerListContainer" class="flex flex-col gap-3 input-group-separator"></div>
        </div>
    </div>

    <!-- Coordinate Display -->
    <div id="coordDisplay"></div>

    <script>
        // --- 1. WORKER CODE (as a string to create a Blob) ---
        const workerCode = `
        function customSqrt(n) {
            if (n.isNegative()) throw new Error("Cannot sqrt negative number");
            if (n.lt(2)) return n;
            let x = n.shiftRight(1);
            if (x.isZero()) return n;
            let y;
            while (true) {
                y = x.add(n.divide(x)).shiftRight(1);
                if (y.geq(x)) {
                    return x;
                }
                x = y;
            }
        }
        function getAllDivisors(factors) {
            const factorCounts = new Map();
            for (const factor of factors) {
                const fStr = factor.toString();
                factorCounts.set(fStr, (factorCounts.get(fStr) || 0) + 1);
            }
            let divisorsList = [self.bigInt(1)];
            for(const [fStr, count] of factorCounts.entries()) {
                const factor = self.bigInt(fStr);
                const currentSize = divisorsList.length;
                for (let i = 0; i < currentSize; i++) {
                    let d = divisorsList[i];
                    for (let j = 0; j < count; j++) {
                        d = d.multiply(factor);
                        divisorsList.push(d);
                    }
                }
            }
            // Returns BigInts
            return Array.from(new Set(divisorsList.map(d => d.toString()))).map(s => self.bigInt(s)).sort((a, b) => a.compareTo(b));
        }
        function getPrimeFactors(n) {
            const factors = [];
            let currentN = self.bigInt(n);
            while (currentN.isEven()) {
                factors.push(self.bigInt(2));
                currentN = currentN.divide(2);
            }
            let limit = customSqrt(currentN);
            for (let i = self.bigInt(3); i.leq(limit); i = i.add(2)) {
                while (currentN.mod(i).isZero()) {
                    factors.push(i);
                    currentN = currentN.divide(i);
                    limit = customSqrt(currentN); // Re-calculate limit
                }
            }
            if (currentN.gt(1)) {
                factors.push(currentN);
            }
            return factors;
        }
        function getFactorPairs(n, primeFactors) {
            const divisors = getAllDivisors(primeFactors);
            const pairs = [];
            const limit = customSqrt(n);
            for (const d of divisors) {
                if (d.gt(limit)) {
                    break;
                }
                if (n.mod(d).isZero()) {
                    pairs.push([d, n.divide(d)]);
                }
            }
            return pairs;
        }

        self.onmessage = function(e) {
            self.importScripts('https://unpkg.com/big-integer@1.6.48/BigInteger.min.js');
            const numStr = e.data.number;
            const n = self.bigInt(numStr);
            try {
                const primeFactors = getPrimeFactors(n);
                const factorPairs = getFactorPairs(n, primeFactors);

                self.postMessage({
                    number: numStr,
                    primeFactors: primeFactors.map(f => f.toString()),
                    factorPairs: factorPairs.map(p => [p[0].toString(), p[1].toString()])
                });
            } catch (err) {
                // Return an error object if factoring fails
                self.postMessage({ number: numStr, error: err.message });
            }
        };
        `;

        // --- 2. GLOBAL STATE & UI ELEMENTS ---
        const canvas = document.getElementById('latticeCanvas');
        const ctx = canvas.getContext('2d');

        const numberInput = document.getElementById('numberInput');
        const plotButton = document.getElementById('plotButton');
        const clearButton = document.getElementById('clearButton');
        const layerListContainer = document.getElementById('layerListContainer');
        const coordDisplay = document.getElementById('coordDisplay');
        const sequenceStartInput = document.getElementById('sequenceStartInput');
        const sequenceEndInput = document.getElementById('sequenceEndInput');
        const plotSequenceButton = document.getElementById('plotSequenceButton');
        const globalTogglesContainer = document.getElementById('globalToggles');
        
        // Modulus UI
        const modulusInput = document.getElementById('modulusInput');
        const modulusDownButton = document.getElementById('modulusDownButton');
        const modulusUpButton = document.getElementById('modulusUpButton');
        const modulusOperationSelect = document.getElementById('modulusOperationSelect');
        const modulusColorSelect = document.getElementById('modulusColorSelect');
        const plotModulusButton = document.getElementById('plotModulusButton');
        
        const layers = new Map(); // Unified map for all layer types
        let transform = { x: 0, y: 0, scale: 1 };
        let isPanning = false;
        let lastPanPoint = { x: 0, y: 0 };
        let hoveredInfo = null;
        let needsRedraw = true;
        const colors = ['#E63946', '#457B9D', '#31a354', '#754F8E', '#F4A261', '#2A9D8F', '#E76F51', '#6A040F'];
        let worker;
        let isPlottingSequence = false;
        let layerCounter = 0; // To give unique IDs to layers

        // Map for operation display names
        const opDisplayNames = {
            'multiply': '(x * y) % N',
            'add': '(x + y) % N',
            'quadratic_x': '(x^2) % N',
            'quadratic_y': '(y^2) % N'
        };

        // --- 3. HELPER FUNCTIONS (Main Thread) ---

        // HSL to RGB for modulus colors
        function hslToRgb(h, s, l) {
            let r, g, b;
            if (s == 0) {
                r = g = b = l; // achromatic
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1 / 6) return p + (q - p) * 6 * t;
                    if (t < 1 / 2) return q;
                    if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
                    return p;
                };
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1 / 3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1 / 3);
            }
            return `rgb(${Math.round(r * 255)}, ${Math.round(g * 255)}, ${Math.round(b * 255)})`;
        }

        function getViewBounds() {
            const minX = (0 - transform.x) / transform.scale;
            const maxX = (canvas.width - transform.x) / transform.scale;
            const minY = (0 - transform.y) / transform.scale;
            const maxY = (canvas.height - transform.y) / transform.scale;
            return { minX, maxX, minY, maxY };
        }

        function worldToScreen(x, y) {
            return {
                x: x * transform.scale + transform.x,
                y: y * transform.scale + transform.y
            };
        }

        function screenToWorld(x, y) {
            return {
                x: (x - transform.x) / transform.scale,
                y: (y - transform.y) / transform.scale
            };
        }

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            if (transform.x === 0 && transform.y === 0) {
                transform.x = canvas.width / 2;
                transform.y = canvas.height / 2;
            }
            needsRedraw = true;
        }

        // --- 3a. LATTICE CALCULATION & DRAWING HELPERS (MOVED FOR SCOPING FIX) ---

        /**
         * Generates categorized equations for a lattice.
         * @returns {object} - { core: [], factors: [], diamonds: [], parabolas: [] }
         */
        function generateLatticeEquations(lattice) {
            const { number, factorPairs } = lattice;
            const N = Number(number.toString());
            const eqs = { core: [], factors: [], diamonds: [], parabolas: [] };

            // Core
            eqs.core.push({ type: 'line', m: 1, c: 0, label: 'y = x' });
            eqs.core.push({ type: 'line', m: -1, c: 0, label: 'y = -x' });
            eqs.core.push({ type: 'hyperbola', N: N, label: `xy = ${N}` });
            eqs.core.push({ type: 'hyperbola', N: -N, label: `xy = -${N}` });

            // Parabolas
            eqs.parabolas.push({ type: 'parabola', form: 'y=x^2-N', N: N, label: `y = x^2 - ${N}` });
            eqs.parabolas.push({ type: 'parabola', form: 'y=N-x^2', N: N, label: `y = ${N} - x^2` });
            eqs.parabolas.push({ type: 'parabola', form: 'x=y^2-N', N: N, label: `x = y^2 - ${N}` });
            eqs.parabolas.push({ type: 'parabola', form: 'x=N-y^2', N: N, label: `x = ${N} - y^2` });

            // Factors & Diamonds
            for (const [pStr, qStr] of factorPairs) {
                const p = Number(pStr); const q = Number(qStr);
                eqs.factors.push({ type: 'vline', x: p, label: `x = ${p}` });
                eqs.factors.push({ type: 'vline', x: -p, label: `x = -${p}` });
                eqs.factors.push({ type: 'hline', y: p, label: `y = ${p}` });
                eqs.factors.push({ type: 'hline', y: -p, label: `y = -${p}` });
                
                const p_plus_q = p + q; const q_minus_p = q - p;
                eqs.diamonds.push({ type: 'line', m: 1, c: p_plus_q, label: `y = x + ${p_plus_q}` });
                eqs.diamonds.push({ type: 'line', m: 1, c: -p_plus_q, label: `y = x - ${p_plus_q}` });
                eqs.diamonds.push({ type: 'line', m: -1, c: p_plus_q, label: `y = -x + ${p_plus_q}` });
                eqs.diamonds.push({ type: 'line', m: -1, c: -p_plus_q, label: `y = -x - ${p_plus_q}` });
                
                if (p !== q) {
                    eqs.factors.push({ type: 'vline', x: q, label: `x = ${q}` });
                    eqs.factors.push({ type: 'vline', x: -q, label: `x = -${q}` });
                    eqs.factors.push({ type: 'hline', y: q, label: `y = ${q}` });
                    eqs.factors.push({ type: 'hline', y: -q, label: `y = -${q}` });

                    eqs.diamonds.push({ type: 'line', m: 1, c: q_minus_p, label: `y = x + ${q_minus_p}` });
                    eqs.diamonds.push({ type: 'line', m: 1, c: -q_minus_p, label: `y = x - ${q_minus_p}` });
                    eqs.diamonds.push({ type: 'line', m: -1, c: q_minus_p, label: `y = -x + ${q_minus_p}` });
                    eqs.diamonds.push({ type: 'line', m: -1, c: -q_minus_p, label: `y = -x - ${q_minus_p}` });
                }
            }
            return eqs;
        }

        function generateLatticeIntersections(lattice) {
            const { factorPairs } = lattice;
            const points = new Set();
            for (const [pStr, qStr] of factorPairs) {
                const p = Number(pStr); const q = Number(qStr);
                // Store only the first-quadrant points
                points.add(JSON.stringify({x: p, y: q}));
                if (p !== q) points.add(JSON.stringify({x: q, y: p}));
            }
            return Array.from(points).map(s => JSON.parse(s));
        }

        // --- 4. DRAWING FUNCTIONS ---

        // --- 4a. Specific Drawing Helpers (MOVED FOR SCOPING FIX) ---
        function drawLine(m, c, bounds) {
            const y1 = m * bounds.minX + c;
            const y2 = m * bounds.maxX + c;
            ctx.beginPath(); ctx.moveTo(bounds.minX, y1); ctx.lineTo(bounds.maxX, y2); ctx.stroke();
        }
        function drawVerticalLine(x, bounds) {
            ctx.beginPath(); ctx.moveTo(x, bounds.minY); ctx.lineTo(x, bounds.maxY); ctx.stroke();
        }
        function drawHorizontalLine(y, bounds) {
            ctx.beginPath(); ctx.moveTo(bounds.minX, y); ctx.lineTo(bounds.maxX, y); ctx.stroke();
        }
        function drawHyperbola(N, bounds) {
            if (N === 0) return;
            const step = (bounds.maxX - bounds.minX) / 1000;
            ctx.beginPath();
            let first = true;
            for (let x = Math.max(step, bounds.minX); x <= bounds.maxX; x += step) {
                const y = N / x;
                if (y < bounds.minY || y > bounds.maxY) { first = true; continue; }
                if (first) { ctx.moveTo(x, y); first = false; }
                else { ctx.lineTo(x, y); }
            }
            ctx.stroke();
            ctx.beginPath();
            first = true;
            for (let x = Math.min(-step, bounds.maxX); x >= bounds.minX; x -= step) {
                const y = N / x;
                if (y < bounds.minY || y > bounds.maxY) { first = true; continue; }
                if (first) { ctx.moveTo(x, y); first = false; }
                else { ctx.lineTo(x, y); }
            }
            ctx.stroke();
        }
        function drawParabola(form, N, bounds) {
            const step = (bounds.maxX - bounds.minX) / 1000;
            ctx.beginPath();
            let first = true;
            if (form === 'y=x^2-N' || form === 'y=N-x^2') {
                for (let x = bounds.minX; x <= bounds.maxX; x += step) {
                    const y = (form === 'y=x^2-N') ? (x * x - N) : (N - x * x);
                    if (y < bounds.minY || y > bounds.maxY) { first = true; continue; }
                    if (first) { ctx.moveTo(x, y); first = false; }
                    else { ctx.lineTo(x, y); }
                }
            } else { // x = y^2 - N or x = N - y^2
                for (let y = bounds.minY; y <= bounds.maxY; y += step) {
                    const x = (form === 'x=y^2-N') ? (y * y - N) : (N - y * y);
                    if (x < bounds.minY || x > bounds.maxX) { first = true; continue; }
                    if (first) { ctx.moveTo(x, y); first = false; }
                    else { ctx.lineTo(x, y); }
                }
            }
            ctx.stroke();
        }


        function drawLoop() {
            if (needsRedraw) {
                needsRedraw = false;
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                ctx.save();
                ctx.translate(transform.x, transform.y);
                ctx.scale(transform.scale, transform.scale);

                const bounds = getViewBounds();
                
                // Draw layers in order. Modulus layers behind lattices.
                for (const layer of layers.values()) {
                    if (layer.visible && layer.type === 'modulus') {
                        drawModulusLayer(layer, bounds);
                    }
                }
                
                drawGrid(bounds);
                drawOriginAxes(bounds);

                for (const layer of layers.values()) {
                    if (layer.visible && layer.type === 'lattice') {
                        drawLattice(layer, bounds);
                    }
                }
                
                ctx.restore();

                // Draw highlighted snap point on top, in screen space
                if (hoveredInfo) {
                    coordDisplay.style.display = 'block';
                    
                    // Format the coordinates to 2 decimal places
                    const xStr = hoveredInfo.x.toFixed(2);
                    const yStr = hoveredInfo.y.toFixed(2);
                    // Combine coordinates and the label
                    coordDisplay.textContent = `(${xStr}, ${yStr}) ${hoveredInfo.label}`;
                    
                    const screenPos = worldToScreen(hoveredInfo.x, hoveredInfo.y);
                    ctx.fillStyle = '#333';
                    ctx.beginPath();
                    // Draw a 5px radius dot in screen space
                    ctx.arc(screenPos.x, screenPos.y, 5, 0, Math.PI * 2); 
                    ctx.fill();
                } else {
                    coordDisplay.style.display = 'none';
                }
            }
            requestAnimationFrame(drawLoop);
        }

        function drawGrid(bounds) {
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1 / transform.scale;
            const baseGridSize = 100;
            let gridSize = baseGridSize;
            while (gridSize * transform.scale < 50) gridSize *= 5;
            while (gridSize * transform.scale > 150) gridSize /= 5;
            const startX = Math.floor(bounds.minX / gridSize) * gridSize;
            const endX = Math.ceil(bounds.maxX / gridSize) * gridSize;
            const startY = Math.floor(bounds.minY / gridSize) * gridSize;
            const endY = Math.ceil(bounds.maxY / gridSize) * gridSize;
            ctx.beginPath();
            for (let x = startX; x <= endX; x += gridSize) {
                ctx.moveTo(x, startY);
                ctx.lineTo(x, endY);
            }
            for (let y = startY; y <= endY; y += gridSize) {
                ctx.moveTo(startX, y);
                ctx.lineTo(endX, y);
            }
            ctx.stroke();
        }

        function drawOriginAxes(bounds) {
            ctx.strokeStyle = '#333333';
            ctx.lineWidth = 2 / transform.scale;
            ctx.beginPath();
            ctx.moveTo(bounds.minX, 0); ctx.lineTo(bounds.maxX, 0);
            ctx.moveTo(0, bounds.minY); ctx.lineTo(0, bounds.maxY);
            ctx.stroke();
        }

        /**
         * Draws all components for a single lattice layer.
         */
        function drawLattice(lattice, bounds) {
            const { color, originOffset, equations, intersections, toggles } = lattice;

            ctx.save();
            ctx.strokeStyle = color;
            ctx.lineWidth = 2 / transform.scale;
            ctx.translate(originOffset.x, originOffset.y);

            const offsetBounds = {
                minX: bounds.minX - originOffset.x,
                maxX: bounds.maxX - originOffset.x,
                minY: bounds.minY - originOffset.y,
                maxY: bounds.maxY - originOffset.y
            };

            // Conditionally draw each equation category
            const drawEqs = (eqs) => {
                if (!eqs) return;
                for (const eq of eqs) {
                    switch (eq.type) {
                        case 'line': drawLine(eq.m, eq.c, offsetBounds); break;
                        case 'vline': drawVerticalLine(eq.x, offsetBounds); break;
                        case 'hline': drawHorizontalLine(eq.y, offsetBounds); break;
                        case 'hyperbola': drawHyperbola(eq.N, offsetBounds); break;
                        case 'parabola': drawParabola(eq.form, eq.N, offsetBounds); break;
                    }
                }
            };

            if (toggles.core) drawEqs(equations.core);
            if (toggles.factors) drawEqs(equations.factors);
            if (toggles.diamonds) drawEqs(equations.diamonds);
            if (toggles.parabolas) drawEqs(equations.parabolas);

            // Conditionally draw intersection dots
            if (toggles.intersections) {
                ctx.fillStyle = color; // Use lattice color for dots
                ctx.globalAlpha = 0.7; // Make them slightly transparent
                const dotRadius = 4 / transform.scale;
                for (const point of intersections) {
                    // Draw dots in all 4 quadrants
                    ctx.beginPath(); ctx.arc(point.x, point.y, dotRadius, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(-point.x, point.y, dotRadius, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(point.x, -point.y, dotRadius, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(-point.x, -point.y, dotRadius, 0, Math.PI * 2); ctx.fill();
                }
                ctx.globalAlpha = 1.0;
            }

            ctx.restore();
        }

        /**
         * Draws a modulus grid layer, centered on the integer coordinates.
         */
        function drawModulusLayer(layer, bounds) {
            const { modulus, operation, colorMode, originOffset, opacity } = layer;

            const worldCellSize = 1;
            const screenCellSize = worldCellSize * transform.scale;
            if (screenCellSize < 3) return; // Don't draw if cells are too small
            
            ctx.save();
            ctx.translate(originOffset.x, originOffset.y);
            ctx.globalAlpha = opacity;

            // Offset bounds by 0.5 to correctly catch centers
            const startCol = Math.floor(bounds.minX - originOffset.x - 0.5);
            const endCol = Math.ceil(bounds.maxX - originOffset.x + 0.5);
            const startRow = Math.floor(bounds.minY - originOffset.y - 0.5);
            const endRow = Math.ceil(bounds.maxY - originOffset.y + 0.5);

            // Limit drawing to a reasonable number of cells
            if ((endCol - startCol) > 500 || (endRow - startRow) > 500) {
                 if (screenCellSize < 10) { // Only draw at reasonable zoom
                    ctx.restore();
                    return; 
                 }
            }
            
            const fontThreshold = 20; // Increased threshold for text
            const canDrawText = screenCellSize > fontThreshold;
            
            // Set text alignment properties once
            if (canDrawText) {
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
            }

            for (let x = startCol; x <= endCol; x++) {
                for (let y = startRow; y <= endRow; y++) {
                    let value;
                    const c = Math.floor(x);
                    const r = Math.floor(y);

                    if (operation === 'multiply') {
                        value = (r * c) % modulus;
                    } else if (operation === 'add') {
                        value = (r + c) % modulus;
                    } else if (operation === 'quadratic_x') {
                        value = (c * c) % modulus;
                    } else if (operation === 'quadratic_y') {
                        value = (r * r) % modulus;
                    }

                    if (value < 0) value += modulus;
                    
                    let color;
                    if (colorMode === 'grayscale') {
                        const brightness = (modulus === 1) ? 0 : 1 - (value / (modulus - 1));
                        const gray = Math.floor(255 * brightness);
                        color = `rgb(${gray}, ${gray}, ${gray})`;
                    } else { // hue
                        const hue = value / modulus;
                        color = hslToRgb(hue, 0.8, 0.6);
                    }
                    
                    ctx.fillStyle = color;
                    // Draw rect centered at (x, y)
                    ctx.fillRect(x - 0.5, y - 0.5, 1, 1);

                    if (canDrawText) {
                        const brightness = (modulus === 1) ? 0 : (value / (modulus - 1));
                        ctx.fillStyle = brightness > 0.5 ? '#000000' : '#FFFFFF';
                        if (colorMode === 'hue') ctx.fillStyle = brightness > 0.6 ? '#222' : '#FFF';
                        
                        ctx.save();
                        ctx.translate(x, y);
                        ctx.scale(1 / transform.scale, 1 / transform.scale);
                        
                        const scaledFontSize = 0.5 * transform.scale; 
                        ctx.font = `${scaledFontSize}px Inter`;
                        if(scaledFontSize > 5) {
                           ctx.fillText(value, 0, 0);
                        }
                        ctx.restore();
                    }
                }
            }

            ctx.restore();
        }

        // --- 4a. Specific Drawing Helpers ---
        function drawLine(m, c, bounds) {
            const y1 = m * bounds.minX + c;
            const y2 = m * bounds.maxX + c;
            ctx.beginPath(); ctx.moveTo(bounds.minX, y1); ctx.lineTo(bounds.maxX, y2); ctx.stroke();
        }
        function drawVerticalLine(x, bounds) {
            ctx.beginPath(); ctx.moveTo(x, bounds.minY); ctx.lineTo(x, bounds.maxY); ctx.stroke();
        }
        function drawHorizontalLine(y, bounds) {
            ctx.beginPath(); ctx.moveTo(bounds.minX, y); ctx.lineTo(bounds.maxX, y); ctx.stroke();
        }
        function drawHyperbola(N, bounds) {
            if (N === 0) return;
            const step = (bounds.maxX - bounds.minX) / 1000;
            ctx.beginPath();
            let first = true;
            for (let x = Math.max(step, bounds.minX); x <= bounds.maxX; x += step) {
                const y = N / x;
                if (y < bounds.minY || y > bounds.maxY) { first = true; continue; }
                if (first) { ctx.moveTo(x, y); first = false; }
                else { ctx.lineTo(x, y); }
            }
            ctx.stroke();
            ctx.beginPath();
            first = true;
            for (let x = Math.min(-step, bounds.maxX); x >= bounds.minX; x -= step) {
                const y = N / x;
                if (y < bounds.minY || y > bounds.maxY) { first = true; continue; }
                if (first) { ctx.moveTo(x, y); first = false; }
                else { ctx.lineTo(x, y); }
            }
            ctx.stroke();
        }
        function drawParabola(form, N, bounds) {
            const step = (bounds.maxX - bounds.minX) / 1000;
            ctx.beginPath();
            let first = true;
            if (form === 'y=x^2-N' || form === 'y=N-x^2') {
                for (let x = bounds.minX; x <= bounds.maxX; x += step) {
                    const y = (form === 'y=x^2-N') ? (x * x - N) : (N - x * x);
                    if (y < bounds.minY || y > bounds.maxY) { first = true; continue; }
                    if (first) { ctx.moveTo(x, y); first = false; }
                    else { ctx.lineTo(x, y); }
                }
            } else { // x = y^2 - N or x = N - y^2
                for (let y = bounds.minY; y <= bounds.maxY; y += step) {
                    const x = (form === 'x=y^2-N') ? (y * y - N) : (N - y * y);
                    if (x < bounds.minY || x > bounds.maxX) { first = true; continue; }
                    if (first) { ctx.moveTo(x, y); first = false; }
                    else { ctx.lineTo(x, y); }
                }
            }
            ctx.stroke();
        }

        // --- 5. UI & STATE MANAGEMENT ---

        function requestLatticeData(numStr) {
             const existing = Array.from(layers.values()).find(l => l.type === 'lattice' && l.number.toString() === numStr);
             if (existing) {
                existing.visible = true;
                updateLayerListUI();
                needsRedraw = true;
                return;
            }
            worker.postMessage({ number: numStr });
        }

        function plotSingleNumber() {
            const numStr = numberInput.value.trim();
            if (!numStr) return;
            try {
                bigInt(numStr); // Validate input
                requestLatticeData(numStr);
            } catch (e) {
                alert("Invalid number format.");
            }
        }

        async function plotSequence() {
            if (isPlottingSequence) return;
            let startNum, endNum;
            try {
                startNum = bigInt(sequenceStartInput.value.trim());
                endNum = bigInt(sequenceEndInput.value.trim());
            } catch (e) {
                alert("Invalid start or end number for sequence.");
                return;
            }
            if (startNum.gt(endNum)) {
                alert("Start number must be less than or equal to end number.");
                return;
            }

            isPlottingSequence = true;
            plotSequenceButton.disabled = true;
            plotSequenceButton.textContent = "Plotting...";

            for (let currentNum = startNum; currentNum.leq(endNum); currentNum = currentNum.add(1)) {
                 const numStr = currentNum.toString();
                 const existing = Array.from(layers.values()).find(l => l.type === 'lattice' && l.number.toString() === numStr);
                 if (!existing) {
                    requestLatticeData(numStr);
                    await new Promise(resolve => setTimeout(resolve, 50));
                 } else {
                     existing.visible = true;
                 }
            }
             updateLayerListUI();
             needsRedraw = true;

            plotSequenceButton.disabled = false;
            plotSequenceButton.textContent = "Plot Sequence";
            isPlottingSequence = false;
        }

        /**
         * Plots the modulus grid as a new layer.
         */
        function plotModulusLayer() {
            const modulus = parseInt(modulusInput.value, 10);
            if (isNaN(modulus) || modulus < 2) {
                alert("Modulus must be a number >= 2.");
                return;
            }
            const operation = modulusOperationSelect.value;
            const colorMode = modulusColorSelect.value;
            
            // Check if this exact layer already exists
            const existing = Array.from(layers.values()).find(l => 
                l.type === 'modulus' && 
                l.modulus === modulus && 
                l.operation === operation && 
                l.colorMode === colorMode
            );
            
            if (existing) {
                existing.visible = true;
                updateLayerListUI();
                needsRedraw = true;
                return;
            }

            layerCounter++;
            const newLayer = {
                id: `mod-${layerCounter}`,
                type: 'modulus',
                modulus: modulus,
                operation: operation,
                colorMode: colorMode,
                visible: true,
                originOffset: { x: 0, y: 0 },
                opacity: 0.75
            };
            
            layers.set(newLayer.id, newLayer);
            updateLayerListUI();
            needsRedraw = true;
        }

        function clearAll() {
            layers.clear();
            updateLayerListUI();
            needsRedraw = true;
        }

        function updateLayerListUI() {
            layerListContainer.innerHTML = '';
            // Sort keys by type (modulus first, then lattice), then by number/id
            const typeOrder = { 'modulus': 1, 'lattice': 2 };
            const sortedKeys = Array.from(layers.keys()).sort((a, b) => {
                const layerA = layers.get(a);
                const layerB = layers.get(b);
                
                if (layerA.type !== layerB.type) {
                    return typeOrder[layerA.type] - typeOrder[layerB.type];
                }
                if (layerA.type === 'lattice') {
                    return layerA.number.compareTo(layerB.number);
                }
                return layerA.id.localeCompare(layerB.id); // Sort others by id
            });

            sortedKeys.forEach((key) => {
                const layer = layers.get(key);
                const item = document.createElement('div');
                item.className = 'layer-item';

                if (layer.type === 'lattice') {
                    const factors = layer.primeFactors.length > 6 ? `${layer.primeFactors.slice(0, 6).join('×')}...` : layer.primeFactors.join('×');
                    const { core, factors: factorToggle, diamonds, parabolas, intersections } = layer.toggles;
                    item.innerHTML = `
                        <div class="layer-info">Lattice: ${layer.number.toString()}</div>
                        <button class="remove-btn" data-key="${key}" title="Remove layer">✕</button>
                        <div class="layer-sub-info">(${factors || 'Prime'})</div>

                        <div class="layer-controls">
                            <label title="Change lattice color">
                                <input type="color" class="color-input" data-key="${key}" value="${layer.color}" title="Change lattice color">
                            </label>
                            <label>
                                <input type="checkbox" class="vis-toggle" data-key="${key}" ${layer.visible ? 'checked' : ''}>
                                Visible
                            </label>
                            <label>
                                X: <input type="number" class="offset-input border rounded px-1" data-key="${key}" data-axis="x" value="${layer.originOffset.x}">
                            </label>
                            <label>
                                Y: <input type="number" class="offset-input border rounded px-1" data-key="${key}" data-axis="y" value="${layer.originOffset.y}">
                            </label>
                        </div>
                        <div class="layer-toggles">
                            <label><input type="checkbox" class="toggle-input" data-key="${key}" data-type="core" ${core ? 'checked' : ''}> Core</label>
                            <label><input type="checkbox" class="toggle-input" data-key="${key}" data-type="factors" ${factorToggle ? 'checked' : ''}> Factors</label>
                            <label><input type="checkbox" class="toggle-input" data-key="${key}" data-type="diamonds" ${diamonds ? 'checked' : ''}> Diamonds</label>
                            <label><input type="checkbox" class="toggle-input" data-key="${key}" data-type="parabolas" ${parabolas ? 'checked' : ''}> Parabolas</label>
                            <label><input type="checkbox" class="toggle-input" data-key="${key}" data-type="intersections" ${intersections ? 'checked' : ''}> Dots</label>
                        </div>
                    `;
                } else if (layer.type === 'modulus') {
                    const opName = opDisplayNames[layer.operation] || layer.operation;
                    item.innerHTML = `
                        <div class="layer-info">Modulus: ${layer.modulus}</div>
                        <button class="remove-btn" data-key="${key}" title="Remove layer">✕</button>
                        <div class="layer-sub-info">(${opName}, ${layer.colorMode})</div>

                        <div class="layer-controls">
                             <label>
                                <input type="checkbox" class="vis-toggle" data-key="${key}" ${layer.visible ? 'checked' : ''}>
                                Visible
                            </label>
                            <label>
                                X: <input type="number" class="offset-input border rounded px-1" data-key="${key}" data-axis="x" value="${layer.originOffset.x}">
                            </label>
                            <label>
                                Y: <input type="number" class="offset-input border rounded px-1" data-key="${key}" data-axis="y" value="${layer.originOffset.y}">
                            </label>
                            <label>
                                Opacity: <input type="range" class="opacity-slider" data-key="${key}" min="0.1" max="1" step="0.1" value="${layer.opacity}">
                            </label>
                        </div>
                    `;
                }
                layerListContainer.appendChild(item);
            });
        }


        // --- 6. EVENT LISTENERS ---
        function handleWorkerMessage(e) {
            
            if (!isPlottingSequence) {
                 plotButton.disabled = false;
                 plotSequenceButton.disabled = false;
                 plotButton.textContent = "Plot";
            }
            
            const { number, primeFactors, factorPairs, error } = e.data;
            if (error) {
                console.error(`Worker error for ${number}: ${error}`);
                if (!isPlottingSequence) alert(`Error factoring ${number}: ${error}`);
                return;
            }

            // --- Plotting Logic ---
            const latticeCount = Array.from(layers.values()).filter(l => l.type === 'lattice').length;
            const colorIndex = latticeCount % colors.length;

            layerCounter++;
            const newLattice = {
                id: `lat-${layerCounter}`,
                type: 'lattice',
                number: bigInt(number),
                primeFactors: primeFactors,
                factorPairs: factorPairs,
                color: colors[colorIndex],
                visible: true,
                originOffset: { x: 0, y: 0 },
                toggles: { core: true, factors: true, diamonds: true, parabolas: true, intersections: true },
                equations: { core: [], factors: [], diamonds: [], parabolas: [] },
                intersections: []
            };
            // FIX: generateLatticeEquations and generateLatticeIntersections are now defined earlier
            newLattice.equations = generateLatticeEquations(newLattice);
            newLattice.intersections = generateLatticeIntersections(newLattice);
            layers.set(newLattice.id, newLattice);
            updateLayerListUI();
            needsRedraw = true;
        }

        function handleInputKey(e) {
            if (e.key === 'Enter') {
                plotSingleNumber();
            } else if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                e.preventDefault();
                try {
                    let num = bigInt(numberInput.value);
                    num = (e.key === 'ArrowUp') ? num.add(1) : num.subtract(1);
                    if (num.isZero()) num = (e.key === 'ArrowUp') ? num.add(1) : num.subtract(1);
                    numberInput.value = num.toString();
                    plotSingleNumber();
                } catch (err) { /* ignore */ }
            }
        }
        
        function handleModulusArrows(e) {
             let num = parseInt(modulusInput.value, 10);
             if (isNaN(num)) num = 12;
             if (e.target.id === 'modulusUpButton') {
                 num++;
             } else {
                 num--;
             }
             if (num < 2) num = 2;
             modulusInput.value = num;
        }

        function findSnapPoint(worldX, worldY) {
            const worldThreshold = 10 / transform.scale; 
            let bestSnap = null;
            let minDelta = worldThreshold;
            const visibleLattices = Array.from(layers.values()).filter(l => l.type === 'lattice' && l.visible).reverse();

            for (const lattice of visibleLattices) {
                const ox = lattice.originOffset.x; const oy = lattice.originOffset.y;
                const lx = worldX - ox; const ly = worldY - oy;

                const checkEqs = (eqs) => {
                    if (!eqs) return;
                    for (const eq of eqs) {
                        let dist = Infinity; let snappedY = ly; let snappedX = lx;
                        switch (eq.type) {
                            case 'line':
                                dist = Math.abs(eq.m * lx - ly + eq.c) / Math.sqrt(eq.m * eq.m + 1);
                                snappedY = eq.m * lx + eq.c;
                                break;
                            case 'vline':
                                dist = Math.abs(lx - eq.x);
                                snappedX = eq.x;
                                break;
                            case 'hline':
                                dist = Math.abs(ly - eq.y);
                                snappedY = eq.y;
                                break;
                            case 'hyperbola':
                                if (lx !== 0) {
                                    const h_y = eq.N / lx;
                                    dist = Math.abs(ly - h_y);
                                    snappedY = h_y;
                                }
                                break;
                            case 'parabola':
                                if (eq.form.startsWith('y=')) {
                                    const p_y = (eq.form === 'y=x^2-N') ? (lx * lx - eq.N) : (eq.N - lx * lx);
                                    dist = Math.abs(ly - p_y);
                                    snappedY = p_y;
                                } else {
                                    const p_x = (eq.form === 'x=y^2-N') ? (ly * ly - eq.N) : (eq.N - ly * ly);
                                    dist = Math.abs(lx - p_x);
                                    snappedX = p_x;
                                }
                                break;
                        }
                        if (dist < minDelta) {
                            minDelta = dist;
                            if (eq.type === 'vline') {
                                bestSnap = { x: snappedX + ox, y: worldY, label: eq.label };
                            } else if (eq.type === 'parabola' && eq.form.startsWith('x=')) {
                                bestSnap = { x: snappedX + ox, y: worldY, label: eq.label };
                            } else if (eq.type === 'hline') {
                                bestSnap = { x: worldX, y: snappedY + oy, label: eq.label };
                            } else {
                                bestSnap = { x: worldX, y: snappedY + oy, label: eq.label };
                            }
                        }
                    }
                };
                
                if (lattice.toggles.core) checkEqs(lattice.equations.core);
                if (lattice.toggles.factors) checkEqs(lattice.equations.factors);
                if (lattice.toggles.diamonds) checkEqs(lattice.equations.diamonds);
                if (lattice.toggles.parabolas) checkEqs(lattice.equations.parabolas);

                if (bestSnap) return bestSnap; 
            }
            return null;
        }

        function handleCoordinateSnap(e) {
            if (isPanning) {
                hoveredInfo = null;
                return;
            };
            const clientX = e.clientX; const clientY = e.clientY;
            const worldPos = screenToWorld(clientX, clientY);
            let snap = findSnapPoint(worldPos.x, worldPos.y);
            
            if (snap) {
                hoveredInfo = {
                    x: snap.x,
                    y: snap.y,
                    label: snap.label
                };
            } else {
                 hoveredInfo = {
                    x: worldPos.x,
                    y: worldPos.y,
                    label: `[${Math.floor(worldPos.x)}, ${Math.floor(worldPos.y)}]`
                 }
            }
            needsRedraw = true;
        }

        canvas.addEventListener('mousedown', (e) => {
            isPanning = true;
            lastPanPoint = { x: e.clientX, y: e.clientY };
            canvas.style.cursor = 'grabbing';
            hoveredInfo = null;
            needsRedraw = true;
        });
        canvas.addEventListener('mouseup', () => {
            isPanning = false;
            canvas.style.cursor = 'grab';
        });
        canvas.addEventListener('mouseleave', () => {
            isPanning = false;
            canvas.style.cursor = 'grab';
            if (hoveredInfo) {
                hoveredInfo = null;
                needsRedraw = true;
            }
        });
        canvas.addEventListener('mousemove', (e) => {
            if (isPanning) {
                const dx = e.clientX - lastPanPoint.x; const dy = e.clientY - lastPanPoint.y;
                transform.x += dx; transform.y += dy;
                lastPanPoint = { x: e.clientX, y: e.clientY };
            } else {
                handleCoordinateSnap(e);
            }
            needsRedraw = true;
        });
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const zoomFactor = 1.1;
            const delta = e.deltaY > 0 ? 1 / zoomFactor : zoomFactor;
            const mouse = { x: e.clientX, y: e.clientY };
            const worldPosBefore = screenToWorld(mouse.x, mouse.y);
            
            transform.scale *= delta;
            
            const worldPosAfter = screenToWorld(mouse.x, mouse.y);
            transform.x += (worldPosAfter.x - worldPosBefore.x) * transform.scale;
            transform.y += (worldPosAfter.y - worldPosBefore.y) * transform.scale;
           
            handleCoordinateSnap(e);
            needsRedraw = true;
        });

        let lastTouchDist = 0;
        let lastTouchCenter = null;
        
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            hoveredInfo = null;
            if (e.touches.length === 1) {
                const clientX = e.touches[0].clientX;
                const clientY = e.touches[0].clientY;
                
                handleCoordinateSnap(e.touches[0]); 
                
                if (hoveredInfo && hoveredInfo.label.startsWith('[')) {
                    isPanning = true;
                    lastPanPoint = { x: clientX, y: clientY };
                    hoveredInfo = null;
                } else if (hoveredInfo) {
                    isPanning = false;
                } else {
                    isPanning = true;
                    lastPanPoint = { x: clientX, y: clientY };
                }

            } else if (e.touches.length === 2) {
                isPanning = false;
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                lastTouchDist = Math.hypot(dx, dy);
                lastTouchCenter = {
                    x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
                    y: (e.touches[0].clientY + e.touches[1].clientY) / 2
                };
            }
            needsRedraw = true;
        }, { passive: false });
        
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (e.touches.length === 1 && isPanning) {
                const dx = e.touches[0].clientX - lastPanPoint.x;
                const dy = e.touches[0].clientY - lastPanPoint.y;
                transform.x += dx;
                transform.y += dy;
                lastPanPoint = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                hoveredInfo = null;
            } else if (e.touches.length === 1 && !isPanning) {
                handleCoordinateSnap(e.touches[0]);
            } else if (e.touches.length === 2) {
                isPanning = false;
                hoveredInfo = null;
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                const newDist = Math.hypot(dx, dy);
                if (lastTouchDist === 0) { lastTouchDist = newDist; return; }
                const delta = newDist / lastTouchDist;
                
                const newTouchCenter = {
                    x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
                    y: (e.touches[0].clientY + e.touches[1].clientY) / 2
                };
                
                const worldPosBefore = screenToWorld(lastTouchCenter.x, lastTouchCenter.y);
                transform.scale *= delta;
                const worldPosAfter = screenToWorld(newTouchCenter.x, newTouchCenter.y);

                transform.x += (worldPosAfter.x - worldPosBefore.x) * transform.scale;
                transform.y += (worldPosAfter.y - worldPosBefore.y) * transform.scale;

                lastTouchDist = newDist;
                lastTouchCenter = newTouchCenter;
            }
            needsRedraw = true;
        }, { passive: false });
        
        canvas.addEventListener('touchend', (e) => {
            if (e.touches.length < 1) {
                isPanning = false;
            }
            if (e.touches.length < 2) {
                lastTouchDist = 0;
                lastTouchCenter = null;
            }
        });

        layerListContainer.addEventListener('click', (e) => {
            const key = e.target.dataset.key;
            if (key && e.target.classList.contains('remove-btn')) {
                layers.delete(key);
                updateLayerListUI();
                needsRedraw = true;
            }
        });

        layerListContainer.addEventListener('change', (e) => {
            const key = e.target.dataset.key;
            if (!key) return;
            const layer = layers.get(key);
            if (!layer) return;
            
            if (e.target.classList.contains('vis-toggle')) {
                layer.visible = e.target.checked;
            } else if (e.target.classList.contains('offset-input')) {
                const axis = e.target.dataset.axis;
                layer.originOffset[axis] = Number(e.target.value) || 0;
            } else if (e.target.classList.contains('toggle-input')) {
                if (layer.type === 'lattice') {
                    const type = e.target.dataset.type;
                    if (layer.toggles.hasOwnProperty(type)) {
                        layer.toggles[type] = e.target.checked;
                    }
                }
            }
            needsRedraw = true;
        });

        layerListContainer.addEventListener('input', (e) => {
            const key = e.target.dataset.key;
            if (!key) return;
            const layer = layers.get(key);
            if (!layer) return;

            if (layer.type === 'lattice' && e.target.classList.contains('color-input')) {
                layer.color = e.target.value;
            } else if (layer.type === 'modulus' && e.target.classList.contains('opacity-slider')) {
                layer.opacity = Number(e.target.value);
            }
            needsRedraw = true;
        });

        globalTogglesContainer.addEventListener('change', (e) => {
            if (e.target.classList.contains('global-toggle-input')) {
                const type = e.target.dataset.type;
                const isChecked = e.target.checked;
                for (const layer of layers.values()) {
                    if (layer.type === 'lattice' && layer.toggles.hasOwnProperty(type)) {
                        layer.toggles[type] = isChecked;
                    }
                }
                updateLayerListUI();
                needsRedraw = true;
            }
        });

        // --- 7. INITIALIZATION ---
        function init() {
            // CRITICAL FIX: Ensure the worker is initialized properly
            const workerBlob = new Blob([workerCode], { type: 'application/javascript' });
            worker = new Worker(URL.createObjectURL(workerBlob));
            worker.onmessage = handleWorkerMessage;
            
            plotButton.addEventListener('click', plotSingleNumber);
            plotSequenceButton.addEventListener('click', plotSequence);
            clearButton.addEventListener('click', clearAll);
            numberInput.addEventListener('keydown', handleInputKey);
            
            // Auxiliary Listeners
            plotModulusButton.addEventListener('click', plotModulusLayer);
            modulusDownButton.addEventListener('click', handleModulusArrows);
            modulusUpButton.addEventListener('click', handleModulusArrows);
            modulusInput.addEventListener('change', () => {
                 if (parseInt(modulusInput.value, 10) < 2) modulusInput.value = 2;
            });

            document.getElementById('toggleControls').addEventListener('click', () => {
                document.getElementById('controls').classList.toggle('collapsed');
            });
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();
            plotSingleNumber(); // This kicks off the initial plot (1007)
            drawLoop();
        }
        
        // Start the application
        init();
    </script>
</body>
</html>
