<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1.0"/>
<title>S-Factorizer: Quadratic Residue Filtering</title>
<script src="https://cdn.tailwindcss.com"></script>
<style>
  :root{
    --bg:#f3f4f6;
    --panel:#fff;
    --accent:#3b82f6;
    --good:#10b981;
    --bad:#ef4444;
    --log:#061124;
    --log-text:#9ff1c7;
  }
  body{font-family:Inter,system-ui,Segoe UI,Roboto,Arial;margin:0;background:var(--bg);padding:1rem;}
  .card{max-width:100%; margin:0 auto;background:var(--panel);padding:1.5rem;border-radius:12px;box-shadow:0 12px 30px rgba(0,0,0,.08);border-top:6px solid var(--accent);}
  h1{margin-top:0; margin-bottom:0.25rem;color:var(--accent); font-size:1.5rem; font-weight:700;}
  .subtitle{margin-bottom:1rem;color:#6b7280; font-size:0.875rem;}
  .grid-input{display:grid;grid-template-columns:repeat(2,1fr);gap:1rem;}
  @media (min-width: 640px) { .grid-input{grid-template-columns:repeat(4,1fr);} }
  input{padding:0.6rem;border-radius:6px;border:1px solid #d1d5db;font-size:1rem; width:100%; box-sizing:border-box;}
  label{display:block;font-size:0.8rem;color:#374151;margin-bottom:0.25rem; font-weight: 500;}
  .btn-group{display:flex;gap:0.75rem;margin-top:1rem; align-items:center;}
  button{padding:0.75rem 1rem;border-radius:8px;border:none;font-weight:600;cursor:pointer; transition: transform 0.1s, box-shadow 0.2s;}
  button:active{transform:translateY(1px);}
  .start{background:var(--good);color:white; box-shadow:0 4px 6px rgba(16, 185, 129, 0.4);}
  .stop{background:var(--bad);color:white; box-shadow:0 4px 6px rgba(239, 68, 68, 0.4);}
  .log-container{background:var(--log);color:var(--log-text);padding:0.75rem;border-radius:8px;height:12rem;overflow:auto;white-space:pre-wrap;margin-top:1rem; font-size:0.85rem;}
  .progress-container{height:0.75rem;background:#eef2ff;border-radius:999px;overflow:hidden;margin-top:0.5rem;}
  .progress-bar{height:100%;width:0;background:var(--accent);color:white;text-align:center;font-weight:700;font-size:0.75rem; transition: width 0.3s;}
  .stat-grid{display:grid;grid-template-columns:repeat(2,1fr);gap:1rem;margin-top:1rem;}
  @media (min-width: 640px) { .stat-grid{grid-template-columns:repeat(3,1fr);} }
  .stat-label{font-size:0.8rem;color:#475569;}
  .stat-value{font-weight:700;font-size:1.1rem;color:#1f2937;}
  .status-line{font-size:0.875rem;margin-top:0.75rem; padding: 0.5rem 0; color:#475569;}
</style>
</head>
<body>
  <div class="card">
    <h1>S-Factorizer (Parallel)</h1>
    <p class="subtitle">Finds factors near $\sqrt{N}$ using $N = a^b+c$ input. It employs **Quadratic Residue Filtering** (Step 2) to rapidly eliminate unlikely $S$-candidates before the expensive **Discriminant Check** (Step 4).</p>

    <div class="grid-input">
      <div>
        <label>Base ($a$)</label>
        <input id="base" value="2" placeholder="e.g., 2">
      </div>
      <div>
        <label>Exponent ($b$)</label>
        <input id="exp" value="103" placeholder="e.g., 103">
      </div>
      <div>
        <label>Addend ($c$)</label>
        <input id="add" value="-1" placeholder="e.g., -1">
      </div>
      <div>
        <label>Max S Range</label>
        <input id="range" value="200000" placeholder="e.g., 200000">
      </div>
    </div>

    <div id="preCheckStatus" class="status-line">Pre-Check Status: Ready</div>

    <div class="btn-group">
      <button id="startBtn" class="start shadow-lg hover:opacity-90">Run Factorization</button>
      <button id="stopBtn" class="stop shadow-lg" disabled>Stop</button>
      
      <div class="ml-auto text-right">
        <div class="stat-label">Phase: <span id="phase" class="font-bold text-gray-700">Idle</span></div>
        <div class="progress-container"><div id="bar" class="progress-bar">0%</div></div>
      </div>
    </div>

    <div class="stat-grid">
      <div>
        <div class="stat-label">Target $N$ Digits</div>
        <div id="ndigits" class="stat-value">N/A</div>
      </div>
      <div>
        <div class="stat-label">Calculated $S_{min} (\approx 2\sqrt{N})$</div>
        <div id="smin" class="stat-value">N/A</div>
      </div>
      <div>
        <div class="stat-label">Factors Found</div>
        <div id="factors" class="stat-value">None</div>
      </div>
      <div>
        <div class="stat-label">S-candidates (Filtered)</div>
        <div id="candidates" class="stat-value">0</div>
      </div>
    </div>

    <h3 class="text-base font-semibold mt-4 text-gray-700">Execution Log</h3>
    <pre id="log" class="log-container">Ready. Enter a base, exponent, and range, then click Run Factorization.</pre>
  </div>

<script>
/* -------------------------
   Main thread control & UI
   ------------------------- */
const startBtn       = document.getElementById('startBtn');
const stopBtn        = document.getElementById('stopBtn');
const baseEl         = document.getElementById('base');
const expEl          = document.getElementById('exp');
const addEl          = document.getElementById('add');
const rangeEl        = document.getElementById('range');
const logEl          = document.getElementById('log');
const phaseEl        = document.getElementById('phase');
const barEl          = document.getElementById('bar');
const sminEl         = document.getElementById('smin');
const factorsEl      = document.getElementById('factors');
const candEl         = document.getElementById('candidates');
const ndigitsEl      = document.getElementById('ndigits');
const preCheckStatus = document.getElementById('preCheckStatus');

let sqrtWorker = null;
let workers = [];
let N_str = '';
let SMin = 0n;
let candidateList = [];
let foundFactors = new Set();
let isRunning = false;
let stopChecker = null;
const TRIAL_DIVISION_LIMIT = 1000;

// --- Utility Functions ---

function parseBigInt(str) {
  if (!str) return 0n;
  str = String(str).replace(/\s/g, '');
  if (str.includes('+')) {
    const terms = str.split('+');
    return terms.reduce((sum, term) => sum + parseBigInt(term), 0n);
  }
  if (str.includes('e') || str.includes('E')) {
    const parts = str.toLowerCase().split('e');
    try { return BigInt(parts[0]) * 10n ** BigInt(parts[1]); } catch(e) { return 0n; }
  }
  try { return BigInt(str); } catch(e) { return 0n; }
}
function powMod(base, exp, mod) {
  let result = 1n;
  base %= mod;
  if (base === 0n) return 0n;
  while (exp > 0n) {
    if ((exp & 1n) === 1n) result = (result * base) % mod;
    exp >>= 1n;
    base = (base * base) % mod;
  }
  return result;
}
function nthRoot(n, k) {
    if (n < 0n || k < 1n) return null;
    if (k === 1n) return n;
    let low = 1n;
    let high = n;
    while (low <= high) {
        const mid = (low + high) >> 1n;
        if (mid === 0n) { low = 1n; continue; }
        let power;
        try { power = mid ** k; } catch (e) { power = -1n; }
        if (power === n) return mid;
        else if (power > 0n && power < n) low = mid + 1n;
        else high = mid - 1n;
    }
    return null;
}
function log(msg){
  const t = new Date().toLocaleTimeString();
  logEl.textContent += `\n[${t}] ${msg}`;
  logEl.scrollTop = logEl.scrollHeight;
}
function setPhase(text, pct=0){
  phaseEl.textContent = text;
  barEl.style.width = pct + '%';
  barEl.textContent = pct.toFixed(2) + '%';
}
function setPreCheckStatus(msg, append = false) {
    if (append) {
        preCheckStatus.textContent += ` | ${msg}`;
    } else {
        preCheckStatus.textContent = `Pre-Check Status: ${msg}`;
    }
}
function logFactor(factor){
    const factorStr = factor.toString();
    if (!foundFactors.has(factorStr)) {
        foundFactors.add(factorStr);
        let display = Array.from(foundFactors).join(' × ');
        factorsEl.textContent = display.length > 30 ? display.substring(0, 30) + '...' : display;
        log(`Factor found: ${factorStr}`);
    }
}
async function checkAlgebraicFactors(a, b, c) {
    // ... (Algebraic Check logic remains the same)
    setPreCheckStatus('Checking algebraic factors...');
    let factorFound = false;
    if (c > 0n && (b & 1n) === 1n) {
        const d = nthRoot(c, b);
        if (d !== null) {
            const factor = a + d;
            log(`Algebraic Form a^b + d^b (d=${d}) found. Factor: ${factor}`);
            logFactor(factor);
            factorFound = true;
        }
    }
    if (c < 0n) {
        const c_abs = -c;
        const d = nthRoot(c_abs, b);
        if (d !== null) {
            const factor1 = a - d;
            log(`Algebraic Form a^b - d^b (d=${d}) found. Factor: ${factor1}`);
            logFactor(factor1);
            factorFound = true;
            if ((b & 1n) === 0n) {
                const factor2 = a + d;
                log(`Exponent b is even. Additional factor: ${factor2}`);
                logFactor(factor2);
            }
        }
    }
    setPreCheckStatus(factorFound ? 'Algebraic Check: Factors Found' : 'Algebraic Check: None');
    return factorFound;
}
async function trialDivision(a, b, c) {
    // ... (Trial Division logic remains the same)
    setPreCheckStatus('', false);
    setPreCheckStatus(`Checking small primes up to ${TRIAL_DIVISION_LIMIT}...`);
    const limit = TRIAL_DIVISION_LIMIT;
    const isPrime = new Array(limit + 1).fill(true);
    isPrime[0] = isPrime[1] = false;
    for (let i = 2; i * i <= limit; i++) {
        if (isPrime[i]) {
            for (let j = i * i; j <= limit; j += i) isPrime[j] = false;
        }
    }
    const smallPrimes = [];
    for (let i = 2; i <= limit; i++) if (isPrime[i]) smallPrimes.push(BigInt(i));
    let factorFound = false;
    for (const p of smallPrimes) {
        const rem = (powMod(a, b, p) + c) % p;
        if (rem === 0n) {
            logFactor(p);
            factorFound = true;
        }
    }
    setPreCheckStatus(factorFound ? 'Trial Division: Factors Found' : 'Trial Division: None', true);
    return factorFound;
}


/* ====================================================
   Worker functions (Core Arithmetic & Sqrt)
   Updated to handle arbitrary base 'a' (non-10) in the worker.
   ==================================================== */

// ---- Streaming sqrt worker function (Phase 1) ----
function sqrtWorkerFn(){
  // --- General Large Number Arithmetic Helpers ---
  const CHUNK_DIGITS = 9;
  const BASE = 10 ** CHUNK_DIGITS;

  function trimChunks(a){ if(!Array.isArray(a)||a.length===0) return [0]; let i=0; while(i<a.length-1 && a[i]===0) i++; return a.slice(i); }
  function stringToChunks(s){
    s = (s||'').replace(/^\+/, '').trim(); if(s[0]==='+') s=s.slice(1);
    if(s.length===0) return [0];
    const pad = (CHUNK_DIGITS - (s.length % CHUNK_DIGITS)) % CHUNK_DIGITS;
    s = '0'.repeat(pad) + s;
    const out=[];
    for(let i=0;i<s.length;i+=CHUNK_DIGITS) out.push(parseInt(s.substring(i,i+CHUNK_DIGITS),10));
    return trimChunks(out);
  }
  function chunksToString(chunks){ chunks = trimChunks(chunks); if(chunks.length===1 && chunks[0]===0) return '0'; let s = String(chunks[0]); for(let i=1;i<chunks.length;i++) s += String(chunks[i]).padStart(CHUNK_DIGITS,'0'); return s; }
  function cmpChunks(a,b){ a=trimChunks(a); b=trimChunks(b); if(a.length!==b.length) return a.length>b.length?1:-1; for(let i=0;i<a.length;i++) if(a[i]!==b[i]) return a[i]>b[i]?1:-1; return 0; }
  function addChunks(a,b){ let ar=a.slice().reverse(), br=b.slice().reverse(), n=Math.max(ar.length,br.length), carry=0, out=[]; for(let i=0;i<n;i++){ let s=(ar[i]||0)+(br[i]||0)+carry; out.push(s%BASE); carry=Math.floor(s/BASE);} if(carry) out.push(carry); return trimChunks(out.reverse()); }
  function subChunks(a,b){ let ar=a.slice().reverse(), br=b.slice().reverse(), n=ar.length, borrow=0, out=[]; for(let i=0;i<n;i++){ let v=(ar[i]||0)-(br[i]||0)-borrow; if(v<0){ v+=BASE; borrow=1;} else borrow=0; out.push(v);} return trimChunks(out.reverse()); }
  function mulSmallChunks(a,s){ if(!Array.isArray(a)||a.length===0) return [0]; if(s===0) return [0]; let a_rev=a.slice().reverse(), carry=0, out=[]; for(let d of a_rev){ let p=d*s+carry; out.push(p%BASE); carry=Math.floor(p/BASE);} while(carry>0){ out.push(carry%BASE); carry=Math.floor(carry/BASE);} return trimChunks(out.reverse()); }
  function shiftChunks(a,k){ if(!Array.isArray(a)||a.length===0) return [0]; if(k<=0) return a.slice(); return a.concat(new Array(k).fill(0)); }
  function mulChunks(A,B){
    let a=A.slice().reverse(), b=B.slice().reverse(), len_a=a.length, len_b=b.length, res=new Array(len_a+len_b).fill(0), carry=0;
    for(let i=0;i<len_a;i++){ carry=0; for(let j=0;j<len_b;j++){ let p=a[i]*b[j]+res[i+j]+carry; res[i+j]=p%BASE; carry=Math.floor(p/BASE); } res[i+len_b]+=carry; }
    return trimChunks(res.reverse());
  }

  function streamingIntegerSqrt(N_str, onProgress){
    const groupDigits = CHUNK_DIGITS*2;
    let s = N_str.replace(/^\+/, '');
    if(s.length===0) s='0';
    const pad = (groupDigits - (s.length % groupDigits)) % groupDigits;
    s = '0'.repeat(pad) + s;
    const groups = [];
    for(let i=0;i<s.length;i+=groupDigits) groups.push(s.substring(i,i+groupDigits));
    let root=[0], remainder=[0];
    const total = groups.length;
    for(let idx=0; idx<groups.length; idx++){
      const g = groups[idx];
      const left = g.substring(0,CHUNK_DIGITS);
      const right = g.substring(CHUNK_DIGITS);
      const groupChunks = [parseInt(left,10), parseInt(right,10)];
      remainder = shiftChunks(remainder, 2);
      remainder = addChunks(remainder, trimChunks(groupChunks));
      let prefix = mulSmallChunks(root,2);
      let lo=0, hi=BASE-1, chosen=0;
      while(lo<=hi){
        const mid = Math.floor((lo+hi)/2);
        let t = shiftChunks(prefix,1);
        t = addChunks(t, [mid]);
        let trial = mulSmallChunks(t, mid);
        if(cmpChunks(trial, remainder) <= 0) { chosen = mid; lo = mid+1; } else hi = mid-1;
      }
      let chosenT = shiftChunks(prefix,1); chosenT = addChunks(chosenT, [chosen]);
      let trialChosen = mulSmallChunks(chosenT, chosen);
      remainder = subChunks(remainder, trialChosen);
      root = addChunks(mulSmallChunks(root,1), [chosen]);
      if(onProgress && (idx % 50 === 0)) {
        try{ onProgress((idx+1)/total*100); } catch(e){}
      }
    }
    return { root: chunksToString(root), remainder: chunksToString(remainder), digits: N_str.length };
  }

  function tryNativeSqrt(N_str){
    try {
      if(N_str.length < 700) {
        const Nbi = BigInt(N_str);
        let x = Nbi, y = (x + 1n) >> 1n;
        while(y < x) { x = y; y = (x + Nbi / x) >> 1n; }
        const rem = Nbi - x*x;
        return { root: x.toString(), remainder: rem.toString() };
      }
    } catch(e){}
    return null;
  }

  // Calculate N = a^b + c using chunked arithmetic
  function calculateN_chunks(aStr, bStr, cStr){
    const a = stringToChunks(aStr);
    const b = BigInt(bStr);
    const c = stringToChunks(cStr);

    if (b === 0n) {
      return chunksToString(addChunks(stringToChunks('1'), c));
    }
    
    // Calculate A^B (Power)
    let result = stringToChunks('1');
    let base = a;
    let exp = b;
    
    while(exp > 0n){
        if((exp & 1n) === 1n){
            result = mulChunks(result, base);
        }
        base = mulChunks(base, base);
        exp >>= 1n;
    }

    // Add C
    function signAndAbs(s){ s = String(s).trim(); let sign=1; if(s[0]==='+')s=s.slice(1); if(s[0]==='-'){ sign=-1; s=s.slice(1); } s=s.replace(/^0+/, '') || '0'; return {sign, s}; }
    const c_signed = signAndAbs(cStr);
    const result_str = chunksToString(result);
    
    if (c_signed.sign > 0) {
        return chunksToString(addChunks(result, c));
    } else { // Subtraction
        const res_chunks = stringToChunks(result_str);
        const c_abs_chunks = stringToChunks(c_signed.s);
        
        if (cmpChunks(res_chunks, c_abs_chunks) >= 0) {
            return chunksToString(subChunks(res_chunks, c_abs_chunks));
        } else {
            // Negative result: Factorization is meaningless, but we handle it mathematically
            const final_chunks = subChunks(c_abs_chunks, res_chunks);
            return '-' + chunksToString(final_chunks);
        }
    }
  }


  self.onmessage = function(ev){
    const data = ev.data || {};
    if(data.mode === 'compute_sqrt'){
      try{
        const aStr = String(data.aStr).trim();
        const bStr = String(data.bStr).trim();
        const cStr = String(data.cStr).trim();

        if (aStr.length === 0 || bStr.length === 0) { self.postMessage({ type:'error', message:'Base and exponent cannot be empty.'}); return; }

        // 1. Calculate N = a^b + c (using general chunked arithmetic)
        const combined = calculateN_chunks(aStr, bStr, cStr);

        if(combined.startsWith('-')) { self.postMessage({ type:'error', message:'Target N is negative (a^b + c < 0). Cannot factor.'}); return; }
        
        self.postMessage({ type:'log', message: `N digits: ${combined.length}` });
        ndigitsEl.textContent = combined.length;

        // 2. Compute the square root of N
        const fast = tryNativeSqrt(combined);
        if(fast){ 
            self.postMessage({ type:'progress', value:100 }); 
            self.postMessage({ type:'result', root:fast.root, remainder:fast.remainder, N_str:combined }); 
            return; 
        }

        const res = streamingIntegerSqrt(combined, function(p){ self.postMessage({ type:'progress', value:p }); });
        self.postMessage({ type:'progress', value:100 });
        self.postMessage({ type:'result', root:res.root, remainder:res.remainder, N_str:combined });
      } catch(err){
        self.postMessage({ type:'error', message: err && err.message ? err.message : String(err) });
      }
    }
  };
}

// ---- Factor worker function (Phase 2 & 3) remains similar, relies on BigInt path for speed ----
function factorWorkerFn(){
  // --- Helpers for Worker ---
  const CHUNK_DIGITS = 9;
  const BASE = 10 ** CHUNK_DIGITS;
  function trimChunks(a){ if(!Array.isArray(a)||a.length===0) return [0]; let i=0; while(i<a.length-1 && a[i]===0) i++; return a.slice(i); }
  function stringToChunks(s){ s=(s||'').replace(/^\+/, '').trim(); if(s.length===0) return [0]; const pad=(CHUNK_DIGITS-(s.length%CHUNK_DIGITS))%CHUNK_DIGITS; s='0'.repeat(pad)+s; const out=[]; for(let i=0;i<s.length;i+=CHUNK_DIGITS) out.push(parseInt(s.substring(i,i+CHUNK_DIGITS),10)); return trimChunks(out); }
  function chunksToString(chunks){ chunks=trimChunks(chunks); if(chunks.length===1 && chunks[0]===0) return '0'; let s=String(chunks[0]); for(let i=1;i<chunks.length;i++) s+=String(chunks[i]).padStart(CHUNK_DIGITS,'0'); return s; }
  function cmpChunks(a,b){ a=trimChunks(a); b=trimChunks(b); if(a.length!==b.length) return a.length>b.length?1:-1; for(let i=0;i<a.length;i++) if(a[i]!==b[i]) return a[i]>b[i]?1:-1; return 0; }
  function addChunks(a,b){ let ar=a.slice().reverse(), br=b.slice().reverse(), n=Math.max(ar.length,br.length), carry=0, out=[]; for(let i=0;i<n;i++){ let s=(ar[i]||0)+(br[i]||0)+carry; out.push(s%BASE); carry=Math.floor(s/BASE);} if(carry) out.push(carry); return trimChunks(out.reverse()); }
  function subChunks(a,b){ let ar=a.slice().reverse(), br=b.slice().reverse(), n=ar.length, borrow=0, out=[]; for(let i=0;i<n;i++){ let v=(ar[i]||0)-(br[i]||0)-borrow; if(v<0){ v+=BASE; borrow=1;} else borrow=0; out.push(v);} return trimChunks(out.reverse()); }
  function isZeroChunk(c){ c=trimChunks(c); return c.length===1 && c[0]===0; }
  function isEvenChunk(c){ c=trimChunks(c); if(isZeroChunk(c)) return true; return (c[c.length-1] % 2) === 0; }
  function divideByTwoChunk(c){ c=trimChunks(c); if(isZeroChunk(c)) return [0]; let out=[], carry=0; for(let i=0;i<c.length;i++){ let v = carry * BASE + c[i]; out.push(Math.floor(v/2)); carry = v % 2;} return trimChunks(out); }
  function customIntegerSqrt(n){ if(n<0n) return null; if(n<2n) return n; let x=n, y=(x+1n)>>1n; while(y<x){ x=y; y=(x + n/x)>>1n;} return x; }
  function powMod(base, exp, mod){ let res=1n; base%=mod; while(exp>0n){ if((exp & 1n) === 1n) res=(res*base)%mod; exp >>=1n; base=(base*base)%mod;} return res; }
  function legendreSymbol(a,p){ if(a===0n) return 0; if(p===2n) return 1; a=(a%p + p)%p; const ls = powMod(a, (p-1n)/2n, p); if(ls===p-1n) return -1; return 1; }
  
  self.onmessage = function(ev){
    const data = ev.data || {};
    try {
      // --- PHASE 2: SGS Filter (Step 2: Quadratic Residue) ---
      if(data.mode === 'filter'){
        const minS = BigInt(data.minS);
        const maxS = BigInt(data.maxS);
        const N_str = data.N_str;
        // Small factor base for modular checks
        const primes = [3n,5n,7n,11n,13n,17n,19n,23n]; 
        let candidates = [];
        const total = maxS - minS + 1n;
        let lastProg = -1;
        
        // Pre-calculate N mod p for all primes (Fast Modular Reduction)
        const Nmods = {};
        for(let p of primes){
          let mod = 0n;
          for(let i=0;i<N_str.length;i++) mod = (mod*10n + BigInt(N_str.charCodeAt(i) - 48)) % p;
          Nmods[p.toString()] = mod;
        }

        for(let S = minS; S <= maxS; S+=2n){ 
          const Ssq = S*S;
          let passes = true;
          for(let p of primes){
            const Nmodp = Nmods[p.toString()];
            // Calculate D^2 mod p = (S^2 - 4N) mod p
            const Dmodp = ( (Ssq % p) - (4n * Nmodp) % p + (p*10n) ) % p;
            
            // Check Quadratic Residue: D^2 must be a square mod p.
            if(legendreSymbol(Dmodp, p) === -1){ passes = false; break; }
          }
          if(passes) candidates.push(S.toString());
          
          if(total > 0n && (S - minS) % 2000n === 0n) {
            const prog = Number((S - minS) * 100n / total);
            if(prog > lastProg){ lastProg = prog; self.postMessage({ type:'filterProgress', progress: prog }); }
          }
        }
        self.postMessage({ type:'filterDone', candidates });

      // --- PHASE 3: Discriminant Resolve (Steps 3, 4, 5, 6) ---
      } else if(data.mode === 'resolve'){
        const S_list = data.S_list || [];
        const N_str = data.N_str;
        
        // Fast path for numbers fitting in BigInt
        let Nbi = null;
        try { if(N_str.length < 700) Nbi = BigInt(N_str); } catch(e){}
        
        const total = S_list.length;
        let lastProg = -1;

        for(let i=0;i<S_list.length;i++){
          const S = BigInt(S_list[i]);
          let factor = null;

          if(Nbi !== null){
            // --- BigInt Path (Fast) ---
            const Dsq = S*S - 4n * Nbi; // Calculate Discriminant Squared (D^2)
            if(Dsq >= 0n){
              const D = customIntegerSqrt(Dsq); // Get potential D
              if(D !== null && D*D === Dsq){ // Step 4: Check if D^2 is a perfect square
                const f2 = (S - D) / 2n; // Factor X (smallest factor: Step 5 - Symmetry)
                
                // Step 6: Final check (N mod X == 0, implicitly verified by perfect square if no small factors missed)
                if(f2 > 1n && Nbi % f2 === 0n){
                  factor = { f1: ((S + D) / 2n).toString(), f2: f2.toString(), S: S.toString() };
                }
              }
            }
          } else {
            // --- Chunked Path (For extremely large N, relies on string manipulation for factors) ---
            // NOTE: We only allow the fast BigInt path for the perfect square check (Dsq) for stability.
            // A full chunked perfect square checker is too complex for this single file.
            // If N is > 700 digits, this path still runs, but relies on a simple BigInt Dsq check,
            // which will throw an error if Dsq itself is > 700 digits.

            try {
                const N_chunks = stringToChunks(N_str); 
                const S_chunks = stringToChunks(S.toString());
                
                const Dsq_bi = S*S - 4n * BigInt(N_str);
                if (Dsq_bi < 0n) continue;

                const D_res_bi = customIntegerSqrt(Dsq_bi);
                if(D_res_bi !== null && D_res_bi*D_res_bi === Dsq_bi) {
                    const D_chunks = stringToChunks(D_res_bi.toString());
                    const S_minus_D_chunks = subChunks(S_chunks, D_chunks);
                    if(isEvenChunk(S_minus_D_chunks)){
                      const f2_chunks = divideByTwoChunk(S_minus_D_chunks); // Factor X
                      if(cmpChunks(f2_chunks, stringToChunks('1')) > 0){
                        // Final check using chunked division/modulo (Step 6)
                        // NOTE: This chunked division is computationally expensive.
                        const div_res = {remainder: stringToChunks('1')}; // Placeholder
                        // const div_res = divRemChunks(N_chunks, f2_chunks); // (Disabled for stability, only BigInt N is fully supported)
                        
                        // We rely on the initial perfect square check for the large number path
                        // If BigInt(N_str) itself is too big, the Nbi path above fails, and this large path is limited.
                        // For the purpose of demonstration, we treat a passing Dsq check as a hit in the large number scenario.
                        // To be fully correct, we would need a full chunked division/modulo here.
                        
                        // If using BigInt for Nbi fails, we rely on string comparison logic for the factors (simplified):
                        const f2_str = chunksToString(f2_chunks);
                        const f1_str = chunksToString(divideByTwoChunk(addChunks(S_chunks, D_chunks)));

                        // To be safe, we only return factors if they are within the BigInt limit or rely on the previous BigInt path.
                        if (N_str.length < 700) { // Fallback check to ensure the factor calculation is valid
                            const N_check = BigInt(f1_str) * BigInt(f2_str);
                            if (N_check === BigInt(N_str)) {
                                factor = { f1: f1_str, f2: f2_str, S: S.toString() };
                            }
                        }
                      }
                    }
                }
            } catch(e) {
                // Ignore large number arithmetic errors and continue.
            }

          }

          if(factor){
            self.postMessage({ type:'resolveDone', factor: factor });
            return;
          }

          const prog = Math.floor(((i+1)/Math.max(1,total))*100);
          if(prog > lastProg){ lastProg = prog; self.postMessage({ type:'resolveProgress', progress: prog }); }
        }
        self.postMessage({ type:'resolveDone', factor: null });
      }
    } catch(err){
      self.postMessage({ type:'error', message: err && err.message ? err.message : String(err) });
    }
  };
}

/* ================
   Helper to create worker from function
   ================ */
function mkWorker(fn){
  const blob = new Blob(['(' + fn.toString() + ')()'], { type: 'application/javascript' });
  return new Worker(URL.createObjectURL(blob));
}

/* ====================================================
   Orchestration
   ==================================================== */

function stopAll(){
  if(!isRunning) return;
  isRunning = false;
  if(stopChecker) clearInterval(stopChecker);
  stopChecker = null;
  try{ if(sqrtWorker) { sqrtWorker.terminate(); sqrtWorker = null; } }catch(e){}
  (workers||[]).forEach(w => { try{ if(w) w.terminate(); }catch(e){} });
  workers = [];
  startBtn.disabled = false;
  stopBtn.disabled = true;
  setPhase('Idle', 0);
  setPreCheckStatus('Ready');
  log('Stopped. All workers terminated.');
}

function startSGSPhase(Smin, range){
  // ... (startSGSPhase logic remains the same, uses the updated worker)
  setPhase('Phase 2: SGS Filter (Quadratic Residue)', 0);
  const RANGE = BigInt(range);
  const start = Smin;
  const end = Smin + RANGE;
  const cores = navigator.hardwareConcurrency || 4;
  const totalS = end - start + 1n;
  const chunk = (totalS / BigInt(cores)) + 1n;
  candidateList = [];
  workers = new Array(cores).fill(null);
  
  stopChecker = setInterval(function(){
    if(!isRunning){ 
      log('Stop checker detected stop, killing workers.');
      stopAll();
    }
  }, 200);

  for(let i=0;i<cores;i++){
    const s = start + BigInt(i)*chunk;
    let e = s + chunk - 1n;
    if(s > end){ workers[i] = null; continue; }
    if(e > end) e = end;

    const ws = mkWorker(factorWorkerFn);
    workers[i] = ws;
    ws.onmessage = function(ev){
      const d = ev.data || {};
      if(d.type === 'filterProgress') setPhase('Phase 2: SGS Filter (Quadratic Residue)', d.progress);
      else if(d.type === 'filterDone'){
        candidateList = candidateList.concat(d.candidates || []);
        ws.terminate(); workers[i] = null;
        if(workers.every(w=>w===null)){
          clearInterval(stopChecker); stopChecker = null;
          candEl.textContent = candidateList.length.toString();
          log(`Phase 2 complete — ${candidateList.length} candidates passed the Sieve.`);
          if(candidateList.length === 0){
            log('No S-candidates found in range. Stopping.');
            stopAll();
          } else {
            startResolvePhase(candidateList);
          }
        }
      } else if(d.type === 'error'){
        log(`[FilterWorker ${i} ERROR] `+d.message);
        ws.terminate(); workers[i]=null;
        if(workers.every(w=>w===null)) stopAll();
      }
    };
    ws.postMessage({ mode:'filter', minS: s.toString(), maxS: e.toString(), N_str: N_str });
    log(`Worker ${i} assigned S [${s} .. ${e}]`);
  }
}

function startResolvePhase(list){
  // ... (startResolvePhase logic remains the same, uses the updated worker)
  setPhase('Phase 3: Discriminant Resolve (D² = S² - 4N)', 0);
  const cores = navigator.hardwareConcurrency || 4;
  const per = Math.ceil(list.length / cores);
  workers = new Array(cores).fill(null);

  stopChecker = setInterval(function(){
    if(!isRunning){
      log('Stop checker detected stop, killing workers.');
      stopAll();
    }
  }, 200);

  for(let i=0;i<cores;i++){
    const subset = list.slice(i*per, (i+1)*per);
    if(subset.length === 0) { workers[i] = null; continue; }
    const ws = mkWorker(factorWorkerFn);
    workers[i] = ws;
    ws.onmessage = function(ev){
      const d = ev.data || {};
      if(d.type === 'resolveProgress') setPhase('Phase 3: Discriminant Resolve', d.progress);
      else if(d.type === 'resolveDone'){
        if(d.factor){
          logFactor(d.factor.f1);
          logFactor(d.factor.f2);
          log('Factorization complete. Found factors from S=' + d.factor.S);
          workers.forEach(w=>{ try{ if(w) w.terminate(); }catch(e){} });
          workers = [];
          stopAll();
        } else {
          ws.terminate(); workers[i] = null;
          if(workers.every(w=>w===null)){
            clearInterval(stopChecker); stopChecker = null;
            log('Phase 3 complete — no factor found in the filtered list.');
            stopAll();
          }
        }
      } else if(d.type === 'error'){
        log(`[ResolveWorker ${i} ERROR] `+d.message);
        ws.terminate(); workers[i]=null;
        if(workers.every(w=>w===null)) stopAll();
      }
    };
    ws.postMessage({ mode:'resolve', S_list: subset, N_str: N_str });
  }
}


/* ====================================================
   Start button: Orchestration of All Phases
   ==================================================== */
startBtn.addEventListener('click', async function(){
  if(isRunning) return;
  // --- Validation ---
  const aVal = baseEl.value.trim();
  const bVal = expEl.value.trim();
  const cVal = addEl.value.trim();
  const rVal = rangeEl.value.trim();
  
  const aBi = parseBigInt(aVal);
  const bBi = parseBigInt(bVal);
  const cBi = parseBigInt(cVal);
  const range = rVal;

  if (aBi <= 1n) { log('Base must be > 1.'); return; }
  if (bBi < 0n) { log('Exponent must be non-negative.'); return; }
  if (Number(rVal) <= 0 || !Number.isFinite(Number(rVal))) { log('Range must be a positive integer.'); return; }
  
  // Reset state
  isRunning = true;
  startBtn.disabled = true;
  stopBtn.disabled = false;
  setPhase('Starting Pre-Checks...', 0);
  sminEl.textContent = 'Calculating...';
  ndigitsEl.textContent = 'Calculating...';
  factorsEl.textContent = 'None';
  candEl.textContent = '0';
  foundFactors.clear();

  const a = aBi;
  const b = bBi;
  const c = cBi;

  log('--- Starting Pre-Checks (Trial Div + Algebraic) ---');

  // --- Phase 0A/0B: Quick Checks ---
  const foundAlg = await checkAlgebraicFactors(a, b, c);
  const foundTrial = await trialDivision(a, b, c);

  if (foundAlg || foundTrial) {
    log('Pre-Checks found factors. Stopping factorization.');
    stopAll();
    return;
  }
  
  log('--- Pre-Checks Complete. Starting S-Search Phases ---');
  setPreCheckStatus('Pre-Checks Complete, starting S-Search');

  // --- Phase 1: Streaming Sqrt (N = a^b + c) ---
  setPhase('Phase 1: Calculating N and S_min', 0);
  sqrtWorker = mkWorker(sqrtWorkerFn);
  
  sqrtWorker.onmessage = function(ev){
    const d = ev.data || {};
    if(d.type === 'log') log('[SqrtWorker] ' + d.message);
    else if(d.type === 'progress') setPhase('Phase 1: Calculating N and S_min', d.value);
    else if(d.type === 'result'){
      N_str = d.N_str;
      ndigitsEl.textContent = N_str.length; // Update N digits display
      const rootStr = d.root;
      const remStr  = d.remainder || '0';
      const rootBig = BigInt(rootStr);
      const remBig  = BigInt(remStr);
      
      let smin = rootBig * 2n;
      if(remBig > 0n) smin += 1n; 
      if(smin % 2n !== 0n) smin += 1n; // S must be even if N is odd (which is typical for a^b+c)
      
      SMin = smin;
      sminEl.textContent = SMin.toString();
      log('Streaming sqrt complete. S_min = ' + SMin.toString());
      sqrtWorker.terminate(); 
      sqrtWorker = null;
      
      startSGSPhase(SMin, range);
    } else if(d.type === 'error'){
      log('[SqrtWorker ERROR] ' + d.message);
      stopAll();
    }
  };

  // start compute
  sqrtWorker.postMessage({
    mode: 'compute_sqrt',
    aStr: aVal,
    bStr: bVal,
    cStr: cVal
  });
});

stopBtn.addEventListener('click', function(){
  log('Stop requested by user. Terminating workers...');
  stopAll();
});

/* init */
setPhase('Idle', 0);
log('Ready. The tool is now compatible with any integer base (a).');
setPreCheckStatus('Ready');
</script>
</body>
</html>

