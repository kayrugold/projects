<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1.0"/>
<title>S-Factorizer: Recursive Parallel Search V11</title>
<script src="https://cdn.tailwindcss.com"></script>
<style>
  :root{
    --bg:#f3f4f6;
    --panel:#fff;
    --accent:#3b82f6;
    --good:#10b981;
    --bad:#ef4444;
    --log:#061124;
    --log-text:#9ff1c7;
  }
  body{font-family:Inter,system-ui,Segoe UI,Roboto,Arial;margin:0;background:var(--bg);padding:1rem;}
  .card{max-width:100%; margin:0 auto;background:var(--panel);padding:1.5rem;border-radius:12px;box-shadow:0 12px 30px rgba(0,0,0,.08);border-top:6px solid var(--accent);}
  h1{margin-top:0; margin-bottom:0.25rem;color:var(--accent); font-size:1.5rem; font-weight:700;}
  .subtitle{margin-bottom:1rem;color:#6b7280; font-size:0.875rem;}
  .grid-input{display:grid;grid-template-columns:repeat(2,1fr);gap:1rem;}
  @media (min-width: 640px) { .grid-input{grid-template-columns:repeat(4,1fr);} }
  input{padding:0.6rem;border-radius:6px;border:1px solid #d1d5db;font-size:1rem; width:100%; box-sizing:border-box;}
  label{display:block;font-size:0.8rem;color:#374151;margin-bottom:0.25rem; font-weight: 500;}
  .btn-group{display:flex;gap:0.75rem;margin-top:1rem; align-items:center;}
  button{padding:0.75rem 1rem;border-radius:8px;border:none;font-weight:600;cursor:pointer; transition: transform 0.1s, box-shadow 0.2s;}
  button:active{transform:translateY(1px);}
  .start{background:var(--good);color:white; box-shadow:0 4px 6px rgba(16, 185, 129, 0.4);}
  .stop{background:var(--bad);color:white; box-shadow:0 4px 6px rgba(239, 68, 68, 0.4);}
  .log-container{background:var(--log);color:var(--log-text);padding:0.75rem;border-radius:8px;height:12rem;overflow:auto;white-space:pre-wrap;margin-top:1rem; font-size:0.85rem;}
  .progress-container{height:0.75rem;background:#eef2ff;border-radius:999px;overflow:hidden;margin-top:0.5rem;}
  .progress-bar{height:100%;width:0;background:var(--accent);color:white;text-align:center;font-weight:700;font-size:0.75rem; transition: width 0.3s;}
  .stat-grid{display:grid;grid-template-columns:repeat(2,1fr);gap:1rem;margin-top:1rem;}
  @media (min-width: 640px) { .stat-grid{grid-template-columns:repeat(3,1fr);} }
  .stat-label{font-size:0.8rem;color:#475569;}
  .stat-value{font-weight:700;font-size:1.1rem;color:#1f2937;}
  .status-line{font-size:0.875rem;margin-top:0.75rem; padding: 0.5rem 0; color:#475569;}
</style>
</head>
<body>
  <div class="card">
    <h1>S-Factorizer (Automatic Recursion)</h1>
    <p class="subtitle">Utilizes **all available CPU cores** ($N_{cores} = \text{navigator.hardwareConcurrency}$) to run the **Quadratic Residue Filtering** (Phase 2) and Discriminant Check (Phase 3). Automatically factors the remaining co-factor.</p>

    <div class="grid-input">
      <div>
        <label>Base ($a$)</label>
        <input id="base" value="9188" placeholder="e.g., 2">
      </div>
      <div>
        <label>Exponent ($b$)</label>
        <input id="exp" value="1" placeholder="e.g., 32">
      </div>
      <div>
        <label>Addend ($c$)</label>
        <input id="add" value="-1" placeholder="e.g., -1">
      </div>
      <div>
        <label>Max S Range</label>
        <input id="range" value="10" placeholder="e.g., 20000000">
      </div>
    </div>

    <div id="preCheckStatus" class="status-line">Pre-Check Status: Ready</div>

    <div class="btn-group">
      <button id="startBtn" class="start shadow-lg hover:opacity-90">Run Factorization</button>
      <button id="stopBtn" class="stop shadow-lg" disabled>Stop</button>
      
      <div class="ml-auto text-right">
        <div class="stat-label">Phase: <span id="phase" class="font-bold text-gray-700">Idle</span></div>
        <div class="progress-container"><div id="bar" class="progress-bar">0%</div></div>
      </div>
    </div>

    <div class="stat-grid">
      <div>
        <div class="stat-label">Target $N$ Digits (Current)</div>
        <div id="ndigits" class="stat-value">N/A</div>
      </div>
      <div>
        <div class="stat-label">Calculated $S_{min} (\approx 2\sqrt{N})$</div>
        <div id="smin" class="stat-value">N/A</div>
      </div>
      <div>
        <div class="stat-label">Total Factors Found</div>
        <div id="factors" class="stat-value">None</div>
      </div>
      <div>
        <div class="stat-label">S-candidates (Filtered)</div>
        <div id="candidates" class="stat-value">0</div>
      </div>
    </div>

    <h3 class="text-base font-semibold mt-4 text-gray-700">Execution Log</h3>
    <pre id="log" class="log-container">Ready. Using <span id="coreCount">...</span> cores for parallel search.</pre>
  </div>

<script>
/* -------------------------
   Main thread control & UI
   ------------------------- */
const startBtn       = document.getElementById('startBtn');
const stopBtn        = document.getElementById('stopBtn');
const baseEl         = document.getElementById('base');
const expEl          = document.getElementById('exp');
const addEl          = document.getElementById('add');
const rangeEl        = document.getElementById('range');
const logEl          = document.getElementById('log');
const phaseEl        = document.getElementById('phase');
const barEl          = document.getElementById('bar');
const sminEl         = document.getElementById('smin');
const factorsEl      = document.getElementById('factors');
const candEl         = document.getElementById('candidates');
const ndigitsEl      = document.getElementById('ndigits');
const preCheckStatus = document.getElementById('preCheckStatus');
const coreCountEl    = document.getElementById('coreCount');

let sqrtWorker = null;
let workers = [];
let N_current_str = ''; // The current number being factored (the cofactor)
let SMin = 0n;
let candidateList = [];
let foundFactors = new Set();
let foundFactorsThisStage = new Set(); // Factors found during current stage (Phase 0, 3)
let isRunning = false;
let stopChecker = null;
const TRIAL_DIVISION_LIMIT = 1000;
const DYNAMIC_WORKER_COUNT = navigator.hardwareConcurrency || 4; 

// --- Utility Functions ---

function parseBigInt(str) {
  if (!str) return 0n;
  str = String(str).replace(/\s/g, '');
  if (str.includes('+')) {
    const terms = str.split('+');
    return terms.reduce((sum, term) => sum + parseBigInt(term), 0n);
  }
  if (str.includes('e') || str.includes('E')) {
    const parts = str.toLowerCase().split('e');
    try { return BigInt(parts[0]) * 10n ** BigInt(parts[1]); } catch(e) { return 0n; }
  }
  try { return BigInt(str); } catch(e) { return 0n; }
}
function powMod(base, exp, mod) {
  let result = 1n;
  base %= mod;
  if (base === 0n) return 0n;
  while (exp > 0n) {
    if ((exp & 1n) === 1n) result = (result * base) % mod;
    exp >>= 1n;
    base = (base * base) % mod;
  }
  return result;
}
function nthRoot(n, k) {
    if (n < 0n || k < 1n) return null;
    if (k === 1n) return n;
    let low = 1n;
    let high = n;
    while (low <= high) {
        const mid = (low + high) >> 1n;
        if (mid === 0n) { low = 1n; continue; }
        let power;
        try { power = mid ** k; } catch (e) { power = -1n; }
        if (power === n) return mid;
        else if (power > 0n && power < n) low = mid + 1n;
        else high = mid - 1n;
    }
    return null;
}
function log(msg){
  const t = new Date().toLocaleTimeString();
  logEl.textContent += `\n[${t}] ${msg}`;
  logEl.scrollTop = logEl.scrollHeight;
}
function setPhase(text, pct=0){
  phaseEl.textContent = text;
  barEl.style.width = pct + '%';
  barEl.textContent = pct.toFixed(2) + '%';
}
function setPreCheckStatus(msg, append = false) {
    if (append) {
        preCheckStatus.textContent += ` | ${msg}`;
    } else {
        preCheckStatus.textContent = `Pre-Check Status: ${msg}`;
    }
}
function logFactor(factor){
    const factorBig = BigInt(factor);
    if (factorBig <= 1n) return false;
    
    const factorStr = factorBig.toString();
    if (!foundFactors.has(factorStr)) {
        foundFactors.add(factorStr);
        foundFactorsThisStage.add(factorStr); // Track factors found in this stage
        let display = Array.from(foundFactors).join(' × ');
        factorsEl.textContent = display.length > 30 ? display.substring(0, 30) + '...' : display;
        log(`Non-trivial factor found: ${factorStr}`);
        return true;
    }
    return false;
}

// Global function to find the remaining cofactor from the current N
function findRemainingCofactor(N_str, newFactors) {
    let N_bi = BigInt(N_str);
    for (const factor of newFactors) {
        const factor_bi = BigInt(factor);
        if (factor_bi > 1n) {
            // Repeatedly divide N_bi by the factor until it's no longer divisible
            while (N_bi % factor_bi === 0n) {
                N_bi /= factor_bi;
            }
        }
    }
    return N_bi.toString();
}


async function checkAlgebraicFactors(a, b, c) {
    setPreCheckStatus('Checking algebraic factors...');
    let factorFound = false;

    if (c > 0n && (b & 1n) === 1n) {
        const d = nthRoot(c, b);
        if (d !== null) {
            const factor = a + d;
            if (logFactor(factor)) factorFound = true;
        }
    }

    if (c < 0n) {
        const c_abs = -c;
        const d = nthRoot(c_abs, b);
        if (d !== null) {
            const factor1 = a - d;
            if (logFactor(factor1)) factorFound = true;
            if ((b & 1n) === 0n) {
                const factor2 = a + d;
                if (logFactor(factor2)) factorFound = true;
            }
        }
    }
    setPreCheckStatus(factorFound ? 'Algebraic Check: Factors Found' : 'Algebraic Check: None');
    return factorFound;
}

async function trialDivision(N_bi) {
    setPreCheckStatus('', false);
    setPreCheckStatus(`Checking small primes up to ${TRIAL_DIVISION_LIMIT}...`);

    const limit = TRIAL_DIVISION_LIMIT;
    const isPrime = new Array(limit + 1).fill(true);
    isPrime[0] = isPrime[1] = false;
    for (let i = 2; i * i <= limit; i++) {
        if (isPrime[i]) {
            for (let j = i * i; j <= limit; j += i) isPrime[j] = false;
        }
    }
    const smallPrimes = [];
    for (let i = 3; i <= limit; i += 2) { 
        if (isPrime[i]) smallPrimes.push(BigInt(i));
    }
    smallPrimes.unshift(2n); // Add 2 for completeness

    let factorFound = false;
    for (const p of smallPrimes) {
        if (N_bi % p === 0n) {
            if (logFactor(p)) factorFound = true;
        }
    }
    setPreCheckStatus(factorFound ? 'Trial Division: Factors Found' : 'Trial Division: None', true);
    return factorFound;
}

/* ====================================================
   Worker functions (Core Arithmetic & Sqrt)
   ==================================================== */

function sqrtWorkerFn(){
  const CHUNK_DIGITS = 9;
  const BASE = 10 ** CHUNK_DIGITS;

  function trimChunks(a){ if(!Array.isArray(a)||a.length===0) return [0]; let i=0; while(i<a.length-1 && a[i]===0) i++; return a.slice(i); }
  function stringToChunks(s){
    s = (s||'').replace(/^\+/, '').trim(); if(s[0]==='+') s=s.slice(1);
    if(s.length===0) return [0];
    const pad = (CHUNK_DIGITS - (s.length % CHUNK_DIGITS)) % CHUNK_DIGITS;
    s = '0'.repeat(pad) + s;
    const out=[];
    for(let i=0;i<s.length;i+=CHUNK_DIGITS) out.push(parseInt(s.substring(i,i+CHUNK_DIGITS),10));
    return trimChunks(out);
  }
  function chunksToString(chunks){ chunks = trimChunks(chunks); if(chunks.length===1 && chunks[0]===0) return '0'; let s = String(chunks[0]); for(let i=1;i<chunks.length;i++) s += String(chunks[i]).padStart(CHUNK_DIGITS,'0'); return s; }
  function cmpChunks(a,b){ a=trimChunks(a); b=trimChunks(b); if(a.length!==b.length) return a.length>b.length?1:-1; for(let i=0;i<a.length;i++) if(a[i]!==b[i]) return a[i]>b[i]?1:-1; return 0; }
  function addChunks(a,b){ let ar=a.slice().reverse(), br=b.slice().reverse(), n=Math.max(ar.length,br.length), carry=0, out=[]; for(let i=0;i<n;i++){ let s=(ar[i]||0)+(br[i]||0)+carry; out.push(s%BASE); carry=Math.floor(s/BASE);} if(carry) out.push(carry); return trimChunks(out.reverse()); }
  function subChunks(a,b){ let ar=a.slice().reverse(), br=b.slice().reverse(), n=ar.length, borrow=0, out=[]; for(let i=0;i<n;i++){ let v=(ar[i]||0)-(br[i]||0)-borrow; if(v<0){ v+=BASE; borrow=1;} else borrow=0; out.push(v);} return trimChunks(out.reverse()); }
  function mulSmallChunks(a,s){ if(!Array.isArray(a)||a.length===0) return [0]; if(s===0) return [0]; let a_rev=a.slice().reverse(), carry=0, out=[]; for(let d of a_rev){ let p=d*s+carry; out.push(p%BASE); carry=Math.floor(p/BASE);} while(carry>0){ out.push(carry%BASE); carry=Math.floor(carry/BASE);} return trimChunks(out.reverse()); }
  function shiftChunks(a,k){ if(!Array.isArray(a)||a.length===0) return [0]; if(k<=0) return a.slice(); return a.concat(new Array(k).fill(0)); }
  function mulChunks(A,B){
    let a=A.slice().reverse(), b=B.slice().reverse(), len_a=a.length, len_b=b.length, res=new Array(len_a+len_b).fill(0), carry=0;
    for(let i=0;i<len_a;i++){ carry=0; for(let j=0;j<len_b;j++){ let p=a[i]*b[j]+res[i+j]+carry; res[i+j]=p%BASE; carry=Math.floor(p/BASE); } res[i+len_b]+=carry; }
    return trimChunks(res.reverse());
  }

  function streamingIntegerSqrt(N_str, onProgress){
    const groupDigits = CHUNK_DIGITS*2;
    let s = N_str.replace(/^\+/, '');
    if(s.length===0) s='0';
    const pad = (groupDigits - (s.length % groupDigits)) % groupDigits;
    s = '0'.repeat(pad) + s;
    const groups = [];
    for(let i=0;i<s.length;i+=groupDigits) groups.push(s.substring(i,i+groupDigits));
    let root=[0], remainder=[0];
    const total = groups.length;
    for(let idx=0; idx<groups.length; idx++){
      const g = groups[idx];
      const left = g.substring(0,CHUNK_DIGITS);
      const right = g.substring(CHUNK_DIGITS);
      const groupChunks = [parseInt(left,10), parseInt(right,10)];
      remainder = shiftChunks(remainder, 2);
      remainder = addChunks(remainder, trimChunks(groupChunks));
      let prefix = mulSmallChunks(root,2);
      let lo=0, hi=BASE-1, chosen=0;
      while(lo<=hi){
        const mid = Math.floor((lo+hi)/2);
        let t = shiftChunks(prefix,1);
        t = addChunks(t, [mid]);
        let trial = mulSmallChunks(t, mid);
        if(cmpChunks(trial, remainder) <= 0) { chosen = mid; lo = mid+1; } else hi = mid-1;
      }
      let chosenT = shiftChunks(prefix,1); chosenT = addChunks(chosenT, [chosen]);
      let trialChosen = mulSmallChunks(chosenT, chosen);
      remainder = subChunks(remainder, trialChosen);
      root = addChunks(mulSmallChunks(root,1), [chosen]);
      if(onProgress && (idx % 50 === 0)) {
        try{ onProgress((idx+1)/total*100); } catch(e){}
      }
    }
    return { root: chunksToString(root), remainder: chunksToString(remainder), digits: N_str.length };
  }

  function tryNativeSqrt(N_str){
    try {
      if(N_str.length < 700) {
        const Nbi = BigInt(N_str);
        let x = Nbi, y = (x + 1n) >> 1n;
        while(y < x) { x = y; y = (x + Nbi / x) >> 1n; }
        const rem = Nbi - x*x;
        return { root: x.toString(), remainder: rem.toString() };
      }
    } catch(e){}
    return null;
  }

  function calculateN_chunks(aStr, bStr, cStr){
    const a = stringToChunks(aStr);
    const b = BigInt(bStr);
    const c = stringToChunks(cStr);

    if (b === 0n) {
      return chunksToString(addChunks(stringToChunks('1'), c));
    }
    
    let result = stringToChunks('1');
    let base = a;
    let exp = b;
    
    while(exp > 0n){
        if((exp & 1n) === 1n){
            result = mulChunks(result, base);
        }
        base = mulChunks(base, base);
        exp >>= 1n;
    }

    function signAndAbs(s){ s = String(s).trim(); let sign=1; if(s[0]==='+')s=s.slice(1); if(s[0]==='-'){ sign=-1; s=s.slice(1); } s=s.replace(/^0+/, '') || '0'; return {sign, s}; }
    const c_signed = signAndAbs(cStr);
    const result_str = chunksToString(result);
    
    if (c_signed.sign > 0) {
        return chunksToString(addChunks(result, c));
    } else {
        const res_chunks = stringToChunks(result_str);
        const c_abs_chunks = stringToChunks(c_signed.s);
        
        if (cmpChunks(res_chunks, c_abs_chunks) >= 0) {
            return chunksToString(subChunks(res_chunks, c_abs_chunks));
        } else {
            const final_chunks = subChunks(c_abs_chunks, res_chunks);
            return '-' + chunksToString(final_chunks);
        }
    }
  }


  self.onmessage = function(ev){
    const data = ev.data || {};
    if(data.mode === 'compute_sqrt'){
        const N_str_source = data.N_str_source;
        let combined = '';

        if (data.isInitialRun) {
            // First run: Calculate N = a^b + c
            const aStr = String(data.aStr).trim();
            const bStr = String(data.bStr).trim();
            const cStr = String(data.cStr).trim();
            try {
                combined = calculateN_chunks(aStr, bStr, cStr);
            } catch (err) {
                self.postMessage({ type:'error', message: 'Calculation Error: ' + (err.message || String(err)) });
                return;
            }
        } else {
            // Recursive run: N_str is provided directly
            combined = N_str_source;
        }

        if(combined.startsWith('-')) { self.postMessage({ type:'error', message:'Target N is negative. Cannot factor.'}); return; }
        
        self.postMessage({ type:'log', message: `N digits: ${combined.length}` });
        
        const fast = tryNativeSqrt(combined);
        if(fast){ 
            self.postMessage({ type:'progress', value:100 }); 
            self.postMessage({ type:'result', root:fast.root, remainder:fast.remainder, N_str:combined }); 
            return; 
        }

        const res = streamingIntegerSqrt(combined, function(p){ self.postMessage({ type:'progress', value:p }); });
        self.postMessage({ type:'progress', value:100 });
        self.postMessage({ type:'result', root:res.root, remainder:res.remainder, N_str:combined });
    }
  };
}

function factorWorkerFn(){
  const CHUNK_DIGITS = 9;
  const BASE = 10 ** CHUNK_DIGITS;
  function trimChunks(a){ if(!Array.isArray(a)||a.length===0) return [0]; let i=0; while(i<a.length-1 && a[i]===0) i++; return a.slice(i); }
  function stringToChunks(s){ s=(s||'').replace(/^\+/, '').trim(); if(s.length===0) return [0]; const pad=(CHUNK_DIGITS-(s.length%CHUNK_DIGITS))%CHUNK_DIGITS; s='0'.repeat(pad)+s; const out=[]; for(let i=0;i<s.length;i+=CHUNK_DIGITS) out.push(parseInt(s.substring(i,i+CHUNK_DIGITS),10)); return trimChunks(out); }
  function chunksToString(chunks){ chunks=trimChunks(chunks); if(chunks.length===1 && chunks[0]===0) return '0'; let s=String(chunks[0]); for(let i=1;i<chunks.length;i++) s+=String(chunks[i]).padStart(CHUNK_DIGITS,'0'); return s; }
  function cmpChunks(a,b){ a=trimChunks(a); b=trimChunks(b); if(a.length!==b.length) return a.length>b.length?1:-1; for(let i=0;i<a.length;i++) if(a[i]!==b[i]) return a[i]>b[i]?1:-1; return 0; }
  function addChunks(a,b){ let ar=a.slice().reverse(), br=b.slice().reverse(), n=Math.max(ar.length,br.length), carry=0, out=[]; for(let i=0;i<n;i++){ let s=(ar[i]||0)+(br[i]||0)+carry; out.push(s%BASE); carry=Math.floor(s/BASE);} if(carry) out.push(carry); return trimChunks(out.reverse()); }
  function subChunks(a,b){ let ar=a.slice().reverse(), br=b.slice().reverse(), n=ar.length, borrow=0, out=[]; for(let i=0;i<n;i++){ let v=(ar[i]||0)-(br[i]||0)-borrow; if(v<0){ v+=BASE; borrow=1;} else borrow=0; out.push(v);} return trimChunks(out.reverse()); }
  function isZeroChunk(c){ c=trimChunks(c); return c.length===1 && c[0]===0; }
  function divideByTwoChunk(c){ c=trimChunks(c); if(isZeroChunk(c)) return [0]; let out=[], carry=0; for(let i=0;i<c.length;i++){ let v = carry * BASE + c[i]; out.push(Math.floor(v/2)); carry = v % 2;} return trimChunks(out); }
  function customIntegerSqrt(n){ if(n<0n) return null; if(n<2n) return n; let x=n, y=(x+1n)>>1n; while(y<x){ x=y; y=(x + n/x)>>1n;} return x; }
  function powMod(base, exp, mod){ let res=1n; base%=mod; while(exp>0n){ if((exp & 1n) === 1n) res=(res*base)%mod; exp >>=1n; base=(base*base)%mod;} return res; }
  function legendreSymbol(a,p){ if(a===0n) return 0; if(p===2n) return 1; a=(a%p + p)%p; const ls = powMod(a, (p-1n)/2n, p); if(ls===p-1n) return -1; return 1; }
  
  // Custom chunked sqrt for perfect square check in resolve
  function chunkedIntegerSqrt(chunks){
    const s = chunksToString(chunks);
    if(s.length < 700){
      try {
        const nbi = BigInt(s);
        let x = nbi, y = (x + 1n) >> 1n;
        while(y < x) { x = y; y = (x + nbi / x) >> 1n; }
        return { root: x.toString(), isPerfect: nbi === x*x };
      } catch(e) {}
    }
    // For numbers > 700 digits, we fall back to a basic check for perfect square
    // This is a known limitation when moving from the Streaming Sqrt approach.
    // However, the worker can't initiate the Streaming Sqrt itself.
    return null; 
  }

  // Chunked division for final factor check
  function divRemChunks(N, D) {
      let n = N.slice(), d = D.slice();
      if (isZeroChunk(d)) return { quotient: [0], remainder: n };
      if (cmpChunks(n, d) < 0) return { quotient: [0], remainder: n };
      let quotient = [];
      let remainder = [];
      let d_len = trimChunks(d).length;
      remainder = n.slice(0, d_len - 1);
      for (let i = d_len - 1; i < n.length; i++) {
          remainder.push(n[i]);
          remainder = trimChunks(remainder);
          let lo = 0, hi = BASE - 1, q = 0;
          let best_rem = remainder.slice();
          let rem_head = remainder[0] * BASE + (remainder[1] || 0);
          let div_head = d[0];
          let q_est = Math.floor(rem_head / div_head);
          lo = Math.max(0, q_est - 2); 
          hi = Math.min(BASE - 1, q_est + 2);
          while (lo <= hi) {
              let mid = Math.floor((lo + hi) / 2);
              let trial = mulSmallChunks(d, mid);
              if (cmpChunks(trial, remainder) <= 0) {
                  q = mid;
                  best_rem = subChunks(remainder, trial);
                  lo = mid + 1;
              } else {
                  hi = mid - 1;
              }
          }
          quotient.push(q);
          remainder = best_rem;
      }
      return { quotient: trimChunks(quotient), remainder: trimChunks(remainder) };
  }
  
  self.onmessage = function(ev){
    const data = ev.data || {};
    try {
      if(data.mode === 'filter'){
        const minS = BigInt(data.minS);
        const maxS = BigInt(data.maxS);
        const N_str = data.N_str;
        const primes = [3n,5n,7n,11n,13n,17n]; 
        let candidates = [];
        const total = maxS - minS + 1n; 
        let lastProg = -1;
        
        const Nmods = {};
        for(let p of primes){
          let mod = 0n;
          for(let i=0;i<N_str.length;i++) mod = (mod*10n + BigInt(N_str.charCodeAt(i) - 48)) % p;
          Nmods[p.toString()] = mod;
        }
        
        for(let S = minS; S <= maxS; S+=2n){ // S must be even
          const Ssq = S*S;
          let passes = true;
          for(let p of primes){
            const Nmodp = Nmods[p.toString()];
            const Dmodp = ( (Ssq % p) - (4n * Nmodp) % p + (p*10n) ) % p;
            
            if(legendreSymbol(Dmodp, p) === -1){ passes = false; break; }
          }
          if(passes) candidates.push(S.toString());
          
          if(total > 0n && (S - minS) % 2000n === 0n) {
            const prog = Number((S - minS) * 100n / total);
            if(prog > lastProg){ lastProg = prog; self.postMessage({ type:'filterProgress', progress: prog }); }
          }
        }
        self.postMessage({ type:'filterDone', candidates });

      } else if(data.mode === 'resolve'){
        const S_list = data.S_list || [];
        const N_str = data.N_str;
        
        let Nbi = null;
        try { if(N_str.length < 700) Nbi = BigInt(N_str); } catch(e){}
        const N_chunks = stringToChunks(N_str); 
        const N_chunks_4 = mulSmallChunks(N_chunks, 4); 
        
        const total = S_list.length;
        let lastProg = -1;

        for(let i=0;i<S_list.length;i++){
          const S = BigInt(S_list[i]);
          let factor = null;

          if(Nbi !== null){
            // --- BigInt Path (Fast Fermat for small N) ---
            const Dsq = S*S - 4n * Nbi;
            if(Dsq >= 0n){
              const D = customIntegerSqrt(Dsq);
              if(D !== null && D*D === Dsq){
                const f2 = (S - D) / 2n;
                if(f2 > 1n && Nbi % f2 === 0n){
                  factor = { f1: ((S + D) / 2n).toString(), f2: f2.toString(), S: S.toString() };
                }
              }
            }
          } else {
            // --- Chunked Resolution Path (For huge N) ---
            const S_chunks = stringToChunks(S.toString());
            const S_chunks_sq = mulChunks(S_chunks, S_chunks); 
            
            if(cmpChunks(S_chunks_sq, N_chunks_4) >= 0){
              const Dsq_chunks = subChunks(S_chunks_sq, N_chunks_4);
              const D_res = chunkedIntegerSqrt(Dsq_chunks); 
              
              if(D_res && D_res.isPerfect){
                const D_chunks = stringToChunks(D_res.root);
                
                const S_plus_D_chunks = addChunks(S_chunks, D_chunks);
                const S_minus_D_chunks = subChunks(S_chunks, D_chunks);

                if(isEvenChunk(S_plus_D_chunks) && isEvenChunk(S_minus_D_chunks)){
                  const f1_chunks = divideByTwoChunk(S_plus_D_chunks);
                  const f2_chunks = divideByTwoChunk(S_minus_D_chunks);
                  
                  if(cmpChunks(f2_chunks, stringToChunks('1')) > 0){
                    // Final check using chunked division/modulo
                    const div_res = divRemChunks(N_chunks, f2_chunks);
                    if(isZeroChunk(div_res.remainder)){
                      factor = { 
                          f1: chunksToString(f1_chunks), 
                          f2: chunksToString(f2_chunks), 
                          S: S.toString() 
                      };
                    }
                  }
                }
              }
            }
          }

          if(factor){
            self.postMessage({ type:'resolveDone', factor: factor });
            return;
          }

          const prog = Math.floor(((i+1)/Math.max(1,total))*100);
          if(prog > lastProg){ lastProg = prog; self.postMessage({ type:'resolveProgress', progress: prog }); }
        }
        self.postMessage({ type:'resolveDone', factor: null });
      }
    } catch(err){
      self.postMessage({ type:'error', message: err && err.message ? err.message : String(err) });
    }
  };
}

/* ====================================================
   Helper to create worker from function
   ==================================================== */
function mkWorker(fn){
  const blob = new Blob(['(' + fn.toString() + ')()'], { type: 'application/javascript' });
  return new Worker(URL.createObjectURL(blob));
}

/* ====================================================
   Orchestration Functions
   ==================================================== */

function stopAll(){
  if(!isRunning) return;
  isRunning = false;
  if(stopChecker) clearInterval(stopChecker);
  stopChecker = null;
  try{ if(sqrtWorker) { sqrtWorker.terminate(); sqrtWorker = null; } }catch(e){}
  (workers||[]).forEach(w => { try{ if(w) w.terminate(); }catch(e){} });
  workers = [];
  startBtn.disabled = false;
  stopBtn.disabled = true;
  setPhase('Idle', 0);
  setPreCheckStatus('Ready');
  log('Stopped. All workers terminated.');
}

function getEvenSearchRanges(Smin, Smax, numWorkers) {
    const totalRange = Smax - Smin;
    if (totalRange <= 0n) return [];
    
    const baseChunk = totalRange / BigInt(numWorkers);
    const remainder = totalRange % BigInt(numWorkers);
    
    let currentS = Smin;
    const ranges = [];

    // Ensure Smin starts on an even number
    if (Smin % 2n !== 0n) Smin += 1n;
    
    for (let i = 0; i < numWorkers; i++) {
        let chunkSize = baseChunk;
        if (i < remainder) {
            chunkSize += 1n; 
        }

        let start = currentS;
        let end = start + chunkSize;
        
        // Ensure end stays within Smax and is even
        if (end > Smax) end = Smax;
        if (end % 2n !== 0n && end > Smin) end -= 1n;
        
        if (start <= end) {
            ranges.push({ name: `Worker ${i+1}`, start: start, end: end });
        }
        
        currentS = end + 2n;
    }
    
    // Safety check: ensure the last worker covers up to Smax if Smax is even
    if (ranges.length > 0 && ranges[ranges.length - 1].end < Smax && Smax % 2n === 0n) {
        ranges[ranges.length - 1].end = Smax;
    }

    return ranges;
}


// Entry point for the core factorization steps (Phases 0, 1, 2, 3)
async function startFactorizationStage(current_N_str, range) {
    if (!isRunning) return;

    N_current_str = current_N_str;
    const N_bi = BigInt(N_current_str);

    // Stop condition 1: Number is reduced to 1
    if (N_bi === 1n) {
        log('\n--- FINAL RESULT ---');
        log('All factors found. Original N is fully reduced.');
        stopAll();
        return;
    }

    // Stop condition 2: Number is too small (assumed prime/fully factored)
    if (N_bi <= BigInt(TRIAL_DIVISION_LIMIT * TRIAL_DIVISION_LIMIT)) {
        log(`Current N is small (${N_current_str.length} digits). Assuming it is prime or semi-prime.`);
        logFactor(N_bi); // Add the small remaining number as a factor
        startNextRecursionStep();
        return;
    }

    // Reset tracking for this stage
    foundFactorsThisStage.clear();
    ndigitsEl.textContent = N_current_str.length;
    log(`\n--- STARTING STAGE: Factoring N (${N_current_str.length} digits) ---`);

    // --- Phase 0B: Trial Division (Algebraic check only runs on initial input) ---
    await trialDivision(N_bi);
    
    if (foundFactorsThisStage.size > 0) {
        log(`Phase 0 found ${foundFactorsThisStage.size} small factor(s). Recursing.`);
        startNextRecursionStep();
        return;
    }

    // --- Phase 1: Sqrt Calculation (Only runs if no small factors found) ---
    setPhase('Phase 1: Calculating S_min', 0);
    sminEl.textContent = 'Calculating...';
    
    sqrtWorker = mkWorker(sqrtWorkerFn);
    
    sqrtWorker.onmessage = function(ev){
        const d = ev.data || {};
        if(d.type === 'log') log('[SqrtWorker] ' + d.message);
        else if(d.type === 'progress') setPhase('Phase 1: Calculating S_min', d.value);
        else if(d.type === 'result'){
            const rootStr = d.root;
            const remStr  = d.remainder || '0';
            const rootBig = BigInt(rootStr);
            const remBig  = BigInt(remStr);
            
            let smin = rootBig * 2n;
            if(remBig > 0n) smin += 1n; 
            if(smin % 2n !== 0n) smin += 1n; // S must be even
            
            SMin = smin;
            sminEl.textContent = SMin.toString();
            log('Streaming sqrt complete. S_min = ' + SMin.toString());
            sqrtWorker.terminate(); 
            sqrtWorker = null;
            
            startSGSPhase(SMin, range); // Go to Phase 2
        } else if(d.type === 'error'){
            log('[SqrtWorker ERROR] ' + d.message);
            stopAll();
        }
    };
    
    // Start compute on the current N_str
    sqrtWorker.postMessage({
        mode: 'compute_sqrt',
        N_str_source: current_N_str,
        isInitialRun: false
    });
}

function startSGSPhase(Smin, range){
    setPhase('Phase 2: SGS Filter (Quadratic Residue)', 0);
    const RANGE = BigInt(range);
    const Smax = Smin + RANGE;
    const numWorkers = DYNAMIC_WORKER_COUNT;
    
    const searchRanges = getEvenSearchRanges(Smin, Smax, numWorkers);
    
    if (searchRanges.length === 0) {
        log('Range too small or invalid. Exhausted search range.');
        startNextRecursionStep();
        return;
    }
    
    candidateList = [];
    workers = new Array(searchRanges.length).fill(null);
    
    stopChecker = setInterval(function(){
      if(!isRunning){ log('Stop checker detected stop, killing workers.'); stopAll(); }
    }, 200);

    for(let i=0;i<searchRanges.length;i++){
      const { name, start, end } = searchRanges[i];
      const ws = mkWorker(factorWorkerFn);
      workers[i] = ws;
      ws.onmessage = function(ev){
        const d = ev.data || {};
        if(d.type === 'filterProgress') {
          setPhase(`Phase 2: SGS Filter (${name})`, d.progress);
        }
        else if(d.type === 'filterDone'){
          candidateList = candidateList.concat(d.candidates || []);
          ws.terminate(); workers[i] = null;
          log(`${name} complete. Found ${d.candidates.length} candidates.`);
          if(workers.every(w=>w===null)){
            clearInterval(stopChecker); stopChecker = null;
            candEl.textContent = candidateList.length.toString();
            log(`Phase 2 complete — ${candidateList.length} candidates passed the Sieve.`);
            if(candidateList.length === 0){
              log('No S-candidates found in the filter range.');
              startNextRecursionStep();
            } else {
              startResolvePhase(candidateList);
            }
          }
        } else if(d.type === 'error'){
          log(`[FilterWorker ${name} ERROR] `+d.message);
          ws.terminate(); workers[i]=null;
          if(workers.every(w=>w===null)) stopAll();
        }
      };
      ws.postMessage({ mode:'filter', minS: start.toString(), maxS: end.toString(), N_str: N_current_str });
      log(`${name} assigned S [${start} .. ${end}]`);
    }
}

function startResolvePhase(list){
    setPhase('Phase 3: Discriminant Resolve (D² = S² - 4N)', 0);
    
    const cores = DYNAMIC_WORKER_COUNT; 
    const per = Math.ceil(list.length / cores);
    workers = new Array(cores).fill(null);

    stopChecker = setInterval(function(){
      if(!isRunning){ log('Stop checker detected stop, killing workers.'); stopAll(); }
    }, 200);

    for(let i=0;i<cores;i++){
      const subset = list.slice(i*per, (i+1)*per);
      if(subset.length === 0) { workers[i] = null; continue; }
      
      const ws = mkWorker(factorWorkerFn);
      workers[i] = ws;
      ws.onmessage = function(ev){
        const d = ev.data || {};
        if(d.type === 'resolveProgress') setPhase(`Phase 3: Discriminant Resolve (Worker ${i+1})`, d.progress);
        else if(d.type === 'resolveDone'){
          if(d.factor){
            logFactor(d.factor.f1);
            logFactor(d.factor.f2);
            log('Factorization found via S-Search at S=' + d.factor.S);
            workers.forEach(w=>{ try{ if(w) w.terminate(); }catch(e){} });
            workers = [];
            startNextRecursionStep(); // Found factor, restart process
          } else {
            ws.terminate(); workers[i] = null;
            if(workers.every(w=>w===null)){
              clearInterval(stopChecker); stopChecker = null;
              log('Phase 3 complete — no factor found in the filtered list.');
              startNextRecursionStep(); // No factor found, advance to next stage
            }
          }
        } else if(d.type === 'error'){
          log(`[ResolveWorker ${i+1} ERROR] `+d.message);
          ws.terminate(); workers[i]=null;
          if(workers.every(w=>w===null)) stopAll();
        }
      };
      ws.postMessage({ mode:'resolve', S_list: subset, N_str: N_current_str });
    }
}

function startNextRecursionStep() {
    // 1. Calculate the current co-factor
    const old_N = N_current_str;
    const factors_to_remove = Array.from(foundFactorsThisStage);
    const new_N_str = findRemainingCofactor(old_N, factors_to_remove);
    const new_N_bi = BigInt(new_N_str);

    // 2. Clear stage-specific factors
    foundFactorsThisStage.clear();

    // 3. Check for final termination
    if (new_N_bi === 1n) {
        log('\n--- FINAL RESULT ---');
        log('All factors found. Original N is fully reduced.');
        stopAll();
        return;
    }
    
    // 4. Check if the remaining cofactor is irreducible by this method (Range Exhausted)
    // This check means: did the S-Search run on a large number AND failed to find factors?
    if (new_N_str.length === old_N.length && factors_to_remove.length === 0) {
        log(`\n--- SEARCH RANGE EXHAUSTED ---`);
        log(`Current number has ${N_current_str.length} digits. No factors found in the S-Search window.`);
        log(`The remaining number is too large to factor in this range or is prime.`);
        logFactor(N_current_str); // Add the large remaining number as a factor for display
        stopAll();
        return;
    }
    
    // 5. If factors were found, or if this is the first run, proceed to the next stage
    N_current_str = new_N_str;
    const originalRange = rangeEl.value.trim();
    
    startFactorizationStage(N_current_str, originalRange);
}


/* ====================================================
   Initial Run Handler
   ==================================================== */
startBtn.addEventListener('click', async function(){
    if(isRunning) return;
    
    // 1. Validation and Setup
    const aVal = baseEl.value.trim();
    const bVal = expEl.value.trim();
    const cVal = addEl.value.trim();
    const rVal = rangeEl.value.trim();
    
    const aBi = parseBigInt(aVal);
    const bBi = parseBigInt(bVal);
    const cBi = parseBigInt(cVal);
    
    if (aBi === 0n) { log('Base must be non-zero.'); return; }
    if (bBi < 0n) { log('Exponent must be non-negative.'); return; }
    if (Number(rVal) <= 0 || !Number.isFinite(Number(rVal))) { log('Range must be a positive integer.'); return; }
    
    isRunning = true;
    startBtn.disabled = true;
    stopBtn.disabled = false;
    foundFactors.clear();
    foundFactorsThisStage.clear();
    setPhase('Starting Initial Calculation...', 0);

    // 2. Initial N Calculation (a^b + c)
    log('--- STARTING INITIAL N CALCULATION ---');
    
    const initialCalcWorker = mkWorker(sqrtWorkerFn);
    initialCalcWorker.onmessage = async function(ev) {
        const d = ev.data || {};
        if (d.type === 'log') log('[CalcWorker] ' + d.message);
        else if (d.type === 'result') {
            const initial_N_str = d.N_str;
            const initial_N_bi = BigInt(initial_N_str);
            initialCalcWorker.terminate();
            
            // --- Phase 0A: Algebraic Checks (Only on original N) ---
            await checkAlgebraicFactors(aBi, bBi, cBi);
            
            // 3. Start the recursive factorization with the initial N
            startFactorizationStage(initial_N_str, rVal);

        } else if (d.type === 'error') {
            log('[CalcWorker ERROR] ' + d.message);
            initialCalcWorker.terminate();
            stopAll();
        }
    };
    initialCalcWorker.postMessage({
        mode: 'compute_sqrt',
        aStr: aVal,
        bStr: bVal,
        cStr: cVal,
        isInitialRun: true
    });
});

stopBtn.addEventListener('click', function(){
  log('Stop requested by user. Terminating workers...');
  stopAll();
});

/* init */
coreCountEl.textContent = `${DYNAMIC_WORKER_COUNT} (${navigator.hardwareConcurrency})`
setPhase('Idle', 0);
log('Ready. The tool is now configured for automatic recursive factoring.');
setPreCheckStatus('Ready');
</script>
</body>
</html>
