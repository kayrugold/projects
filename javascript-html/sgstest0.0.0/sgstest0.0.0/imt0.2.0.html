<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Infinite Multiplication Table v0.2.3 (Header Flow Fixed)</title>
    <script src="https://unpkg.com/big-integer@1.6.48/BigInteger.min.js"></script>
    <style>
        :root {
            --bg-color: #1a1a1a;
            --grid-bg: #2c2c2c;
            --text-color: #e5e7eb;
            --placeholder-text: #6b7280;
            --header-bg: #111;
            --header-text: #fff;
            --header-prime: #f72585;
            --header-blue: #4361ee;
            --header-probable: #facc15;
            --highlight-blue: rgba(67, 97, 238, 0.5);
            --grid-line: #333;
            --controls-bg: rgba(20, 20, 20, 0.8);
            --log-text-color: #9ca3af;
            --terminal-bg: #0d0d0d;
            --terminal-text: #00ff41;
            --terminal-prime: #f72585;
            --terminal-probable: #facc15;
            --terminal-composite: #4361ee;
        }
        html, body {
            margin: 0; padding: 0; overflow: hidden;
            width: 100%; height: 100%;
            background-color: var(--bg-color); color: var(--text-color);
            font-family: system-ui, sans-serif;
            user-select: none; touch-action: none;
        }
        canvas {
            display: block; background-color: var(--grid-bg);
            touch-action: none; position: fixed; top: 0; left: 0;
        }
        #controls {
            position: fixed; bottom: 0; left: 0; width: 100%;
            background: var(--controls-bg); backdrop-filter: blur(5px);
            border-top: 1px solid var(--grid-line); z-index: 10;
            transition: all 0.3s ease-in-out; overflow: hidden;
        }
        #controlsHandle {
            display: flex; justify-content: space-between; align-items: center;
            padding: 10px; cursor: pointer; font-weight: bold;
        }
        #zoomInfo { font-size: 0.9em; color: #aaa; }
        #controlsContent {
            padding: 10px; display: flex; flex-wrap: wrap;
            gap: 10px; align-items: center; border-top: 1px solid #444;
        }
        #controls.collapsed #controlsContent { display: none; }
        #controls label { font-weight: bold; font-size: 1.1em; }
        #controls input {
            background: #333; color: var(--text-color);
            border: 1px solid #555; border-radius: 5px;
            padding: 8px; font-size: 1em; width: 100px;
        }
        #controls button {
            background: var(--header-blue); color: white;
            border: none; border-radius: 5px;
            padding: 8px 12px; font-weight: bold;
            cursor: pointer; font-size: 1em;
        }
        #controls button:hover { background: #3a52cc; }
        
        #terminal {
            position: fixed;
            bottom: -100%;
            left: 0;
            width: 100%;
            max-height: 40%;
            background: var(--terminal-bg);
            border-top: 1px solid var(--header-prime);
            box-shadow: 0 -5px 20px rgba(0,0,0,0.5);
            z-index: 20;
            transition: bottom 0.3s ease-in-out;
            display: flex;
            flex-direction: column;
        }
        #terminal.active {
            bottom: 0;
        }
        #terminalHeader {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: #222;
            color: var(--header-text);
            font-weight: bold;
        }
        #terminalTitle { flex-grow: 1; }
        #terminalButtons { display: flex; gap: 10px; }
        .terminalBtn {
            background: #444;
            color: #fff;
            border: 1px solid #666;
            border-radius: 4px;
            padding: 4px 8px;
            cursor: pointer;
            font-size: 0.8em;
        }
        .terminalBtn:hover { background: #555; }
        #terminalClose {
            cursor: pointer;
            font-size: 1.2em;
            padding: 0 5px;
            margin-left: 10px;
        }
        #terminalContent {
            padding: 12px;
            font-family: 'Courier New', Courier, monospace;
            color: var(--terminal-text);
            overflow-y: auto;
            white-space: pre-wrap;
            word-break: break-all;
            flex-grow: 1;
        }
        .status-prime { color: var(--header-prime); }
        .status-probable { color: var(--header-probable); }
        .status-composite { color: var(--header-blue); }
    </style>
</head>
<body>

    <canvas id="gridCanvas"></canvas>

    <div id="controls" class="collapsed">
        <div id="controlsHandle">
            <span>Controls</span>
            <span id="zoomInfo">Zoom: 1.00x</span>
        </div>
        <div id="controlsContent">
            <label for="xInput">X:</label>
            <input type="text" id="xInput" value="1" inputmode="text">
            <label for="yInput">Y:</label>
            <input type="text" id="yInput" value="1" inputmode="text">
            <button id="goButton">Go</button>
        </div>
    </div>
    
    <div id="terminal">
        <div id="terminalHeader">
            <span id="terminalTitle">Cell Details</span>
            <div id="terminalButtons">
                <button id="calcFullBtn" class="terminalBtn" style="display:none;">Calculate Full Value</button>
                <button id="copyTermBtn" class="terminalBtn">Copy</button>
            </div>
            <span id="terminalClose">&times;</span>
        </div>
        <pre id="terminalContent">Loading...</pre>
    </div>

    <script>
        // --- Web Worker Code (as a string) ---
        const workerCode = " \
            self.importScripts('https://unpkg.com/big-integer@1.6.48/BigInteger.min.js'); \
 \
            const SMALL_PRIMES = [3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53]; \
 \
            function powMod(base, exp, mod) { \
                if (mod === null) return base.pow(exp); \
                let result = self.bigInt.one; \
                base = base.mod(mod); \
                while (exp.greater(0)) { \
                    if (exp.isOdd()) result = result.multiply(base).mod(mod); \
                    exp = exp.shiftRight(1); \
                    base = base.square().mod(mod); \
                } \
                return result; \
            } \
 \
            function getComponents(obj) { \
                if (obj.val) { \
                    return [self.bigInt(obj.val), self.bigInt.zero, self.bigInt.zero]; \
                } else { \
                    return [self.bigInt(obj.a), self.bigInt(obj.b), self.bigInt(obj.c)]; \
                } \
            } \
             \
            function getMagnitude(obj) { \
                if (obj.val) return obj.val.length; \
                return parseInt(obj.b, 10) + obj.a.length - 1; \
            } \
 \
            function getBigInt(obj, force = false) { \
                const b_bi = obj.b ? self.bigInt(obj.b) : self.bigInt.zero; \
                if (!force && b_bi.greater(200)) { \
                    throw new Error('Exponent too large for direct calculation'); \
                } \
                const [a, b, c] = getComponents(obj); \
                if (b.isZero()) return a; \
                return powMod(self.bigInt(10), b, null).multiply(a).add(c); \
            } \
             \
            function millerRabinTest(n, k = 10) { \
                if (n.equals(2) || n.equals(3)) return true; \
                if (n.lesser(2) || n.isEven()) return false; \
                if (n.toString().length > 200) k = 2;  \
                let d = n.subtract(1); \
                let s = 0; \
                while (d.isEven()) { d = d.shiftRight(1); s++; } \
                for (let i = 0; i < k; i++) { \
                    const a = self.bigInt.randBetween(2, n.subtract(2)); \
                    let x = powMod(a, d, n); \
                    if (x.equals(1) || x.equals(n.subtract(1))) continue; \
                    let composite = true; \
                    for (let j = 1; j < s; j++) { \
                        x = x.square().mod(n); \
                        if (x.equals(1)) break; \
                        if (x.equals(n.subtract(1))) { composite = false; break; } \
                    } \
                    if (composite) return false; \
                } \
                return true; \
            } \
             \
            function primeCheckStream(n_obj) { \
                const [A, B, C] = getComponents(n_obj); \
                const TEN = self.bigInt(10); \
                if (A.isZero() && C.isZero()) return false; \
                if (B.isZero()) return millerRabinTest(A.add(C)); \
                let lastDigitC = C.mod(10); \
                if (B.greater(0)) { \
                    if (!C.isEven()) return false; \
                } else { \
                    if (!A.add(C).isEven()) return false; \
                } \
                for (let p_val of SMALL_PRIMES) { \
                    const p = self.bigInt(p_val); \
                    const A_mod_p = A.mod(p); \
                    const C_mod_p = C.mod(p); \
                    const Pow_mod_p = powMod(TEN, B, p); \
                    const N_mod_p = A_mod_p.multiply(Pow_mod_p).add(C_mod_p).mod(p); \
                    if (N_mod_p.isZero()) { \
                        return false; \
                    } \
                } \
                return true; \
            } \
 \
            function getProductString(x_obj, y_obj) { \
                const xMag = getMagnitude(x_obj); \
                const yMag = getMagnitude(y_obj); \
                let approxDigits = xMag + yMag - 1; \
 \
                if (approxDigits >= 21) { \
                    const [Ax, Bx, Cx] = getComponents(x_obj); \
                    const [Ay, By, Cy] = getComponents(y_obj); \
                    let New_A = Ax.multiply(Ay); \
                    const New_B = Bx.add(By); \
                    let coeffStr = New_A.toString(); \
                    if (coeffStr.length > 4) { \
                         coeffStr = New_A.toExponential(0).replace('e+0', ''); \
                    } \
                    return { text: '~' + coeffStr + 'e' + New_B.toString(), color: 'log' }; \
                } \
                const x = getBigInt(x_obj); \
                const y = getBigInt(y_obj); \
                const product = x.multiply(y); \
                if (approxDigits >= 9) { \
                    return { text: product.toExponential(2), color: 'normal' }; \
                } else { \
                    return { text: product.toString(), color: 'normal' }; \
                } \
            } \
 \
            function getPrimality(n_obj) { \
                const mag = getMagnitude(n_obj); \
                if (mag >= 200) { \
                    if (primeCheckStream(n_obj)) { \
                        return { isProbablePrime: true }; \
                    } else { \
                        return { isPrime: false }; \
                    } \
                } else { \
                    const n = getBigInt(n_obj); \
                    if (millerRabinTest(n)) { \
                        return { isPrime: true }; \
                    } else { \
                        return { isPrime: false }; \
                    } \
                } \
            } \
            \
            function getPrimalityStatusString(n_obj) { \
                const statusObj = getPrimality(n_obj); \
                if (statusObj.isPrime === true) return 'Prime'; \
                if (statusObj.isProbablePrime === true) return 'Probable Prime'; \
                return 'Composite'; \
            } \
 \
            function getDetails(x_obj, y_obj, force = false) { \
                const xMag = getMagnitude(x_obj); \
                const yMag = getMagnitude(y_obj); \
                const approxDigits = xMag + yMag - 1; \
                const x_id = x_obj.val ? x_obj.val : (x_obj.a + 'e' + x_obj.b + '+' + x_obj.c); \
                const y_id = y_obj.val ? y_obj.val : (y_obj.a + 'e' + y_obj.b + '+' + y_obj.c); \
                \
                if (!force && approxDigits >= 100) { \
                    const approxProduct = getProductString(x_obj, y_obj); \
                    return { \
                        mode: 'equation', \
                        x: x_id, \
                        y: y_id, \
                        approx: approxProduct.text \
                    }; \
                } \
                \
                /* --- Streaming String Path for Products (Limited to simple val * AeB+C) --- */ \
                if (!force && y_obj.val && x_obj.b && self.bigInt(x_obj.b).greater(x_obj.c.length)) { \
                    const [A, B, C] = getComponents(x_obj); \
                    const Y = self.bigInt(y_obj.val); \
                    const New_A = A.multiply(Y); \
                    const New_C = C.multiply(Y); \
                    const b_bi = self.bigInt(x_obj.b); \
                    const c_str = New_C.toString(); \
                    \
                    if (b_bi.greater(c_str.length)) { \
                        const numZeros = b_bi.subtract(c_str.length); \
                        const fullValue = New_A.toString() + '0'.repeat(numZeros) + c_str; \
                        return { mode: 'full', value: fullValue }; \
                    } \
                } \
                if (!force && x_obj.val && y_obj.b && self.bigInt(y_obj.b).greater(y_obj.c.length)) { \
                    const [A, B, C] = getComponents(y_obj); \
                    const X = self.bigInt(x_obj.val); \
                    const New_A = A.multiply(X); \
                    const New_C = C.multiply(X); \
                    const b_bi = self.bigInt(y_obj.b); \
                    const c_str = New_C.toString(); \
                    \
                    if (b_bi.greater(c_str.length)) { \
                        const numZeros = b_bi.subtract(c_str.length); \
                        const fullValue = New_A.toString() + '0'.repeat(numZeros) + c_str; \
                        return { mode: 'full', value: fullValue }; \
                    } \
                } \
                \
                const x = getBigInt(x_obj, force); \
                const y = getBigInt(y_obj, force); \
                const product = x.multiply(y); \
                return { \
                    mode: 'full', \
                    value: product.toString() \
                }; \
            } \
 \
            function getSingleValueDetails(n_obj) { \
                let value = '...'; \
                const status = getPrimalityStatusString(n_obj); \
                \
                try { \
                    /* Try streaming string path */ \
                    if (n_obj.b && self.bigInt(n_obj.b).greater(n_obj.c.length)) { \
                        const [A, B, C] = getComponents(n_obj); \
                        const b_bi = self.bigInt(n_obj.b); \
                        const c_str = n_obj.c; \
                        const numZeros = b_bi.subtract(c_str.length); \
                        value = A.toString() + '0'.repeat(numZeros) + c_str; \
                    } else { \
                        value = getBigInt(n_obj, false).toString(); \
                    } \
                } catch (e) { \
                    value = 'Error: Number too large to display full value.'; \
                } \
                \
                return { \
                    mode: 'single', \
                    value: value, \
                    status: status \
                }; \
            } \
 \
            self.onmessage = (e) => { \
                const tasks = e.data; \
                const results = []; \
                for (const task of tasks) { \
                    try { \
                        let data = {}; \
                        if (task.type === 'getProduct') { \
                            data = getProductString(task.x_obj, task.y_obj); \
                        } else if (task.type === 'getPrimality') { \
                            data = getPrimality(task.n_obj); \
                        } else if (task.type === 'getDetails') { \
                            data = getDetails(task.x_obj, task.y_obj, false); \
                        } else if (task.type === 'forceGetDetails') { \
                            data = getDetails(task.x_obj, task.y_obj, true); \
                        } else if (task.type === 'getSingleValueDetails') { \
                            data = getSingleValueDetails(task.n_obj); \
                        } \
                        results.push({ id: task.id, status: 'success', data: data }); \
                    } catch (err) { \
                        if (task.type.includes('Details')) { \
                             results.push({ id: task.id, status: 'error', data: { value: 'Error: ' + err.message } }); \
                        } else { \
                             results.push({ id: task.id, status: 'error', data: { text: 'ERR' } }); \
                        } \
                    } \
                } \
                self.postMessage(results); \
            }; \
        ";

        // --- Globals ---
        const canvas = document.getElementById('gridCanvas');
        const ctx = canvas.getContext('2d');
        const xInput = document.getElementById('xInput');
        const yInput = document.getElementById('yInput');
        const goButton = document.getElementById('goButton');
        const controlsPanel = document.getElementById('controls');
        const controlsHandle = document.getElementById('controlsHandle');
        const zoomInfo = document.getElementById('zoomInfo');
        const terminal = document.getElementById('terminal');
        const terminalContent = document.getElementById('terminalContent');
        const terminalClose = document.getElementById('terminalClose');
        const calcFullBtn = document.getElementById('calcFullBtn');
        const copyTermBtn = document.getElementById('copyTermBtn');

        let scale = 1.0, offsetX = 0.0, offsetY = 0.0, cellSize = 80;
        let gridOriginCol = { val: "1" };
        let gridOriginRow = { val: "1" };
        let highlightedCell = { x: { val: "1" }, y: { val: "1" } };
        let isPanning = false, lastPan = { x: 0, y: 0 }, lastTouchDist = 0;
        const colors = {};
        
        let activeDetailId = null;
        let activeDetailObjects = null;

        const cellCache = new Map();
        
        class WorkerManager {
            constructor(numWorkers) {
                this.requestQueue = new Map();
                this.workerIdle = new Array(numWorkers).fill(true);
                this.workers = [];
                const blob = new Blob([workerCode], { type: 'application/javascript' });
                const workerUrl = URL.createObjectURL(blob);
                for (let i = 0; i < numWorkers; i++) {
                    const worker = new Worker(workerUrl);
                    worker.onmessage = (e) => this.handleWorkerResult(e, i);
                    this.workers.push(worker);
                }
            }
            queueRequest(task) {
                if (task.id === activeDetailId && !this.workerIdle.every(Boolean)) return;
                if (!cellCache.has(task.id)) {
                    this.requestQueue.set(task.id, task);
                }
            }
            processQueue() {
                if (this.requestQueue.size === 0) return;
                const idleWorkerIndex = this.workerIdle.indexOf(true);
                if (idleWorkerIndex === -1) return;
                
                let tasks = Array.from(this.requestQueue.values());
                const detailTask = tasks.find(t => t.type.includes('Details'));
                const batch = detailTask ? [detailTask] : tasks.slice(0, 10);
                
                for(const task of batch) { this.requestQueue.delete(task.id); }
                if (batch.length > 0) {
                    this.workers[idleWorkerIndex].postMessage(batch);
                    this.workerIdle[idleWorkerIndex] = false;
                }
            }
            handleWorkerResult(e, workerIndex) {
                this.workerIdle[workerIndex] = true;
                const results = e.data;
                let needsRedraw = false;
                for (const result of results) {
                    if (result.status === 'success') {
                        if (result.id === activeDetailId) {
                            updateTerminal(result.data);
                        }
                        if (!result.id.startsWith('d:')) {
                             cellCache.set(result.id, result.data);
                        }
                        if (result.id.startsWith('p:') || result.id.startsWith('c:')) {
                            needsRedraw = true;
                        }
                    } else {
                        cellCache.set(result.id, { text: 'ERR' });
                        if (result.id === activeDetailId) {
                            updateTerminal({ mode: 'full', value: 'Error calculating value.' });
                        }
                    }
                }
                if (needsRedraw) {
                    requestAnimationFrame(draw);
                }
                if (this.requestQueue.size > 0) {
                    this.processQueue();
                }
            }
        }
        const workerManager = new WorkerManager(navigator.hardwareConcurrency || 2);
        
        function parseCoordinate(input) {
            const str = input.replace(/\s/g, '').replace(/[+\-]$/, '');
            let match = str.match(/^(\d+)\^(\d+)\+(\d+)$/);
            if (match) {
                if (match[1] === "10") return { a: "1", b: match[2], c: match[3] };
                throw new Error("Base-power format only supported for base 10.");
            }
            match = str.match(/^(\d*\.?\d*)e(\d+)\+(\d+)$/);
            if (match) return { a: (match[1] === '' ? '1' : match[1]), b: match[2], c: match[3] };
            match = str.match(/^(\d*\.?\d*)e(\d+)$/);
            if (match) return { a: (match[1] === '' ? '1' : match[1]), b: match[2], c: "0" };
            if (str.match(/^\d+$/)) return { val: str };
            throw new Error("Invalid number format");
        }

        function incrementCoord(coord_obj, i) {
            if (i === 0) return coord_obj;
            if (coord_obj.val) {
                return { val: bigInt(coord_obj.val).add(i).toString() };
            } else {
                return { a: coord_obj.a, b: coord_obj.b, c: bigInt(coord_obj.c).add(i).toString() };
            }
        }

        function getCoordID(obj) {
            if (obj.val) return obj.val;
            return `${obj.a}e${obj.b}+${obj.c}`;
        }
        
        function areCoordsEqual(obj1, obj2) {
            if (obj1.val && obj2.val) return obj1.val === obj2.val;
            if (obj1.val || obj2.val) return false;
            return obj1.a === obj2.a && obj1.b === obj2.b && obj1.c === obj2.c;
        }
        
        function getDisplayLabel(current_obj, anchor_obj) {
            const current_id = getCoordID(current_obj);
            if (current_obj.val || (anchor_obj && anchor_obj.val)) {
                return current_id.length > 15 ? `...${current_id.slice(-12)}` : current_id;
            }
            if (anchor_obj && current_obj.a === anchor_obj.a && current_obj.b === anchor_obj.b) {
                const c_curr = bigInt(current_obj.c);
                const c_anchor = bigInt(anchor_obj.c);
                const diff = c_curr.subtract(c_anchor);
                if (diff.isZero()) return current_id.length > 12 ? `...${current_id.slice(-10)}` : current_id;
                const diffStr = diff.toString();
                if (diff.isPositive()) return `+${diffStr}`;
                return diffStr;
            }
            return current_id.length > 12 ? `...${current_id.slice(-10)}` : current_id;
        }
        
        function setFittedFont(baseSize, text, isLog, scaledCellSize) {
            let fontSize = baseSize;
            if (isLog) fontSize *= 0.8;
            ctx.font = `bold ${fontSize}px Arial`;
            const padding = scaledCellSize * 0.1;
            const maxWidth = scaledCellSize - padding;
            let width = ctx.measureText(text).width;
            if (width > maxWidth && width > 0) {
                const scaleFactor = maxWidth / width;
                fontSize = Math.max(8, fontSize * scaleFactor);
                ctx.font = `bold ${fontSize}px Arial`;
            }
        }

        function getColors() {
            const rootStyle = getComputedStyle(document.documentElement);
            colors.gridBg = rootStyle.getPropertyValue('--grid-bg').trim();
            colors.textColor = rootStyle.getPropertyValue('--text-color').trim();
            colors.placeholderText = rootStyle.getPropertyValue('--placeholder-text').trim();
            colors.headerBg = rootStyle.getPropertyValue('--header-bg').trim();
            colors.headerText = rootStyle.getPropertyValue('--header-text').trim();
            colors.headerPrime = rootStyle.getPropertyValue('--header-prime').trim();
            colors.headerBlue = rootStyle.getPropertyValue('--header-blue').trim();
            colors.headerProbable = rootStyle.getPropertyValue('--header-probable').trim();
            colors.highlightBlue = rootStyle.getPropertyValue('--highlight-blue').trim();
            colors.gridLine = rootStyle.getPropertyValue('--grid-line').trim();
            colors.logText = rootStyle.getPropertyValue('--log-text-color').trim();
        }

        function getPrimality(n_obj) {
            const id = `p:${getCoordID(n_obj)}`;
            const cached = cellCache.get(id);
            if (cached) return cached;
            if (n_obj.val && n_obj.val.length > 1 && (n_obj.val.endsWith('0') || n_obj.val.endsWith('2') || n_obj.val.endsWith('4') || n_obj.val.endsWith('5') || n_obj.val.endsWith('6') || n_obj.val.endsWith('8'))) {
                cellCache.set(id, { isPrime: false });
                return { isPrime: false };
            }
            workerManager.queueRequest({ id: id, type: 'getPrimality', n_obj: n_obj });
            return undefined;
        }

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            draw();
        }
        window.addEventListener('resize', resizeCanvas);

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const currentCellSize = cellSize;
            const scaledCellSize = currentCellSize * scale;
            if (scaledCellSize < 2) return;

            const view = {
                x1: -offsetX / scale, y1: -offsetY / scale,
                x2: (canvas.width - offsetX) / scale, y2: (canvas.height - offsetY) / scale
            };
            const dataView = {
                x1: view.x1 - currentCellSize, y1: view.y1 - currentCellSize,
                x2: view.x2 - currentCellSize, y2: view.y2 - currentCellSize
            };
            const minCol = Math.floor(dataView.x1 / currentCellSize);
            const maxCol = Math.ceil(dataView.x2 / currentCellSize);
            const minRow = Math.floor(dataView.y1 / currentCellSize);
            const maxRow = Math.ceil(dataView.y2 / currentCellSize);
            const prefetchAmount = 5;

            ctx.save();
            ctx.translate(offsetX, offsetY);
            ctx.scale(scale, scale);
            const baseFontSize = 16 / scale;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            for (let r = minRow - prefetchAmount; r <= maxRow + prefetchAmount; r++) {
                const cellY_obj = incrementCoord(gridOriginRow, r);
                if (cellY_obj.val && bigInt(cellY_obj.val).lesser(1)) continue;
                const drawY = currentCellSize + r * currentCellSize;
                const y_id = getCoordID(cellY_obj);

                for (let c = minCol - prefetchAmount; c <= maxCol + prefetchAmount; c++) {
                    const cellX_obj = incrementCoord(gridOriginCol, c);
                    if (cellX_obj.val && bigInt(cellX_obj.val).lesser(1)) continue;
                    const drawX = currentCellSize + c * currentCellSize;
                    const x_id = getCoordID(cellX_obj);
                    const cellId = `c:${x_id},${y_id}`;
                    const cachedProduct = cellCache.get(cellId);
                    if (!cachedProduct) {
                        workerManager.queueRequest({ id: cellId, type: 'getProduct', x_obj: cellX_obj, y_obj: cellY_obj });
                    }
                    if (r >= minRow && r <= maxRow && c >= minCol && c <= maxCol) {
                        ctx.fillStyle = colors.gridBg;
                        ctx.fillRect(drawX, drawY, currentCellSize, currentCellSize);
                        if (areCoordsEqual(cellX_obj, highlightedCell.x) && areCoordsEqual(cellY_obj, highlightedCell.y)) {
                            ctx.fillStyle = colors.highlightBlue;
                            ctx.fillRect(drawX, drawY, currentCellSize, currentCellSize);
                        }
                        ctx.strokeStyle = colors.gridLine;
                        ctx.strokeRect(drawX, drawY, currentCellSize, currentCellSize);
                        let productString = "...";
                        let isLog = false;
                        ctx.fillStyle = colors.placeholderText;
                        if (cachedProduct) {
                            productString = cachedProduct.text;
                            isLog = cachedProduct.color === 'log';
                            ctx.fillStyle = isLog ? colors.logText : colors.textColor;
                        }
                        setFittedFont(baseFontSize, productString, isLog, scaledCellSize);
                        ctx.fillText(productString, drawX + currentCellSize / 2, drawY + currentCellSize / 2);
                    }
                }
            }
            ctx.restore();

            ctx.save();
            ctx.fillStyle = colors.headerBg;
            ctx.fillRect(0, 0, canvas.width, scaledCellSize);
            ctx.fillRect(0, 0, scaledCellSize, canvas.height);
            const headerBaseFontSize = Math.min(20, scaledCellSize * 0.35);
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            for (let r = minRow - prefetchAmount; r <= maxRow + prefetchAmount; r++) {
                const cellY_obj = incrementCoord(gridOriginRow, r);
                if (cellY_obj.val && bigInt(cellY_obj.val).lesser(1)) continue;
                const primality = getPrimality(cellY_obj);
                const worldY = currentCellSize + r * currentCellSize;
                const drawY = worldY * scale + offsetY;
                if (drawY > canvas.height || drawY + scaledCellSize < scaledCellSize) continue;
                const label = getDisplayLabel(cellY_obj, highlightedCell.y);
                if (primality && primality.isPrime === true) {
                    ctx.fillStyle = colors.headerPrime;
                } else if (primality && primality.isProbablePrime === true) {
                    ctx.fillStyle = colors.headerProbable;
                } else {
                    ctx.fillStyle = colors.headerBlue;
                }
                ctx.fillRect(0, drawY, scaledCellSize, scaledCellSize);
                ctx.fillStyle = colors.headerText;
                ctx.strokeStyle = colors.gridLine;
                ctx.strokeRect(0, drawY, scaledCellSize, scaledCellSize);
                setFittedFont(headerBaseFontSize, label, false, scaledCellSize);
                ctx.fillText(label, scaledCellSize / 2, drawY + scaledCellSize / 2);
            }

            for (let c = minCol - prefetchAmount; c <= maxCol + prefetchAmount; c++) {
                const cellX_obj = incrementCoord(gridOriginCol, c);
                if (cellX_obj.val && bigInt(cellX_obj.val).lesser(1)) continue;
                const primality = getPrimality(cellX_obj);
                const worldX = currentCellSize + c * currentCellSize;
                const drawX = worldX * scale + offsetX;
                if (drawX > canvas.width || drawX + scaledCellSize < scaledCellSize) continue;
                const label = getDisplayLabel(cellX_obj, highlightedCell.x);
                if (primality && primality.isPrime === true) {
                    ctx.fillStyle = colors.headerPrime;
                } else if (primality && primality.isProbablePrime === true) {
                    ctx.fillStyle = colors.headerProbable;
                } else {
                    ctx.fillStyle = colors.headerBlue;
                }
                ctx.fillRect(drawX, 0, scaledCellSize, scaledCellSize);
                ctx.fillStyle = colors.headerText;
                ctx.strokeStyle = colors.gridLine;
                ctx.strokeRect(drawX, 0, scaledCellSize, scaledCellSize);
                setFittedFont(headerBaseFontSize, label, false, scaledCellSize);
                ctx.fillText(label, drawX + scaledCellSize / 2, scaledCellSize / 2);
            }

            ctx.fillStyle = "#000";
            ctx.fillRect(0, 0, scaledCellSize, scaledCellSize);
            ctx.strokeStyle = colors.gridLine;
            ctx.strokeRect(0, 0, scaledCellSize, scaledCellSize);
            ctx.fillStyle = colors.headerText;
            setFittedFont(headerBaseFontSize, "X * Y", false, scaledCellSize);
            ctx.fillText("X * Y", scaledCellSize/2, scaledCellSize/2);
            ctx.restore();
        }
        
        function showTerminal() {
            terminal.classList.add('active');
        }
        function hideTerminal() {
            terminal.classList.remove('active');
            activeDetailId = null;
            activeDetailObjects = null;
        }
        function updateTerminal(data) {
            terminalContent.style.color = 'var(--terminal-text)';
            if (data.mode === 'full') {
                terminalContent.textContent = data.value;
                calcFullBtn.style.display = 'none';
            } else if (data.mode === 'equation') {
                terminalContent.textContent = 
`X: ${data.x}
Y: ${data.y}
-------------------
Product:
(${data.x}) * (${data.y})

Approximate:
${data.approx}`;
                calcFullBtn.style.display = 'inline-block';
            } else if (data.mode === 'single') {
                let statusClass = 'status-composite';
                if (data.status === 'Prime') statusClass = 'status-prime';
                if (data.status === 'Probable Prime') statusClass = 'status-probable';
                
                terminalContent.innerHTML = 
`Value: ${getCoordID(activeDetailObjects.n_obj)}

Status: <span class="${statusClass}">${data.status}</span>

Full Value:
${data.value}`;
                calcFullBtn.style.display = 'none';
            }
        }
        terminalClose.addEventListener('click', hideTerminal);
        
        copyTermBtn.addEventListener('click', () => {
            navigator.clipboard.writeText(terminalContent.textContent);
        });
        
        calcFullBtn.addEventListener('click', () => {
            if (activeDetailObjects) {
                terminalContent.textContent = "Calculating full value...\n(This may take a long time or freeze the worker)";
                calcFullBtn.style.display = 'none';
                activeDetailId = `d:force:${getCoordID(activeDetailObjects.x_obj)},${getCoordID(activeDetailObjects.y_obj)}`;
                const task = { 
                    id: activeDetailId, 
                    type: 'forceGetDetails',
                    x_obj: activeDetailObjects.x_obj, 
                    y_obj: activeDetailObjects.y_obj
                };
                workerManager.queueRequest(task);
                workerManager.processQueue();
            }
        });


        function centerOnCell(targetX_obj, targetY_obj) {
            highlightedCell = { x: targetX_obj, y: targetY_obj };
            gridOriginCol = targetX_obj;
            gridOriginRow = targetY_obj;
            const worldX = cellSize + (cellSize / 2);
            const worldY = cellSize + (cellSize / 2);
            const screenX = canvas.width / 2;
            const screenY = canvas.height / 2;
            offsetX = screenX - worldX * scale;
            offsetY = screenY - worldY * scale;
            cellCache.clear();
            draw();
            workerManager.requestQueue.clear();
            workerManager.processQueue();
        }

        goButton.addEventListener('click', () => {
            try {
                const x_obj = parseCoordinate(xInput.value);
                const y_obj = parseCoordinate(yInput.value);
                if (x_obj.val && bigInt(x_obj.val).lesser(1)) throw new Error("X must be >= 1");
                if (y_obj.val && bigInt(y_obj.val).lesser(1)) throw new Error("Y must be >= 1");
                centerOnCell(x_obj, y_obj);
            } catch (e) {
                console.error(e);
                alert(`Invalid format. Use '123', '1e9', '5e30+7' or '10^100+25'.\nError: ${e.message}`);
            }
        });

        controlsHandle.addEventListener('click', () => {
            controlsPanel.classList.toggle('collapsed');
        });

        function getCellFromEvent(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const worldX = (x - offsetX) / scale;
            const worldY = (y - offsetY) / scale;
            
            const scaledCellSize = cellSize;
            
            if (worldX < scaledCellSize && worldY < scaledCellSize) {
                return { type: 'corner' };
            }
            const col = Math.floor((worldX - scaledCellSize) / scaledCellSize);
            const row = Math.floor((worldY - scaledCellSize) / scaledCellSize);
            if (worldX < scaledCellSize) {
                return { type: 'y-header', obj: incrementCoord(gridOriginRow, row) };
            }
            if (worldY < scaledCellSize) {
                return { type: 'x-header', obj: incrementCoord(gridOriginCol, col) };
            }
            return {
                type: 'cell',
                x_obj: incrementCoord(gridOriginCol, col),
                y_obj: incrementCoord(gridOriginRow, row)
            };
        }
        
        let panStart = {x: 0, y: 0};
        let didPan = false;

        canvas.addEventListener('mousedown', (e) => {
            isPanning = true;
            didPan = false;
            lastPan = { x: e.clientX, y: e.clientY };
            panStart = { x: e.clientX, y: e.clientY };
        });
        canvas.addEventListener('mousemove', (e) => {
            if (!isPanning) return;
            const deltaX = e.clientX - lastPan.x;
            const deltaY = e.clientY - lastPan.y;
            if (Math.abs(deltaX) > 5 || Math.abs(deltaY) > 5) {
                didPan = true;
            }
            offsetX += deltaX;
            offsetY += deltaY;
            lastPan = { x: e.clientX, y: e.clientY };
            requestAnimationFrame(draw);
        });
        canvas.addEventListener('mouseup', (e) => {
            if (!didPan && !controlsPanel.contains(e.target)) {
                handleCellClick(e);
            }
            if(isPanning) {
                isPanning = false;
                workerManager.processQueue();
            }
            didPan = false;
        });
        canvas.addEventListener('mouseleave', () => { isPanning = false; didPan = false; });

        function handleCellClick(e) {
            const cell = getCellFromEvent(e);
            if (!cell) return;
            
            let id, task;
            
            // **FIXED LOGIC**: Headers now use the standard getDetails path (like a normal cell)
            if (cell.type === 'cell' || cell.type === 'x-header' || cell.type === 'y-header') {
                // Determine coordinates for product X*Y
                const x_coord = cell.type === 'y-header' ? { val: "1" } : cell.x_obj;
                const y_coord = cell.type === 'x-header' ? { val: "1" } : cell.y_obj;

                id = `d:c:${getCoordID(x_coord)},${getCoordID(y_coord)}`;
                task = { id: id, type: 'getDetails', x_obj: x_coord, y_obj: y_coord };
                activeDetailObjects = {x_obj: x_coord, y_obj: y_coord};
            } else {
                return;
            }

            activeDetailId = id;
            terminalContent.textContent = "Loading...";
            calcFullBtn.style.display = 'none';
            showTerminal();
            const cached = cellCache.get(id);
            if (cached) {
                updateTerminal(cached);
            } else {
                workerManager.queueRequest(task);
                workerManager.processQueue();
            }
        }

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const factor = e.deltaY > 0 ? 0.9 : 1.1;
            const mouseX = e.clientX;
            const mouseY = e.clientY;
            offsetX = mouseX - (mouseX - offsetX) * factor;
            offsetY = mouseY - (mouseY - offsetY) * factor;
            scale *= factor;
            scale = Math.max(0.1, Math.min(scale, 20));
            zoomInfo.textContent = `Zoom: ${scale.toFixed(2)}x`;
            requestAnimationFrame(draw);
             clearTimeout(canvas.wheelTimer);
             canvas.wheelTimer = setTimeout(() => {
                 workerManager.processQueue();
             }, 150);
        }, { passive: false });

        canvas.addEventListener('touchstart', (e) => {
            if (controlsPanel.contains(e.target)) return;
            if (e.touches.length === 1) {
                isPanning = true;
                didPan = false;
                lastPan = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            } else if (e.touches.length === 2) {
                isPanning = false;
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                lastTouchDist = Math.hypot(dx, dy);
            }
        });
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (e.touches.length === 1 && isPanning) {
                const touchX = e.touches[0].clientX;
                const touchY = e.touches[0].clientY;
                const deltaX = touchX - lastPan.x;
                const deltaY = touchY - lastPan.y;
                if (Math.abs(deltaX) > 5 || Math.abs(deltaY) > 5) {
                    didPan = true;
                }
                offsetX += deltaX;
                offsetY += deltaY;
                lastPan = { x: touchX, y: touchY };
                requestAnimationFrame(draw);
            } else if (e.touches.length === 2) {
                didPan = true;
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                const newDist = Math.hypot(dx, dy);
                const factor = newDist / lastTouchDist;
                const midX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                const midY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
                offsetX = midX - (midX - offsetX) * factor;
                offsetY = midY - (midY - offsetY) * factor;
                scale *= factor;
                scale = Math.max(0.1, Math.min(scale, 20));
                zoomInfo.textContent = `Zoom: ${scale.toFixed(2)}x`;
                lastTouchDist = newDist;
                requestAnimationFrame(draw);
            }
        }, { passive: false });
        canvas.addEventListener('touchend', (e) => {
            if (!didPan && e.touches.length === 0 && !controlsPanel.contains(e.target)) {
                 handleCellClick({ clientX: lastPan.x, clientY: lastPan.y });
            }
            if (e.touches.length < 2) isPanning = false;
            if (e.touches.length < 1) lastTouchDist = 0;
            workerManager.processQueue();
        });
        
        getColors();
        resizeCanvas();
        centerOnCell({val: "1"}, {val: "1"});
        setTimeout(() => {
            workerManager.processQueue();
        }, 100);
    </script>
</body>
</html>
