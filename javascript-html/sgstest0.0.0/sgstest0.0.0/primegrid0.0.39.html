<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Lattice Prime Grid (Sequential)</title>
  <style>
    :root {
      --bg-color: #0f172a;
      --grid-line: #1e293b;
      --text-muted: #64748b;
      --text-bright: #f1f5f9;
    }

    body {
      background-color: var(--bg-color);
      margin: 0;
      overflow: hidden;
      height: 100vh;
      width: 100vw;
      font-family: 'Courier New', Courier, monospace;
      touch-action: none; /* Vital for mobile gestures */
    }

    /* HUD controls */
    .hud {
      position: absolute;
      top: 0; left: 0; width: 100%;
      background: rgba(15, 23, 42, 0.95);
      border-bottom: 1px solid #334155;
      padding: 8px;
      z-index: 50;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      box-shadow: 0 4px 6px -1px rgba(0,0,0,0.2);
    }

    .input-group { display: flex; flex-direction: column; }
    .input-group label { font-size: 9px; color: var(--text-muted); margin-bottom: 2px; text-transform: uppercase; }

    input {
      background: #334155; border: 1px solid #475569; color: white;
      padding: 6px; border-radius: 4px; width: 60px;
      font-family: inherit; font-size: 12px; outline: none;
    }
    .wide { width: 110px; }

    button {
      background: #2563eb; color: white; border: none;
      padding: 8px 16px; border-radius: 4px; font-weight: bold;
      font-size: 12px; cursor: pointer; margin-left: auto;
    }
    button:active { transform: scale(0.98); }

    /* The Infinite Canvas */
    .viewport {
      position: relative;
      width: 100%; height: 100%;
      overflow: hidden;
    }

    canvas {
      position: absolute; top: 0; left: 0;
      width: 100%; height: 100%;
      z-index: 0; /* Behind numbers */
    }

    /* The Number Cells */
    .cell-layer {
      position: absolute; top: 0; left: 0;
      z-index: 1;
      will-change: transform;
    }

    .cell {
      position: absolute;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      box-sizing: border-box;
      border: 1px solid transparent; /* Grid lines provided by canvas */
      font-size: 12px;
      white-space: nowrap;
      overflow: hidden;
      background: rgba(30, 41, 59, 0.85); /* Slightly transparent */
      border-radius: 2px;
    }

    /* Cell States */
    .cell.candidate {
      color: #34d399; /* Green */
      background: rgba(6, 78, 59, 0.4);
      border: 1px solid #059669;
      font-weight: bold;
    }
    .cell.composite {
      color: #94a3b8; /* Grayed out */
      background: rgba(30, 41, 59, 0.4);
      opacity: 0.7;
    }
    .cell.prime-confirmed {
        color: #fbbf24; /* Gold */
        border: 1px solid #fbbf24;
        box-shadow: 0 0 10px rgba(251, 191, 36, 0.2);
    }

    .cell-coords {
        font-size: 9px;
        color: #64748b;
        position: absolute;
        top: 2px;
        left: 2px;
    }
    
    .cell-val {
        font-size: 14px;
    }

    .info-bar {
        position: absolute; bottom: 10px; right: 10px;
        color: #64748b; font-size: 10px; pointer-events: none;
    }

  </style>
</head>
<body>

  <div class="hud">
    <div class="input-group">
      <label>Base (a)</label>
      <input type="text" id="baseInput" value="10">
    </div>
    <div class="input-group">
      <label>Exp (b)</label>
      <input type="text" id="expInput" value="1000000000" class="wide">
    </div>
    <div class="input-group">
      <label>Add (c)</label>
      <input type="text" id="addInput" value="19">
    </div>
    
    <div class="input-group">
      <label>Grid Width</label>
      <input type="number" id="widthInput" value="10">
    </div>

    <button id="updateBtn">Update</button>
  </div>

  <div class="viewport" id="viewport">
    <canvas id="gridCanvas"></canvas>
    <div class="cell-layer" id="cellLayer"></div>
    <div class="info-bar" id="infoBar">Zoom: 1.0 | Pan: 0,0</div>
  </div>

  <script id="worker-code" type="javascript/worker">
    // 1. Generate Sieve of Eratosthenes for small prime checking
    const SIEVE_LIMIT = 10000;
    const PRIMES = [];
    {
        const s = new Uint8Array(SIEVE_LIMIT+1);
        for(let i=2; i<=SIEVE_LIMIT; i++){
            if(!s[i]){
                PRIMES.push(i);
                for(let j=i*i; j<=SIEVE_LIMIT; j+=i) s[j]=1;
            }
        }
    }

    // 2. Modular Exponentiation (BigInt)
    function powMod(b, e, m) {
        let r = 1n;
        b %= m;
        while(e > 0n){
            if((e & 1n) === 1n) r = (r * b) % m;
            e >>= 1n;
            b = (b * b) % m;
        }
        return r;
    }

    // Cache for starting remainders
    let cacheKey = "";
    let baseRemainders = null; // Int32Array

    self.onmessage = function(e) {
        const { tasks, aStr, bStr, cStr } = e.data;
        
        // Check if inputs changed
        const currentKey = `${aStr}|${bStr}|${cStr}`;
        if(currentKey !== cacheKey) {
            // Re-calculate remainders of the Starting Number for every prime
            const a = BigInt(aStr);
            const b = BigInt(bStr);
            const c = BigInt(cStr);
            
            baseRemainders = new Int32Array(PRIMES.length);
            for(let i=0; i<PRIMES.length; i++){
                const p = BigInt(PRIMES[i]);
                // (a^b + c) % p
                const rem = (powMod(a, b, p) + c) % p;
                baseRemainders[i] = Number(rem);
            }
            cacheKey = currentKey;
        }

        const results = [];
        
        // Process visual cells
        for(let task of tasks) {
            // The task contains the Sequential Offset
            const offset = task.offset; 
            
            let isComposite = false;
            
            // Check: (StartRemainder + offset) % p == 0 ?
            for(let i=0; i<PRIMES.length; i++){
                const p = PRIMES[i];
                const rem = baseRemainders[i];
                
                if( (rem + offset) % p === 0 ) {
                    isComposite = true;
                    break;
                }
            }
            
            results.push({
                id: task.id,
                status: isComposite ? 'composite' : 'candidate',
                // For display, we just show the +Offset
                val: `+${offset}`
            });
        }

        self.postMessage(results);
    };
  </script>

  <script>
    /* --- ENGINE --- */
    const canvas = document.getElementById('gridCanvas');
    const ctx = canvas.getContext('2d');
    const cellLayer = document.getElementById('cellLayer');
    const viewport = document.getElementById('viewport');
    const infoBar = document.getElementById('infoBar');

    // Viewport State
    let cellSize = 80;
    let scale = 1.0;
    let panX = 0, panY = 0;
    
    // Grid Logic
    let gridWidth = 10; // How many numbers before wrapping

    // Worker State
    let worker;
    const renderedCells = new Map();

    function initWorker() {
        const blob = new Blob([document.getElementById('worker-code').textContent], { type: "text/javascript" });
        worker = new Worker(window.URL.createObjectURL(blob));
        worker.onmessage = (e) => {
            const results = e.data;
            results.forEach(res => {
                const el = document.getElementById(res.id);
                if(el) {
                    el.className = `cell ${res.status}`;
                    el.querySelector('.cell-val').textContent = res.val;
                }
            });
        };
    }
    initWorker();

    function resize() {
        canvas.width = viewport.clientWidth;
        canvas.height = viewport.clientHeight;
        draw();
    }
    window.addEventListener('resize', resize);

    /* --- DRAWING LOOP --- */
    function draw() {
        // 1. Draw Grid Lines (Lattice Look)
        ctx.fillStyle = '#0f172a';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        const size = cellSize * scale;
        const offX = panX % size;
        const offY = panY % size;

        ctx.beginPath();
        ctx.strokeStyle = '#334155'; // Grid line color
        ctx.lineWidth = 1;

        // Vertical Lines
        for (let x = offX; x < canvas.width; x += size) { 
            ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); 
        }
        // Horizontal Lines
        for (let y = offY; y < canvas.height; y += size) { 
            ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); 
        }
        ctx.stroke();

        // 2. Update DOM Cells
        updateCells(size);
        
        infoBar.textContent = `Zoom: ${scale.toFixed(2)} | Offset: ${Math.round(-panX)}, ${Math.round(-panY)}`;
    }

    function updateCells(size) {
        const startCol = Math.floor(-panX / size);
        const startRow = Math.floor(-panY / size);
        const colsVisible = Math.ceil(canvas.width / size) + 1;
        const rowsVisible = Math.ceil(canvas.height / size) + 1;

        const visibleIds = new Set();
        const tasks = [];

        for(let r = startRow; r < startRow + rowsVisible; r++) {
            for(let c = startCol; c < startCol + colsVisible; c++) {
                const id = `cell_${c}_${r}`;
                visibleIds.add(id);

                // --- KEY LOGIC: Sequential Wrapping ---
                // Unlike the previous Cartesian formula, this uses standard reading order
                // Start at 0,0. 
                // Number = (Row * GridWidth) + Col
                
                const offset = (r * gridWidth) + c;
                
                // If cell exists, move it
                if(renderedCells.has(id)){
                    const el = renderedCells.get(id).el;
                    const px = panX + (c * size);
                    const py = panY + (r * size);
                    el.style.transform = `translate(${px}px, ${py}px)`;
                    el.style.width = (size-1)+'px';
                    el.style.height = (size-1)+'px';
                    // Show/Hide logic for performance?
                    continue;
                }

                // Create Cell
                const el = document.createElement('div');
                el.id = id;
                el.className = 'cell'; // Default state
                // The HTML structure requested: Coordinates + Number
                el.innerHTML = `
                    <span class="cell-coords">${c},${r}</span>
                    <span class="cell-val">...</span>
                `;
                
                const px = panX + (c * size);
                const py = panY + (r * size);
                el.style.transform = `translate(${px}px, ${py}px)`;
                el.style.width = (size-1)+'px';
                el.style.height = (size-1)+'px';

                cellLayer.appendChild(el);
                renderedCells.set(id, { el });
                
                // Add to worker task list to check primality
                tasks.push({ id, offset });
            }
        }

        // Cleanup offscreen cells
        for(const [id, data] of renderedCells){
            if(!visibleIds.has(id)){
                data.el.remove();
                renderedCells.delete(id);
            }
        }

        // Send batch to worker
        if(tasks.length > 0) {
            worker.postMessage({
                tasks,
                aStr: document.getElementById('baseInput').value,
                bStr: document.getElementById('expInput').value,
                cStr: document.getElementById('addInput').value
            });
        }
    }

    /* --- GESTURE ENGINE (Mobile First) --- */
    let isDragging = false;
    let lastPos = {x:0, y:0};
    let lastDist = 0;

    // Mouse
    viewport.addEventListener('mousedown', e => { isDragging=true; lastPos={x:e.clientX, y:e.clientY}; });
    window.addEventListener('mousemove', e => {
        if(!isDragging) return;
        panX += e.clientX - lastPos.x;
        panY += e.clientY - lastPos.y;
        lastPos={x:e.clientX, y:e.clientY};
        requestAnimationFrame(draw);
    });
    window.addEventListener('mouseup', () => isDragging=false);
    
    // Wheel Zoom
    viewport.addEventListener('wheel', e => {
        e.preventDefault();
        const delta = -Math.sign(e.deltaY) * 0.1;
        const newScale = Math.max(0.2, Math.min(5, scale + delta));
        
        // Zoom toward mouse
        const mx = e.clientX;
        const my = e.clientY;
        const gx = (mx - panX) / scale;
        const gy = (my - panY) / scale;
        
        scale = newScale;
        panX = mx - (gx * scale);
        panY = my - (gy * scale);
        requestAnimationFrame(draw);
    }, {passive:false});

    // Touch
    viewport.addEventListener('touchstart', e => {
        if(e.touches.length===1) {
            isDragging=true; lastPos={x:e.touches[0].clientX, y:e.touches[0].clientY};
        } else if(e.touches.length===2) {
            isDragging=true;
            const p1={x:e.touches[0].clientX, y:e.touches[0].clientY};
            const p2={x:e.touches[1].clientX, y:e.touches[1].clientY};
            lastDist = Math.hypot(p1.x-p2.x, p1.y-p2.y);
            lastPos = {x:(p1.x+p2.x)/2, y:(p1.y+p2.y)/2};
        }
    }, {passive:false});

    viewport.addEventListener('touchmove', e => {
        e.preventDefault();
        if(!isDragging) return;
        
        if(e.touches.length===1) {
            const curr = {x:e.touches[0].clientX, y:e.touches[0].clientY};
            panX += curr.x - lastPos.x;
            panY += curr.y - lastPos.y;
            lastPos=curr;
            requestAnimationFrame(draw);
        } else if(e.touches.length===2) {
            const p1={x:e.touches[0].clientX, y:e.touches[0].clientY};
            const p2={x:e.touches[1].clientX, y:e.touches[1].clientY};
            const dist = Math.hypot(p1.x-p2.x, p1.y-p2.y);
            const center = {x:(p1.x+p2.x)/2, y:(p1.y+p2.y)/2};
            
            // Pan
            panX += center.x - lastPos.x;
            panY += center.y - lastPos.y;
            
            // Zoom
            const zoom = dist / lastDist;
            const newScale = Math.max(0.2, Math.min(5, scale * zoom));
            const gx = (center.x - panX) / scale;
            const gy = (center.y - panY) / scale;
            
            scale = newScale;
            panX = center.x - (gx * scale);
            panY = center.y - (gy * scale);
            
            lastDist = dist;
            lastPos = center;
            requestAnimationFrame(draw);
        }
    }, {passive:false});

    viewport.addEventListener('touchend', e => {
        if(e.touches.length===0) isDragging=false;
        if(e.touches.length===1) lastPos={x:e.touches[0].clientX, y:e.touches[0].clientY};
    });

    // UI Controls
    document.getElementById('updateBtn').addEventListener('click', () => {
        gridWidth = parseInt(document.getElementById('widthInput').value) || 10;
        cellLayer.innerHTML = '';
        renderedCells.clear();
        draw();
    });

    // Initialize
    resize();
    // Center 0,0
    panX = canvas.width/2 - cellSize/2;
    panY = canvas.height/2 - cellSize/2;
    draw();

  </script>
</body>
</html>
