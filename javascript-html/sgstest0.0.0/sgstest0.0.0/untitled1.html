<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Infinite Prime Grid (Cartesian Scroll & QR Filter)</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body {
      background-color: #1a1a1a;
      color: #e5e7eb;
      font-family: 'Inter', sans-serif;
      user-select: none;
      min-height: 100vh;
      overflow: hidden; /* Hide main scrollbars for canvas-like effect */
    }

    .grid-window {
      position: relative;
      width: 100%;
      height: calc(100vh - 250px); /* Fill most of the remaining screen height */
      overflow: hidden;
      cursor: grab;
      border: 1px solid #374151;
      border-radius: 0.5rem;
    }

    .grid-container {
      position: absolute;
      display: grid;
      gap: 1px;
      touch-action: none;
      transform-origin: 0 0;
      transition: opacity 0.5s;
    }

    .grid-cell {
      width: 80px; /* Fixed cell size for grid calculations */
      height: 80px;
      background-color: #2c2c2c;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-size: 11px;
      font-weight: bold;
      word-break: break-all;
      overflow: hidden;
      cursor: default;
      border: 1px solid #333;
      transition: background-color 0.5s ease;
      box-sizing: border-box;
      white-space: nowrap;
    }

    .grid-cell.prime { background-color: #34d399; color: #1a1a1a; }
    .grid-cell.composite { background-color: #ef4444; }
    .grid-cell.qr-fail { background-color: #facc15; box-shadow: 0 0 0 2px #facc15 inset; color: #1a1a1a; }
    .grid-cell.processing { background-color: #374151; animation: pulse 1.5s infinite; }
    .grid-cell.axis { background-color: #4b5563; }
    .grid-cell.origin { background-color: #0ea5e9; }

    @keyframes pulse {
      0% { opacity: 1; }
      50% { opacity: 0.7; }
      100% { opacity: 1; }
    }

    .input-field {
        width: 100%;
        padding: 0.5rem;
        background-color: #4b5563;
        border: 1px solid #374151;
        border-radius: 0.375rem;
        color: #f9fafb;
    }
  </style>
</head>
<body class="p-4 sm:p-6">
  <div class="max-w-7xl mx-auto space-y-4">
    <header class="text-center">
      <h1 class="text-2xl font-bold text-blue-400">Infinite Cartesian Prime Explorer</h1>
      <p id="formulaDisplay" class="text-gray-400 text-sm">N = X * Y + C</p>
    </header>

    <!-- INPUT CONTROLS -->
    <section class="bg-gray-800 p-4 rounded-lg shadow space-y-3">
      <div class="grid grid-cols-2 sm:grid-cols-4 gap-4">
        <!-- Input Fields -->
        <div class="input-group sm:col-span-2">
          <label for="formulaInput" class="block text-sm text-gray-400">Cell Formula (e.g., X*Y+C or X^Y+C)</label>
          <input type="text" id="formulaInput" value="X*Y+1" class="input-field">
        </div>
        <div class="input-group">
          <label for="initialXInput" class="block text-sm text-gray-400">Initial X (e.g., 100)</label>
          <input type="text" id="initialXInput" value="1" class="input-field">
        </div>
        <div class="input-group">
          <label for="initialYInput" class="block text-sm text-gray-400">Initial Y (e.g., 100)</label>
          <input type="text" id="initialYInput" value="1" class="input-field">
        </div>
      </div>

      <div class="flex flex-wrap gap-3">
        <button id="drawButton" class="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white font-bold rounded-lg transition-colors">Generate Grid</button>
        <button id="resetButton" class="px-4 py-2 bg-gray-600 hover:bg-gray-700 text-white font-bold rounded-lg transition-colors">Reset View</button>
      </div>

      <div id="statusMessage" class="text-gray-300 text-sm font-mono">Status: Ready. Drag the grid to explore!</div>
    </section>

    <!-- GRID WINDOW -->
    <section class="grid-window" id="gridWindow">
      <div id="grid-container" class="grid-container"></div>
    </section>

    <!-- LEGEND -->
    <div class="mt-4 flex flex-wrap justify-center gap-4 text-xs text-gray-300">
        <span class="flex items-center gap-1"><div class="w-3 h-3 rounded-full bg-gray-600"></div> Processing</span>
        <span class="flex items-center gap-1"><div class="w-3 h-3 rounded-full bg-red-500"></div> Composite (MR Fail)</span>
        <span class="flex items-center gap-1"><div class="w-3 h-3 rounded-full bg-green-500"></div> Prime (MR Pass)</span>
        <span class="flex items-center gap-1"><div class="w-3 h-3 rounded-full bg-yellow-400 shadow-md"></div> **QR Fail (Composite)**</span>
    </div>
  </div>

  <script>
    // --- UTILITY FUNCTIONS (BigInt Handling) ---
    function parseBigInt(str) {
      if (!str) return 0n;
      str = String(str).replace(/,/g, '').replace(/\s/g, '');
      if (str.includes('e') || str.includes('E')) {
        const parts = str.toLowerCase().split('e');
        return BigInt(parts[0]) * 10n ** BigInt(parts[1]);
      }
      return BigInt(str);
    }

    function formatNumberWithCommas(n) {
        if (!n) return '0';
        // Limit display size for massive numbers
        const s = n.toString();
        if (s.length > 18) {
             return s.substring(0, 5) + 'e+' + (s.length - 1);
        }
        return s.replace(/\B(?=(\d{3})+(?!\d))/g, ",");
    }

    function setStatus(text, isError = false) {
      const el = document.getElementById('statusMessage');
      el.textContent = `Status: ${text}`;
      el.classList.toggle('text-red-500', isError);
    }

    // --- DOM REFERENCES ---
    const gridWindow = document.getElementById('gridWindow');
    const gridContainer = document.getElementById('grid-container');
    const formulaInput = document.getElementById('formulaInput');
    const initialXInput = document.getElementById('initialXInput');
    const initialYInput = document.getElementById('initialYInput');
    const drawButton = document.getElementById('drawButton');
    const resetButton = document.getElementById('resetButton');

    // --- GLOBAL STATE ---
    const CELL_SIZE = 80;
    const QR_SCREEN_PRIMES = [3n, 5n, 7n, 11n, 13n, 17n, 19n, 23n, 29n, 31n, 37n]; // Primes for QR filter
    
    let isDragging = false;
    let startX = 0, startY = 0;
    let gridOffsetX = 0, gridOffsetY = 0; // Current pan position in pixels
    let currentX = 1n, currentY = 1n;      // Logical coordinates of the top-left visible cell
    let numCols = 0, numRows = 0;           // Number of visible cells
    let itemsProcessing = 0;

    let primalityWorker = null;

    // --- WORKER 1: PRIMALITY CHECKER WITH QR FILTER ---
    const primalityWorkerCode = `
      const QR_SCREEN_PRIMES = [3n, 5n, 7n, 11n, 13n, 17n, 19n, 23n, 29n, 31n, 37n];

      function powMod(base, exp, mod) {
        let result = 1n;
        base %= mod;
        while (exp > 0n) {
          if ((exp & 1n) === 1n) result = (result * base) % mod;
          exp >>= 1n;
          base = (base * base) % mod;
        }
        return result;
      }

      // Legendre Symbol: (a/p) -> 1, 0, or -1
      function legendreSymbol(a, p) {
        if (p === 2n) return 1; // 2 is special
        if (a % p === 0n) return 0;
        a = a % p;
        const ls = powMod(a, (p - 1n) / 2n, p);
        if (ls === p - 1n) return -1;
        return 1;
      }

      // Miller-Rabin Primality Test
      function millerRabinTest(n, k = 5) {
        if (n <= 1n) return false;
        if (n <= 3n) return true;
        if ((n & 1n) === 0n) return false;

        let d = n - 1n;
        let s = 0n;
        while ((d & 1n) === 0n) {
          d >>= 1n;
          s++;
        }
        const witnesses = [2n, 3n, 5n, 7n, 11n];
        if (k > witnesses.length) k = witnesses.length;
        
        for (let i = 0; i < k; i++) {
          const a = witnesses[i];
          if (a >= n - 1n) continue;

          let x = powMod(a, d, n);
          if (x === 1n || x === n - 1n) continue;

          let composite = true;
          for (let j = 1n; j < s; j++) {
            x = powMod(x, 2n, n);
            if (x === n - 1n) {
              composite = false;
              break;
            }
            if (x === 1n) break;
          }
          if (composite) return false;
        }
        return true;
      }

      // --- Main Worker Check ---
      self.onmessage = (e) => {
        const { number, formula } = e.data;
        const n = BigInt(number);

        if (n <= 1n) {
             self.postMessage({ number, result: 'composite', reason: 'N <= 1' });
             return;
        }
        if (n === 2n || n === 3n || n === 5n) {
             self.postMessage({ number, result: 'prime', reason: 'Small Prime' });
             return;
        }

        // 1. Check small factors (2, 3, 5)
        if (n % 2n === 0n) {
             self.postMessage({ number, result: 'qr-fail', reason: 'Divisible by 2' });
             return;
        }
        if (n % 3n === 0n) {
             self.postMessage({ number, result: 'qr-fail', reason: 'Divisible by 3' });
             return;
        }
        if (n % 5n === 0n) {
             self.postMessage({ number, result: 'qr-fail', reason: 'Divisible by 5' });
             return;
        }


        // 2. Quadratic Residue (QR) Filter
        // The QR filter is most effective when N is of the form p*q, and it works by checking small primes p for which N is a quadratic residue.
        // For a general test, we check if N is a perfect square mod p for several small primes.
        let qrFailed = false;
        for (const p of QR_SCREEN_PRIMES) {
             // Skip p if N is divisible by p (already checked 3, 5)
             if (n === p) continue; 
             
             // Check if N has a square root modulo p. If not, N is composite.
             if (legendreSymbol(n, p) === -1) {
                 qrFailed = true;
                 break;
             }
        }
        
        if (qrFailed) {
             // This is a fast indication of compositeness, often faster than MR
             self.postMessage({ number, result: 'qr-fail', reason: 'QR Failed' });
             return;
        }

        // 3. Miller-Rabin Test (Heavy Lifting)
        const isPrime = millerRabinTest(n);
        
        self.postMessage({
          number: number,
          result: isPrime ? 'prime' : 'composite',
          reason: isPrime ? 'MR Pass' : 'MR Fail'
        });
      };
    `;


    // --- GRID SETUP & RENDERING ---
    function initializeWorker() {
        if (primalityWorker) primalityWorker.terminate();
        primalityWorker = new Worker(URL.createObjectURL(new Blob([primalityWorkerCode], { type: 'application/javascript' })));
        primalityWorker.onmessage = handleWorkerMessage;
    }

    function calculateGridSize() {
      const w = gridWindow.offsetWidth;
      const h = gridWindow.offsetHeight;
      numCols = Math.ceil(w / CELL_SIZE) + 1; // Add 1 for edge scrolling buffer
      numRows = Math.ceil(h / CELL_SIZE) + 1;
      gridContainer.style.gridTemplateColumns = `repeat(${numCols}, ${CELL_SIZE}px)`;
      gridContainer.style.width = `${numCols * CELL_SIZE}px`;
      gridContainer.style.height = `${numRows * CELL_SIZE}px`;
    }

    function evaluateFormula(x, y, formulaStr) {
      try {
        const C_match = formulaStr.match(/C/i);
        const formula = formulaStr.replace(/X/ig, `BigInt(${x})`).replace(/Y/ig, `BigInt(${y})`).replace(/C/ig, `BigInt(${x}*${y})`);
        // If C is present, try to parse it relative to X and Y. For simplicity here, we stick to standard formulas.
        
        // This is a powerful but dangerous use of eval for BigInt math:
        return eval(formula); 
      } catch (e) {
        // Fallback for complex formula failures, just return X*Y
        return BigInt(x) * BigInt(y);
      }
    }

    function renderGrid(shouldCheck = true) {
      calculateGridSize();

      gridContainer.innerHTML = '';
      itemsProcessing = 0;
      const formula = formulaInput.value || "X*Y";
      const X_start_coord = currentX;
      const Y_start_coord = currentY;

      // Apply pixel offset for smooth scrolling
      gridContainer.style.transform = `translate(${gridOffsetX}px, ${gridOffsetY}px)`;

      for (let r = 0; r < numRows; r++) {
        for (let c = 0; c < numCols; c++) {
          // Logical X, Y for the formula
          const x = X_start_coord + BigInt(c);
          const y = Y_start_coord + BigInt(r);
          
          let N = evaluateFormula(x, y, formula);

          const cell = document.createElement('div');
          cell.className = 'grid-cell';
          cell.id = `cell-${x}-${y}`;

          // Display coords and number
          cell.innerHTML = `(${formatNumberWithCommas(x)}, ${formatNumberWithCommas(y)})<br><span class="text-xs font-normal">${formatNumberWithCommas(N)}</span>`;
          
          if (x === 0n || y === 0n) {
             cell.classList.add('axis');
             if (x === 0n && y === 0n) {
                cell.classList.add('origin');
             }
          }

          if (shouldCheck) {
            itemsProcessing++;
            cell.classList.add('processing');
            // Send N to worker for check
            primalityWorker.postMessage({
              type: 'check_primality',
              number: N.toString(),
              formula: formula
            });
          }
          gridContainer.appendChild(cell);
        }
      }
      if (shouldCheck) {
          setStatus(`Checking ${numRows * numCols} cells using QR Filter and Miller-Rabin...`);
      } else {
          setStatus('Grid generated. Drag to scroll.');
      }
      document.getElementById('formulaDisplay').textContent = `N = ${formula}`;
    }

    // --- WORKER MESSAGE HANDLER ---
    function handleWorkerMessage(e) {
      const data = e.data;
      const N = BigInt(data.number);
      // The formula here requires finding the X, Y coordinates again, which is tricky.
      // We rely on the fact that N will be unique in the view for now.
      
      let foundCell = null;
      // Search for the cell containing the number N (by its content string, not its ID, as IDs are based on currentX/Y)
      // This is inefficient but necessary since we don't send X,Y back from the worker
      const allCells = gridContainer.querySelectorAll('.grid-cell');
      for(const cell of allCells) {
          if (cell.innerHTML.includes(formatNumberWithCommas(N))) {
              foundCell = cell;
              break;
          }
      }

      if (!foundCell) return;

      itemsProcessing--;
      foundCell.classList.remove('processing');

      // Apply visual classes based on result
      if (data.result === 'prime') {
        foundCell.classList.add('prime');
      } else if (data.result === 'qr-fail') {
        foundCell.classList.add('qr-fail');
      } else { // composite
        foundCell.classList.add('composite');
      }

      if (itemsProcessing === 0) {
        setStatus('All primality checks complete. Drag to refresh.');
      }
    }

    // --- INFINITE SCROLL / PAN LOGIC ---

    function updateLogicalCoords() {
      // Calculate how many cells we've logically scrolled past
      const deltaX = Math.round(gridOffsetX / CELL_SIZE);
      const deltaY = Math.round(gridOffsetY / CELL_SIZE);
      
      // Update logical start coordinates
      currentX = currentX - BigInt(deltaX);
      currentY = currentY - BigInt(deltaY);

      // Reset pixel offset to keep the grid centralized and prevent floating point errors
      gridOffsetX = gridOffsetX % CELL_SIZE; 
      gridOffsetY = gridOffsetY % CELL_SIZE;

      // Re-render the grid based on the new logical coordinates
      renderGrid(true);
    }

    // --- Event Handlers ---
    gridWindow.addEventListener('mousedown', (e) => {
      isDragging = true;
      startX = e.clientX;
      startY = e.clientY;
      gridWindow.style.cursor = 'grabbing';
      gridContainer.style.transition = 'none'; // Disable transition during drag
    });

    window.addEventListener('mouseup', () => {
      if (isDragging) {
        isDragging = false;
        gridWindow.style.cursor = 'grab';
        gridContainer.style.transition = 'transform 0.5s'; 
        updateLogicalCoords(); // Re-render grid after drag ends
      }
    });

    window.addEventListener('mousemove', (e) => {
      if (!isDragging) return;
      const dx = e.clientX - startX;
      const dy = e.clientY - startY;

      // Update total pixel offsets
      gridOffsetX += dx;
      gridOffsetY += dy;

      // Apply temporary transform for smooth visual dragging
      gridContainer.style.transform = `translate(${gridOffsetX}px, ${gridOffsetY}px)`;

      startX = e.clientX;
      startY = e.clientY;
    });
    
    // Touch event setup for mobile scrolling
    gridWindow.addEventListener('touchstart', (e) => {
        e.preventDefault(); 
        isDragging = true;
        startX = e.touches[0].clientX;
        startY = e.touches[0].clientY;
        gridContainer.style.transition = 'none';
    }, { passive: false });

    gridWindow.addEventListener('touchmove', (e) => {
        if (!isDragging) return;
        const dx = e.touches[0].clientX - startX;
        const dy = e.touches[0].clientY - startY;

        gridOffsetX += dx;
        gridOffsetY += dy;
        gridContainer.style.transform = `translate(${gridOffsetX}px, ${gridOffsetY}px)`;
        
        startX = e.touches[0].clientX;
        startY = e.touches[0].clientY;
    });
    
    gridWindow.addEventListener('touchend', () => {
        if (isDragging) {
            isDragging = false;
            gridContainer.style.transition = 'transform 0.5s'; 
            updateLogicalCoords();
        }
    });

    // --- Initialization ---
    function initialize() {
        // Initial setup for logical coordinates
        currentX = parseBigInt(initialXInput.value);
        currentY = parseBigInt(initialYInput.value);
        gridOffsetX = 0; gridOffsetY = 0;

        initializeWorker();
        renderGrid(true);
    }

    drawButton.addEventListener('click', () => {
        currentX = parseBigInt(initialXInput.value);
        currentY = parseBigInt(initialYInput.value);
        gridOffsetX = 0; gridOffsetY = 0;
        initializeWorker();
        renderGrid(true);
    });
    
    resetButton.addEventListener('click', () => {
        initialXInput.value = "1";
        initialYInput.value = "1";
        formulaInput.value = "X*Y+1";
        initialize();
    });

    // Re-render on window resize to adjust column/row count
    window.addEventListener('resize', () => renderGrid(false));
    
    initialize();

  </script>
</body>
</html>

