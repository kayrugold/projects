<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Infinite Multiplication Table v0.0.2</title>
    <script src="https://unpkg.com/big-integer@1.6.48/BigInteger.min.js"></script>
    <style>
        :root {
            --bg-color: #1a1a1a;
            --grid-bg: #2c2c2c;
            --text-color: #e5e7eb;
            --header-bg: #111;
            --header-text: #fff;
            --header-prime: #f72585; /* Hot Pink */
            --header-blue: #4361ee;
            --highlight-blue: rgba(67, 97, 238, 0.5);
            --grid-line: #333;
        }
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            width: 100%;
            height: 100%;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            user-select: none;
            touch-action: none;
        }
        canvas {
            display: block;
            background-color: var(--grid-bg);
            touch-action: none;
            /* --- FIX: Position canvas --- */
            position: fixed;
            top: 50px; /* Default, will be updated by JS */
            left: 0;
        }
        #controls {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            background: rgba(20, 20, 20, 0.8);
            backdrop-filter: blur(5px);
            padding: 10px;
            box-sizing: border-box;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
            border-bottom: 1px solid var(--grid-line);
            z-index: 10;
        }
        #controls label {
            font-weight: bold;
            font-size: 1.1em;
        }
        #controls input {
            background: #333;
            color: var(--text-color);
            border: 1px solid #555;
            border-radius: 5px;
            padding: 8px;
            font-size: 1em;
            width: 100px;
        }
        #controls button {
            background: var(--header-blue);
            color: white;
            border: none;
            border-radius: 5px;
            padding: 8px 12px;
            font-weight: bold;
            cursor: pointer;
            font-size: 1em;
        }
        #controls button:hover {
            background: #3a52cc;
        }
        #infoBox {
            font-size: 0.9em;
            color: #aaa;
        }
    </style>
</head>
<body>

    <div id="controls">
        <label for="xInput">X:</label>
        <input type="text" id="xInput" value="1" inputmode="numeric">
        <label for="yInput">Y:</label>
        <input type="text" id="yInput" value="1" inputmode="numeric">
        <button id="goButton">Go</button>
        <div id="infoBox">Zoom: 1.00x</div>
    </div>

    <canvas id="gridCanvas"></canvas>

    <script>
        // --- Globals ---
        const canvas = document.getElementById('gridCanvas');
        const ctx = canvas.getContext('2d');
        const xInput = document.getElementById('xInput');
        const yInput = document.getElementById('yInput');
        const goButton = document.getElementById('goButton');
        const infoBox = document.getElementById('infoBox');
        const controlsPanel = document.getElementById('controls');

        // --- Grid State ---
        let scale = 1.0;
        let offsetX = 0.0;
        let offsetY = 0.0;
        let headerSize = 60;
        let cellSize = 80;
        let controlPanelHeight = 50; // Default, will be measured
        
        let gridOriginCol = bigInt(1);
        let gridOriginRow = bigInt(1);
        let highlightedCell = { x: bigInt(1), y: bigInt(1) };

        let isPanning = false;
        let lastPan = { x: 0, y: 0 };
        let lastTouchDist = 0;

        const primeCache = new Map();
        const colors = {};
        function getColors() {
            const rootStyle = getComputedStyle(document.documentElement);
            colors.gridBg = rootStyle.getPropertyValue('--grid-bg').trim();
            colors.textColor = rootStyle.getPropertyValue('--text-color').trim();
            colors.headerBg = rootStyle.getPropertyValue('--header-bg').trim();
            colors.headerText = rootStyle.getPropertyValue('--header-text').trim();
            colors.headerPrime = rootStyle.getPropertyValue('--header-prime').trim();
            colors.headerBlue = rootStyle.getPropertyValue('--header-blue').trim();
            colors.highlightBlue = rootStyle.getPropertyValue('--highlight-blue').trim();
            colors.gridLine = rootStyle.getPropertyValue('--grid-line').trim();
        }

        // --- Primality Test Functions ---
        function powMod(base, exp, mod) {
            let result = bigInt.one;
            base = base.mod(mod);
            while (exp.greater(0)) {
                if (exp.isOdd()) result = result.multiply(base).mod(mod);
                exp = exp.shiftRight(1);
                base = base.square().mod(mod);
            }
            return result;
        }
        function randomBigInt(low, high) {
            return bigInt.randBetween(low, high);
        }
        function millerRabinTest(n, k = 10) {
            if (n.equals(2) || n.equals(3)) return true;
            if (n.lesser(2) || n.isEven()) return false;
            const nStr = n.toString();
            if (primeCache.has(nStr)) return primeCache.get(nStr);
            let d = n.subtract(1);
            let s = 0;
            while (d.isEven()) {
                d = d.shiftRight(1);
                s++;
            }
            for (let i = 0; i < k; i++) {
                const a = randomBigInt(bigInt(2), n.subtract(2));
                let x = powMod(a, d, n);
                if (x.equals(1) || x.equals(n.subtract(1))) continue;
                let composite = true;
                for (let j = 1; j < s; j++) {
                    x = x.square().mod(n);
                    if (x.equals(1)) break;
                    if (x.equals(n.subtract(1))) {
                        composite = false;
                        break;
                    }
                }
                if (composite) {
                    primeCache.set(nStr, false);
                    return false;
                }
            }
            primeCache.set(nStr, true);
            return true;
        }

        // --- Canvas Setup ---
        function resizeCanvas() {
            // **FIX**: Measure control panel and position canvas below it
            controlPanelHeight = controlsPanel.offsetHeight;
            canvas.style.top = controlPanelHeight + 'px';
            
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight - controlPanelHeight;
            draw();
        }
        window.addEventListener('resize', resizeCanvas);

        // --- Main Draw Loop ---
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const view = {
                x1: -offsetX / scale,
                y1: -offsetY / scale,
                x2: (canvas.width - offsetX) / scale,
                y2: (canvas.height - offsetY) / scale
            };
            const dataView = {
                x1: view.x1 - headerSize,
                y1: view.y1 - headerSize,
                x2: view.x2 - headerSize,
                y2: view.y2 - headerSize
            };
            const currentCellSize = cellSize;
            const minCol = Math.floor(dataView.x1 / currentCellSize);
            const maxCol = Math.ceil(dataView.x2 / currentCellSize);
            const minRow = Math.floor(dataView.y1 / currentCellSize);
            const maxRow = Math.ceil(dataView.y2 / currentCellSize);

            ctx.save();
            ctx.translate(offsetX, offsetY);
            ctx.scale(scale, scale);
            ctx.font = `${16 / scale}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            for (let r = minRow; r <= maxRow; r++) {
                const cellYNum = gridOriginRow.add(r);
                if (cellYNum.lesser(1)) continue;
                const drawY = headerSize + r * currentCellSize;
                for (let c = minCol; c <= maxCol; c++) {
                    const cellXNum = gridOriginCol.add(c);
                    if (cellXNum.lesser(1)) continue;
                    const drawX = headerSize + c * currentCellSize;
                    const product = cellXNum.multiply(cellYNum);
                    ctx.fillStyle = colors.gridBg;
                    ctx.fillRect(drawX, drawY, currentCellSize, currentCellSize);
                    if (cellXNum.equals(highlightedCell.x) && cellYNum.equals(highlightedCell.y)) {
                        ctx.fillStyle = colors.highlightBlue;
                        ctx.fillRect(drawX, drawY, currentCellSize, currentCellSize);
                    }
                    ctx.strokeStyle = colors.gridLine;
                    ctx.strokeRect(drawX, drawY, currentCellSize, currentCellSize);
                    ctx.fillStyle = colors.textColor;
                    ctx.fillText(product.toString(), drawX + currentCellSize / 2, drawY + currentCellSize / 2);
                }
            }
            ctx.restore();

            ctx.save();
            ctx.fillStyle = colors.headerBg;
            // **FIX**: Draw headers relative to canvas, not viewport
            ctx.fillRect(0, 0, canvas.width, headerSize);
            ctx.fillRect(0, 0, headerSize, canvas.height); 
            ctx.fillStyle = colors.headerText;
            ctx.font = `bold ${Math.min(20, headerSize * 0.3)}px Arial`;
            
            for (let r = minRow; r <= maxRow; r++) {
                const cellYNum = gridOriginRow.add(r);
                if (cellYNum.lesser(1)) continue;
                const worldY = headerSize + r * currentCellSize;
                const drawY = worldY * scale + offsetY;
                if (drawY > canvas.height || drawY + currentCellSize * scale < headerSize) continue;
                const isPrime = millerRabinTest(cellYNum);
                ctx.fillStyle = isPrime ? colors.headerPrime : colors.headerBlue;
                ctx.fillRect(0, drawY, headerSize, currentCellSize * scale);
                ctx.fillStyle = colors.headerText;
                ctx.strokeStyle = colors.gridLine;
                ctx.strokeRect(0, drawY, headerSize, currentCellSize * scale);
                ctx.fillText(cellYNum.toString(), headerSize / 2, drawY + (currentCellSize * scale) / 2);
            }

            for (let c = minCol; c <= maxCol; c++) {
                const cellXNum = gridOriginCol.add(c);
                if (cellXNum.lesser(1)) continue;
                const worldX = headerSize + c * currentCellSize;
                const drawX = worldX * scale + offsetX;
                if (drawX > canvas.width || drawX + currentCellSize * scale < headerSize) continue;
                const isPrime = millerRabinTest(cellXNum);
                ctx.fillStyle = isPrime ? colors.headerPrime : colors.headerBlue;
                ctx.fillRect(drawX, 0, currentCellSize * scale, headerSize);
                ctx.fillStyle = colors.headerText;
                ctx.strokeStyle = colors.gridLine;
                ctx.strokeRect(drawX, 0, currentCellSize * scale, headerSize);
                ctx.fillText(cellXNum.toString(), drawX + (currentCellSize * scale) / 2, headerSize / 2);
            }

            ctx.fillStyle = "#000";
            ctx.fillRect(0, 0, headerSize, headerSize);
            ctx.strokeStyle = colors.gridLine;
            ctx.strokeRect(0, 0, headerSize, headerSize);
            ctx.fillStyle = colors.headerText;
            ctx.fillText("X * Y", headerSize/2, headerSize/2);
            ctx.restore();
        }

        // --- Interaction Handlers ---
        function centerOnCell(targetX, targetY) {
            highlightedCell = { x: targetX, y: targetY };
            const targetCol = targetX.subtract(gridOriginCol);
            const targetRow = targetY.subtract(gridOriginRow);
            const worldX = headerSize + targetCol.multiply(cellSize).toJSNumber() + cellSize / 2;
            const worldY = headerSize + targetRow.multiply(cellSize).toJSNumber() + cellSize / 2;
            const screenX = canvas.width / 2;
            const screenY = canvas.height / 2;
            offsetX = screenX - worldX * scale;
            offsetY = screenY - worldY * scale;
            draw();
        }

        goButton.addEventListener('click', () => {
            try {
                const x = bigInt(xInput.value);
                const y = bigInt(yInput.value);
                if (x.lesser(1) || y.lesser(1)) {
                    alert("Please enter positive integers.");
                    return;
                }
                centerOnCell(x, y);
            } catch (e) {
                console.error(e);
                alert("Invalid number format.");
            }
        });

        // --- Pan Listeners (using offsetX/Y for canvas-relative coords) ---
        canvas.addEventListener('mousedown', (e) => {
            isPanning = true;
            lastPan = { x: e.offsetX, y: e.offsetY };
        });
        canvas.addEventListener('mousemove', (e) => {
            if (!isPanning) return;
            const deltaX = e.offsetX - lastPan.x;
            const deltaY = e.offsetY - lastPan.y;
            offsetX += deltaX;
            offsetY += deltaY;
            lastPan = { x: e.offsetX, y: e.offsetY };
            draw();
        });
        canvas.addEventListener('mouseup', () => { isPanning = false; });
        canvas.addEventListener('mouseleave', () => { isPanning = false; });

        // --- Zoom Listener (using offsetX/Y) ---
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const factor = e.deltaY > 0 ? 0.9 : 1.1;
            const mouseX = e.offsetX; // **FIX**: Use offsetX
            const mouseY = e.offsetY; // **FIX**: Use offsetY
            offsetX = mouseX - (mouseX - offsetX) * factor;
            offsetY = mouseY - (mouseY - offsetY) * factor;
            scale *= factor;
            scale = Math.max(0.1, Math.min(scale, 20));
            infoBox.textContent = `Zoom: ${scale.toFixed(2)}x`;
            draw();
        }, { passive: false });

        // --- Touch Listeners (calculating canvas-relative coords) ---
        canvas.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1) {
                isPanning = true;
                // **FIX**: Calculate canvas-relative touch position
                lastPan = { 
                    x: e.touches[0].clientX, 
                    y: e.touches[0].clientY - controlPanelHeight 
                };
            } else if (e.touches.length === 2) {
                isPanning = false;
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                lastTouchDist = Math.hypot(dx, dy);
            }
        });
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (e.touches.length === 1 && isPanning) {
                // **FIX**: Calculate canvas-relative touch position
                const touchX = e.touches[0].clientX;
                const touchY = e.touches[0].clientY - controlPanelHeight;
                const deltaX = touchX - lastPan.x;
                const deltaY = touchY - lastPan.y;
                offsetX += deltaX;
                offsetY += deltaY;
                lastPan = { x: touchX, y: touchY };
                draw();
            } else if (e.touches.length === 2) {
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                const newDist = Math.hypot(dx, dy);
                const factor = newDist / lastTouchDist;
                
                // **FIX**: Calculate canvas-relative midpoint
                const midX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                const midY = (e.touches[0].clientY + e.touches[1].clientY) / 2 - controlPanelHeight;

                offsetX = midX - (midX - offsetX) * factor;
                offsetY = midY - (midY - offsetY) * factor;
                scale *= factor;
                scale = Math.max(0.1, Math.min(scale, 20));
                infoBox.textContent = `Zoom: ${scale.toFixed(2)}x`;
                lastTouchDist = newDist;
                draw();
            }
        }, { passive: false });
        canvas.addEventListener('touchend', () => {
            isPanning = false;
            lastTouchDist = 0;
        });

        // --- Initial Load ---
        getColors();
        resizeCanvas(); // This now also positions the canvas
        centerOnCell(bigInt(1), bigInt(1));
    </script>
</body>
</html>
