<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>SGS Poly-Algo Squad (v0.0.12 - Recursive Check)</title>
<script src="https://cdn.tailwindcss.com"></script>
<style>
:root {
  --bg-color: #0f172a;
  --card-bg: #1e293b;
  --text-main: #e2e8f0;
  --accent-fermat: #6366f1;
  --accent-rho: #f59e0b;
  --accent-p1: #ec4899;
  --accent-td: #22c55e;
  --accent-qs: #0ea5e9;
}
body { font-family: 'Inter', sans-serif; background: var(--bg-color); color: var(--text-main); padding: 1rem; }
.card { max-width: 1000px; margin: 0 auto; background: var(--card-bg); border-radius: 1rem; padding: 1.5rem; box-shadow: 0 20px 25px -5px rgba(0,0,0,0.3); }
.worker-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 0.75rem; margin-top: 1rem; }
.worker-card { padding: 0.75rem; border-radius: 0.5rem; font-size: 0.70rem; font-weight: bold; text-align: center; color: white; transition: transform 0.1s; box-shadow: 0 4px 6px -1px rgba(0,0,0,0.2); }
.log-box { height: 250px; overflow-y: auto; background: #020617; color: #34d399; padding: 1rem; border-radius: 0.5rem; font-family: monospace; font-size: 0.8rem; border: 1px solid #334155; }
.input { background: #334155; border: 1px solid #475569; color: white; padding: 0.5rem; border-radius: 0.25rem; width: 100%; }
.btn { padding: 0.75rem 1.5rem; border-radius: 0.5rem; font-weight: bold; cursor: pointer; transition: opacity 0.2s; }
.bg-fermat { background: var(--accent-fermat); }
.bg-rho { background: var(--accent-rho); color: black; }
.bg-p1 { background: var(--accent-p1); }
.bg-td { background: var(--accent-td); color: black; }
.bg-qs { background: var(--accent-qs); color: black; }
.flash { animation: flashRed 1s infinite; }
@keyframes flashRed { 0% { color: #f87171; } 50% { color: white; } 100% { color: #f87171; } }
</style>
</head>
<body>
<div class="card">
    <h1 class="text-2xl font-bold text-center text-blue-400 mb-2">SGS Poly-Algorithm Squad v0.0.12</h1>
    <div class="text-center text-xs text-gray-400 mb-4">
        <span class="text-purple-400 font-bold">FEATURE: Recursive Miller-Rabin Gatekeeper</span>
    </div>

    <div class="grid grid-cols-3 gap-4 mb-4">
        <div><label class="block text-xs font-bold mb-1 text-gray-400">Base (a)</label><input id="base-input" type="text" class="input" value="10"></div>
        <div><label class="block text-xs font-bold mb-1 text-gray-400">Exp (b)</label><input id="exponent-input" type="text" class="input" value="40"></div>
        <div><label class="block text-xs font-bold mb-1 text-gray-400">Add (c)</label><input id="addend-input" type="text" class="input" value="1"></div>
    </div>
    
    <div class="flex gap-4 justify-center mb-6">
        <button id="start-btn" class="btn bg-green-600 text-white">Deploy Squad</button>
        <button id="stop-btn" class="btn bg-red-600 text-white" disabled>Abort</button>
    </div>

    <div id="worker-grid" class="worker-grid"></div>

    <div class="mt-4 bg-slate-800 p-3 rounded border border-slate-700">
        <div class="flex justify-between items-end">
            <div>
                <p class="text-xs uppercase font-bold text-slate-400">Factors Found</p>
                <p id="factors-output" class="text-md font-bold text-white break-all">None</p>
            </div>
            <div class="text-right">
                <p class="text-xs uppercase font-bold text-slate-400">Remaining N</p>
                <p id="cofactor-output" class="text-xs font-mono text-slate-300 break-all">N/A</p>
            </div>
        </div>
    </div>

    <div class="mt-4">
        <pre id="log-output" class="log-box">System Ready.</pre>
    </div>
</div>

<script>
const NUM_WORKERS = 8;
const QR_PRIMES = [3n, 5n, 7n, 11n, 13n, 17n, 19n, 23n, 29n, 31n, 37n, 41n, 43n, 47n, 53n];
const FERMAT_RANGE = 2000000n;

// --- MAIN THREAD MILLER-RABIN UTILS ---
function mainPowMod(base, exp, mod) {
    let r = 1n; base %= mod;
    while (exp > 0n) { if ((exp & 1n) === 1n) r = (r * base) % mod; exp >>= 1n; base = (base * base) % mod; }
    return r;
}

function isPrimeMR(n) {
    if (n === 2n || n === 3n) return true;
    if (n < 2n || n % 2n === 0n) return false;
    let d = n - 1n;
    let s = 0n;
    while (d % 2n === 0n) { d /= 2n; s++; }
    const bases = [2n, 3n, 5n, 7n, 11n, 13n, 17n, 19n, 23n, 29n, 31n, 37n];
    for (let a of bases) {
        if (n <= a) break;
        let x = mainPowMod(a, d, n);
        if (x === 1n || x === n - 1n) continue;
        let composite = true;
        for (let r = 1n; r < s; r++) {
            x = (x * x) % n;
            if (x === n - 1n) { composite = false; break; }
        }
        if (composite) return false;
    }
    return true;
}

const factorWorkerCode = `
    let spinIdx = 0;
    const spinners = ['|', '/', '-', '\\\\'];
    function getSpin() { spinIdx = (spinIdx + 1) % 4; return spinners[spinIdx]; }

    const SQ_MOD_4096 = new Uint8Array(4096);
    for (let i = 0; i < 4096; i++) SQ_MOD_4096[(i * i) % 4096] = 1;

    function gcd(a, b) { while (b > 0n) { let t = b; b = a % b; a = t; } return a; }
    function powMod(base, exp, mod) {
        let r = 1n; base %= mod;
        while (exp > 0n) { if ((exp & 1n) === 1n) r = (r * base) % mod; exp >>= 1n; base = (base * base) % mod; }
        return r;
    }
    function customIntegerSqrt(n) {
        if (n < 0n) return null; if (n < 2n) return n;
        let x = n; let y = (x + 1n) / 2n;
        while (y < x) { x = y; y = (x + n / x) / 2n; }
        return x;
    }
    function legendreSymbol(a, p) {
        if (a === 0n) return 0; if (p === 2n) return 1;
        a = (a % p + p) % p;
        const ls = powMod(a, (p - 1n) / 2n, p);
        return (ls === p - 1n) ? -1 : 1;
    }

    function runRho(data) {
        const N = BigInt(data.n_str);
        let c = 1n; let x = 2n, y = 2n, d = 1n;
        let steps = 0;
        while (d === 1n) {
            x = (x * x + c) % N;
            y = (y * y + c) % N; y = (y * y + c) % N;
            let diff = x > y ? x - y : y - x;
            d = gcd(diff, N);
            steps++;
            if (steps % 50000 === 0) {
                self.postMessage({ type: 'status', msg: \`\${getSpin()} Spin \${steps}\`, idx: data.idx });
            }
        }
        if (d !== N) self.postMessage({ type: 'factor', val: d.toString(), algo: 'Rho', idx: data.idx });
    }

    function runP1(data) {
        const N = BigInt(data.n_str);
        let B = 50000n; 
        let a = 2n;
        while (true) {
            self.postMessage({ type: 'status', msg: \`\${getSpin()} Revving to \${B}\`, idx: data.idx });
            a = 2n; 
            for (let i = 2n; i <= B; i++) {
                a = powMod(a, i, N);
                if (i % 10000n === 0n) {
                    self.postMessage({ type: 'status', msg: \`\${getSpin()} Revving \${i}/\${B}\`, idx: data.idx });
                }
            }
            const d = gcd(a - 1n, N);
            if (d > 1n && d < N) {
                self.postMessage({ type: 'factor', val: d.toString(), algo: 'P-1', idx: data.idx });
                return;
            } else {
                B *= 2n;
                self.postMessage({ type: 'status', msg: \`Missed. Power -> \${B}\`, idx: data.idx });
            }
        }
    }

    function runTrialDiv(data) {
        const N = BigInt(data.n_str);
        let p = 3n; 
        let checks = 0;
        if (N % 2n === 0n) { self.postMessage({ type: 'factor', val: '2', algo: 'TrialDiv', idx: data.idx }); return; }
        while (true) {
            if (p * p > N) break; 
            if (N % p === 0n) {
                self.postMessage({ type: 'factor', val: p.toString(), algo: 'TrialDiv', idx: data.idx });
                return;
            }
            p += 2n;
            checks++;
            if (checks % 50000 === 0) {
                self.postMessage({ type: 'status', msg: \`\${getSpin()} Checking \${p}\`, idx: data.idx });
            }
        }
    }

    function runQS(data) {
        const N = BigInt(data.n_str);
        const idx = data.idx;
        const B = 1200; 
        const factorBase = [];
        const isPrime = new Uint8Array(B + 1).fill(1);
        factorBase.push(2n);
        for(let i=3; i<=B; i+=2) {
            if(isPrime[i]) {
                if (legendreSymbol(N, BigInt(i)) !== -1) factorBase.push(BigInt(i));
                for(let j=i*i; j<=B; j+=i) isPrime[j] = 0;
            }
        }
        self.postMessage({ type: 'status', msg: \`FB: \${factorBase.length} Primes\`, idx });

        let sqrtN = customIntegerSqrt(N);
        let relations = [];
        let targetRelations = factorBase.length + 10; 
        let xOffset = 0n;
        let limit = 200000n;

        while (relations.length < targetRelations) {
            let x = sqrtN + xOffset;
            let Q = x * x - N; 
            let tempQ = Q < 0n ? -Q : Q;
            let vector = new Array(factorBase.length).fill(0);
            for (let i = 0; i < factorBase.length; i++) {
                const p = factorBase[i];
                while (tempQ % p === 0n) {
                    tempQ /= p;
                    vector[i] ^= 1;
                }
            }
            if (tempQ === 1n) {
                relations.push({ x: x, v: vector, q: Q });
                self.postMessage({ type: 'status', msg: \`\${getSpin()} Rels: \${relations.length}/\${targetRelations}\`, idx });
            }
            xOffset = (xOffset <= 0n) ? (-xOffset + 1n) : (-xOffset);
            if (xOffset > limit) {
                limit *= 2n;
                self.postMessage({ type: 'status', msg: \`Widening QS Net...\`, idx });
            }
        }

        self.postMessage({ type: 'status', msg: 'Solving Matrix...', idx });
        const M = relations.length;
        const K = factorBase.length;
        let matrix = relations.map(r => [...r.v]);
        let history = relations.map((r, i) => [i]); 

        for (let col = 0; col < K; col++) {
            let pivot = -1;
            for (let row = 0; row < M; row++) {
                if (matrix[row][col] === 1) { pivot = row; break; }
            }
            if (pivot !== -1) {
                for (let row = 0; row < M; row++) {
                    if (row !== pivot && matrix[row][col] === 1) {
                        for (let j = 0; j < K; j++) matrix[row][j] ^= matrix[pivot][j];
                        history[row] = history[row].concat(history[pivot]);
                    }
                }
            }
        }

        for (let row = 0; row < M; row++) {
            if (matrix[row].every(val => val === 0)) {
                let X = 1n;
                let Y_sq_prod = 1n;
                for (let originalIdx of history[row]) {
                    X = (X * relations[originalIdx].x) % N;
                    Y_sq_prod = Y_sq_prod * relations[originalIdx].q;
                }
                let Y = customIntegerSqrt(Y_sq_prod);
                if (Y !== null) {
                    Y = Y % N;
                    let f1 = gcd(X - Y, N);
                    if (f1 > 1n && f1 < N) {
                        self.postMessage({ type: 'factor', val: f1.toString(), algo: 'QuadSieve', idx });
                        return;
                    }
                }
            }
        }
        self.postMessage({ type: 'status', msg: 'Matrix Failed', idx });
    }

    function runFermat(data) {
        const N = BigInt(data.n_str);
        let minS = BigInt(data.minS);
        const maxS = BigInt(data.maxS);
        const primes = data.primes.map(BigInt);
        const fourN = N * 4n;
        let step = (N % 2n !== 0n) ? 2n : 1n;
        if (step === 2n && minS % 2n !== 0n) minS += 1n;

        let candidates = [];
        let processed = 0n;
        const total = maxS - minS;

        for (let S = minS; S <= maxS; S += step) {
            const D_sq = S * S - fourN;
            if (D_sq >= 0n) {
                let passes = true;
                if (SQ_MOD_4096[Number(D_sq & 4095n)] !== 1) passes = false;
                else {
                    for (const p of primes) {
                        if (legendreSymbol(D_sq, p) === -1) { passes = false; break; }
                    }
                }
                if (passes) candidates.push(S);
            }
            processed += step;
            if (processed % 20000n === 0n) { 
                 const pct = Number(processed * 100n / total);
                 self.postMessage({ type: 'status', msg: \`\${getSpin()} Scanning \${pct}%\`, idx: data.idx });
            }
        }
        for (const S of candidates) {
            const D_sq = S * S - fourN;
            const D = customIntegerSqrt(D_sq);
            if (D !== null && D * D === D_sq) {
                const f = (S - D) / 2n;
                if (f > 1n) {
                    self.postMessage({ type: 'factor', val: f.toString(), algo: 'Fermat', idx: data.idx });
                    return;
                }
            }
        }
        self.postMessage({ type: 'fermatDone', idx: data.idx });
    }

    self.onmessage = function(e) {
        if (e.data.mode === 'rho') runRho(e.data);
        else if (e.data.mode === 'p1') runP1(e.data);
        else if (e.data.mode === 'trial') runTrialDiv(e.data);
        else if (e.data.mode === 'qs') runQS(e.data);
        else if (e.data.mode === 'fermat') runFermat(e.data);
    };
`;
const workerBlob = new Blob([factorWorkerCode], { type: 'application/javascript' });
const workerUrl = URL.createObjectURL(workerBlob);

let workers = [];
let N_current = 0n;
let foundFactors = new Set();
let isRunning = false;
let SMin = 0n;
let startTime = 0;

function log(msg) {
    const t = new Date().toLocaleTimeString();
    const el = document.getElementById('log-output');
    el.innerHTML += `[${t}] ${msg}\n`;
    el.scrollTop = el.scrollHeight;
}

function initGrid() {
    const grid = document.getElementById('worker-grid');
    grid.innerHTML = '';
    const roles = [
        { name: 'Fermat 1', color: 'bg-fermat' },
        { name: 'Fermat 2', color: 'bg-fermat' },
        { name: 'Fermat 3', color: 'bg-fermat' },
        { name: 'Fermat 4', color: 'bg-fermat' },
        { name: 'Rho Scout', color: 'bg-rho' },
        { name: 'P-1 Sniper', color: 'bg-p1' },
        { name: 'Trial Div', color: 'bg-td' },
        { name: 'Quad Sieve', color: 'bg-qs' }
    ];

    roles.forEach((role, i) => {
        const div = document.createElement('div');
        div.className = `worker-card ${role.color}`;
        div.innerHTML = `${role.name}<br><span id="status-${i}" class="opacity-75 font-normal">Idle</span>`;
        grid.appendChild(div);
    });
}

function updateStatus(idx, msg) {
    const el = document.getElementById(`status-${idx}`);
    if (el) el.textContent = msg;
}

function stopAll() {
    workers.forEach(w => w && w.terminate());
    workers = new Array(NUM_WORKERS).fill(null);
    isRunning = false;
    document.getElementById('start-btn').disabled = false;
    document.getElementById('stop-btn').disabled = true;
}

function deploySquad() {
    // Force Kill
    workers.forEach(w => w && w.terminate());
    workers = new Array(NUM_WORKERS).fill(null);
    
    for(let i=0; i<NUM_WORKERS; i++) {
        const el = document.getElementById(`status-${i}`);
        if(el) el.innerHTML = '<i class="flash">WAITING...</i>';
    }

    // Initial Start Logic
    if (!isRunning) {
        startTime = Date.now();
        foundFactors.clear();
        document.getElementById('factors-output').textContent = 'None';
        try {
            const a = BigInt(document.getElementById('base-input').value);
            const b = BigInt(document.getElementById('exponent-input').value);
            const c = BigInt(document.getElementById('addend-input').value);
            N_current = a**b + c;
        } catch(e) { log('Invalid Input'); return; }
        log(`Target: ${N_current.toString().substring(0, 20)}...`);
        isRunning = true; // Set running immediately
    }

    // --- THE GATEKEEPER (Miller-Rabin) ---
    if (N_current === 1n) {
        log('Mission Complete: Target reduced to 1.');
        stopAll();
        for(let i=0; i<NUM_WORKERS; i++) document.getElementById(`status-${i}`).textContent = "Complete";
        return;
    }

    if (isPrimeMR(N_current)) {
        log(`ðŸ›‘ GATEKEEPER: ${N_current} is PRIME.`);
        if (!foundFactors.has(N_current.toString())) {
            foundFactors.add(N_current.toString());
            document.getElementById('factors-output').textContent = Array.from(foundFactors).join(' Ã— ');
        }
        N_current = 1n;
        document.getElementById('cofactor-output').textContent = "1";
        log('Mission Complete: Final Factor Found.');
        stopAll();
        for(let i=0; i<NUM_WORKERS; i++) document.getElementById(`status-${i}`).textContent = "Complete";
        return;
    }

    // If we are here, N is Composite. PROCEED.
    document.getElementById('cofactor-output').textContent = N_current.toString();
    
    const sqrt = n => { if(n<2n)return n; let x=n, y=(x+1n)/2n; while(y<x){x=y; y=(x+n/x)/2n;} return x; };
    const isqrt = sqrt(N_current);
    SMin = isqrt * 2n;
    if (SMin*SMin < 4n*N_current) SMin += 1n;

    document.getElementById('start-btn').disabled = true;
    document.getElementById('stop-btn').disabled = false;

    setTimeout(() => {
        for (let i = 0; i < NUM_WORKERS; i++) {
            const w = new Worker(workerUrl);
            workers[i] = w;
            w.onmessage = handleMsg;
            
            if (i < 4) startFermatChunk(i, 4);
            else if (i === 4) w.postMessage({ mode: 'rho', n_str: N_current.toString(), idx: i });
            else if (i === 5) w.postMessage({ mode: 'p1', n_str: N_current.toString(), idx: i });
            else if (i === 6) w.postMessage({ mode: 'trial', n_str: N_current.toString(), idx: i });
            else if (i === 7) w.postMessage({ mode: 'qs', n_str: N_current.toString(), idx: i });
        }
    }, 100);
}

function startFermatChunk(idx, armySize) {
    if (!isRunning) return;
    const offset = BigInt(idx);
    const range = FERMAT_RANGE;
    const myMin = SMin + (offset * range);
    const myMax = myMin + range - 1n;
    workers[idx].postMessage({
        mode: 'fermat',
        n_str: N_current.toString(),
        minS: myMin.toString(),
        maxS: myMax.toString(),
        primes: QR_PRIMES.map(String),
        idx: idx
    });
}

function handleMsg(e) {
    const d = e.data;
    if (d.type === 'status') {
        updateStatus(d.idx, d.msg);
    } else if (d.type === 'factor') {
        const f = BigInt(d.val);
        if (f !== 1n && f !== N_current) {
            const elapsed = (Date.now() - startTime) / 1000;
            log(`ðŸ’¥ ${d.algo} Found: ${f} (${elapsed.toFixed(2)}s)`);
            if (!foundFactors.has(d.val)) {
                foundFactors.add(d.val);
                document.getElementById('factors-output').textContent = Array.from(foundFactors).join(' Ã— ');
                
                if (N_current % f === 0n) {
                    N_current /= f;
                    document.getElementById('cofactor-output').textContent = N_current.toString();
                    log(`Reduced N: ${N_current.toString().substring(0,15)}...`);
                    
                    // RECURSIVE CHECK LOGIC IS INSIDE deploySquad()
                    // We just call it, and it checks Prime status immediately.
                    log('ðŸ”„ Checking New N...');
                    deploySquad(); 
                }
            }
        }
    } else if (d.type === 'fermatDone') {
        if (isRunning) {
            SMin += (FERMAT_RANGE * 4n);
            startFermatChunk(d.idx, 4);
        }
    }
}

document.getElementById('start-btn').onclick = () => { isRunning = false; deploySquad(); };
document.getElementById('stop-btn').onclick = () => {
    stopAll();
    log('Squad Aborted.');
};

initGrid();
</script>
</body>
</html>
