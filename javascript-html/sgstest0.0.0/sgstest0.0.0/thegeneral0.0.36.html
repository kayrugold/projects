<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Number Theory Toolkit</title>
    
    <script src="https://unpkg.com/big-integer@1.6.48/BigInteger.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>

    <style>
        /* --- Global & Tab Navigation Styles --- */
        body {
            margin: 0; padding: 0;
            font-family: system-ui, sans-serif;
            background-color: #1a1a1a; /* Base color from IMT */
        }
        #tab-nav {
            position: fixed;
            top: 0; left: 0; width: 100%;
            display: flex;
            background-color: #0d0d0d;
            border-bottom: 2px solid #f72585;
            z-index: 1000;
        }
        .tab-button {
            padding: 12px 20px;
            color: #9ca3af;
            font-weight: bold;
            font-size: 0.9em;
            cursor: pointer;
            border: none;
            background: transparent;
            flex-grow: 1;
            text-align: center;
        }
        .tab-button.active {
            color: #fff;
            background-color: #f72585;
        }
        .tab-button:hover:not(.active) {
            background-color: #222;
        }
        .app-container {
            width: 100%;
            height: 100vh;
            position: fixed;
            top: 0; left: 0;
            padding-top: 48px; /* Height of tab bar */
            box-sizing: border-box;
            overflow: hidden; /* Prevent scrollbars on parent */
        }
        .app-container:not(.active) {
            display: none;
        }

        /* --- STYLES FOR APP 1: IMT (Prime Hunter) --- */
        #app-imt {
            --bg-color: #1a1a1a;
            --grid-bg: #2c2c2c;
            --text-color: #e5e7eb;
            --placeholder-text: #6b7280;
            --header-bg: #111;
            --header-text: #fff;
            --header-prime: #f72585;
            --header-blue: #4361ee;
            --header-probable: #facc15;
            --highlight-blue: rgba(67, 97, 238, 0.5);
            --grid-line: #333;
            --controls-bg: rgba(20, 20, 20, 0.8);
            --log-text-color: #9ca3af;
            --terminal-bg: #0d0d0d;
            --terminal-text: #00ff41;
            --terminal-prime: #f72585;
            --terminal-probable: #facc15;
            --terminal-composite: #4361ee;
            
            background-color: var(--bg-color);
            color: var(--text-color);
            overflow: hidden;
        }
        #app-imt canvas {
            display: block; background-color: var(--grid-bg);
            touch-action: none; position: fixed;
            top: 48px; 
            left: 0;
            height: calc(100% - 48px);
            width: 100%;
        }
        #app-imt #controls {
            position: fixed; bottom: 0; left: 0; width: 100%;
            background: var(--controls-bg); backdrop-filter: blur(5px);
            border-top: 1px solid var(--grid-line); z-index: 10;
            transition: all 0.3s ease-in-out; overflow: hidden;
        }
        #app-imt #controlsHandle {
            display: flex; justify-content: space-between; align-items: center;
            padding: 10px; cursor: pointer; font-weight: bold;
        }
        #app-imt #zoomInfo { font-size: 0.9em; color: #aaa; }
        #app-imt #controlsContent {
            padding: 10px; display: flex; flex-wrap: wrap;
            gap: 10px; align-items: center; border-top: 1px solid #444;
        }
        #app-imt #controls.collapsed #controlsContent { display: none; }
        #app-imt #controls label { font-weight: bold; font-size: 1.1em; }
        #app-imt #controls input {
            background: #333; color: var(--text-color);
            border: 1px solid #555; border-radius: 5px;
            padding: 8px; font-size: 1em; width: 100px;
        }
        #app-imt #controls button {
            background: var(--header-blue); color: white;
            border: none; border-radius: 5px;
            padding: 8px 12px; font-weight: bold;
            cursor: pointer; font-size: 1em;
        }
        #app-imt #controls button:hover { background: #3a52cc; }
        #app-imt #terminal {
            position: fixed; bottom: -100%; left: 0; width: 100%;
            max-height: 40%; background: var(--terminal-bg);
            border-top: 1px solid var(--header-prime);
            box-shadow: 0 -5px 20px rgba(0,0,0,0.5); z-index: 20;
            transition: bottom 0.3s ease-in-out; display: flex; flex-direction: column;
        }
        #app-imt #terminal.active { bottom: 0; }
        #app-imt #terminalHeader {
            display: flex; justify-content: space-between; align-items: center;
            padding: 8px 12px; background: #222;
            color: var(--header-text); font-weight: bold;
        }
        #app-imt #terminalTitle { flex-grow: 1; }
        #app-imt #terminalButtons { display: flex; gap: 10px; }
        #app-imt .terminalBtn {
            background: #444; color: #fff; border: 1px solid #666;
            border-radius: 4px; padding: 4px 8px;
            cursor: pointer; font-size: 0.8em;
        }
        #app-imt .terminalBtn:hover { background: #555; }
        #app-imt #terminalClose {
            cursor: pointer; font-size: 1.2em;
            padding: 0 5px; margin-left: 10px;
        }
        #app-imt #terminalContent {
            padding: 12px; font-family: 'Courier New', Courier, monospace;
            color: var(--terminal-text); overflow-y: auto; white-space: pre-wrap;
            word-break: break-all; flex-grow: 1;
        }
        #app-imt .status-prime { color: var(--header-prime); }
        #app-imt .status-probable { color: var(--header-probable); }
        #app-imt .status-composite { color: var(--header-blue); }

        /* --- STYLES FOR APP 2: SGS Analyzer --- */
        #app-sgs {
            background-color: #0f172a; color: #e2e8f0;
            font-family: monospace; padding: 2rem;
            overflow-y: auto;
        }
        #app-sgs .card { 
            max-width: 800px; margin: 0 auto; background: #1e293b; 
            padding: 2rem; border-radius: 1rem; 
            box-shadow: 0 10px 30px rgba(0,0,0,0.5); 
        }
        #app-sgs .input { 
            background: #334155; border: 1px solid #475569; padding: 0.5rem; 
            color: white; width: 100%; border-radius: 0.25rem; 
        }
        #app-sgs .btn { 
            background: #3b82f6; color: white; padding: 0.75rem 1.5rem; 
            border-radius: 0.5rem; font-weight: bold; width: 100%; 
            transition: 0.2s; cursor: pointer; 
        }
        #app-sgs .btn:hover { background: #2563eb; }
        #app-sgs .row { display: flex; align-items: center; margin-bottom: 6px; font-size: 0.9rem; }
        #app-sgs .lbl { width: 150px; color: #94a3b8; flex-shrink: 0; }
        #app-sgs .bar-container { flex-grow: 1; background: #0f172a; height: 24px; border-radius: 4px; overflow: hidden; margin: 0 10px; position: relative; }
        #app-sgs .bar { height: 100%; transition: width 0.5s; }
        #app-sgs .val { width: 100px; text-align: right; font-weight: bold; color: #fff; flex-shrink: 0; }
        #app-sgs .delta { width: 80px; text-align: right; color: #f87171; flex-shrink: 0; font-size: 0.8rem; }
        #app-sgs .bg-total { background: #64748b; }
        #app-sgs .bg-bin { background: #8b5cf6; }
        #app-sgs .bg-prime { background: #10b981; }
        #app-sgs .bg-final { background: #f59e0b; }

        /* --- STYLES FOR APP 3: The General --- */
        #app-gen {
            /* Scoped CSS Variables from :root */
            --bg-color: #0f172a;
            --card-bg: #1e293b;
            --text-main: #e2e8f0;
            --accent-fermat: #6366f1;
            --accent-rho: #f59e0b;
            --accent-p1: #ec4899;
            --accent-pp1: #06b6d4;
            --accent-td: #22c55e;
            --accent-qs: #0ea5e9;
            --accent-ecm: #f97316; 
            --accent-giga: #ef4444;
            
            font-family: 'Inter', sans-serif;
            background: var(--bg-color);
            color: var(--text-main);
            padding: 1rem;
            overflow-y: auto;
        }
        #app-gen .card { 
            max-width: 1000px; margin: 0 auto; background: var(--card-bg); 
            border-radius: 1rem; padding: 1.5rem; 
            box-shadow: 0 20px 25px -5px rgba(0,0,0,0.3); 
        }
        #app-gen .worker-grid { 
            display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); 
            gap: 0.75rem; margin-top: 1rem; 
        }
        #app-gen .worker-card { 
            padding: 0.75rem; border-radius: 0.5rem; font-size: 0.70rem; 
            font-weight: bold; text-align: center; color: white; 
            transition: all 0.2s ease; box-shadow: 0 4px 6px -1px rgba(0,0,0,0.2); 
        }
        #app-gen .log-box { 
            height: 250px; overflow-y: auto; background: #020617; 
            color: #34d399; padding: 1rem; border-radius: 0.5rem; 
            font-family: monospace; font-size: 0.8rem; 
            border: 1px solid #334155; 
        }
        #app-gen .input { 
            background: #334155; border: 1px solid #475569; color: white; 
            padding: 0.5rem; border-radius: 0.25rem; width: 100%; 
        }
        #app-gen .btn { 
            padding: 0.5rem 1rem; border-radius: 0.5rem; font-weight: bold; 
            cursor: pointer; transition: opacity 0.2s; 
            display: inline-block; text-align: center;
        }
        #app-gen .bg-fermat { background: var(--accent-fermat); }
        #app-gen .bg-rho { background: var(--accent-rho); color: black; }
        #app-gen .bg-p1 { background: var(--accent-p1); }
        #app-gen .bg-pp1 { background: var(--accent-pp1); color: black; }
        #app-gen .bg-td { background: var(--accent-td); color: black; }
        #app-gen .bg-qs { background: var(--accent-qs); color: black; }
        #app-gen .bg-ecm { background: var(--accent-ecm); color: black; }
        #app-gen .bg-giga { background: var(--accent-giga); color: white; }
        #app-gen .bg-offline { background: #334155 !important; color: #64748b !important; opacity: 0.5; box-shadow: none; border: 1px solid #475569; }
        #app-gen .flash { animation: flashRed 1s infinite; }
        @keyframes flashRed { 0% { color: #f87171; } 50% { color: white; } 100% { color: #f87171; } }
    </style>
</head>
<body>

    <div id="tab-nav">
        <button id="tab-imt" class="tab-button active" onclick="showApp('imt')">Prime Hunter</button>
        <button id="tab-sgs" class="tab-button" onclick="showApp('sgs')">SGS Analyzer</button>
        <button id="tab-gen" class="tab-button" onclick="showApp('gen')">The General</button>
    </div>

    <div id="app-imt" class="app-container active">
        <canvas id="gridCanvas"></canvas>
        <div id="controls" class="collapsed">
            <div id="controlsHandle">
                <span>Controls</span>
                <span id="zoomInfo">Zoom: 1.00x</span>
            </div>
            <div id="controlsContent">
                <label for="xInput">X:</label>
                <input type="text" id="xInput" value="1" inputmode="text">
                <label for="yInput">Y:</label>
                <input type="text" id="yInput" value="1" inputmode="text">
                <button id="goButton">Go</button>
            </div>
        </div>
        <div id="terminal">
            <div id="terminalHeader">
                <span id="terminalTitle">Cell Details</span>
                <div id="terminalButtons">
                    <button id="calcFullBtn" class="terminalBtn" style="display:none;">Calculate Full Value</button>
                    <button id="copyTermBtn" class="terminalBtn">Copy</button>
                </div>
                <span id="terminalClose">&times;</span>
            </div>
            <pre id="terminalContent">Loading...</pre>
        </div>
    </div>
    
    <div id="app-sgs" class="app-container">
        <div class="card">
            <h1 class="text-2xl font-bold text-center text-blue-400 mb-2">SGS Filter Analyzer</h1>
            <p class="text-center text-xs text-gray-400 mb-6">
                Test how many "S-list Candidates" survive your filters.<br>
                (This does NOT find factors; it measures efficiency.)
            </p>
            <div class="grid grid-cols-3 gap-4 mb-4">
                <div><label class="text-xs text-gray-400">Base</label><input id="sgs-base" type="text" class="input" value="10"></div>
                <div><label class="text-xs text-gray-400">Exponent</label><input id="sgs-exp" type="text" class="input" value="30"></div>
                <div><label class="text-xs text-gray-400">Addend</label><input id="sgs-add" type="text" class="input" value="1"></div>
            </div>
            <div class="grid grid-cols-2 gap-4 mb-6">
                <div>
                    <label class="text-xs text-gray-400">Sample Size (Test Shots)</label>
                    <input id="sgs-sample" type="number" class="input" value="100000">
                </div>
                <div>
                    <label class="text-xs text-gray-400">Filter Depth (Primes)</label>
                    <input id="sgs-primeCount" type="number" class="input" value="15">
                </div>
            </div>
            <button onclick="sgs_runAnalysis()" class="btn" id="sgs-runBtn">Run Analysis</button>
            <div id="sgs-status" class="text-center text-yellow-400 mt-2 text-sm h-6"></div>
            <div id="sgs-results" class="mt-8 hidden">
                <div class="flex justify-between border-b border-slate-700 pb-2 mb-2 text-xs text-slate-400 uppercase font-bold">
                    <span style="width:150px">Filter Step</span>
                    <span class="flex-grow text-center">Visual Reduction</span>
                    <span style="width:100px; text-align:right">Remaining</span>
                    <span style="width:80px; text-align:right">Drop</span>
                </div>
                <div id="sgs-bars"></div>
                <div class="mt-6 p-4 bg-slate-800 rounded border border-slate-700 text-sm text-center">
                    <p class="text-slate-300">
                        <strong class="text-yellow-400" id="sgs-res-pct"></strong> of numbers survived to the final check.
                    </p>
                </div>
            </div>
        </div>
    </div>

    <div id="app-gen" class="app-container">
        <div class="card">
            <h1 class="text-2xl font-bold text-center text-blue-400 mb-2">SGS Poly-Algorithm Squad v0.0.39</h1>
            <div class="text-center text-xs text-gray-400 mb-4">
                <span class="text-orange-400 font-bold">FIXED: Rho Heartbeat & QS Discharge</span>
            </div>
            <div class="grid grid-cols-3 gap-4 mb-4">
                <div><label class="block text-xs font-bold mb-1 text-gray-400">Base (a)</label><input id="gen-base-input" type="text" class="input" value="10"></div>
                <div><label class="block text-xs font-bold mb-1 text-gray-400">Exp (b)</label><input id="gen-exponent-input" type="text" class="input" value="1007"></div>
                <div><label class="block text-xs font-bold mb-1 text-gray-400">Add (c)</label><input id="gen-addend-input" type="text" class="input" value="1"></div>
            </div>
            <div class="flex flex-wrap gap-4 justify-center mb-6 items-center">
                <button id="gen-start-btn" class="btn bg-green-600 text-white">Deploy Squad</button>
                <button id="gen-stop-btn" class="btn bg-red-600 text-white" disabled>Abort</button>
                <div class="flex gap-2 ml-4 border-l border-gray-600 pl-4">
                    <button onclick="gen_saveMission()" class="btn bg-blue-600 text-white text-xs">üíæ Save</button>
                    <label class="btn bg-purple-600 text-white text-xs cursor-pointer">
                        üìÇ Load <input type="file" id="gen-file-input" class="hidden" onchange="gen_loadMission(this)">
                    </label>
                    <button onclick="gen_checkFactorDB()" class="btn bg-yellow-600 text-white text-xs">üåê FactorDB</button>
                </div>
            </div>
            <div id="gen-worker-grid" class="worker-grid"></div>
            <div class="mt-4 bg-slate-800 p-3 rounded border border-slate-700">
                <div class="flex justify-between items-end">
                    <div style="max-width: 45%;">
                        <p class="text-xs uppercase font-bold text-slate-400">Factors Found</p>
                        <p id="gen-factors-output" class="text-md font-bold text-white break-all">None</p>
                    </div>
                    <div class="text-right" style="max-width: 50%;">
                        <p class="text-xs uppercase font-bold text-slate-400">Cofactor (Remaining N)</p>
                        <p id="gen-cofactor-output" class="text-xs font-mono text-slate-300 break-all max-h-20 overflow-y-auto">‚Äî</p>
                    </div>
                </div>
                <div class="mt-2 text-right">
                     <p class="text-xs font-bold text-slate-500">Target Status: <span id="gen-target-status" class="text-slate-300">Idle</span></p>
                </div>
            </div>
            <div class="mt-4">
                <pre id="gen-log-output" class="log-box">System Ready.</pre>
            </div>
        </div>
    </div>


    <script>
        // --- Global Tab Switching Logic ---
        const appImt = document.getElementById('app-imt');
        const appSgs = document.getElementById('app-sgs');
        const appGen = document.getElementById('app-gen');
        
        const tabImt = document.getElementById('tab-imt');
        const tabSgs = document.getElementById('tab-sgs');
        const tabGen = document.getElementById('tab-gen');
        
        function showApp(appName) {
            appImt.classList.remove('active');
            appSgs.classList.remove('active');
            appGen.classList.remove('active');
            
            tabImt.classList.remove('active');
            tabSgs.classList.remove('active');
            tabGen.classList.remove('active');

            if (appName === 'imt') {
                appImt.classList.add('active');
                tabImt.classList.add('active');
                if (window.handleImtResize) window.handleImtResize();
            } else if (appName === 'sgs') {
                appSgs.classList.add('active');
                tabSgs.classList.add('active');
            } else if (appName === 'gen') {
                appGen.classList.add('active');
                tabGen.classList.add('active');
            }
        }

        // ===========================================================
        // ===== SCRIPT FOR APP 1: IMT (Prime Hunter) ================
        // ===========================================================
        (function() {
            // This is a self-contained "bubble" for the IMT app.
            // All its vars and functions are private unless attached to window.
            
            // --- Web Worker Code (as a string) ---
            const workerCode = " \
                self.importScripts('https://unpkg.com/big-integer@1.6.48/BigInteger.min.js'); \
                let TRIAL_DIVISION_PRIMES = []; \
                const SIEVE_LIMIT = 10000; \
                function runSieve(limit) { \
                    const isPrime = new Array(limit + 1).fill(true); \
                    isPrime[0] = isPrime[1] = false; \
                    for (let p = 2; p * p <= limit; p++) { \
                        if (isPrime[p]) { \
                            for (let i = p * p; i <= limit; i += p) { \
                                isPrime[i] = false; \
                            } \
                        } \
                    } \
                    const primes = []; \
                    for (let p = 7; p <= limit; p++) { \
                        if (isPrime[p]) { \
                            primes.push(self.bigInt(p)); \
                        } \
                    } \
                    return primes; \
                } \
                TRIAL_DIVISION_PRIMES = runSieve(SIEVE_LIMIT); \
                let A_MOD_P_CACHE = new Map(); \
                let POW_MOD_P_CACHE = new Map(); \
                function powMod(base, exp, mod) { \
                    if (mod === null) return base.pow(exp); \
                    let result = self.bigInt.one; \
                    base = base.mod(mod); \
                    while (exp.greater(0)) { \
                        if (exp.isOdd()) result = result.multiply(base).mod(mod); \
                        exp = exp.shiftRight(1); \
                        base = base.square().mod(mod); \
                    } \
                    return result; \
                } \
                function getComponents(obj) { \
                    if (obj.val) { \
                        return [self.bigInt(obj.val), self.bigInt.zero, self.bigInt.zero]; \
                    } else { \
                        return [self.bigInt(obj.a), self.bigInt(obj.b), self.bigInt(obj.c)]; \
                    } \
                } \
                function getMagnitude(obj) { \
                    if (obj.val) return obj.val.length; \
                    return parseInt(obj.b, 10) + obj.a.length - 1; \
                } \
                function getBigInt(obj, force = false) { \
                    const b_bi = obj.b ? self.bigInt(obj.b) : self.bigInt.zero; \
                    if (!force && b_bi.greater(200)) { \
                        throw new Error('Exponent too large for direct calculation'); \
                    } \
                    const [a, b, c] = getComponents(obj); \
                    if (b.isZero()) return a.add(c); \
                    return powMod(self.bigInt(10), b, null).multiply(a).add(c); \
                } \
                function millerRabinTest(n, k = 10) { \
                    if (n.equals(2) || n.equals(3)) return true; \
                    if (n.lesser(2) || n.isEven()) return false; \
                    if (n.toString().length > 200) k = 2;  \
                    let d = n.subtract(1); \
                    let s = 0; \
                    while (d.isEven()) { d = d.shiftRight(1); s++; } \
                    for (let i = 0; i < k; i++) { \
                        const a = self.bigInt.randBetween(2, n.subtract(2)); \
                        let x = powMod(a, d, n); \
                        if (x.equals(1) || x.equals(n.subtract(1))) continue; \
                        let composite = true; \
                        for (let j = 1; j < s; j++) { \
                            x = x.square().mod(n); \
                            if (x.equals(1)) break; \
                            if (x.equals(n.subtract(1))) { composite = false; break; } \
                        } \
                        if (composite) return false; \
                    } \
                    return true; \
                } \
                function primeCheckStream(n_obj) { \
                    const [A, B, C] = getComponents(n_obj); \
                    const FIVE = self.bigInt(5); \
                    const THREE = self.bigInt(3); \
                    const TEN = self.bigInt(10); \
                    if (A.isZero() && C.isZero()) return false; \
                    if (B.isZero()) { \
                        const N = A.add(C); \
                        if (N.lesser(2)) return false; \
                        if (N.equals(2) || N.equals(3) || N.equals(5)) return true; \
                        if (N.isEven() || N.mod(THREE).isZero() || N.mod(FIVE).isZero()) return false; \
                        return millerRabinTest(N); \
                    } \
                    if (C.isEven()) { return false; } \
                    if (A.add(C).mod(THREE).isZero()) { return false; } \
                    if (C.mod(FIVE).isZero()) { return false; } \
                    const A_str = A.toString(); \
                    const B_str = B.toString(); \
                    for (const p of TRIAL_DIVISION_PRIMES) { \
                        const p_str = p.toString(); \
                        const a_key = A_str + ':' + p_str; \
                        const pow_key = B_str + ':' + p_str; \
                        let A_mod_p = A_MOD_P_CACHE.get(a_key); \
                        if (A_mod_p === undefined) { \
                            A_mod_p = A.mod(p); \
                            A_MOD_P_CACHE.set(a_key, A_mod_p); \
                        } \
                        let Pow_mod_p = POW_MOD_P_CACHE.get(pow_key); \
                        if (Pow_mod_p === undefined) { \
                            Pow_mod_p = powMod(TEN, B, p); \
                            POW_MOD_P_CACHE.set(pow_key, Pow_mod_p); \
                        } \
                        const C_mod_p = C.mod(p); \
                        const N_mod_p = A_mod_p.multiply(Pow_mod_p).add(C_mod_p).mod(p); \
                        if (N_mod_p.isZero()) { \
                            return false; \
                        } \
                    } \
                    return true; \
                } \
                function getProductString(x_obj, y_obj) { \
                    const xMag = getMagnitude(x_obj); \
                    const yMag = getMagnitude(y_obj); \
                    let approxDigits = xMag + yMag - 1; \
                    if (approxDigits >= 21) { \
                        const [Ax, Bx, Cx] = getComponents(x_obj); \
                        const [Ay, By, Cy] = getComponents(y_obj); \
                        let New_A = Ax.multiply(Ay); \
                        const New_B = Bx.add(By); \
                        let coeffStr = New_A.toString(); \
                        if (coeffStr.length > 4) { \
                             coeffStr = New_A.toExponential(0).replace('e+0', ''); \
                        } \
                        return { text: '~' + coeffStr + 'e' + New_B.toString(), color: 'log' }; \
                    } \
                    const x = getBigInt(x_obj); \
                    const y = getBigInt(y_obj); \
                    const product = x.multiply(y); \
                    const productBaseN = product.toString(10); \
                    if (approxDigits >= 9) { \
                        return { text: product.toExponential(2), color: 'normal' }; \
                    } else { \
                        return { text: productBaseN.toUpperCase(), color: 'normal' }; \
                    } \
                } \
                function getPrimality(n_obj) { \
                    const mag = getMagnitude(n_obj); \
                    if (mag >= 200) { \
                        if (primeCheckStream(n_obj)) { \
                            return { isProbablePrime: true }; \
                        } else { \
                            return { isPrime: false }; \
                        } \
                    } else { \
                        if (!primeCheckStream(n_obj)) { \
                            return { isPrime: false }; \
                        } \
                        const n = getBigInt(n_obj, true); \
                        if (millerRabinTest(n)) { \
                            return { isPrime: true }; \
                        } else { \
                            return { isPrime: false }; \
                        } \
                    } \
                } \
                function getDetails(x_obj, y_obj, base, force = false) { \
                    const xMag = getMagnitude(x_obj); \
                    const yMag = getMagnitude(y_obj); \
                    const approxDigits = xMag + yMag - 1; \
                    const x_id = x_obj.val ? x_obj.val : (x_obj.a + 'e' + x_obj.b + '+' + x_obj.c); \
                    const y_id = y_obj.val ? y_obj.val : (y_obj.a + 'e' + y_obj.b + '+' + y_obj.c); \
                    if (!force && approxDigits >= 100) { \
                        const approxProduct = getProductString(x_obj, y_obj); \
                        return { \
                            mode: 'equation', \
                            x: x_id, \
                            y: y_id, \
                            base: 10, \
                            approx: approxProduct.text \
                        }; \
                    } \
                    if (!force && y_obj.val && x_obj.b && self.bigInt(x_obj.b).greater(x_obj.c.length)) { \
                        const [A, B, C] = getComponents(x_obj); \
                        const Y = self.bigInt(y_obj.val); \
                        const New_A = A.multiply(Y); \
                        const New_C = C.multiply(Y); \
                        const b_bi = self.bigInt(x_obj.b); \
                        const c_str = New_C.toString(); \
                        if (b_bi.greater(c_str.length)) { \
                            const numZeros = b_bi.subtract(c_str.length); \
                            const fullValue = New_A.toString() + '0'.repeat(numZeros) + c_str; \
                            return { mode: 'full', value: fullValue }; \
                        } \
                    } \
                    if (!force && x_obj.val && y_obj.b && self.bigInt(y_obj.b).greater(y_obj.c.length)) { \
                        const [A, B, C] = getComponents(y_obj); \
                        const X = self.bigInt(x_obj.val); \
                        const New_A = A.multiply(X); \
                        const New_C = C.multiply(X); \
                        const b_bi = self.bigInt(y_obj.b); \
                        const c_str = New_C.toString(); \
                        if (b_bi.greater(c_str.length)) { \
                            const numZeros = b_bi.subtract(c_str.length); \
                            const fullValue = New_A.toString() + '0'.repeat(numZeros) + c_str; \
                            return { mode: 'full', value: fullValue }; \
                        } \
                    } \
                    try { \
                        const x = getBigInt(x_obj, force); \
                        const y = getBigInt(y_obj, force); \
                        const product = x.multiply(y); \
                        return { \
                            mode: 'full', \
                            value: product.toString(10).toUpperCase(), \
                            base: 10 \
                        }; \
                    } catch (err) { \
                        if (force) { throw err; } \
                        const approxProduct = getProductString(x_obj, y_obj); \
                        return { \
                            mode: 'equation', \
                            x: x_id, \
                            y: y_id, \
                            base: 10, \
                            approx: approxProduct.text \
                        }; \
                    } \
                } \
                self.onmessage = (e) => { \
                    const tasks = e.data; \
                    const base = 10; \
                    const results = []; \
                    for (const task of tasks) { \
                        try { \
                            let data = {}; \
                            if (task.type === 'getProduct') { \
                                data = getProductString(task.x_obj, task.y_obj); \
                            } else if (task.type === 'getPrimality') { \
                                data = getPrimality(task.n_obj); \
                            } else if (task.type === 'getDetails') { \
                                data = getDetails(task.x_obj, task.y_obj, base, false); \
                            } else if (task.type === 'forceGetDetails') { \
                                data = getDetails(task.x_obj, task.y_obj, base, true); \
                            } \
                            results.push({ id: task.id, status: 'success', data: data }); \
                        } catch (err) { \
                            if (task.type.includes('Details')) { \
                                 results.push({ id: task.id, status: 'error', data: { value: 'Error: ' + err.message } }); \
                            } else { \
                                 results.push({ id: task.id, status: 'error', data: { text: 'ERR' } }); \
                            } \
                        } \
                    } \
                    self.postMessage(results); \
                }; \
            ";

            // --- IMT Globals ---
            const canvas = document.getElementById('gridCanvas');
            const ctx = canvas.getContext('2d');
            const xInput = document.getElementById('xInput');
            const yInput = document.getElementById('yInput');
            const goButton = document.getElementById('goButton');
            const controlsPanel = document.getElementById('controls');
            const controlsHandle = document.getElementById('controlsHandle');
            const zoomInfo = document.getElementById('zoomInfo');
            const terminal = document.getElementById('terminal');
            const terminalContent = document.getElementById('terminalContent');
            const terminalClose = document.getElementById('terminalClose');
            const calcFullBtn = document.getElementById('calcFullBtn');
            const copyTermBtn = document.getElementById('copyTermBtn');

            let scale = 1.0, offsetX = 0.0, offsetY = 0.0, cellSize = 80;
            let gridOriginCol = { val: "1" };
            let gridOriginRow = { val: "1" };
            let highlightedCell = { x: { val: "1" }, y: { val: "1" } };
            let isPanning = false, lastPan = { x: 0, y: 0 }, lastTouchDist = 0;
            const colors = {};
            let activeDetailId = null;
            let activeDetailObjects = null;
            const cellCache = new Map();
            let resizeImtCanvas;

            class WorkerManager {
                constructor(numWorkers) {
                    this.requestQueue = new Map();
                    this.workerIdle = new Array(numWorkers).fill(true);
                    this.workers = [];
                    const blob = new Blob([workerCode], { type: 'application/javascript' });
                    const workerUrl = URL.createObjectURL(blob);
                    for (let i = 0; i < numWorkers; i++) {
                        const worker = new Worker(workerUrl);
                        worker.onmessage = (e) => this.handleWorkerResult(e, i);
                        this.workers.push(worker);
                    }
                }
                queueRequest(task) {
                    if (task.id === activeDetailId && !this.workerIdle.every(Boolean)) return;
                    if (!cellCache.has(task.id)) {
                        this.requestQueue.set(task.id, task);
                    }
                }
                processQueue() {
                    if (this.requestQueue.size === 0) return;
                    const idleWorkerIndex = this.workerIdle.indexOf(true);
                    if (idleWorkerIndex === -1) return;
                    let tasks = Array.from(this.requestQueue.values());
                    tasks = tasks.map(t => ({ ...t, base: 10 }));
                    const detailTask = tasks.find(t => t.type.includes('Details'));
                    const batch = detailTask ? [detailTask] : tasks.slice(0, 10);
                    for (const task of batch) { this.requestQueue.delete(task.id); }
                    if (batch.length > 0) {
                        this.workers[idleWorkerIndex].postMessage(batch);
                        this.workerIdle[idleWorkerIndex] = false;
                    }
                }
                handleWorkerResult(e, workerIndex) {
                    this.workerIdle[workerIndex] = true;
                    const results = e.data;
                    let needsRedraw = false;
                    for (const result of results) {
                        if (result.status === 'success') {
                            if (result.id === activeDetailId) { updateTerminal(result.data); }
                            if (!result.id.startsWith('d:')) { cellCache.set(result.id, result.data); }
                            if (result.id.startsWith('p:') || result.id.startsWith('c:')) { needsRedraw = true; }
                        } else {
                            cellCache.set(result.id, { text: 'ERR' });
                            if (result.id === activeDetailId) { updateTerminal({ mode: 'full', value: 'Error calculating value.' }); }
                        }
                    }
                    if (needsRedraw) { requestAnimationFrame(draw); }
                    if (this.requestQueue.size > 0) { this.processQueue(); }
                }
            }
            const workerManager = new WorkerManager(navigator.hardwareConcurrency || 2);
            
            function parseCoordinate(input) {
                const str = input.replace(/\s/g, '').replace(/[+\-]$/, '');
                let match = str.match(/^(\d+)\^(\d+)\+(\d+)$/);
                if (match) {
                    if (match[1] === "10") return { a: "1", b: match[2], c: match[3] };
                    throw new Error("Base-power format only supported for base 10.");
                }
                match = str.match(/^(\d*\.?\d*)e(\d+)\+(\d+)$/);
                if (match) return { a: (match[1] === '' ? '1' : match[1]), b: match[2], c: match[3] };
                match = str.match(/^(\d*\.?\d*)e(\d+)$/);
                if (match) return { a: (match[1] === '' ? '1' : match[1]), b: match[2], c: "0" };
                if (str.match(/^\d+$/)) return { val: str };
                throw new Error("Invalid number format");
            }
            function incrementCoord(coord_obj, i) {
                if (i === 0) return coord_obj;
                if (coord_obj.val) { return { val: bigInt(coord_obj.val).add(i).toString() }; } // Uses big-integer.js
                else { return { a: coord_obj.a, b: coord_obj.b, c: bigInt(coord_obj.c).add(i).toString() }; }
            }
            function getCoordID(obj) {
                if (obj.val) return obj.val;
                return `${obj.a}e${obj.b}+${obj.c}`;
            }
            function areCoordsEqual(obj1, obj2) {
                if (obj1.val && obj2.val) return obj1.val === obj2.val;
                if (obj1.val || obj2.val) return false;
                return obj1.a === obj2.a && obj1.b === obj2.b && obj1.c === obj2.c;
            }
            function getDisplayLabel(current_obj, anchor_obj) {
                const current_id = getCoordID(current_obj);
                if (current_obj.val || (anchor_obj && anchor_obj.val)) {
                    return current_id.length > 15 ? `...${current_id.slice(-12)}` : current_id;
                }
                if (anchor_obj && current_obj.a === anchor_obj.a && current_obj.b === anchor_obj.b) {
                    const c_curr = bigInt(current_obj.c); // Uses big-integer.js
                    const c_anchor = bigInt(anchor_obj.c); // Uses big-integer.js
                    const diff = c_curr.subtract(c_anchor);
                    if (diff.isZero()) return current_id.length > 12 ? `...${current_id.slice(-10)}` : current_id;
                    const diffStr = diff.toString(10).toUpperCase();
                    if (diff.isPositive()) return `+${diffStr}`;
                    return diffStr;
                }
                return current_id.length > 12 ? `...${current_id.slice(-10)}` : current_id;
            }
            function setFittedFont(baseSize, text, isLog, scaledCellSize) {
                let fontSize = baseSize;
                if (isLog) fontSize *= 0.8;
                ctx.font = `bold ${fontSize}px Arial`;
                const padding = scaledCellSize * 0.1;
                const maxWidth = scaledCellSize - padding;
                let width = ctx.measureText(text).width;
                if (width > maxWidth && width > 0) {
                    const scaleFactor = maxWidth / width;
                    fontSize = Math.max(8, fontSize * scaleFactor);
                    ctx.font = `bold ${fontSize}px Arial`;
                }
            }
            function getColors() {
                const rootStyle = getComputedStyle(document.documentElement);
                colors.gridBg = rootStyle.getPropertyValue('--grid-bg').trim();
                colors.textColor = rootStyle.getPropertyValue('--text-color').trim();
                colors.placeholderText = rootStyle.getPropertyValue('--placeholder-text').trim();
                colors.headerBg = rootStyle.getPropertyValue('--header-bg').trim();
                colors.headerText = rootStyle.getPropertyValue('--header-text').trim();
                colors.headerPrime = rootStyle.getPropertyValue('--header-prime').trim();
                colors.headerBlue = rootStyle.getPropertyValue('--header-blue').trim();
                colors.headerProbable = rootStyle.getPropertyValue('--header-probable').trim();
                colors.highlightBlue = rootStyle.getPropertyValue('--highlight-blue').trim();
                colors.gridLine = rootStyle.getPropertyValue('--grid-line').trim();
                colors.logText = rootStyle.getPropertyValue('--log-text-color').trim();
            }
            function draw() {
                if (!window.imtCanvasSize || window.imtCanvasSize.width === 0) return;
                ctx.clearRect(0, 0, window.imtCanvasSize.width, window.imtCanvasSize.height);
                const scaledCellSize = cellSize * scale;
                if (scaledCellSize < 2) return;
                const view = { x1: -offsetX / scale, y1: -offsetY / scale, x2: (window.imtCanvasSize.width - offsetX) / scale, y2: (window.imtCanvasSize.height - offsetY) / scale };
                const dataView = { x1: view.x1 - cellSize, y1: view.y1 - cellSize, x2: view.x2 - cellSize, y2: view.y2 - cellSize };
                const minCol = Math.floor(dataView.x1 / cellSize), maxCol = Math.ceil(dataView.x2 / cellSize);
                const minRow = Math.floor(dataView.y1 / cellSize), maxRow = Math.ceil(dataView.y2 / cellSize);
                ctx.save();
                ctx.translate(offsetX, offsetY);
                ctx.scale(scale, scale);
                const baseFontSize = 16 / scale;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                for (let r = minRow - 5; r <= maxRow + 5; r++) {
                    const cellY_obj = incrementCoord(gridOriginRow, r);
                    if (cellY_obj.val && bigInt(cellY_obj.val).lesser(1)) continue;
                    const drawY = cellSize + r * cellSize, y_id = getCoordID(cellY_obj);
                    for (let c = minCol - 5; c <= maxCol + 5; c++) {
                        const cellX_obj = incrementCoord(gridOriginCol, c);
                        if (cellX_obj.val && bigInt(cellX_obj.val).lesser(1)) continue;
                        const drawX = cellSize + c * cellSize, x_id = getCoordID(cellX_obj);
                        const cellId = `c:${x_id},${y_id}`;
                        if (!cellCache.has(cellId)) { workerManager.queueRequest({ id: cellId, type: 'getProduct', x_obj: cellX_obj, y_obj: cellY_obj }); }
                        if (r >= minRow && r <= maxRow && c >= minCol && c <= maxCol) {
                            ctx.fillStyle = colors.gridBg;
                            ctx.fillRect(drawX, drawY, cellSize, cellSize);
                            if (areCoordsEqual(cellX_obj, highlightedCell.x) && areCoordsEqual(cellY_obj, highlightedCell.y)) {
                                ctx.fillStyle = colors.highlightBlue;
                                ctx.fillRect(drawX, drawY, cellSize, cellSize);
                            }
                            ctx.strokeStyle = colors.gridLine;
                            ctx.strokeRect(drawX, drawY, cellSize, cellSize);
                            const cachedProduct = cellCache.get(cellId);
                            let productString = "...", isLog = false;
                            ctx.fillStyle = colors.placeholderText;
                            if (cachedProduct) {
                                productString = cachedProduct.text;
                                isLog = cachedProduct.color === 'log';
                                ctx.fillStyle = isLog ? colors.logText : colors.textColor;
                            }
                            setFittedFont(baseFontSize, productString, isLog, scaledCellSize);
                            ctx.fillText(productString, drawX + cellSize / 2, drawY + cellSize / 2);
                        }
                    }
                }
                ctx.restore();
                ctx.save();
                ctx.fillStyle = colors.headerBg;
                ctx.fillRect(0, 0, window.imtCanvasSize.width, scaledCellSize);
                ctx.fillRect(0, 0, scaledCellSize, window.imtCanvasSize.height);
                const headerBaseFontSize = Math.min(20, scaledCellSize * 0.35);
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                for (let r = minRow - 5; r <= maxRow + 5; r++) {
                    const cellY_obj = incrementCoord(gridOriginRow, r);
                    if (cellY_obj.val && bigInt(cellY_obj.val).lesser(1)) continue;
                    const primality = getPrimality(cellY_obj);
                    const drawY = (cellSize + r * cellSize) * scale + offsetY;
                    if (drawY > window.imtCanvasSize.height || drawY + scaledCellSize < scaledCellSize) continue;
                    const label = getDisplayLabel(cellY_obj, highlightedCell.y, 10);
                    ctx.fillStyle = (primality && primality.isPrime) ? colors.headerPrime : (primality && primality.isProbablePrime) ? colors.headerProbable : colors.headerBlue;
                    ctx.fillRect(0, drawY, scaledCellSize, scaledCellSize);
                    ctx.fillStyle = colors.headerText;
                    ctx.strokeStyle = colors.gridLine;
                    ctx.strokeRect(0, drawY, scaledCellSize, scaledCellSize);
                    setFittedFont(headerBaseFontSize, label, false, scaledCellSize);
                    ctx.fillText(label, scaledCellSize / 2, drawY + scaledCellSize / 2);
                }
                for (let c = minCol - 5; c <= maxCol + 5; c++) {
                    const cellX_obj = incrementCoord(gridOriginCol, c);
                    if (cellX_obj.val && bigInt(cellX_obj.val).lesser(1)) continue;
                    const primality = getPrimality(cellX_obj);
                    const drawX = (cellSize + c * cellSize) * scale + offsetX;
                    if (drawX > window.imtCanvasSize.width || drawX + scaledCellSize < scaledCellSize) continue;
                    const label = getDisplayLabel(cellX_obj, highlightedCell.x, 10);
                    ctx.fillStyle = (primality && primality.isPrime) ? colors.headerPrime : (primality && primality.isProbablePrime) ? colors.headerProbable : colors.headerBlue;
                    ctx.fillRect(drawX, 0, scaledCellSize, scaledCellSize);
                    ctx.fillStyle = colors.headerText;
                    ctx.strokeStyle = colors.gridLine;
                    ctx.strokeRect(drawX, 0, scaledCellSize, scaledCellSize);
                    setFittedFont(headerBaseFontSize, label, false, scaledCellSize);
                    ctx.fillText(label, drawX + scaledCellSize / 2, scaledCellSize / 2);
                }
                ctx.fillStyle = "#000";
                ctx.fillRect(0, 0, scaledCellSize, scaledCellSize);
                ctx.strokeStyle = colors.gridLine;
                ctx.strokeRect(0, 0, scaledCellSize, scaledCellSize);
                ctx.fillStyle = colors.headerText;
                setFittedFont(headerBaseFontSize, `B10`, false, scaledCellSize);
                ctx.fillText(`B10`, scaledCellSize / 2, scaledCellSize / 2);
                ctx.restore();
            }
            function getPrimality(n_obj) {
                const id = `p:${getCoordID(n_obj)}`;
                const cached = cellCache.get(id);
                if (cached) return cached;
                try {
                    if (n_obj.val) {
                        const val = n_obj.val;
                        if (val === '2' || val === '3' || val === '5') {} 
                        else if (val.length > 1 && (val.endsWith('0') || val.endsWith('2') || val.endsWith('4') || val.endsWith('5') || val.endsWith('6') || val.endsWith('8'))) {
                            cellCache.set(id, { isPrime: false }); return { isPrime: false };
                        }
                        let sum = 0;
                        for (let i = 0; i < val.length; i++) { sum = (sum + parseInt(val[i], 10)) % 3; }
                        if (sum === 0 && val !== '3') { cellCache.set(id, { isPrime: false }); return { isPrime: false }; }
                    } else {
                        const A = bigInt(n_obj.a), B = bigInt(n_obj.b), C = bigInt(n_obj.c);
                        if (B.greater(0)) {
                            if (C.isEven()) { cellCache.set(id, { isPrime: false }); return { isPrime: false }; }
                            if (C.mod(5).isZero()) { cellCache.set(id, { isPrime: false }); return { isPrime: false }; }
                        } else {
                            const N = A.add(C);
                            if (N.isEven() && !N.equals(2)) { cellCache.set(id, { isPrime: false }); return { isPrime: false }; }
                            if (N.mod(5).isZero() && !N.equals(5)) { cellCache.set(id, { isPrime: false }); return { isPrime: false }; }
                        }
                        const N_mod_3 = A.add(C).mod(3);
                        if (N_mod_3.isZero()) {
                            let is_3 = (B.isZero() && A.add(C).equals(3));
                            if (!is_3) { cellCache.set(id, { isPrime: false }); return { isPrime: false }; }
                        }
                    }
                } catch (e) { console.warn("Pre-filter error:", e); }
                workerManager.queueRequest({ id: id, type: 'getPrimality', n_obj: n_obj });
                return undefined;
            }
            
            resizeImtCanvas = function() {
                if (!appImt.classList.contains('active')) return;
                const rect = appImt.getBoundingClientRect();
                if (!rect || rect.width === 0 || rect.height === 0) return;
                canvas.width = rect.width;
                canvas.height = rect.height;
                window.imtCanvasSize = { width: rect.width, height: rect.height, top: rect.top }; // Use global store
                draw();
            }
            window.handleImtResize = resizeImtCanvas; // Expose to global
            window.addEventListener('resize', resizeImtCanvas);

            function showTerminal() { terminal.classList.add('active'); }
            function hideTerminal() { terminal.classList.remove('active'); activeDetailId = null; activeDetailObjects = null; }
            function updateTerminal(data) {
                terminalContent.style.color = 'var(--terminal-text)';
                if (data.mode === 'full') {
                    terminalContent.textContent = data.value;
                    calcFullBtn.style.display = 'none';
                } else if (data.mode === 'equation') {
                    terminalContent.textContent = `X: ${data.x}\nY: ${data.y}\nBase: 10\n-------------------\nProduct:\n(${data.x}) * (${data.y})\n\nApproximate:\n${data.approx}`;
                    calcFullBtn.style.display = 'inline-block';
                }
            }
            terminalClose.addEventListener('click', hideTerminal);
            copyTermBtn.addEventListener('click', () => { navigator.clipboard.writeText(terminalContent.textContent); });
            calcFullBtn.addEventListener('click', () => {
                if (activeDetailObjects) {
                    terminalContent.textContent = "Calculating full value...";
                    calcFullBtn.style.display = 'none';
                    activeDetailId = `d:force:${getCoordID(activeDetailObjects.x_obj)},${getCoordID(activeDetailObjects.y_obj)}`;
                    workerManager.queueRequest({ id: activeDetailId, type: 'forceGetDetails', x_obj: activeDetailObjects.x_obj, y_obj: activeDetailObjects.y_obj });
                    workerManager.processQueue();
                }
            });
            function centerOnCell(targetX_obj, targetY_obj) {
                highlightedCell = { x: targetX_obj, y: targetY_obj };
                gridOriginCol = targetX_obj;
                gridOriginRow = targetY_obj;
                const screenX = window.imtCanvasSize.width / 2;
                const screenY = window.imtCanvasSize.height / 2;
                offsetX = screenX - (cellSize + cellSize / 2) * scale;
                offsetY = screenY - (cellSize + cellSize / 2) * scale;
                cellCache.clear();
                draw();
                workerManager.requestQueue.clear();
                workerManager.processQueue();
            }
            goButton.addEventListener('click', () => {
                try {
                    const x_obj = parseCoordinate(xInput.value);
                    const y_obj = parseCoordinate(yInput.value);
                    if ((x_obj.val && bigInt(x_obj.val).lesser(1)) || (y_obj.val && bigInt(y_obj.val).lesser(1))) throw new Error("Coords must be >= 1");
                    centerOnCell(x_obj, y_obj);
                } catch (e) { alert(`Invalid format. Use '123', '1e9', '5e30+7' or '10^100+25'.\nError: ${e.message}`); }
            });
            controlsHandle.addEventListener('click', () => { controlsPanel.classList.toggle('collapsed'); });
            function getCellFromEvent(e) {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left, y = e.clientY - rect.top;
                const worldX = (x - offsetX) / scale, worldY = (y - offsetY) / scale;
                if (worldX < cellSize && worldY < cellSize) { return { type: 'corner' }; }
                const col = Math.floor((worldX - cellSize) / cellSize), row = Math.floor((worldY - cellSize) / cellSize);
                if (worldX < cellSize) { return { type: 'y-header', obj: incrementCoord(gridOriginRow, row) }; }
                if (worldY < cellSize) { return { type: 'x-header', obj: incrementCoord(gridOriginCol, col) }; }
                return { type: 'cell', x_obj: incrementCoord(gridOriginCol, col), y_obj: incrementCoord(gridOriginRow, row) };
            }
            let panStart = { x: 0, y: 0 }, didPan = false;
            canvas.addEventListener('mousedown', (e) => { isPanning = true; didPan = false; lastPan = { x: e.clientX, y: e.clientY }; });
            canvas.addEventListener('mousemove', (e) => {
                if (!isPanning) return;
                const deltaX = e.clientX - lastPan.x, deltaY = e.clientY - lastPan.y;
                if (Math.abs(deltaX) > 5 || Math.abs(deltaY) > 5) { didPan = true; }
                offsetX += deltaX; offsetY += deltaY;
                lastPan = { x: e.clientX, y: e.clientY };
                requestAnimationFrame(draw);
            });
            canvas.addEventListener('mouseup', (e) => {
                if (!didPan && !controlsPanel.contains(e.target)) { handleCellClick(e); }
                if (isPanning) { isPanning = false; workerManager.processQueue(); }
                didPan = false;
            });
            canvas.addEventListener('mouseleave', () => { isPanning = false; didPan = false; });
            function handleCellClick(e) {
                const cell = getCellFromEvent(e);
                if (!cell || cell.type === 'corner') return;
                let id, task, objects;
                if (cell.type === 'cell') {
                    id = `d:c:${getCoordID(cell.x_obj)},${getCoordID(cell.y_obj)}`;
                    task = { id, type: 'getDetails', x_obj: cell.x_obj, y_obj: cell.y_obj };
                    objects = { x_obj: cell.x_obj, y_obj: cell.y_obj };
                } else if (cell.type === 'x-header') {
                    id = `d:h:x:${getCoordID(cell.obj)}`;
                    task = { id, type: 'getDetails', x_obj: cell.obj, y_obj: { val: "1" } }; // Simplified details
                    objects = { x_obj: cell.obj, y_obj: { val: "1" } };
                } else if (cell.type === 'y-header') {
                    id = `d:h:y:${getCoordID(cell.obj)}`;
                    task = { id, type: 'getDetails', x_obj: { val: "1" }, y_obj: cell.obj };
                    objects = { x_obj: { val: "1" }, y_obj: cell.obj };
                } else { return; }
                activeDetailId = id; activeDetailObjects = objects;
                terminalContent.textContent = "Loading...";
                calcFullBtn.style.display = 'none';
                showTerminal();
                const cached = cellCache.get(id);
                if (cached) { updateTerminal(cached); } 
                else { workerManager.queueRequest(task); workerManager.processQueue(); }
            }
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left, mouseY = e.clientY - rect.top;
                const factor = e.deltaY > 0 ? 0.9 : 1.1;
                offsetX = mouseX - (mouseX - offsetX) * factor;
                offsetY = mouseY - (mouseY - offsetY) * factor;
                scale = Math.max(0.1, Math.min(scale, 20));
                zoomInfo.textContent = `Zoom: ${scale.toFixed(2)}x`;
                requestAnimationFrame(draw);
                clearTimeout(canvas.wheelTimer);
                canvas.wheelTimer = setTimeout(() => { workerManager.processQueue(); }, 150);
            }, { passive: false });
            canvas.addEventListener('touchstart', (e) => {
                if (controlsPanel.contains(e.target)) return;
                if (e.touches.length === 1) { isPanning = true; didPan = false; lastPan = { x: e.touches[0].clientX, y: e.touches[0].clientY }; } 
                else if (e.touches.length === 2) {
                    isPanning = false;
                    const dx = e.touches[0].clientX - e.touches[1].clientX, dy = e.touches[0].clientY - e.touches[1].clientY;
                    lastTouchDist = Math.hypot(dx, dy);
                }
            });
            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (e.touches.length === 1 && isPanning) {
                    const deltaX = e.touches[0].clientX - lastPan.x, deltaY = e.touches[0].clientY - lastPan.y;
                    if (Math.abs(deltaX) > 5 || Math.abs(deltaY) > 5) { didPan = true; }
                    offsetX += deltaX; offsetY += deltaY;
                    lastPan = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                    requestAnimationFrame(draw);
                } else if (e.touches.length === 2) {
                    didPan = true;
                    const dx = e.touches[0].clientX - e.touches[1].clientX, dy = e.touches[0].clientY - e.touches[1].clientY;
                    const newDist = Math.hypot(dx, dy);
                    const factor = newDist / lastTouchDist;
                    const rect = canvas.getBoundingClientRect();
                    const midX = (e.touches[0].clientX + e.touches[1].clientX) / 2 - rect.left;
                    const midY = (e.touches[0].clientY + e.touches[1].clientY) / 2 - rect.top;
                    offsetX = midX - (midX - offsetX) * factor;
                    offsetY = midY - (midY - offsetY) * factor;
                    scale = Math.max(0.1, Math.min(scale, 20));
                    zoomInfo.textContent = `Zoom: ${scale.toFixed(2)}x`;
                    lastTouchDist = newDist;
                    requestAnimationFrame(draw);
                }
            }, { passive: false });
            canvas.addEventListener('touchend', (e) => {
                if (!didPan && e.touches.length === 0 && !controlsPanel.contains(e.target)) {
                    handleCellClick({ clientX: lastPan.x, clientY: lastPan.y });
                }
                if (e.touches.length < 2) isPanning = false;
                if (e.touches.length < 1) lastTouchDist = 0;
                workerManager.processQueue();
            });
            
            getColors();
            resizeImtCanvas();
            centerOnCell({ val: "1" }, { val: "1" });
            setTimeout(() => { workerManager.processQueue(); }, 100);
        
        }()); // End IMT App IIFE

        // ===========================================================
        // ===== SCRIPT FOR APP 2: SGS Filter Analyzer ================
        // ===========================================================
        (function() {
            // This is a self-contained "bubble" for the SGS Analyzer app.
            // All its vars and functions are private unless attached to window.
            
            // --- MATH UTILS ---
            function powMod(base, exp, mod) {
                let r = 1n; base %= mod;
                while (exp > 0n) { if ((exp & 1n) === 1n) r = (r * base) % mod; exp >>= 1n; base = (base * base) % mod; }
                return r;
            }
            function legendreSymbol(a, p) {
                if (a === 0n) return 0; 
                if (p === 2n) return 1;
                a = (a % p + p) % p;
                const ls = powMod(a, (p - 1n) / 2n, p);
                return (ls === p - 1n) ? -1 : 1;
            }
            function customIntegerSqrt(n) {
                if (n < 0n) return null; if (n < 2n) return n;
                let x = n; let y = (x + 1n) / 2n;
                while (y < x) { x = y; y = (x + n / x) / 2n; }
                return x;
            }
            const SQ_MOD_4096 = new Uint8Array(4096);
            for (let i = 0; i < 4096; i++) SQ_MOD_4096[(i * i) % 4096] = 1;

            function getPrimes(count) {
                const p = []; let n = 3;
                while(p.length < count) {
                    let isP = true;
                    for(let i=2; i*i<=n; i++) if(n%i===0) isP=false;
                    if(isP) p.push(BigInt(n));
                    n+=2;
                }
                return p;
            }

            // Expose the run function to the global scope for the onclick handler
            window.sgs_runAnalysis = async function() {
                const statusEl = document.getElementById('sgs-status');
                const btn = document.getElementById('sgs-runBtn');
                try {
                    btn.disabled = true;
                    statusEl.innerText = "Calculating N...";
                    await new Promise(r => setTimeout(r, 10));
                    
                    // Use new prefixed IDs
                    const aStr = document.getElementById('sgs-base').value;
                    const bStr = document.getElementById('sgs-exp').value;
                    const cStr = document.getElementById('sgs-add').value;
                    const sampleSize = parseInt(document.getElementById('sgs-sample').value);
                    const maxPrimes = parseInt(document.getElementById('sgs-primeCount').value);
                    
                    let N;
                    try { N = BigInt(aStr)**BigInt(bStr) + BigInt(cStr); } // Native BigInt
                    catch(e) { throw new Error("Invalid Number Input"); }
                    
                    const fourN = N * 4n;
                    statusEl.innerText = "Calculating Square Root...";
                    const sqrtN = customIntegerSqrt(N);
                    let S_start = sqrtN * 2n;
                    if (S_start*S_start < fourN) S_start += 1n;
                    if(N % 2n !== 0n && S_start % 2n !== 0n) S_start++; 

                    const primes = getPrimes(maxPrimes);
                    let counts = new Array(primes.length + 2).fill(0);
                    
                    statusEl.innerText = `Testing ${sampleSize.toLocaleString()} Candidates...`;
                    await new Promise(r => setTimeout(r, 10));

                    for(let i=0; i<sampleSize; i++) {
                        let S = S_start + BigInt(i*2);
                        let D = S*S - fourN; 
                        counts[0]++;
                        if (SQ_MOD_4096[Number(D & 4095n)] !== 1) continue; 
                        counts[1]++; 
                        let pIdx = 0;
                        for(; pIdx<primes.length; pIdx++) {
                            let p = primes[pIdx];
                            if (legendreSymbol(D, p) === -1) break;
                            counts[pIdx + 2]++; 
                        }
                    }
                    renderSgsResults(counts, primes, sampleSize);
                    statusEl.innerText = "Analysis Complete.";
                } catch (err) {
                    alert("Error: " + err.message);
                    statusEl.innerText = "Error.";
                    console.error(err);
                }
                btn.disabled = false;
            }

            function renderSgsResults(counts, primes, total) {
                const container = document.getElementById('sgs-bars');
                container.innerHTML = '';
                document.getElementById('sgs-results').classList.remove('hidden');
                
                const createRow = (label, count, prevCount, color) => {
                    const pctTotal = ((count / total) * 100); 
                    const width = Math.max(pctTotal, 0.5); 
                    let dropText = "";
                    if(prevCount > 0) {
                        const drop = 100 - ((count / prevCount) * 100);
                        if(drop > 0) dropText = `-${drop.toFixed(1)}%`;
                    }
                    return `
                    <div class="row">
                        <div class="lbl">${label}</div>
                        <div class="bar-container"><div class="bar ${color}" style="width: ${width}%"></div></div>
                        <div class="val">${count.toLocaleString()}</div>
                        <div class="delta">${dropText}</div>
                    </div>`;
                };
                
                let html = createRow("1. Initial Set", counts[0], counts[0], "bg-total");
                html += createRow("2. Mod 4096", counts[1], counts[0], "bg-bin");
                primes.forEach((p, i) => {
                    let color = (i === primes.length - 1) ? "bg-final" : "bg-prime";
                    html += createRow(`Mod ${p}`, counts[i+2], counts[i+1], color);
                });
                container.innerHTML = html;
                
                const final = counts[counts.length-1];
                const pct = ((final / total) * 100).toFixed(4);
                document.getElementById('sgs-res-pct').innerText = `${pct}%`;
            }
        
        }()); // End SGS-Analyzer App IIFE

        // ===========================================================
        // ===== SCRIPT FOR APP 3: The General =======================
        // ===========================================================
        (function() {
            // This is a self-contained "bubble" for The General app.
            // All its vars and functions are private unless attached to window.

            const NUM_WORKERS = 8;
            const QR_PRIMES = [3n,5n,7n,11n,13n,17n,19n,23n,29n,31n,37n,41n,43n,47n,53n];
            const FERMAT_RANGE = 2000000n;
            const GIGA_CHUNK_SIZE = 5000000n;

            let ecmShellsFired = 0;
            let isMissionLoaded = false;
            let workers = [];
            let N_current = 0n;
            let foundFactors = new Set();
            let isRunning = false;
            let SMin = 0n;
            let startTime = 0;
            let isGigantic = false;
            let gigaFrontier = 0n;
            let currentMissionID = 0; 
            
            // DOM Elements
            const baseInput = document.getElementById('gen-base-input');
            const exponentInput = document.getElementById('gen-exponent-input');
            const addendInput = document.getElementById('gen-addend-input');
            const startBtn = document.getElementById('gen-start-btn');
            const stopBtn = document.getElementById('gen-stop-btn');
            const factorsOutput = document.getElementById('gen-factors-output');
            const cofactorOutput = document.getElementById('gen-cofactor-output');
            const targetStatus = document.getElementById('gen-target-status');
            const logOutput = document.getElementById('gen-log-output');

            /* ==================== UTILS ==================== */
            function parseBigInt(str) {
              if (!str) return 0n;
              str = str.replace(/,/g,'').replace(/\s/g,'');
              if (str.includes('+')) return str.split('+').reduce((s,t)=>s+parseBigInt(t),0n);
              if (str.includes('e')||str.includes('E')) {
                const [m,e]=str.toLowerCase().split('e'); return BigInt(m)*10n**BigInt(e);
              }
              try { return BigInt(str); } catch(e) { return 0n; }
            }
            function randomBigInt(low,high){ const d=high-low; const bits=d.toString(2).length; const bytes=Math.ceil(bits/8); const buf=new Uint8Array(bytes); crypto.getRandomValues(buf); let r=0n; for(let b of buf) r=(r<<8n)|BigInt(b); return low+(r%d); }
            function mainPowMod(b,e,m){ let r=1n; b%=m; while(e>0n){ if(e&1n) r=(r*b)%m; e>>=1n; b=(b*b)%m; } return r; }
            function isPrimeMR(n,k=20){
              if(n<=1n)return false; if(n<=3n)return true; if(n%2n===0n)return false;
              if(n>10n**100n) k=5; let d=n-1n,s=0n; while(d%2n===0n){d>>=1n;s++;}
              const witnesses = (n<3825123056546413051n)?[2n,3n,5n,7n,11n,13n,23n]:null;
              if(witnesses&&k>witnesses.length)k=witnesses.length;
              for(let i=0;i<k;i++){
                let a=witnesses?witnesses[i]:randomBigInt(2n,n-2n); if(a>=n-1n)continue;
                let x=mainPowMod(a,d,n); if(x===1n||x===n-1n)continue;
                let comp=true; for(let j=1n;j<s;j++){ x=(x*x)%n; if(x===n-1n){comp=false;break;} if(x===1n)break; }
                if(comp)return false;
              }
              return true;
            }
            function log(msg){ const t=new Date().toLocaleTimeString(); logOutput.innerHTML+=`[${t}] ${msg}\n`; logOutput.scrollTop=logOutput.scrollHeight; }
            function initGrid(){
              const g=document.getElementById('gen-worker-grid'); g.innerHTML='';
              for(let i=0;i<NUM_WORKERS;i++){
                const d=document.createElement('div'); d.id=`gen-card-${i}`; d.className='worker-card bg-slate-700';
                d.innerHTML=`Worker ${i}<br><span id="gen-status-${i}" class="opacity-75 font-normal">Ready</span>`;
                g.appendChild(d);
              }
            }
            function updateStatus(idx,msg,mID){ 
                if(mID !== currentMissionID) return; 
                const el=document.getElementById(`gen-status-${idx}`); 
                if(el) el.textContent=msg; 
            }
            function stopAll(){
              workers.forEach(w=>w&&w.terminate()); workers=Array(NUM_WORKERS).fill(null);
              isRunning=false; startBtn.disabled=false; stopBtn.disabled=true;
              for(let i=0;i<NUM_WORKERS;i++){
                  const card=document.getElementById(`gen-card-${i}`);
                  const status=document.getElementById(`gen-status-${i}`);
                  if(card) card.classList.add('bg-offline');
                  if(status) status.textContent = "Unit Withdrawn";
              }
            }

            // --- Expose to Window ---
            window.gen_saveMission = function(){
              const data={timestamp:Date.now(),inputs:{a:baseInput.value,b:exponentInput.value,c:addendInput.value},
                currentState:{N_str:N_current?N_current.toString():"0",factors:Array.from(foundFactors),ecm_shells:ecmShellsFired,isGigantic}};
              const blob=new Blob([JSON.stringify(data,null,2)],{type:'application/json'});
              const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=`sgs_mission_${Date.now()}.json`;
              document.body.appendChild(a); a.click(); document.body.removeChild(a); log("Mission State Saved.");
            }
            window.gen_loadMission = function(input){
              const f=input.files[0]; if(!f)return; const r=new FileReader(); r.onload=e=>{
                try{ const d=JSON.parse(e.target.result);
                  baseInput.value=d.inputs.a;
                  exponentInput.value=d.inputs.b;
                  addendInput.value=d.inputs.c;
                  N_current=BigInt(d.currentState.N_str); foundFactors=new Set(d.currentState.factors);
                  ecmShellsFired=d.currentState.ecm_shells||0; isGigantic=d.currentState.isGigantic; isMissionLoaded=true;
                  factorsOutput.textContent=Array.from(foundFactors).join(' √ó ')||"None";
                  cofactorOutput.textContent=N_current>0n?N_current.toString():"Implicit";
                  targetStatus.textContent="LOADED"; log("Mission Loaded. Click 'Deploy Squad' to resume.");
                }catch(err){log("Error Loading Mission File.");console.error(err);}
              }; r.readAsText(f);
            }
            window.gen_checkFactorDB = function(){ 
                const val = baseInput.value + "^" + exponentInput.value + "+" + addendInput.value;
                const url=`https://factordb.com/index.php?query=${encodeURIComponent(val)}`; 
                window.open(url,'_blank'); 
            }

            /* ==================== WORKER CODE ==================== */
            // This is the same worker code as before, just in a variable
            const factorWorkerCode = `
                let spinIdx=0; const spinners=['|','/','-','\\\\']; function getSpin(){spinIdx=(spinIdx+1)%4;return spinners[spinIdx];}
                const SQ_MOD_4096=new Uint8Array(4096); for(let i=0;i<4096;i++) SQ_MOD_4096[(i*i)%4096]=1;
                function gcd(a,b){while(b>0n){let t=b;b=a%b;a=t;}return a;}
                function powMod(b,e,m){let r=1n;b%=m;while(e>0n){if(e&1n)r=(r*b)%m;e>>=1n;b=(b*b)%m;}return r;}
                function customIntegerSqrt(n){if(n<0n)return null;if(n<2n)return n;let x=n,y=(x+1n)/2n;while(y<x){x=y;y=(x+n/x)/2n;}return x;}
                function legendreSymbol(a,p){if(a===0n)return 0;if(p===2n)return 1;a=(a%p+p)%p;const ls=powMod(a,(p-1n)/2n,p);return(ls===p-1n)?-1:1;}
                function montAdd(x1,z1,x2,z2,xDiff,zDiff,N){let u=(x1-z1)*(x2+z2)%N;let v=(x1+z1)*(x2-z2)%N;let add=(u+v)%N;let sub=(u-v)%N;let x3=(zDiff*add*add)%N;let z3=(xDiff*sub*sub)%N;return[x3,z3];}
                function montDouble(x1,z1,N,A24){let u=(x1+z1);u=(u*u)%N;let v=(x1-z1);v=(v*v)%N;let diff=u-v;let x2=(u*v)%N;let z2=(diff*(v+A24*diff))%N;return[x2,z2];}
                function montLadder(k,x,N,A24){let x1=x,z1=1n,x2=1n,z2=0n;[x2,z2]=montDouble(x1,z1,N,A24);let bits=k.toString(2);for(let i=1;i<bits.length;i++){if(bits[i]==='1'){[x1,z1]=montAdd(x2,z2,x1,z1,x,1n,N);[x2,z2]=montDouble(x2,z2,N,A24);}else{[x2,z2]=montAdd(x1,z1,x2,z2,x,1n,N);[x1,z1]=montDouble(x1,z1,N,A24);}}return[x1,z1];}
                function runECM(data){
                  self.postMessage({type:'status',msg:'Deploying ECM...',idx:data.idx, mID:data.mID});
                  const N=BigInt(data.n_str); let B1=2000n,curveCount=parseInt(data.startCurve||0);
                  while(true){
                    for(let batch=0;batch<10;batch++){
                      curveCount++; let sigma=BigInt(Math.floor(Math.random()*100000000))+6n;
                      let x=BigInt(Math.floor(Math.random()*1000000)); let A24=BigInt(Math.floor(Math.random()*10000))+100n;
                      let X=x,Z=1n;
                      for(let p=2n;p<B1;p++){
                        let isP=true; if(p>2n&&p%2n===0n)isP=false; else for(let t=3n;t*t<=p;t+=2n)if(p%t===0n)isP=false;
                        if(isP){let q=p;while(q<B1){[X,Z]=montLadder(p,X,N,A24);q*=p;}}
                      }
                      let g=gcd(Z,N); if(g>1n&&g<N){self.postMessage({type:'factor',val:g.toString(),algo:'ECM',idx:data.idx, mID:data.mID});return;}
                    }
                    self.postMessage({type:'status',msg:getSpin()+' Firing Shell #'+curveCount,idx:data.idx,shell:curveCount, mID:data.mID});
                    if(curveCount%50===0)B1+=500n;
                  }
                }
                function runRho(data){
                  self.postMessage({type:'status',msg:'Deploying Rho...',idx:data.idx, mID:data.mID});
                  const N=BigInt(data.n_str); let c=1n,m=128n,steps=0;
                  let nextReport = 0; const interval = 100;
                  while(true){
                    let x=BigInt(Math.floor(Math.random()*1000))+2n,y=x,g=1n,r=1n,q=1n;
                    while(g===1n){
                      x=y; for(let i=0n;i<r;i++)y=(y*y+c)%N;
                      let k=0n; while(k<r&&g===1n){
                        let ys=y,lim=(m<(r-k))?m:(r-k);
                        for(let i=0n;i<lim;i++){y=(y*y+c)%N; let diff=x>y?x-y:y-x; q=(q*diff)%N;}
                        g=gcd(q,N); k+=m; steps+=Number(lim);
                        if(steps > nextReport) {
                            self.postMessage({type:'status',msg:getSpin()+' Spin '+steps,idx:data.idx, mID:data.mID});
                            nextReport = steps + 5000;
                        }
                      }
                      r*=2n;
                    }
                    if(g===N){c++;}else{self.postMessage({type:'factor',val:g.toString(),algo:'Rho (Brent)',idx:data.idx, mID:data.mID});return;}
                  }
                }
                function runP1(data){
                  self.postMessage({type:'status',msg:'Deploying P-1...',idx:data.idx, mID:data.mID});
                  const N=BigInt(data.n_str); let B=50000n,a=2n;
                  while(true){
                    self.postMessage({type:'status',msg:getSpin()+' Revving to '+B,idx:data.idx, mID:data.mID});
                    a=2n; for(let i=2n;i<=B;i++){a=powMod(a,i,N); if(i%2000n===0n)self.postMessage({type:'status',msg:getSpin()+' Revving '+i+'/'+B,idx:data.idx, mID:data.mID});}
                    const d=gcd(a-1n,N); if(d>1n&&d<N){self.postMessage({type:'factor',val:d.toString(),algo:'P-1',idx:data.idx, mID:data.mID});return;}
                    B*=2n; self.postMessage({type:'status',msg:'Missed. Power -> '+B,idx:data.idx, mID:data.mID});
                  }
                }
                function runPPlus1(data){
                  self.postMessage({type:'status',msg:'Deploying P+1...',idx:data.idx, mID:data.mID});
                  const N=BigInt(data.n_str); let B=50000n,P_val=3n;
                  while(true){
                    self.postMessage({type:'status',msg:getSpin()+' Hammering B='+B,idx:data.idx, mID:data.mID});
                    let V=P_val;
                    for(let i=2n;i<=B;i++){
                      let v0=2n,v1=V,bits=i.toString(2);
                      for(let b=0;b<bits.length;b++){
                        if(bits[b]==='1'){let t=(v0*v1-P_val)%N; if(t<0n)t+=N; v0=t; let t2=(v1*v1-2n)%N; if(t2<0n)t2+=N; v1=t2;}
                        else{let t=(v0*v1-P_val)%N; if(t<0n)t+=N; v1=t; let t2=(v0*v0-2n)%N; if(t2<0n)t2+=N; v0=t2;}
                      }
                      V=v0; if(i%2000n===0n)self.postMessage({type:'status',msg:getSpin()+' Hammering '+i+'/'+B,idx:data.idx, mID:data.mID});
                    }
                    let g=gcd(V-2n,N); if(g>1n&&g<N){self.postMessage({type:'factor',val:g.toString(),algo:'P+1',idx:data.idx, mID:data.mID});return;}
                    B*=2n; self.postMessage({type:'status',msg:'Wall held. Power -> '+B,idx:data.idx, mID:data.mID});
                  }
                }
                function runTrialDiv(data){
                  self.postMessage({type:'status',msg:'Deploying Grunt...',idx:data.idx, mID:data.mID});
                  const N=BigInt(data.n_str);
                  if(N%2n===0n){self.postMessage({type:'factor',val:'2',algo:'TrialDiv',idx:data.idx, mID:data.mID});return;}
                  if(N%3n===0n){self.postMessage({type:'factor',val:'3',algo:'TrialDiv',idx:data.idx, mID:data.mID});return;}
                  if(N%5n===0n){self.postMessage({type:'factor',val:'5',algo:'TrialDiv',idx:data.idx, mID:data.mID});return;}
                  let p=7n; const wheel=[4n,2n,4n,2n,4n,6n,2n,6n]; let w=0,checks=0;
                  while(true){ if(p*p>N)break; if(N%p===0n){self.postMessage({type:'factor',val:p.toString(),algo:'TrialDiv',idx:data.idx, mID:data.mID});return;}
                    p+=wheel[w]; w=(w+1)%8; checks++; if(checks%50000===0)self.postMessage({type:'status',msg:getSpin()+' Checking '+p,idx:data.idx, mID:data.mID});
                  }
                }
                function runQS(data){
                  self.postMessage({type:'status',msg:'Deploying QS...',idx:data.idx, mID:data.mID});
                  const N=BigInt(data.n_str),idx=data.idx;
                  if(data.n_str.length > 60) {
                      self.postMessage({type:'requestSwap', newRole:'ecm', reason:'Target > 60 digits', idx:data.idx, mID:data.mID});
                      return;
                  }
                  let B_size=data.n_str.length>45?15000:data.n_str.length>30?5000:1200;
                  self.postMessage({type:'status',msg:'Building FB ('+B_size+')...',idx, mID:data.mID});
                  const fb=[]; const sieve=new Uint8Array(B_size*15); sieve.fill(1); fb.push(2n); let cnt=1;
                  for(let i=3;cnt<B_size;i+=2){ if(sieve[i]){ if(legendreSymbol(N,BigInt(i))!==-1){fb.push(BigInt(i));cnt++;}
                    for(let j=i*i;j<sieve.length;j+=i)sieve[j]=0; } }
                  self.postMessage({type:'status',msg:'FB Ready: '+fb.length,idx, mID:data.mID});
                  const sqrtN=customIntegerSqrt(N); const target=fb.length+20; const rels=[]; let xOff=0n,limit=500000n,polyK=1n;
                  while(rels.length<target){
                    const curN=N*polyK; const x=customIntegerSqrt(curN)+xOff; const Q=x*x-curN; let tmp=Q<0n?-Q:Q; const vec=new Array(fb.length).fill(0);
                    for(let i=0;i<fb.length;i++){ const p=fb[i]; while(tmp%p===0n){tmp/=p;vec[i]^=1;} if(tmp===1n)break; }
                    if(tmp===1n){rels.push({x,v:vec,q:Q,k:polyK}); self.postMessage({type:'status',msg:getSpin()+' Rels: '+rels.length+'/'+target,idx, mID:data.mID});}
                    xOff=(xOff<=0n)?(-xOff+1n):(-xOff); if(xOff>limit){polyK++;xOff=0n;self.postMessage({type:'status',msg:'Switching Poly -> '+polyK+'N',idx, mID:data.mID});}
                  }
                  const M=rels.length,K=fb.length; const mat=rels.map(r=>[...r.v]); const hist=rels.map((_,i)=>[i]);
                  for(let col=0;col<K;col++){ let piv=-1; for(let row=0;row<M;row++)if(mat[row][col]===1){piv=row;break;}
                    if(piv!==-1)for(let row=0;row<M;row++)if(row!==piv&&mat[row][col]===1){for(let j=0;j<K;j++)mat[row][j]^=mat[piv][j]; hist[row]=hist[row].concat(hist[piv]);}}
                  for(let row=0;row<M;row++)if(mat[row].every(v=>v===0)){
                    let X=1n,Ysq=1n; for(let i of hist[row]){const r=rels[i]; X=(X*r.x)%N; Ysq=(Ysq*r.q)%N;}
                    const Y=customIntegerSqrt(Ysq); if(Y&&Y*Y===Ysq){
                      const f1=gcd(X>Y?X-Y:Y-X,N),f2=gcd(X+Y,N);
                      if(f1>1n&&f1<N){self.postMessage({type:'factor',val:f1.toString(),algo:'QS (Poly)',idx, mID:data.mID});return;}
                      if(f2>1n&&f2<N){self.postMessage({type:'factor',val:f2.toString(),algo:'QS (Poly)',idx, mID:data.mID});return;}
                    }
                  }
                  self.postMessage({type:'status',msg:'QS: No factor found',idx, mID:data.mID});
                }
                function runFermat(data){
                  self.postMessage({type:'status',msg:'Scanning 0%',idx:data.idx, mID:data.mID});
                  const N=BigInt(data.n_str),minS=BigInt(data.minS),maxS=BigInt(data.maxS),primes=data.primes.map(BigInt);
                  const fourN=N*4n; let step=(N%2n!==0n)?2n:1n; if(step===2n&&minS%2n!==0n)minS+=1n;
                  let cand=[],proc=0n,total=maxS-minS;
                  for(let S=minS;S<=maxS;S+=step){
                    const Dsq=S*S-fourN; if(Dsq>=0n){ let ok=true; if(SQ_MOD_4096[Number(Dsq&4095n)]!==1)ok=false;
                      else for(const p of primes)if(legendreSymbol(Dsq,p)===-1){ok=false;break;}
                      if(ok)cand.push(S);}
                    proc+=step; if(proc%5000n===0n){const pct=Number(proc*100n/total); self.postMessage({type:'status',msg:getSpin()+' Scanning '+pct+'%',idx:data.idx, mID:data.mID});}
                  }
                  for(const S of cand){
                    const Dsq=S*S-fourN, D=customIntegerSqrt(Dsq); if(D&&D*D===Dsq){ const f=(S-D)/2n; if(f>1n){self.postMessage({type:'factor',val:f.toString(),algo:'Fermat',idx:data.idx, mID:data.mID});return;}}
                  }
                  self.postMessage({type:'fermatDone',idx:data.idx, mID:data.mID});
                }
                function runGigantic(data){
                  self.postMessage({type:'status',msg:'Deploying...',idx:data.idx, mID:data.mID});
                  const a=BigInt(data.a),b=BigInt(data.b),c=BigInt(data.c); let p=BigInt(data.start),end=BigInt(data.end),chk=0;
                  if(p%2n===0n)p++; while(p<=end){ const mod=(powMod(a,b,p)+(c%p)+p)%p; if(mod===0n)self.postMessage({type:'factor',val:p.toString(),algo:'GigaSniper',idx:data.idx, mID:data.mID});
                    p+=2n; chk++; if(chk%50000===0)self.postMessage({type:'status',msg:getSpin()+' Scan '+p,idx:data.idx, mID:data.mID});}
                  self.postMessage({type:'gigaRangeDone',idx:data.idx, mID:data.mID});
                }
                self.onmessage=e=>{
                  const d=e.data;
                  if(d.mode==='gigantic')runGigantic(d);
                  else if(d.mode==='ecm')runECM(d);
                  else if(d.mode==='rho')runRho(d);
                  else if(d.mode==='p1')runP1(d);
                  else if(d.mode==='pp1')runPPlus1(d);
                  else if(d.mode==='trial')runTrialDiv(d);
                  else if(d.mode==='qs')runQS(d);
                  else if(d.mode==='fermat')runFermat(d);
                };
            `;
            const workerBlob = new Blob([factorWorkerCode], {type:'application/javascript'});
            const workerUrl = URL.createObjectURL(workerBlob);

            /* ==================== MAIN LOGIC ==================== */
            function deploySquad(){
              workers.forEach(w=>w&&w.terminate()); workers=Array(NUM_WORKERS).fill(null);
              currentMissionID++; 
              const thisRunID = currentMissionID; 

              const a_str=baseInput.value, b_str=exponentInput.value, c_str=addendInput.value;
              let bigA,bigB,bigC;
              try{ bigA=parseBigInt(a_str); bigB=parseBigInt(b_str); bigC=parseBigInt(c_str); }
              catch(e){ log('Invalid Input Format'); return; }

              const digitCount = bigB * BigInt(bigA.toString().length) + 1n;
              if(digitCount > 10000n) isGigantic = true; else isGigantic = false;

              if(!isRunning && !isMissionLoaded){
                if(isGigantic){
                  startTime=Date.now(); log(`GIGANTIC MODE. Implicit Target.`);
                  targetStatus.textContent='IMPLICIT';
                  cofactorOutput.textContent='Implicit';
                  gigaFrontier=2n;
                }else{
                  startTime=Date.now(); foundFactors.clear(); factorsOutput.textContent='None';
                  cofactorOutput.textContent='‚Äî'; ecmShellsFired=0;
                  try{
                    N_current = bigA**bigB + bigC;
                    targetStatus.textContent='EXPLICIT';
                    const nStr=N_current.toString(); log('Target: '+nStr.substring(0,20)+'... ('+nStr.length+' digits)');
                    cofactorOutput.textContent=N_current.toString();
                  }catch(e){
                    log('Explicit computation failed. Switching to Gigantic.');
                    isGigantic=true; targetStatus.textContent='IMPLICIT';
                    cofactorOutput.textContent='Implicit'; gigaFrontier=2n;
                  }
                }
              }else if(isMissionLoaded){
                isMissionLoaded=false; log("Resuming Mission...");
                cofactorOutput.textContent = N_current>0n?N_current.toString():'Implicit';
              }

              isRunning=true;
              if(!isGigantic){
                if(N_current===1n){ log('Mission Complete: Target reduced to 1.'); stopAll(); return; }
                if(isPrimeMR(N_current)){
                  log('GATEKEEPER: Target is PRIME.');
                  if(!foundFactors.has(N_current.toString())){ foundFactors.add(N_current.toString()); factorsOutput.textContent=Array.from(foundFactors).join(' √ó '); }
                  stopAll(); return;
                }
                const sqrt=n=>{if(n<2n)return n;let x=n,y=(x+1n)/2n;while(y<x){x=y;y=(x+n/x)/2n;}return x;};
                const isqrt=sqrt(N_current); SMin=isqrt*2n; if(SMin*SMin<4n*N_current)SMin+=1n;
              }

              startBtn.disabled=true; stopBtn.disabled=false;

              const nLen = N_current.toString().length;
              let tactic='balanced'; if(nLen<30)tactic='blitz'; if(nLen>60)tactic='siege';
              if(!isGigantic) log(`Tactical Analysis: ${nLen} digits -> Mode: ${tactic.toUpperCase()}`);

              for(let i=0;i<NUM_WORKERS;i++){
                const card=document.getElementById(`gen-card-${i}`); 
                card.className=`worker-card ${isGigantic?'bg-giga':'bg-slate-600'}`; 
                card.classList.remove('bg-offline'); 
                
                let role=`Worker ${i}`;
                if(!isGigantic){
                  if(tactic==='blitz'){
                    if(i<4){card.classList.add('bg-rho');role=`Rho Scout ${i+1}`;}
                    else if(i<6){card.classList.add('bg-fermat');role=`Fermat Marine ${i-3}`;}
                    else if(i===6){card.classList.add('bg-td');role='Trial Grunt';}
                    else{card.classList.add('bg-p1');role='P-1 Sniper';}
                  }else if(tactic==='siege'){
                    if(i<4){card.classList.add('bg-ecm');role=`ECM Artillery ${i+1}`;}
                    else if(i===4){card.classList.add('bg-p1');role='P-1 Sniper';}
                    else if(i===5){card.classList.add('bg-pp1');role='P+1 Breacher';}
                    else if(i===6){card.classList.add('bg-qs');role='QS Mastermind';}
                    else{card.classList.add('bg-rho');role='Rho Scout';}
                  }else{
                    if(i<2){card.classList.add('bg-fermat');role=`Fermat Marine ${i+1}`;}
                    else if(i===2){card.classList.add('bg-ecm');role='ECM Artillery';}
                    else if(i===3){card.classList.add('bg-rho');role='Rho Scout';}
                    else if(i===4){card.classList.add('bg-p1');role='P-1 Sniper';}
                    else if(i===5){card.classList.add('bg-pp1');role='P+1 Breacher';}
                    else if(i===6){card.classList.add('bg-qs');role='QS Mastermind';}
                    else if(i===7){card.classList.add('bg-td');role='Trial Grunt';}
                  }
                }else role=`Giga Sniper ${i}`;
                card.innerHTML=`${role}<br><span id="gen-status-${i}" class="opacity-75 font-normal">Deploying</span>`;
              }

              setTimeout(()=>{
                for(let i=0;i<NUM_WORKERS;i++){
                  const w=new Worker(workerUrl); workers[i]=w; w.onmessage=handleMsg;
                  const payload = {mID: thisRunID, idx: i};
                  
                  if(isGigantic) dispatchGigaChunk(w,i,bigA.toString(),bigB.toString(),bigC.toString(), thisRunID);
                  else{
                    payload.n_str = N_current.toString();
                    if(tactic==='blitz'){
                      if(i<4) w.postMessage({...payload, mode:'rho'});
                      else if(i<6) startFermatChunk(i,2,thisRunID);
                      else if(i===6) w.postMessage({...payload, mode:'trial'});
                      else w.postMessage({...payload, mode:'p1'});
                    }else if(tactic==='siege'){
                      if(i<4) w.postMessage({...payload, mode:'ecm', startCurve:ecmShellsFired});
                      else if(i===4) w.postMessage({...payload, mode:'p1'});
                      else if(i===5) w.postMessage({...payload, mode:'pp1'});
                      else if(i===6) w.postMessage({...payload, mode:'qs'});
                      else w.postMessage({...payload, mode:'rho'});
                    }else{
                      if(i<2) startFermatChunk(i,2,thisRunID);
                      else if(i===2) w.postMessage({...payload, mode:'ecm', startCurve:ecmShellsFired});
                      else if(i===3) w.postMessage({...payload, mode:'rho'});
                      else if(i===4) w.postMessage({...payload, mode:'p1'});
                      else if(i===5) w.postMessage({...payload, mode:'pp1'});
                      else if(i===6) w.postMessage({...payload, mode:'qs'});
                      else if(i===7) w.postMessage({...payload, mode:'trial'});
                    }
                  }
                }
              },100);
            }
            function dispatchGigaChunk(w,idx,a,b,c,mID){
              if(!isRunning)return; const start=gigaFrontier; const end=start+GIGA_CHUNK_SIZE; gigaFrontier=end;
              w.postMessage({mode:'gigantic',a,b,c,start:start.toString(),end:end.toString(),idx, mID});
            }
            function startFermatChunk(idx,army,mID){
              if(!isRunning)return; const off=BigInt(idx); const range=FERMAT_RANGE;
              const min=SMin+(off*range); const max=min+range-1n;
              workers[idx].postMessage({mode:'fermat',n_str:N_current.toString(),minS:min.toString(),maxS:max.toString(),primes:QR_PRIMES.map(String),idx, mID});
            }
            function handleMsg(e){
              const d=e.data;
              if(d.algo==='ECM'&&d.shell)ecmShellsFired=d.shell;
              if(d.type==='status'&&d.shell)ecmShellsFired=d.shell;
              if(d.type==='status') updateStatus(d.idx,d.msg,d.mID); 
              
              if(d.type === 'requestSwap') {
                  if(d.mID !== currentMissionID) return;
                  if(d.newRole === 'ecm') {
                      log(`‚ö†Ô∏è PROMOTION: Worker ${d.idx} (QS) -> ECM Artillery.`);
                      const card = document.getElementById(`gen-card-${d.idx}`);
                      if(card) {
                          card.className = 'worker-card bg-ecm';
                          card.innerHTML = `‚òÑÔ∏è ECM Artillery (Promoted)<br><span id="gen-status-${d.idx}">Deploying...</span>`;
                      }
                      if(workers[d.idx]) workers[d.idx].terminate();
                      const w = new Worker(workerUrl); workers[d.idx] = w; w.onmessage = handleMsg;
                      w.postMessage({mode:'ecm', n_str:N_current.toString(), idx:d.idx, startCurve:0, mID:d.mID});
                  }
                  return;
              }

              else if(d.type==='factor'){
                const elapsed=(Date.now()-startTime)/1000; log(`${d.algo} Found: ${d.val} (${elapsed.toFixed(2)}s)`);
                if(!foundFactors.has(d.val)){
                  foundFactors.add(d.val); factorsOutput.textContent=Array.from(foundFactors).join(' √ó ');
                  if(!isGigantic){
                    const f=BigInt(d.val); if(N_current%f===0n){ N_current/=f; log('Reduced N. Redeploying...');
                      cofactorOutput.textContent=N_current.toString(); 
                      if (N_current > 1n) setTimeout(deploySquad, 100);
                      else { log("TARGET FULLY FACTORED."); targetStatus.textContent = 'FULLY FACTORED'; targetStatus.classList.add('text-green-400', 'font-bold'); stopAll(); }
                    }
                  }
                }
              }else if(d.type==='fermatDone'){
                if(isRunning&&!isGigantic){ SMin += (FERMAT_RANGE * 2n); startFermatChunk(d.idx,2,d.mID); }
              }else if(d.type==='gigaRangeDone'){
                if(isRunning&&isGigantic){
                  const a=baseInput.value,b=exponentInput.value,c=addendInput.value;
                  const A=parseBigInt(a),B=parseBigInt(b),C=parseBigInt(c);
                  dispatchGigaChunk(workers[d.idx],d.idx,A.toString(),B.toString(),C.toString(),d.mID);
                }
              }
            }
            
            // Attach main event listeners
            startBtn.onclick=()=>{ if(!isMissionLoaded){N_current=0n;isRunning=false;} deploySquad(); };
            stopBtn.onclick=()=>{ stopAll(); log('Squad Aborted.'); };
            
            // Initial setup
            initGrid();

        }()); // End "The General" App IIFE

    </script>
</body>
</html>
