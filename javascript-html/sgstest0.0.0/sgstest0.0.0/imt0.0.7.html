<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Infinite Multiplication Table v0.0.9 (Prefetching)</title>
    <script src="https://unpkg.com/big-integer@1.6.48/BigInteger.min.js"></script>
    <style>
        :root {
            --bg-color: #1a1a1a;
            --grid-bg: #2c2c2c;
            --text-color: #e5e7eb;
            --placeholder-text: #6b7280; /* Gray for "..." */
            --header-bg: #111;
            --header-text: #fff;
            --header-prime: #f72585; /* Hot Pink */
            --header-blue: #4361ee;
            --highlight-blue: rgba(67, 97, 238, 0.5);
            --grid-line: #333;
            --controls-bg: rgba(20, 20, 20, 0.8);
            --log-text-color: #9ca3af;
        }
        html, body {
            margin: 0; padding: 0; overflow: hidden;
            width: 100%; height: 100%;
            background-color: var(--bg-color); color: var(--text-color);
            font-family: system-ui, sans-serif;
            user-select: none; touch-action: none;
        }
        canvas {
            display: block; background-color: var(--grid-bg);
            touch-action: none; position: fixed; top: 0; left: 0;
        }
        #controls {
            position: fixed; bottom: 0; left: 0; width: 100%;
            background: var(--controls-bg); backdrop-filter: blur(5px);
            border-top: 1px solid var(--grid-line); z-index: 10;
            transition: all 0.3s ease-in-out; overflow: hidden;
        }
        #controlsHandle {
            display: flex; justify-content: space-between; align-items: center;
            padding: 10px; cursor: pointer; font-weight: bold;
        }
        #zoomInfo { font-size: 0.9em; color: #aaa; }
        #controlsContent {
            padding: 10px; display: flex; flex-wrap: wrap;
            gap: 10px; align-items: center; border-top: 1px solid #444;
        }
        #controls.collapsed #controlsContent { display: none; }
        #controls label { font-weight: bold; font-size: 1.1em; }
        #controls input {
            background: #333; color: var(--text-color);
            border: 1px solid #555; border-radius: 5px;
            padding: 8px; font-size: 1em; width: 100px;
        }
        #controls button {
            background: var(--header-blue); color: white;
            border: none; border-radius: 5px;
            padding: 8px 12px; font-weight: bold;
            cursor: pointer; font-size: 1em;
        }
        #controls button:hover { background: #3a52cc; }
    </style>
</head>
<body>

    <canvas id="gridCanvas"></canvas>

    <div id="controls" class="collapsed">
        <div id="controlsHandle">
            <span>Controls</span>
            <span id="zoomInfo">Zoom: 1.00x</span>
        </div>
        <div id="controlsContent">
            <label for="xInput">X:</label>
            <input type="text" id="xInput" value="1" inputmode="numeric">
            <label for="yInput">Y:</label>
            <input type="text" id="yInput" value="1" inputmode="numeric">
            <button id="goButton">Go</button>
        </div>
    </div>

    <script>
        // --- Web Worker Code (as a string) ---
        const workerCode = `
            self.importScripts('https://unpkg.com/big-integer@1.6.48/BigInteger.min.js');

            function powMod(base, exp, mod) {
                let result = self.bigInt.one;
                base = base.mod(mod);
                while (exp.greater(0)) {
                    if (exp.isOdd()) result = result.multiply(base).mod(mod);
                    exp = exp.shiftRight(1);
                    base = base.square().mod(mod);
                }
                return result;
            }

            function millerRabinTest(n, k = 10) {
                if (n.equals(2) || n.equals(3)) return true;
                if (n.lesser(2) || n.isEven()) return false;
                if (n.toString().length > 200) k = 2; 

                let d = n.subtract(1);
                let s = 0;
                while (d.isEven()) {
                    d = d.shiftRight(1);
                    s++;
                }
                for (let i = 0; i < k; i++) {
                    const a = self.bigInt.randBetween(2, n.subtract(2));
                    let x = powMod(a, d, n);
                    if (x.equals(1) || x.equals(n.subtract(1))) continue;
                    let composite = true;
                    for (let j = 1; j < s; j++) {
                        x = x.square().mod(n);
                        if (x.equals(1)) break;
                        if (x.equals(n.subtract(1))) {
                            composite = false;
                            break;
                        }
                    }
                    if (composite) return false;
                }
                return true;
            }

            function getProductString(xStr, yStr) {
                let approxDigits = xStr.length + yStr.length - 1;
                
                if (approxDigits > 1000) {
                    approxDigits = self.bigInt(xStr.length).add(yStr.length).subtract(1);
                    return { text: \`~10^\${approxDigits.toString()}\`, color: 'log' };
                } else if (approxDigits >= 21) {
                    return { text: \`~10^\${approxDigits}\`, color: 'log' };
                }
                
                const x = self.bigInt(xStr);
                const y = self.bigInt(yStr);
                const product = x.multiply(y);

                if (approxDigits >= 9) {
                    return { text: product.toExponential(2), color: 'normal' };
                } else {
                    return { text: product.toString(), color: 'normal' };
                }
            }

            self.onmessage = (e) => {
                const tasks = e.data;
                const results = [];

                for (const task of tasks) {
                    try {
                        let data = {};
                        if (task.type === 'getProduct') {
                            data = getProductString(task.x, task.y);
                        } else if (task.type === 'getPrimality') {
                            const n = self.bigInt(task.n);
                            data.isPrime = millerRabinTest(n);
                        }
                        results.push({ id: task.id, status: 'success', data: data });
                    } catch (err) {
                        results.push({ id: task.id, status: 'error', data: { text: 'ERR' } });
                    }
                }
                self.postMessage(results);
            };
        `;

        // --- Globals ---
        const canvas = document.getElementById('gridCanvas');
        const ctx = canvas.getContext('2d');
        const xInput = document.getElementById('xInput');
        const yInput = document.getElementById('yInput');
        const goButton = document.getElementById('goButton');
        const controlsPanel = document.getElementById('controls');
        const controlsHandle = document.getElementById('controlsHandle');
        const zoomInfo = document.getElementById('zoomInfo');

        let scale = 1.0, offsetX = 0.0, offsetY = 0.0, cellSize = 80;
        let gridOriginCol = bigInt(1), gridOriginRow = bigInt(1);
        let highlightedCell = { x: bigInt(1), y: bigInt(1) };
        let isPanning = false, lastPan = { x: 0, y: 0 }, lastTouchDist = 0;
        const colors = {};

        // --- Worker & Cache System ---
        const cellCache = new Map();
        
        class WorkerManager {
            constructor(numWorkers) {
                this.requestQueue = new Map();
                this.workerIdle = new Array(numWorkers).fill(true);
                this.workers = [];

                const blob = new Blob([workerCode], { type: 'application/javascript' });
                const workerUrl = URL.createObjectURL(blob);

                for (let i = 0; i < numWorkers; i++) {
                    const worker = new Worker(workerUrl);
                    worker.onmessage = (e) => this.handleWorkerResult(e, i);
                    this.workers.push(worker);
                }
            }

            queueRequest(task) {
                if (!cellCache.has(task.id)) {
                    this.requestQueue.set(task.id, task);
                }
            }

            processQueue() {
                if (this.requestQueue.size === 0) return;

                const idleWorkerIndex = this.workerIdle.indexOf(true);
                if (idleWorkerIndex === -1) return;

                const tasks = Array.from(this.requestQueue.values());
                const batchSize = Math.ceil(tasks.length / this.workerIdle.filter(Boolean).length);
                const batch = tasks.slice(0, batchSize);
                
                for(const task of batch) {
                    this.requestQueue.delete(task.id);
                }
                
                if (batch.length > 0) {
                    this.workers[idleWorkerIndex].postMessage(batch);
                    this.workerIdle[idleWorkerIndex] = false;
                }
            }

            handleWorkerResult(e, workerIndex) {
                this.workerIdle[workerIndex] = true;
                
                const results = e.data;
                let needsRedraw = false;
                for (const result of results) {
                    if (result.status === 'success') {
                        cellCache.set(result.id, result.data);
                        needsRedraw = true;
                    } else {
                        cellCache.set(result.id, { text: 'ERR' });
                    }
                }
                
                if (needsRedraw) {
                    requestAnimationFrame(draw);
                }

                if (this.requestQueue.size > 0) {
                    this.processQueue();
                }
            }
        }

        const workerManager = new WorkerManager(navigator.hardwareConcurrency || 2);
        
        function getColors() {
            const rootStyle = getComputedStyle(document.documentElement);
            colors.gridBg = rootStyle.getPropertyValue('--grid-bg').trim();
            colors.textColor = rootStyle.getPropertyValue('--text-color').trim();
            colors.placeholderText = rootStyle.getPropertyValue('--placeholder-text').trim();
            colors.headerBg = rootStyle.getPropertyValue('--header-bg').trim();
            colors.headerText = rootStyle.getPropertyValue('--header-text').trim();
            colors.headerPrime = rootStyle.getPropertyValue('--header-prime').trim();
            colors.headerBlue = rootStyle.getPropertyValue('--header-blue').trim();
            colors.highlightBlue = rootStyle.getPropertyValue('--highlight-blue').trim();
            colors.gridLine = rootStyle.getPropertyValue('--grid-line').trim();
            colors.logText = rootStyle.getPropertyValue('--log-text-color').trim();
        }

        function getPrimality(nStr) {
            const id = `p:${nStr}`;
            const cached = cellCache.get(id);
            if (cached) return cached.isPrime;

            if (nStr.length > 1 && (nStr.endsWith('0') || nStr.endsWith('2') || nStr.endsWith('4') || nStr.endsWith('5') || nStr.endsWith('6') || nStr.endsWith('8'))) {
                cellCache.set(id, { isPrime: false });
                return false;
            }

            workerManager.queueRequest({ id: id, type: 'getPrimality', n: nStr });
            return undefined; // "loading"
        }

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            draw();
        }
        window.addEventListener('resize', resizeCanvas);

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const currentCellSize = cellSize;
            const scaledCellSize = currentCellSize * scale;
            if (scaledCellSize < 2) return;

            const view = {
                x1: -offsetX / scale, y1: -offsetY / scale,
                x2: (canvas.width - offsetX) / scale, y2: (canvas.height - offsetY) / scale
            };
            const dataView = {
                x1: view.x1 - currentCellSize, y1: view.y1 - currentCellSize,
                x2: view.x2 - currentCellSize, y2: view.y2 - currentCellSize
            };

            const minCol = Math.floor(dataView.x1 / currentCellSize);
            const maxCol = Math.ceil(dataView.x2 / currentCellSize);
            const minRow = Math.floor(dataView.y1 / currentCellSize);
            const maxRow = Math.ceil(dataView.y2 / currentCellSize);
            
            // --- **NEW**: Define prefetch buffer ---
            const prefetchAmount = 5;

            // 1. Draw Grid Content (Pannable)
            ctx.save();
            ctx.translate(offsetX, offsetY);
            ctx.scale(scale, scale);
            const baseFontSize = 16;
            ctx.font = `${baseFontSize / scale}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            // **NEW**: Loop over expanded prefetch range
            for (let r = minRow - prefetchAmount; r <= maxRow + prefetchAmount; r++) {
                const cellYNum = gridOriginRow.add(r);
                if (cellYNum.lesser(1)) continue;
                const drawY = currentCellSize + r * currentCellSize;
                const yString = cellYNum.toString();

                for (let c = minCol - prefetchAmount; c <= maxCol + prefetchAmount; c++) {
                    const cellXNum = gridOriginCol.add(c);
                    if (cellXNum.lesser(1)) continue;
                    const drawX = currentCellSize + c * currentCellSize;
                    const xString = cellXNum.toString();
                    
                    const cellId = `c:${xString},${yString}`;
                    const cachedProduct = cellCache.get(cellId);
                    
                    // --- **NEW**: Only draw if VISIBLE, but queue if in prefetch range ---
                    if (!cachedProduct) {
                        workerManager.queueRequest({ id: cellId, type: 'getProduct', x: xString, y: yString });
                    }
                    
                    // Culling: Only draw if inside the *visual* range
                    if (r >= minRow && r <= maxRow && c >= minCol && c <= maxCol) {
                        ctx.fillStyle = colors.gridBg;
                        ctx.fillRect(drawX, drawY, currentCellSize, currentCellSize);
                        if (cellXNum.equals(highlightedCell.x) && cellYNum.equals(highlightedCell.y)) {
                            ctx.fillStyle = colors.highlightBlue;
                            ctx.fillRect(drawX, drawY, currentCellSize, currentCellSize);
                        }
                        ctx.strokeStyle = colors.gridLine;
                        ctx.strokeRect(drawX, drawY, currentCellSize, currentCellSize);

                        let productString = "...";
                        let productFont = `${(baseFontSize * 0.9) / scale}px Arial`;
                        ctx.fillStyle = colors.placeholderText;
                        
                        if (cachedProduct) {
                            productString = cachedProduct.text;
                            if (cachedProduct.color === 'log') {
                                ctx.fillStyle = colors.logText;
                            } else {
                                ctx.fillStyle = colors.textColor;
                            }
                            if (cachedProduct.text.length < 9) {
                                 productFont = `${baseFontSize / scale}px Arial`;
                            }
                        }
                        
                        ctx.font = productFont;
                        ctx.fillText(productString, drawX + currentCellSize / 2, drawY + currentCellSize / 2);
                    }
                }
            }
            ctx.restore();

            // 2. Draw Static Headers (Overlay)
            ctx.save();
            ctx.fillStyle = colors.headerBg;
            ctx.fillRect(0, 0, canvas.width, scaledCellSize);
            ctx.fillRect(0, 0, scaledCellSize, canvas.height);
            const headerFontSize = Math.min(20, scaledCellSize * 0.3);
            ctx.font = `bold ${headerFontSize}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            // Y-Axis Headers (with prefetching)
            for (let r = minRow - prefetchAmount; r <= maxRow + prefetchAmount; r++) {
                const cellYNum = gridOriginRow.add(r);
                if (cellYNum.lesser(1)) continue;
                
                const yString = cellYNum.toString();
                const isPrime = getPrimality(yString); // Queues request if not cached

                // Culling: Only draw if visible
                const worldY = currentCellSize + r * currentCellSize;
                const drawY = worldY * scale + offsetY;
                if (drawY > canvas.height || drawY + scaledCellSize < scaledCellSize) continue;
                
                ctx.fillStyle = (isPrime === true) ? colors.headerPrime : colors.headerBlue;
                ctx.fillRect(0, drawY, scaledCellSize, scaledCellSize);
                ctx.fillStyle = colors.headerText;
                ctx.strokeStyle = colors.gridLine;
                ctx.strokeRect(0, drawY, scaledCellSize, scaledCellSize);
                ctx.fillText(yString, scaledCellSize / 2, drawY + scaledCellSize / 2);
            }

            // X-Axis Headers (with prefetching)
            for (let c = minCol - prefetchAmount; c <= maxCol + prefetchAmount; c++) {
                const cellXNum = gridOriginCol.add(c);
                if (cellXNum.lesser(1)) continue;
                
                const xString = cellXNum.toString();
                const isPrime = getPrimality(xString); // Queues request if not cached

                // Culling: Only draw if visible
                const worldX = currentCellSize + c * currentCellSize;
                const drawX = worldX * scale + offsetX;
                if (drawX > canvas.width || drawX + scaledCellSize < scaledCellSize) continue;
                
                ctx.fillStyle = (isPrime === true) ? colors.headerPrime : colors.headerBlue;
                ctx.fillRect(drawX, 0, scaledCellSize, scaledCellSize);
                ctx.fillStyle = colors.headerText;
                ctx.strokeStyle = colors.gridLine;
                ctx.strokeRect(drawX, 0, scaledCellSize, scaledCellSize);
                ctx.fillText(xString, drawX + scaledCellSize / 2, scaledCellSize / 2);
            }

            ctx.fillStyle = "#000";
            ctx.fillRect(0, 0, scaledCellSize, scaledCellSize);
            ctx.strokeStyle = colors.gridLine;
            ctx.strokeRect(0, 0, scaledCellSize, scaledCellSize);
            ctx.fillStyle = colors.headerText;
            ctx.fillText("X * Y", scaledCellSize/2, scaledCellSize/2);
            ctx.restore();
        }

        function centerOnCell(targetX, targetY) {
            highlightedCell = { x: targetX, y: targetY };
            const targetCol = targetX.subtract(gridOriginCol);
            const targetRow = targetY.subtract(gridOriginRow);
            const worldX = cellSize + targetCol.multiply(cellSize).toJSNumber() + cellSize / 2;
            const worldY = cellSize + targetRow.multiply(cellSize).toJSNumber() + cellSize / 2;
            const screenX = canvas.width / 2;
            const screenY = canvas.height / 2;
            offsetX = screenX - worldX * scale;
            offsetY = screenY - worldY * scale;
            draw();
            workerManager.requestQueue.clear();
            workerManager.processQueue();
        }

        goButton.addEventListener('click', () => {
            try {
                const x = bigInt(xInput.value);
                const y = bigInt(yInput.value);
                if (x.lesser(1) || y.lesser(1)) {
                    alert("Please enter positive integers.");
                    return;
                }
                centerOnCell(x, y);
            } catch (e) {
                console.error(e);
                alert("Invalid number format. Use large integers for now, e.g., 1000000000");
            }
        });

        controlsHandle.addEventListener('click', () => {
            controlsPanel.classList.toggle('collapsed');
        });

        // --- Pan Listeners ---
        canvas.addEventListener('mousedown', (e) => {
            isPanning = true;
            lastPan = { x: e.clientX, y: e.clientY };
        });
        canvas.addEventListener('mousemove', (e) => {
            if (!isPanning) return;
            const deltaX = e.clientX - lastPan.x;
            const deltaY = e.clientY - lastPan.y;
            offsetX += deltaX;
            offsetY += deltaY;
            lastPan = { x: e.clientX, y: e.clientY };
            requestAnimationFrame(draw);
        });
        canvas.addEventListener('mouseup', () => {
            if(isPanning) {
                isPanning = false;
                workerManager.processQueue();
            }
        });
        canvas.addEventListener('mouseleave', () => { isPanning = false; });

        // --- Zoom Listener ---
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const factor = e.deltaY > 0 ? 0.9 : 1.1;
            const mouseX = e.clientX;
            const mouseY = e.clientY;
            offsetX = mouseX - (mouseX - offsetX) * factor;
            offsetY = mouseY - (mouseY - offsetY) * factor;
            scale *= factor;
            scale = Math.max(0.1, Math.min(scale, 20));
            zoomInfo.textContent = `Zoom: ${scale.toFixed(2)}x`;
            requestAnimationFrame(draw);
             clearTimeout(canvas.wheelTimer);
             canvas.wheelTimer = setTimeout(() => {
                 workerManager.processQueue();
             }, 150);
        }, { passive: false });

        // --- Touch Listeners ---
        canvas.addEventListener('touchstart', (e) => {
            if (controlsPanel.contains(e.target)) return;
            if (e.touches.length === 1) {
                isPanning = true;
                lastPan = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            } else if (e.touches.length === 2) {
                isPanning = false;
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                lastTouchDist = Math.hypot(dx, dy);
            }
        });
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (e.touches.length === 1 && isPanning) {
                const touchX = e.touches[0].clientX;
                const touchY = e.touches[0].clientY;
                const deltaX = touchX - lastPan.x;
                const deltaY = touchY - lastPan.y;
                offsetX += deltaX;
                offsetY += deltaY;
                lastPan = { x: touchX, y: touchY };
                requestAnimationFrame(draw);
            } else if (e.touches.length === 2) {
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                const newDist = Math.hypot(dx, dy);
                const factor = newDist / lastTouchDist;
                const midX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                const midY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
                offsetX = midX - (midX - offsetX) * factor;
                offsetY = midY - (midY - offsetY) * factor;
                scale *= factor;
                scale = Math.max(0.1, Math.min(scale, 20));
                zoomInfo.textContent = `Zoom: ${scale.toFixed(2)}x`;
                lastTouchDist = newDist;
                requestAnimationFrame(draw);
            }
        }, { passive: false });
        canvas.addEventListener('touchend', (e) => {
            if (e.touches.length < 2) isPanning = false;
            if (e.touches.length < 1) lastTouchDist = 0;
            workerManager.processQueue();
        });
        
        // --- Initial Load ---
        getColors();
        resizeCanvas();
        centerOnCell(bigInt(1), bigInt(1));
        setTimeout(() => {
            workerManager.processQueue();
        }, 100);
    </script>
</body>
</html>
