<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>sgstest3_fixed — Two-Phase Factorizer (Streaming Sqrt fixed)</title>
<script src="https://cdn.tailwindcss.com"></script>
<style>
:root {
  --bg: #f3f4f6; --panel:#fff; --accent:#3b82f6; --green:#10b981;
}
body{font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;background:var(--bg);color:#111;display:flex;align-items:flex-start;justify-content:center;min-height:100vh;padding:20px;}
.card{width:100%;max-width:980px;background:var(--panel);border-radius:12px;box-shadow:0 10px 30px rgba(0,0,0,.12);padding:24px;border-top:8px solid var(--accent);}
.title{font-weight:800;color:var(--accent);font-size:1.6rem;margin-bottom:6px;}
.subtitle{color:#6b7280;margin-bottom:16px;}
.input{padding:10px;border:1px solid #e5e7eb;border-radius:8px;font-size:1rem;}
.button{padding:10px 14px;border-radius:8px;border:none;font-weight:700;cursor:pointer;}
.start{background:var(--green);color:#fff}
.stop{background:#ef4444;color:#fff}
.log{height:200px;overflow:auto;background:#0f172a;color:#a7f3d0;padding:12px;border-radius:8px;font-family:monospace;white-space:pre-wrap}
.progress{height:14px;background:#e5e7eb;border-radius:999px;overflow:hidden}
.bar{height:100%;width:0%;background:var(--accent);text-align:center;color:#fff;font-weight:600;font-size:12px}
.small{font-size:0.9rem;color:#374151}
.grid3{display:grid;grid-template-columns:repeat(3,1fr);gap:12px}
</style>
</head>
<body>
<div class="card">
  <div class="title">Two-Phase Factorizer — Streaming Sqrt Fixed</div>
  <div class="subtitle small">Calculates N = a^b + c (supports huge b) and computes S<sub>min</sub> using a robust streaming sqrt (chunked arithmetic). Phase 2 uses chunked/GCD methods.</div>

  <div class="grid3 mb-4">
    <div>
      <label class="small">Base (a)</label><br/>
      <input id="base" class="input" value="10">
    </div>
    <div>
      <label class="small">Exponent (b)</label><br/>
      <input id="exp" class="input" value="30">
    </div>
    <div>
      <label class="small">Addend (c)</label><br/>
      <input id="add" class="input" value="-1">
    </div>
  </div>

  <div class="mb-4">
    <button id="start" class="button start">Calculate S_min & Start</button>
    <button id="stop" class="button stop" disabled>Stop</button>
  </div>

  <div class="small mb-2">Search Status</div>
  <div id="phase" class="small mb-2">Idle</div>
  <div class="progress mb-4"><div id="bar" class="bar">0%</div></div>

  <div class="grid3 mb-4">
    <div>
      <div class="small">Calculated S_min</div>
      <div id="smin" style="font-weight:700;font-size:1.2rem">N/A</div>
    </div>
    <div>
      <div class="small">Factors Found</div>
      <div id="factors" style="font-weight:700;font-size:1.2rem">None</div>
    </div>
    <div>
      <div class="small">Candidates</div>
      <div id="candidates" style="font-weight:700;font-size:1.2rem">0</div>
    </div>
  </div>

  <div class="small mb-2">Log Output</div>
  <pre id="log" class="log">Ready.</pre>
</div>

<script>
/* ------------------------
   Main thread: UI and control
   ------------------------ */
const startBtn = document.getElementById('start');
const stopBtn  = document.getElementById('stop');
const baseEl   = document.getElementById('base');
const expEl    = document.getElementById('exp');
const addEl    = document.getElementById('add');
const logEl    = document.getElementById('log');
const phaseEl  = document.getElementById('phase');
const barEl    = document.getElementById('bar');
const sminEl   = document.getElementById('smin');
const factorsEl= document.getElementById('factors');
const candEl   = document.getElementById('candidates');

let isSearching = false;
let sqrtWorker = null;
let factorWorkers = [];
let N_str_global = '';
let SMin_global = 0n;
let filterCandidates = [];
let foundFactor = null;

// Logging helper
function log(msg) {
  const t = new Date().toLocaleTimeString();
  logEl.textContent += `\n[${t}] ${msg}`;
  logEl.scrollTop = logEl.scrollHeight;
}

// UI helpers
function setPhase(text, pct=0) {
  phaseEl.textContent = text;
  barEl.style.width = pct + '%';
  barEl.textContent = `${pct.toFixed(2)}%`;
}

function resetUI() {
  startBtn.disabled = false;
  stopBtn.disabled = true;
  setPhase('Idle', 0);
  sminEl.textContent = 'N/A';
  factorsEl.textContent = 'None';
  candEl.textContent = '0';
}

// Create worker blobs
const sqrtWorkerCode = `

/* Streaming sqrt worker (chunked decimal arithmetic)
   - Accepts { mode: 'compute_sqrt', aStr, bStr, cStr, maxDigitsLimit }
   - Returns progress updates and final { type:'result', root, remainder, N_str }
   - Uses chunk base 1e9 (9 digits per chunk)
*/

const CHUNK_DIGITS = 9;
const BASE = 10 ** CHUNK_DIGITS;

// Helper: trim leading zeros in chunk array
function trimChunks(a) {
  if (!Array.isArray(a) || a.length === 0) return [0];
  let i = 0;
  while (i < a.length - 1 && a[i] === 0) i++;
  return a.slice(i);
}

// Convert decimal string to chunk array (base = 1e9)
function stringToChunks(s) {
  s = (s||'').trim();
  if (s[0] === '+') s = s.slice(1);
  if (s.length === 0) return [0];
  let pad = (CHUNK_DIGITS - (s.length % CHUNK_DIGITS)) % CHUNK_DIGITS;
  s = '0'.repeat(pad) + s;
  let out = [];
  for (let i = 0; i < s.length; i += CHUNK_DIGITS) {
    out.push(parseInt(s.substring(i, i+CHUNK_DIGITS), 10));
  }
  return trimChunks(out);
}

// Convert chunk array back to decimal string
function chunksToString(chunks) {
  chunks = trimChunks(chunks);
  if (chunks.length === 1 && chunks[0] === 0) return '0';
  let s = String(chunks[0]);
  for (let i = 1; i < chunks.length; i++) {
    s += String(chunks[i]).padStart(CHUNK_DIGITS, '0');
  }
  return s;
}

// Compare chunk arrays a ? b (-1,0,1)
function cmpChunks(a,b) {
  a = trimChunks(a); b = trimChunks(b);
  if (a.length !== b.length) return a.length > b.length ? 1 : -1;
  for (let i = 0; i < a.length; i++) {
    if (a[i] !== b[i]) return a[i] > b[i] ? 1 : -1;
  }
  return 0;
}

// Add chunk arrays
function addChunks(a,b) {
  let ar = a.slice().reverse(), br = b.slice().reverse();
  let n = Math.max(ar.length, br.length);
  let carry = 0, out = [];
  for (let i = 0; i < n; i++) {
    let av = ar[i] || 0, bv = br[i] || 0;
    let s = av + bv + carry;
    out.push(s % BASE);
    carry = Math.floor(s / BASE);
  }
  if (carry) out.push(carry);
  return trimChunks(out.reverse());
}

// Subtract chunk arrays: a - b (assumes a >= b)
function subChunks(a,b) {
  let ar = a.slice().reverse(), br = b.slice().reverse();
  let n = ar.length;
  let borrow = 0, out = [];
  for (let i = 0; i < n; i++) {
    let av = ar[i] || 0, bv = br[i] || 0;
    let v = av - bv - borrow;
    if (v < 0) { v += BASE; borrow = 1; } else borrow = 0;
    out.push(v);
  }
  return trimChunks(out.reverse());
}

// Multiply chunk array by small integer s (0 <= s < BASE)
function mulSmallChunks(a, s) {
  if (!Array.isArray(a) || a.length === 0) return [0];
  if (s === 0) return [0];
  let a_rev = a.slice().reverse();
  let carry = 0, out = [];
  for (let d of a_rev) {
    let p = d * s + carry;
    out.push(p % BASE);
    carry = Math.floor(p / BASE);
  }
  while (carry > 0) {
    out.push(carry % BASE);
    carry = Math.floor(carry / BASE);
  }
  return trimChunks(out.reverse());
}

// Multiply chunk array by chunk array (used rarely, avoid for huge sizes)
function mulChunks(a,b) {
  a = trimChunks(a); b = trimChunks(b);
  if ((a.length === 1 && a[0] === 0) || (b.length === 1 && b[0] === 0)) return [0];
  let ar = a.slice().reverse(), br = b.slice().reverse();
  let res = new Array(ar.length + br.length).fill(0);
  for (let i = 0; i < ar.length; i++) {
    let carry = 0;
    for (let j = 0; j < br.length; j++) {
      let idx = i + j;
      let cur = res[idx] + ar[i] * br[j] + carry;
      res[idx] = cur % BASE;
      carry = Math.floor(cur / BASE);
    }
    if (carry) res[i + br.length] += carry;
  }
  return trimChunks(res.reverse());
}

// Helper to append zeros (multiply by BASE^k)
function shiftChunks(a, k) {
  if (!Array.isArray(a) || a.length === 0) return [0];
  if (k <= 0) return a.slice();
  return a.concat(new Array(k).fill(0));
}

/* Streaming sqrt algorithm
   Implementation of long-hand integer square root on a decimal string using chunk groups:
   - groupDigits = 2*CHUNK_DIGITS (works like grouping pairs in manual sqrt)
   - process each group, maintain 'root' as chunk array, 'remainder' as chunk array
   - at each step find the largest digit d in [0, BASE-1] such that ( (root*2)*BASE + d )*d <= remainder
   - use binary search for d
*/
function streamingIntegerSqrt(N_str, onProgress) {
  // Prepare groups of length groupDigits characters
  const groupDigits = CHUNK_DIGITS * 2;
  let s = N_str.replace(/^\\+/, '');
  if (s.length === 0) s = '0';
  // pad left
  let pad = (groupDigits - (s.length % groupDigits)) % groupDigits;
  s = '0'.repeat(pad) + s;
  let groups = [];
  for (let i = 0; i < s.length; i += groupDigits) groups.push(s.substring(i, i + groupDigits));

  let root = [0];      // chunk array representing current root in base BASE (each element 0..BASE-1)
  let remainder = [0]; // chunk array

  const total = groups.length;
  for (let idx = 0; idx < groups.length; idx++) {
    // add next group's two chunk-values to remainder
    const g = groups[idx];
    const left = g.substring(0, CHUNK_DIGITS);
    const right = g.substring(CHUNK_DIGITS);
    // groupChunks are two integers (each < BASE)
    let groupChunks = [parseInt(left,10), parseInt(right,10)];
    // remainder = remainder * BASE^2 + groupChunks
    remainder = shiftChunks(remainder, 2); // multiply by BASE^2 (append two zero chunks)
    remainder = addChunks(remainder, trimChunks(groupChunks)); // add groupChunks

    // prefix = root * 2 (chunk array)
    let prefix = mulSmallChunks(root, 2);

    // We must find largest d in [0, BASE-1] such that (prefix * BASE + d) * d <= remainder
    // Let candidate(t) = (prefix * BASE + t) * t
    // We'll binary search t.
    let lo = 0, hi = BASE - 1, chosen = 0;
    while (lo <= hi) {
      let mid = Math.floor((lo + hi) / 2);
      // t = prefix * BASE + mid (as chunk array)
      let t = shiftChunks(prefix, 1); // multiply by BASE (append one zero chunk)
      t = addChunks(t, [mid]); // add small mid
      // trial = t * mid  (use mulSmallChunks)
      let trial = mulSmallChunks(t, mid);
      if (cmpChunks(trial, remainder) <= 0) {
        chosen = mid;
        lo = mid + 1;
      } else {
        hi = mid - 1;
      }
    }

    // update remainder: remainder -= (prefix*BASE + chosen) * chosen
    let chosenT = shiftChunks(prefix, 1);
    chosenT = addChunks(chosenT, [chosen]);
    let trialChosen = mulSmallChunks(chosenT, chosen);
    remainder = subChunks(remainder, trialChosen);

    // append chosen to root
    root = addChunks( mulSmallChunks(root, 1), [chosen] ); // root*BASE + chosen  (since root is in chunk base already)
    // normalize root: But root as chunk array already in base BASE digits
    // NOTE: Because we used CHUNK base, root can be large number of chunks; structure kept consistent

    if (onProgress && idx % 50 === 0) {
      onProgress( (idx+1) / total * 100 );
    }
  }

  // root is the base-BASE "digits" array; convert to decimal string
  // But root currently contains chunks representing sqrt in base BASE.
  const rootDecStr = chunksToString(root);
  const remDecStr = chunksToString(remainder);
  return { root: rootDecStr, remainder: remDecStr, groupsProcessed: total };
}

// BigInt fast path for small N (safe when length < ~1000 digits — adjust as needed)
function tryNativeBigInt(N_str) {
  try {
    if (N_str.length < 700) { // safe threshold for most browsers
      let Nbi = BigInt(N_str);
      let isqrt = (function(n) {
        if (n < 0n) return null;
        if (n < 2n) return n;
        let x = n;
        let y = (x + 1n) >> 1n;
        while (y < x) { x = y; y = (x + n / x) >> 1n; }
        return x;
      })(Nbi);
      return { root: isqrt.toString(), remainder: (Nbi - isqrt*isqrt).toString() };
    }
  } catch(e) {
    // fallback to streaming algorithm
  }
  return null;
}

// ******************************************
// Message handler: compute sqrt on request
// ******************************************
self.onmessage = function(e) {
  const data = e.data || {};
  if (data.mode === 'compute_sqrt') {
    try {
      const a = (data.aStr||'10').trim();
      const bStr = (data.bStr||'0').trim();
      const cStr = (data.cStr||'0').trim();
      const maxDigitsLimit = data.maxDigitsLimit || 5000000; // default safety limit

      // Only support base 10 for streaming sqrt in this worker
      if (a !== '10') {
        self.postMessage({ type:'error', message: 'Streaming sqrt worker currently supports only base=10.' });
        return;
      }

      // If exponent small enough, compute N via BigInt fast path
      const bBig = BigInt(bStr);
      if (bBig < 0n) {
        self.postMessage({ type:'error', message: 'Exponent b must be non-negative.' });
        return;
      }

      // If b is not huge, build simple N and try BigInt sqrt
      if (bBig <= 600n) { // small exponent but still can be large; adjust threshold if needed
        // compute N = 10^b + c using BigInt
        const Nbi = (BigInt(10) ** bBig) + BigInt(cStr || '0');
        const native = tryNativeBigInt(Nbi.toString());
        if (native) {
          self.postMessage({ type:'progress', value: 100 });
          self.postMessage({ type:'result', root: native.root, remainder: native.remainder, N_str: Nbi.toString() });
          return;
        }
      }

      // For large b: build decimal string for N without using BigInt pow
      const bNum = Number(bBig);
      if (!Number.isFinite(bNum) || bNum > maxDigitsLimit) {
        self.postMessage({ type:'error', message: `Exponent b is too large or not a finite number. Limit: ${maxDigitsLimit}` });
        return;
      }
      // Build "10^b" as '1' + b zeros
      let Nstr = '1' + '0'.repeat(bNum);
      // Add cStr (which may be negative)
      function addDecimalStrings(A, B) {
        // returns decimal A + B (both strings possibly with leading + or -)
        // We'll do a simple chunked add/sub using base 1e9
        function signAndAbs(s) {
          s = s.trim();
          let sign = 1;
          if (s[0] === '+') s = s.slice(1);
          if (s[0] === '-') { sign = -1; s = s.slice(1); }
          s = s.replace(/^0+/, '') || '0';
          return { sign, s };
        }
        const a = signAndAbs(A);
        const b = signAndAbs(B);
        if (a.sign === b.sign) {
          // same signs, add absolute and keep sign
          const aChunks = stringToChunks(a.s);
          const bChunks = stringToChunks(b.s);
          const res = addChunks(aChunks, bChunks);
          return (a.sign < 0 ? '-' : '') + chunksToString(res);
        } else {
          // different signs => subtract smaller from larger
          const aChunks = stringToChunks(a.s);
          const bChunks = stringToChunks(b.s);
          const cmp = cmpChunks(aChunks, bChunks);
          if (cmp === 0) return '0';
          if (cmp > 0) {
            const res = subChunks(aChunks, bChunks);
            return (a.sign < 0 ? '-' : '') + chunksToString(res);
          } else {
            const res = subChunks(bChunks, aChunks);
            return (b.sign < 0 ? '-' : '') + chunksToString(res);
          }
        }
      }
      // combine Nstr + cStr
      const combined = addDecimalStrings(Nstr, cStr || '0');

      // Now compute streaming integer sqrt on combined
      self.postMessage({ type:'log', message: `N has ${combined.length} digits. Starting streaming sqrt...` });

      const fast = tryNativeBigInt(combined);
      if (fast) {
        self.postMessage({ type:'progress', value: 100 });
        self.postMessage({ type:'result', root: fast.root, remainder: fast.remainder, N_str: combined });
        return;
      }

      // streaming
      const result = streamingIntegerSqrt(combined, (p) => {
        self.postMessage({ type:'progress', value: p });
      });

      self.postMessage({ type:'progress', value: 100 });
      self.postMessage({ type:'result', root: result.root, remainder: result.remainder, N_str: combined });

    } catch (err) {
      self.postMessage({ type:'error', message: err && err.message ? err.message : String(err) });
    }
  }
}; // onmessage end

`; // sqrtWorkerCode end

// Factor worker is simplified: it accepts S candidates and checks Fermat resolution or chunked gcd.
// For this fixed file we keep a robust worker that can perform 'filter' (SGS screening) and 'resolve' (Fermat check).
const factorWorkerCode = `

const CHUNK_DIGITS = 9;
const BASE = 10 ** CHUNK_DIGITS;

// chunk helpers (same as sqrt worker)
function trimChunks(a) {
  if (!Array.isArray(a) || a.length === 0) return [0];
  let i = 0;
  while (i < a.length - 1 && a[i] === 0) i++;
  return a.slice(i);
}
function stringToChunks(s) {
  s = (s||'').trim();
  if (s[0] === '+') s = s.slice(1);
  if (s.length === 0) return [0];
  let pad = (CHUNK_DIGITS - (s.length % CHUNK_DIGITS)) % CHUNK_DIGITS;
  s = '0'.repeat(pad) + s;
  let out = [];
  for (let i = 0; i < s.length; i += CHUNK_DIGITS) {
    out.push(parseInt(s.substring(i, i+CHUNK_DIGITS), 10));
  }
  return trimChunks(out);
}
function chunksToString(chunks) {
  chunks = trimChunks(chunks);
  if (chunks.length === 1 && chunks[0] === 0) return '0';
  let s = String(chunks[0]);
  for (let i = 1; i < chunks.length; i++) s += String(chunks[i]).padStart(CHUNK_DIGITS, '0');
  return s;
}
function cmpChunks(a,b) {
  a = trimChunks(a); b = trimChunks(b);
  if (a.length !== b.length) return a.length > b.length ? 1 : -1;
  for (let i = 0; i < a.length; i++) if (a[i] !== b[i]) return a[i] > b[i] ? 1 : -1;
  return 0;
}
function addChunks(a,b) {
  let ar = a.slice().reverse(), br = b.slice().reverse();
  let n = Math.max(ar.length, br.length), carry = 0, out = [];
  for (let i = 0; i < n; i++) {
    let s = (ar[i]||0) + (br[i]||0) + carry;
    out.push(s % BASE);
    carry = Math.floor(s / BASE);
  }
  if (carry) out.push(carry);
  return trimChunks(out.reverse());
}
function subChunks(a,b) {
  let ar = a.slice().reverse(), br = b.slice().reverse();
  let n = ar.length, borrow = 0, out = [];
  for (let i = 0; i < n; i++) {
    let v = (ar[i]||0) - (br[i]||0) - borrow;
    if (v < 0) { v += BASE; borrow = 1; } else borrow = 0;
    out.push(v);
  }
  return trimChunks(out.reverse());
}
function mulSmallChunks(a,s) {
  if (!Array.isArray(a) || a.length === 0) return [0];
  if (s === 0) return [0];
  let a_rev = a.slice().reverse();
  let carry = 0, out = [];
  for (let d of a_rev) {
    let p = d * s + carry;
    out.push(p % BASE);
    carry = Math.floor(p / BASE);
  }
  while (carry > 0) {
    out.push(carry % BASE);
    carry = Math.floor(carry / BASE);
  }
  return trimChunks(out.reverse());
}
function shiftChunks(a,k) { if (!Array.isArray(a) || a.length === 0) return [0]; if (k<=0) return a.slice(); return a.concat(new Array(k).fill(0)); }

// small integer sqrt for BigInt (if N fits into BigInt)
function customIntegerSqrt(n) {
  if (n < 0n) return null;
  if (n < 2n) return n;
  let x = n;
  let y = (x + 1n) >> 1n;
  while (y < x) {
    x = y;
    y = (x + n / x) >> 1n;
  }
  return x;
}

function legendreSymbol(a, p) {
  if (a === 0n) return 0;
  if (p === 2n) return 1;
  a = (a % p + p) % p;
  const ls = powMod(a, (p - 1n) / 2n, p);
  if (ls === p - 1n) return -1;
  return 1;
}
function powMod(base, exp, mod) {
  let result = 1n;
  base %= mod;
  while (exp > 0n) {
    if ((exp & 1n) === 1n) result = (result * base) % mod;
    exp >>= 1n;
    base = (base * base) % mod;
  }
  return result;
}

// chunkedGCD: Euclid's algorithm on chunk arrays (binary GCD style)
function isZeroChunk(c) { c = trimChunks(c); return c.length === 1 && c[0] === 0; }
function isEvenChunk(c) { c = trimChunks(c); if (isZeroChunk(c)) return true; return (c[c.length-1] % 2) === 0; }
function divideByTwoChunk(c) {
  c = trimChunks(c);
  if (isZeroChunk(c)) return [0];
  let out = [], carry = 0;
  for (let i = 0; i < c.length; i++) {
    let val = carry * BASE + c[i];
    out.push(Math.floor(val / 2));
    carry = val % 2;
  }
  return trimChunks(out);
}
function chunkedGCD(A,B) {
  let a = trimChunks(A.slice()), b = trimChunks(B.slice());
  if (isZeroChunk(a)) return b;
  if (isZeroChunk(b)) return a;
  let k = 0;
  while (isEvenChunk(a) && isEvenChunk(b)) { a = divideByTwoChunk(a); b = divideByTwoChunk(b); k++; }
  while (isEvenChunk(a)) a = divideByTwoChunk(a);
  while (!isZeroChunk(b)) {
    while (isEvenChunk(b)) b = divideByTwoChunk(b);
    if (cmpChunks(a,b) > 0) { b = subChunks(a,b); [a,b] = [b,a]; } else { b = subChunks(b,a); }
  }
  let res = a;
  for (let i = 0; i < k; i++) res = mulSmallChunks(res, 2);
  return res;
}

// Worker message handling: modes 'filter' and 'resolve'
self.onmessage = function(e) {
  const data = e.data || {};
  if (data.mode === 'filter') {
    // Phase 1: SGS filter (screening using Legendre for small primes)
    try {
      const minS = BigInt(data.minS);
      const maxS = BigInt(data.maxS);
      const N_str = data.N_str; // full decimal string
      const N_chunks = stringToChunks(N_str);
      const primes = [3n,5n,7n,11n,13n,17n];
      let candidates = [];
      const total = maxS - minS + 1n;
      let lastProgress = -1;
      for (let S = minS; S <= maxS; S++) {
        const Ssq = S * S;
        const fourN = 4n * BigInt(0); // placeholder not used directly here
        // compute D_sq = S^2 - 4N modulo small primes using BigInt mod
        let passes = true;
        for (let p of primes) {
          // compute N mod p by iterating N_str (string) modulo p
          let mod = 0n;
          for (let i = 0; i < N_str.length; i++) {
            mod = (mod * 10n + BigInt(N_str.charCodeAt(i) - 48)) % p;
          }
          const Dmodp = ( (Ssq % p) - (4n * mod) % p + p*10n ) % p;
          if (legendreSymbol(Dmodp, p) === -1) { passes = false; break; }
        }
        if (passes) candidates.push(S.toString());
        // progress (throttle)
        if ((S - minS) % 1000n === 0n) {
          const progress = Number(((S - minS) * 100n) / total);
          if (progress > lastProgress) {
            lastProgress = progress;
            self.postMessage({ type:'filterProgress', progress });
          }
        }
      }
      self.postMessage({ type:'filterDone', candidates });
    } catch (err) {
      self.postMessage({ type:'error', message: err && err.message ? err.message : String(err) });
    }
  } else if (data.mode === 'resolve') {
    // Phase 2: Fermat resolution for provided candidate S_list
    try {
      const N_str = data.N_str;
      const S_list = data.S_list || [];
      const N_bi = BigInt(N_str);
      const total = S_list.length;
      let lastProgress = -1;
      let found = null;
      for (let i = 0; i < S_list.length; i++) {
        const S = BigInt(S_list[i]);
        const Dsq = S*S - 4n * N_bi;
        if (Dsq >= 0n) {
          const D = customIntegerSqrt(Dsq);
          if (D !== null && D*D === Dsq) {
            const f1 = (S + D) / 2n;
            const f2 = (S - D) / 2n;
            if (f2 > 1n && N_bi % f2 === 0n) {
              found = { f1: f1.toString(), f2: f2.toString(), S: S.toString() };
              self.postMessage({ type:'resolveDone', factor: found });
              return;
            }
          }
        }
        const progress = Math.floor(((i+1) / Math.max(1,total)) * 100);
        if (progress > lastProgress) {
          lastProgress = progress;
          self.postMessage({ type:'resolveProgress', progress });
        }
      }
      self.postMessage({ type:'resolveDone', factor: null });
    } catch (err) {
      self.postMessage({ type:'error', message: err && err.message ? err.message : String(err) });
    }
  }
};

`;

// Create Blobs and object URLs
const sqrtBlob = new Blob([sqrtWorkerCode], { type: 'application/javascript' });
const sqrtURL  = URL.createObjectURL(sqrtBlob);
const factorBlob = new Blob([factorWorkerCode], { type: 'application/javascript' });
const factorURL = URL.createObjectURL(factorBlob);

// Handler for sqrt worker messages
function handleSqrtMessage(e) {
  const d = e.data;
  if (d.type === 'log') log('[SqrtWorker] ' + d.message);
  else if (d.type === 'progress') setPhase('Phase 0: Streaming Sqrt', d.value);
  else if (d.type === 'result') {
    log('Streaming sqrt complete.');
    N_str_global = d.N_str;
    // root returned is decimal string of floor(sqrt(N))
    const rootStr = d.root;
    const remStr = d.remainder || '0';
    // Compute S_min = 2 * ceil(sqrt(N))
    let rootBig = BigInt(rootStr);
    let remBig  = BigInt(remStr);
    let smin = rootBig * 2n;
    if (remBig > 0n) smin += 1n;
    SMin_global = smin;
    sminEl.textContent = smin.toString();
    setPhase('Phase 1: SGS Filter (starting)', 0);
    // Move on to SGS Phase (split ranges into workers)
    startFilterPhase(smin);
  } else if (d.type === 'error') {
    log('[SqrtWorker ERROR] ' + d.message);
    stopAll();
  }
}

// Start the filter (Phase 1) by chunking S space
function startFilterPhase(Smin) {
  // For demonstration let's search S from Smin to Smin + range (e.g., 20000)
  const RANGE = 50000n; // adjust as needed
  const start = Smin;
  const end = Smin + RANGE;
  const totalChunks = navigator.hardwareConcurrency || 4;
  const chunkSize = ((end - start + 1n) / BigInt(totalChunks)) + 1n;

  filterCandidates = [];
  factorWorkers = new Array(totalChunks).fill(null);

  for (let i = 0; i < totalChunks; i++) {
    const worker = new Worker(factorURL);
    factorWorkers[i] = worker;
    worker.onmessage = function(ev) {
      const dd = ev.data;
      if (dd.type === 'filterProgress') {
        setPhase('Phase 1: SGS Filter', dd.progress);
      } else if (dd.type === 'filterDone') {
        filterCandidates = filterCandidates.concat(dd.candidates || []);
        // terminate worker
        worker.terminate();
        factorWorkers[i] = null;
        // check if all done
        if (factorWorkers.every(w => w === null)) {
          candEl.textContent = filterCandidates.length.toString();
          log('Phase 1 complete. Candidates: ' + filterCandidates.length);
          if (filterCandidates.length === 0) {
            log('No S-candidates found. Stopping.');
            stopAll();
            return;
          }
          startResolvePhase(filterCandidates);
        }
      } else if (dd.type === 'error') {
        log('[FactorWorker ERROR] ' + dd.message);
        worker.terminate();
        factorWorkers[i] = null;
      }
    };

    const chunkStart = start + BigInt(i) * chunkSize;
    let chunkEnd = chunkStart + chunkSize - 1n;
    if (chunkStart > end) {
      worker.terminate();
      factorWorkers[i] = null;
      continue;
    }
    if (chunkEnd > end) chunkEnd = end;

    log(\`Worker \${i} assigned S [\${chunkStart} .. \${chunkEnd}]\`);
    worker.postMessage({
      mode: 'filter',
      minS: chunkStart.toString(),
      maxS: chunkEnd.toString(),
      N_str: N_str_global
    });
  }
}

// Start Phase 2: resolution across available cores
function startResolvePhase(candidateList) {
  setPhase('Phase 2: Fermat Resolution', 0);
  const totalWorkers = navigator.hardwareConcurrency || 4;
  const per = Math.ceil(candidateList.length / totalWorkers);
  factorWorkers = new Array(totalWorkers).fill(null);

  for (let i = 0; i < totalWorkers; i++) {
    const subset = candidateList.slice(i*per, (i+1)*per);
    if (subset.length === 0) { factorWorkers[i] = null; continue; }
    const worker = new Worker(factorURL);
    factorWorkers[i] = worker;
    worker.onmessage = function(ev) {
      const d = ev.data;
      if (d.type === 'resolveProgress') {
        setPhase('Phase 2: Fermat Resolution', d.progress);
      } else if (d.type === 'resolveDone') {
        if (d.factor) {
          foundFactor = d.factor;
          log('Factor found: ' + JSON.stringify(d.factor));
          // communicate found and stop other workers
          stopAll(true);
          // update UI with factors
          factorsEl.textContent = d.factor.f1 + ' × ' + d.factor.f2;
        } else {
          // worker finished with no factor
          worker.terminate();
          factorWorkers[i] = null;
          if (factorWorkers.every(w => w === null)) {
            log('Phase 2 complete. No factors found in range.');
            stopAll();
          }
        }
      } else if (d.type === 'error') {
        log('[Resolve ERROR] ' + d.message);
        worker.terminate();
        factorWorkers[i] = null;
      }
    };

    worker.postMessage({
      mode: 'resolve',
      S_list: subset,
      N_str: N_str_global
    });
  }
}

// Stop everything, optionally keep results
function stopAll(found=false) {
  isSearching = false;
  if (sqrtWorker) { try { sqrtWorker.terminate(); } catch(e){} sqrtWorker = null; }
  (factorWorkers || []).forEach(w => { try { if (w) w.terminate(); } catch(e){} });
  factorWorkers = [];
  startBtn.disabled = false;
  stopBtn.disabled = true;
  if (!found) {
    log('Search stopped.');
  } else {
    log('Search stopped due to found factor.');
  }
  setPhase('Idle', 0);
}

// UI button handlers
startBtn.onclick = function() {
  if (isSearching) return;
  isSearching = true;
  startBtn.disabled = true;
  stopBtn.disabled = false;
  log('\\n--- Start requested ---');
  const a = baseEl.value.trim() || '10';
  const b = expEl.value.trim() || '0';
  const c = addEl.value.trim() || '0';

  setPhase('Phase 0: Preparing', 0);

  // create worker and start
  sqrtWorker = new Worker(sqrtURL);
  sqrtWorker.onmessage = handleSqrtMessage;
  sqrtWorker.postMessage({ mode: 'compute_sqrt', aStr: a, bStr: b, cStr: c, maxDigitsLimit: 5000000 });
  log('Sqrt worker started for N = ' + a + '^' + b + ' + (' + c + ')');
};

stopBtn.onclick = function() {
  if (!isSearching) return;
  log('Stop requested by user.');
  stopAll(false);
};

// initialize UI
resetUI();
</script>
</body>
</html>