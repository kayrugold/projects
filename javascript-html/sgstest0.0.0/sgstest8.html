<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>sgstest3_merged — Two-Phase Factorizer (Streaming Sqrt + SGS + Resolve)</title>
<style>
  :root{--bg:#f3f4f6;--panel:#fff;--accent:#3b82f6;--good:#10b981;--bad:#ef4444}
  body{font-family:Inter,system-ui,Segoe UI,Roboto,Arial;margin:0;background:var(--bg);padding:20px}
  .card{max-width:980px;margin:0 auto;background:var(--panel);padding:20px;border-radius:12px;box-shadow:0 12px 30px rgba(0,0,0,.08);border-top:8px solid var(--accent)}
  h1{margin:0 0 6px;color:var(--accent)}
  p.subtitle{margin:0 0 14px;color:#6b7280}
  .grid4{display:grid;grid-template-columns:1fr 1fr 1fr 1fr;gap:10px}
  label{display:block;font-size:0.9rem;color:#374151;margin-bottom:6px}
  input{width:100%;padding:10px;border-radius:8px;border:1px solid #e6eef8;font-size:1rem}
  button{padding:10px 14px;border-radius:8px;border:none;font-weight:700;cursor:pointer}
  .start{background:var(--good);color:white}
  .stop{background:var(--bad);color:white}
  pre.log{background:#061124;color:#9ff1c7;padding:12px;border-radius:8px;height:240px;overflow:auto;white-space:pre-wrap}
  .progress{height:14px;background:#eef2ff;border-radius:999px;overflow:hidden;margin-top:8px}
  .bar{height:100%;width:0;background:var(--accent);color:white;text-align:center;font-weight:700;font-size:12px}
  .small{font-size:0.9rem;color:#475569}
  .stat{font-weight:700;font-size:1.1rem}
  .row{display:flex;gap:8px;margin-top:12px}
</style>
</head>
<body>
  <div class="card">
    <h1>Two-Phase Factorizer — Merged (Streaming Sqrt + SGS + Resolve)</h1>
    <p class="subtitle small">Computes <code>N = a^b + c</code>, calculates <code>S_min = 2·ceil(√N)</code> with a streaming sqrt for very large numbers, then runs SGS screening and Fermat resolution across workers.</p>

    <div class="grid4">
      <div>
        <label>Base (a)</label>
        <input id="base" value="10">
      </div>
      <div>
        <label>Exponent (b)</label>
        <input id="exp" value="30">
      </div>
      <div>
        <label>Addend (c)</label>
        <input id="add" value="-1">
      </div>
      <div>
        <label>Max S Range</label>
        <input id="range" value="50000">
      </div>
    </div>

    <div class="row">
      <button id="startBtn" class="start">Calculate S_min & Start</button>
      <button id="stopBtn" class="stop" disabled>Stop</button>
      <div style="margin-left:auto;text-align:right">
        <div class="small">Status: <span id="phase">Idle</span></div>
        <div class="progress"><div id="bar" class="bar">0%</div></div>
      </div>
    </div>

    <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:12px;margin-top:14px">
      <div>
        <div class="small">Calculated S_min</div>
        <div id="smin" class="stat">N/A</div>
      </div>
      <div>
        <div class="small">Factors Found</div>
        <div id="factors" class="stat">None</div>
      </div>
      <div>
        <div class="small">S-candidates</div>
        <div id="candidates" class="stat">0</div>
      </div>
    </div>

    <h3 style="margin-top:14px">Log</h3>
    <pre id="log" class="log">Ready.</pre>
  </div>

<script>
/* -------------------------
   Main thread control & UI
   ------------------------- */
const startBtn = document.getElementById('startBtn');
const stopBtn  = document.getElementById('stopBtn');
const baseEl   = document.getElementById('base');
const expEl    = document.getElementById('exp');
const addEl    = document.getElementById('add');
const rangeEl  = document.getElementById('range');
const logEl    = document.getElementById('log');
const phaseEl  = document.getElementById('phase');
const barEl    = document.getElementById('bar');
const sminEl   = document.getElementById('smin');
const factorsEl= document.getElementById('factors');
const candEl   = document.getElementById('candidates');

let sqrtWorker = null;
let workers = [];
let N_str = '';
let SMin = 0n;
let candidateList = [];
let foundFactor = null;
let isRunning = false;
let stopChecker = null;

function log(msg){
  const t = new Date().toLocaleTimeString();
  logEl.textContent += `\n[${t}] ${msg}`;
  logEl.scrollTop = logEl.scrollHeight;
}
function setPhase(text, pct=0){
  phaseEl.textContent = text;
  barEl.style.width = pct + '%';
  barEl.textContent = pct.toFixed(2) + '%';
}

/* ================
   Worker functions
   ================ */

// ---- Streaming sqrt worker function ----
function sqrtWorkerFn(){
  const CHUNK_DIGITS = 9;
  const BASE = 10 ** CHUNK_DIGITS;

  function trimChunks(a){ if(!Array.isArray(a)||a.length===0) return [0]; let i=0; while(i<a.length-1 && a[i]===0) i++; return a.slice(i); }
  function stringToChunks(s){
    s = (s||'').replace(/^\+/, '').trim(); if(s[0]==='+') s=s.slice(1);
    if(s.length===0) return [0];
    const pad = (CHUNK_DIGITS - (s.length % CHUNK_DIGITS)) % CHUNK_DIGITS;
    s = '0'.repeat(pad) + s;
    const out=[];
    for(let i=0;i<s.length;i+=CHUNK_DIGITS) out.push(parseInt(s.substring(i,i+CHUNK_DIGITS),10));
    return trimChunks(out);
  }
  function chunksToString(chunks){ chunks = trimChunks(chunks); if(chunks.length===1 && chunks[0]===0) return '0'; let s = String(chunks[0]); for(let i=1;i<chunks.length;i++) s += String(chunks[i]).padStart(CHUNK_DIGITS,'0'); return s; }
  function cmpChunks(a,b){ a=trimChunks(a); b=trimChunks(b); if(a.length!==b.length) return a.length>b.length?1:-1; for(let i=0;i<a.length;i++) if(a[i]!==b[i]) return a[i]>b[i]?1:-1; return 0; }
  function addChunks(a,b){ let ar=a.slice().reverse(), br=b.slice().reverse(), n=Math.max(ar.length,br.length), carry=0, out=[]; for(let i=0;i<n;i++){ let s=(ar[i]||0)+(br[i]||0)+carry; out.push(s%BASE); carry=Math.floor(s/BASE);} if(carry) out.push(carry); return trimChunks(out.reverse()); }
  function subChunks(a,b){ let ar=a.slice().reverse(), br=b.slice().reverse(), n=ar.length, borrow=0, out=[]; for(let i=0;i<n;i++){ let v=(ar[i]||0)-(br[i]||0)-borrow; if(v<0){ v+=BASE; borrow=1;} else borrow=0; out.push(v);} return trimChunks(out.reverse()); }
  function mulSmallChunks(a,s){ if(!Array.isArray(a)||a.length===0) return [0]; if(s===0) return [0]; let a_rev=a.slice().reverse(), carry=0, out=[]; for(let d of a_rev){ let p=d*s+carry; out.push(p%BASE); carry=Math.floor(p/BASE);} while(carry>0){ out.push(carry%BASE); carry=Math.floor(carry/BASE);} return trimChunks(out.reverse()); }
  function shiftChunks(a,k){ if(!Array.isArray(a)||a.length===0) return [0]; if(k<=0) return a.slice(); return a.concat(new Array(k).fill(0)); }

  function streamingIntegerSqrt(N_str, onProgress){
    const groupDigits = CHUNK_DIGITS*2;
    let s = N_str.replace(/^\+/, '');
    if(s.length===0) s='0';
    const pad = (groupDigits - (s.length % groupDigits)) % groupDigits;
    s = '0'.repeat(pad) + s;
    const groups = [];
    for(let i=0;i<s.length;i+=groupDigits) groups.push(s.substring(i,i+groupDigits));
    let root=[0], remainder=[0];
    const total = groups.length;
    for(let idx=0; idx<groups.length; idx++){
      const g = groups[idx];
      const left = g.substring(0,CHUNK_DIGITS);
      const right = g.substring(CHUNK_DIGITS);
      const groupChunks = [parseInt(left,10), parseInt(right,10)];
      remainder = shiftChunks(remainder, 2);
      remainder = addChunks(remainder, trimChunks(groupChunks));
      let prefix = mulSmallChunks(root,2);
      // binary search digit in [0, BASE-1]
      let lo=0, hi=BASE-1, chosen=0;
      while(lo<=hi){
        const mid = Math.floor((lo+hi)/2);
        let t = shiftChunks(prefix,1);
        t = addChunks(t, [mid]);
        let trial = mulSmallChunks(t, mid);
        if(cmpChunks(trial, remainder) <= 0) { chosen = mid; lo = mid+1; } else hi = mid-1;
      }
      let chosenT = shiftChunks(prefix,1); chosenT = addChunks(chosenT, [chosen]);
      let trialChosen = mulSmallChunks(chosenT, chosen);
      remainder = subChunks(remainder, trialChosen);
      // root = root*BASE + chosen
      root = addChunks(mulSmallChunks(root,1), [chosen]);
      if(onProgress && (idx % 50 === 0)) {
        try{ onProgress((idx+1)/total*100); } catch(e){}
      }
    }
    return { root: chunksToString(root), remainder: chunksToString(remainder), digits: N_str.length };
  }

  function tryNative(N_str){
    try {
      if(N_str.length < 700) {
        const Nbi = BigInt(N_str);
        let x = Nbi, y = (x + 1n) >> 1n;
        while(y < x) { x = y; y = (x + Nbi / x) >> 1n; }
        const rem = Nbi - x*x;
        return { root: x.toString(), remainder: rem.toString() };
      }
    } catch(e){}
    return null;
  }

  self.onmessage = function(ev){
    const data = ev.data || {};
    if(data.mode === 'compute_sqrt'){
      try{
        const aStr = String(data.aStr || '10').trim();
        const bStr = String(data.bStr || '0').trim();
        const cStr = String(data.cStr || '0').trim();
        const maxDigitsLimit = Number(data.maxDigitsLimit || 5000000);
        if(aStr !== '10') { self.postMessage({ type:'error', message:'Streaming sqrt supports base=10 only.'}); return; }
        const bBig = BigInt(bStr);
        if(bBig < 0n) { self.postMessage({ type:'error', message:'Exponent must be >= 0'}); return; }
        const bNum = Number(bBig);
        if(!Number.isFinite(bNum) || bNum > maxDigitsLimit) { self.postMessage({ type:'error', message:`Exponent too large. Limit ${maxDigitsLimit}`}); return; }
        // Build 10^b as '1' + b zeros
        const powStr = '1' + '0'.repeat(bNum);
        // Add c (decimal add/sub with chunks)
        function signAndAbs(s){ s = String(s).trim(); let sign=1; if(s[0]==='+') s=s.slice(1); if(s[0]==='-'){ sign=-1; s=s.slice(1);} s = s.replace(/^0+/, '') || '0'; return {sign, s}; }
        function addDecimalStrings(A,B){
          const a = signAndAbs(A), b = signAndAbs(B);
          if(a.sign === b.sign){
            const ra = stringToChunks(a.s), rb = stringToChunks(b.s);
            return (a.sign<0?'-':'') + chunksToString(addChunks(ra, rb));
          } else {
            const ra = stringToChunks(a.s), rb = stringToChunks(b.s);
            const cmp = cmpChunks(ra, rb);
            if(cmp===0) return '0';
            if(cmp>0) return (a.sign<0?'-':'') + chunksToString(subChunks(ra, rb));
            return (b.sign<0?'-':'') + chunksToString(subChunks(rb, ra));
          }
        }
        const combined = addDecimalStrings(powStr, cStr || '0');
        self.postMessage({ type:'log', message: `N digits: ${combined.length}` });
        const fast = tryNative(combined);
        if(fast){ self.postMessage({ type:'progress', value:100 }); self.postMessage({ type:'result', root:fast.root, remainder:fast.remainder, N_str:combined }); return; }
        const res = streamingIntegerSqrt(combined, function(p){ self.postMessage({ type:'progress', value:p }); });
        self.postMessage({ type:'progress', value:100 });
        self.postMessage({ type:'result', root:res.root, remainder:res.remainder, N_str:combined });
      } catch(err){
        self.postMessage({ type:'error', message: err && err.message ? err.message : String(err) });
      }
    }
  };
}

// ---- Factor worker function (filter + resolve) ----
function factorWorkerFn(){
  const CHUNK_DIGITS = 9;
  const BASE = 10 ** CHUNK_DIGITS;
  function trimChunks(a){ if(!Array.isArray(a)||a.length===0) return [0]; let i=0; while(i<a.length-1 && a[i]===0) i++; return a.slice(i); }
  function stringToChunks(s){ s=(s||'').replace(/^\+/, '').trim(); if(s.length===0) return [0]; const pad=(CHUNK_DIGITS-(s.length%CHUNK_DIGITS))%CHUNK_DIGITS; s='0'.repeat(pad)+s; const out=[]; for(let i=0;i<s.length;i+=CHUNK_DIGITS) out.push(parseInt(s.substring(i,i+CHUNK_DIGITS),10)); return trimChunks(out); }
  function chunksToString(chunks){ chunks=trimChunks(chunks); if(chunks.length===1 && chunks[0]===0) return '0'; let s=String(chunks[0]); for(let i=1;i<chunks.length;i++) s+=String(chunks[i]).padStart(CHUNK_DIGITS,'0'); return s; }
  function cmpChunks(a,b){ a=trimChunks(a); b=trimChunks(b); if(a.length!==b.length) return a.length>b.length?1:-1; for(let i=0;i<a.length;i++) if(a[i]!==b[i]) return a[i]>b[i]?1:-1; return 0; }
  function addChunks(a,b){ let ar=a.slice().reverse(), br=b.slice().reverse(), n=Math.max(ar.length,br.length), carry=0, out=[]; for(let i=0;i<n;i++){ let s=(ar[i]||0)+(br[i]||0)+carry; out.push(s%BASE); carry=Math.floor(s/BASE);} if(carry) out.push(carry); return trimChunks(out.reverse()); }
  function subChunks(a,b){ let ar=a.slice().reverse(), br=b.slice().reverse(), n=ar.length, borrow=0, out=[]; for(let i=0;i<n;i++){ let v=(ar[i]||0)-(br[i]||0)-borrow; if(v<0){ v+=BASE; borrow=1;} else borrow=0; out.push(v);} return trimChunks(out.reverse()); }
  function mulSmallChunks(a,s){ if(!Array.isArray(a)||a.length===0) return [0]; if(s===0) return [0]; let a_rev=a.slice().reverse(), carry=0, out=[]; for(let d of a_rev){ let p=d*s+carry; out.push(p%BASE); carry=Math.floor(p/BASE);} while(carry>0){ out.push(carry%BASE); carry=Math.floor(carry/BASE);} return trimChunks(out.reverse()); }
  function shiftChunks(a,k){ if(!Array.isArray(a)||a.length===0) return [0]; if(k<=0) return a.slice(); return a.concat(new Array(k).fill(0)); }
  function mulChunks(A,B){
    let a=A.slice().reverse(), b=B.slice().reverse(), len_a=a.length, len_b=b.length, res=new Array(len_a+len_b).fill(0), carry=0;
    for(let i=0;i<len_a;i++){ carry=0; for(let j=0;j<len_b;j++){ let p=a[i]*b[j]+res[i+j]+carry; res[i+j]=p%BASE; carry=Math.floor(p/BASE); } res[i+len_b]+=carry; }
    return trimChunks(res.reverse());
  }

  // NEW: Chunked Division/Remainder (long division algorithm)
  function divRemChunks(N, D) {
      let n = N.slice(), d = D.slice();
      if (isZeroChunk(d)) throw new Error('Division by zero');
      if (cmpChunks(n, d) < 0) return { quotient: [0], remainder: n };

      let quotient = [];
      let remainder = [];

      let d_len = trimChunks(d).length;
      remainder = n.slice(0, d_len - 1);

      for (let i = d_len - 1; i < n.length; i++) {
          remainder.push(n[i]);
          remainder = trimChunks(remainder);
          
          let lo = 0, hi = BASE - 1, q = 0;
          let best_rem = remainder.slice();

          // Optimization: Estimate q by dividing the first chunk of remainder by first chunk of divisor.
          let rem_head = remainder[0] * BASE + (remainder[1] || 0);
          let div_head = d[0];
          let q_est = Math.floor(rem_head / div_head);
          
          // Binary search for precise q near the estimate.
          // Since the result must be between 0 and BASE-1, clamp search range
          lo = Math.max(0, q_est - 2); 
          hi = Math.min(BASE - 1, q_est + 2);

          while (lo <= hi) {
              let mid = Math.floor((lo + hi) / 2);
              let trial = mulSmallChunks(d, mid);

              if (cmpChunks(trial, remainder) <= 0) {
                  q = mid;
                  best_rem = subChunks(remainder, trial);
                  lo = mid + 1;
              } else {
                  hi = mid - 1;
              }
          }
          quotient.push(q);
          remainder = best_rem;
      }
      return { quotient: trimChunks(quotient), remainder: trimChunks(remainder) };
  }

  // BigInt helpers
  function customIntegerSqrt(n){ if(n<0n) return null; if(n<2n) return n; let x=n, y=(x+1n)>>1n; while(y<x){ x=y; y=(x + n/x)>>1n;} return x; }
  function powMod(base, exp, mod){ let res=1n; base%=mod; while(exp>0n){ if((exp & 1n) === 1n) res=(res*base)%mod; exp >>=1n; base=(base*base)%mod;} return res; }
  function legendreSymbol(a,p){ if(a===0n) return 0; if(p===2n) return 1; a=(a%p + p)%p; const ls = powMod(a, (p-1n)/2n, p); if(ls===p-1n) return -1; return 1; }

  // chunked utility
  function isZeroChunk(c){ c=trimChunks(c); return c.length===1 && c[0]===0; }
  function isEvenChunk(c){ c=trimChunks(c); if(isZeroChunk(c)) return true; return (c[c.length-1] % 2) === 0; }
  function divideByTwoChunk(c){ c=trimChunks(c); if(isZeroChunk(c)) return [0]; let out=[], carry=0; for(let i=0;i<c.length;i++){ let v = carry * BASE + c[i]; out.push(Math.floor(v/2)); carry = v % 2;} return trimChunks(out); }

  self.onmessage = function(ev){
    const data = ev.data || {};
    try {
      if(data.mode === 'filter'){
        const minS = BigInt(data.minS);
        const maxS = BigInt(data.maxS);
        const N_str = data.N_str;
        const primes = [3n,5n,7n,11n,13n,17n];
        let candidates = [];
        const total = maxS - minS + 1n;
        let lastProg = -1;
        const Nmods = {};
        for(let p of primes){
          let mod = 0n;
          for(let i=0;i<N_str.length;i++) mod = (mod*10n + BigInt(N_str.charCodeAt(i) - 48)) % p;
          Nmods[p.toString()] = mod;
        }
        for(let S = minS; S <= maxS; S++){
          const Ssq = S*S;
          let passes = true;
          for(let p of primes){
            const Nmodp = Nmods[p.toString()];
            const Dmodp = ( (Ssq % p) - (4n * Nmodp) % p + (p*10n) ) % p;
            if(legendreSymbol(Dmodp, p) === -1){ passes = false; break; }
          }
          if(passes) candidates.push(S.toString());
          if(total > 0n && (S - minS) % 1000n === 0n) {
            const prog = Number((S - minS) * 100n / total);
            if(prog > lastProg){ lastProg = prog; self.postMessage({ type:'filterProgress', progress: prog }); }
          }
        }
        self.postMessage({ type:'filterDone', candidates });
      } else if(data.mode === 'resolve'){
        const S_list = data.S_list || [];
        const N_str = data.N_str;
        
        let Nbi = null;
        try { if(N_str.length < 700) Nbi = BigInt(N_str); } catch(e){}
        const N_chunks = stringToChunks(N_str); 
        const N_chunks_4 = mulSmallChunks(N_chunks, 4); 
        
        const total = S_list.length;
        let lastProg = -1;

        for(let i=0;i<S_list.length;i++){
          const S = BigInt(S_list[i]);
          let factor = null;

          if(Nbi !== null){
            // --- BigInt Path (Fast Fermat for small N) ---
            const Dsq = S*S - 4n * Nbi;
            if(Dsq >= 0n){
              const D = customIntegerSqrt(Dsq);
              if(D !== null && D*D === Dsq){
                const f2 = (S - D) / 2n;
                if(f2 > 1n && Nbi % f2 === 0n){
                  factor = { f1: ((S + D) / 2n).toString(), f2: f2.toString(), S: S.toString() };
                }
              }
            }
          } else {
            // --- Chunked Division/Modulo Resolution Path (For huge N) ---
            const S_chunks = stringToChunks(S.toString());
            const S_chunks_sq = mulChunks(S_chunks, S_chunks); 
            
            if(cmpChunks(S_chunks_sq, N_chunks_4) >= 0){
              const Dsq_chunks = subChunks(S_chunks_sq, N_chunks_4);
              const D_res = chunkedIntegerSqrt(Dsq_chunks); 
              
              if(D_res && D_res.isPerfect){
                const D_chunks = stringToChunks(D_res.root);
                
                const S_plus_D_chunks = addChunks(S_chunks, D_chunks);
                const S_minus_D_chunks = subChunks(S_chunks, D_chunks);

                if(isEvenChunk(S_plus_D_chunks) && isEvenChunk(S_minus_D_chunks)){
                  const f1_chunks = divideByTwoChunk(S_plus_D_chunks);
                  const f2_chunks = divideByTwoChunk(S_minus_D_chunks);
                  
                  if(cmpChunks(f2_chunks, stringToChunks('1')) > 0){
                    // Final check using chunked division/modulo
                    const div_res = divRemChunks(N_chunks, f2_chunks);
                    if(isZeroChunk(div_res.remainder)){
                      factor = { 
                          f1: chunksToString(f1_chunks), 
                          f2: chunksToString(f2_chunks), 
                          S: S.toString() 
                      };
                    }
                  }
                }
              }
            }
          }

          if(factor){
            self.postMessage({ type:'resolveDone', factor: factor });
            return;
          }

          const prog = Math.floor(((i+1)/Math.max(1,total))*100);
          if(prog > lastProg){ lastProg = prog; self.postMessage({ type:'resolveProgress', progress: prog }); }
        }
        self.postMessage({ type:'resolveDone', factor: null });
      }
    } catch(err){
      self.postMessage({ type:'error', message: err && err.message ? err.message : String(err) });
    }
  };
}

/* ================
   Helper to create worker from function
   ================ */
function mkWorker(fn){
  const blob = new Blob(['(' + fn.toString() + ')()'], { type: 'application/javascript' });
  return new Worker(URL.createObjectURL(blob));
}

/* ================
   Orchestration: start -> sqrt -> filter -> resolve
   ================ */

function stopAll(){
  if(!isRunning) return;
  isRunning = false;
  if(stopChecker) clearInterval(stopChecker);
  stopChecker = null;
  try{ if(sqrtWorker) { sqrtWorker.terminate(); sqrtWorker = null; } }catch(e){}
  (workers||[]).forEach(w => { try{ if(w) w.terminate(); }catch(e){} });
  workers = [];
  startBtn.disabled = false;
  stopBtn.disabled = true;
  setPhase('Idle', 0);
  log('Stopped. All workers terminated.');
}

function startFilterPhase(Smin, range){
  setPhase('Phase 1: SGS Filter (starting)', 0);
  const RANGE = BigInt(range);
  const start = Smin;
  const end = Smin + RANGE;
  const cores = navigator.hardwareConcurrency || 4;
  const totalS = end - start + 1n;
  const chunk = (totalS / BigInt(cores)) + 1n;
  candidateList = [];
  workers = new Array(cores).fill(null);

  stopChecker = setInterval(function(){
    if(!isRunning){
      log('Stop checker detected stop, killing workers.');
      stopAll();
    }
  }, 200);

  for(let i=0;i<cores;i++){
    const s = start + BigInt(i)*chunk;
    let e = s + chunk - 1n;
    if(s > end){ workers[i] = null; continue; }
    if(e > end) e = end;

    const ws = mkWorker(factorWorkerFn);
    workers[i] = ws;
    ws.onmessage = function(ev){
      const d = ev.data || {};
      if(d.type === 'filterProgress') setPhase('Phase 1: SGS Filter', d.progress);
      else if(d.type === 'filterDone'){
        candidateList = candidateList.concat(d.candidates || []);
        ws.terminate(); workers[i] = null;
        if(workers.every(w=>w===null)){
          clearInterval(stopChecker); stopChecker = null;
          candEl.textContent = candidateList.length.toString();
          log(`Phase 1 complete — ${candidateList.length} candidates found in range ${range}.`);
          if(candidateList.length === 0){
            log('No S-candidates found in range. Stopping.');
            stopAll();
          } else {
            startResolvePhase(candidateList);
          }
        }
      } else if(d.type === 'error'){
        log(`[FilterWorker ${i} ERROR] `+d.message);
        ws.terminate(); workers[i]=null;
        if(workers.every(w=>w===null)) stopAll();
      } else if(d.type === 'log') {
        log(`[FilterWorker ${i} LOG] ` + d.message);
      }
    };
    ws.postMessage({ mode:'filter', minS: s.toString(), maxS: e.toString(), N_str: N_str });
    log(`Worker ${i} assigned S [${s} .. ${e}]`);
  }
}

function startResolvePhase(list){
  setPhase('Phase 2: Fermat Resolve', 0);
  const cores = navigator.hardwareConcurrency || 4;
  const per = Math.ceil(list.length / cores);
  workers = new Array(cores).fill(null);

  stopChecker = setInterval(function(){
    if(!isRunning){
      log('Stop checker detected stop, killing workers.');
      stopAll();
    }
  }, 200);

  for(let i=0;i<cores;i++){
    const subset = list.slice(i*per, (i+1)*per);
    if(subset.length === 0) { workers[i] = null; continue; }
    const ws = mkWorker(factorWorkerFn);
    workers[i] = ws;
    ws.onmessage = function(ev){
      const d = ev.data || {};
      if(d.type === 'resolveProgress') setPhase('Phase 2: Fermat Resolve', d.progress);
      else if(d.type === 'resolveDone'){
        if(d.factor){
          foundFactor = d.factor;
          log('Factor found: ' + JSON.stringify(d.factor));
          factorsEl.textContent = `${d.factor.f1} × ${d.factor.f2}`;
          workers.forEach(w=>{ try{ if(w) w.terminate(); }catch(e){} });
          workers = [];
          stopAll();
        } else {
          ws.terminate(); workers[i] = null;
          if(workers.every(w=>w===null)){
            clearInterval(stopChecker); stopChecker = null;
            log('Phase 2 complete — no factor found.');
            stopAll();
          }
        }
      } else if(d.type === 'error'){
        log(`[ResolveWorker ${i} ERROR] `+d.message);
        ws.terminate(); workers[i]=null;
        if(workers.every(w=>w===null)) stopAll();
      } else if(d.type === 'log') {
        log(`[ResolveWorker ${i} LOG] ` + d.message);
      }
    };
    ws.postMessage({ mode:'resolve', S_list: subset, N_str: N_str });
  }
}

/* ================
   Start / Stop Button Logic
   ================ */
startBtn.addEventListener('click', function(){
  if(isRunning) return;
  const aVal = baseEl.value.trim();
  const bVal = expEl.value.trim();
  const cVal = addEl.value.trim();
  const rVal = rangeEl.value.trim();

  if(aVal.length===0 || bVal.length===0) { log('Base and exponent required.'); return; }
  const aNum = Number(aVal), bNum = Number(bVal), cNum = Number(cVal), rNum = Number(rVal);
  if(!Number.isFinite(aNum) || Math.floor(aNum) !== aNum) { log('Base must be an integer.'); return; }
  if(!Number.isFinite(bNum) || Math.floor(bNum) !== bNum || bNum < 0) { log('Exponent must be non-negative integer.'); return; }
  if(!Number.isFinite(cNum) || Math.floor(cNum) !== cNum) { log('Addend must be an integer.'); return; }
  if(!Number.isFinite(rNum) || Math.floor(rNum) !== rNum || rNum <= 0) { log('Range must be a positive integer.'); return; }

  isRunning = true;
  startBtn.disabled = true;
  stopBtn.disabled = false;
  setPhase('Phase 0: Streaming Sqrt (starting)', 0);
  sminEl.textContent = 'Calculating...';
  factorsEl.textContent = 'None';
  candEl.textContent = '0';
  foundFactor = null;
  candidateList = [];

  sqrtWorker = mkWorker(sqrtWorkerFn);
  sqrtWorker.onmessage = function(ev){
    const d = ev.data || {};
    if(d.type === 'log') log('[SqrtWorker] ' + d.message);
    else if(d.type === 'progress') setPhase('Phase 0: Streaming Sqrt', d.value);
    else if(d.type === 'result'){
      N_str = d.N_str;
      const rootStr = d.root;
      const remStr  = d.remainder || '0';
      const rootBig = BigInt(rootStr);
      const remBig  = BigInt(remStr);
      let smin = rootBig * 2n;
      if(remBig > 0n) smin += 1n;
      SMin = smin;
      sminEl.textContent = SMin.toString();
      log('Streaming sqrt complete. S_min = ' + SMin.toString());
      startFilterPhase(SMin, rNum);
    } else if(d.type === 'error'){
      log('[SqrtWorker ERROR] ' + d.message);
      stopAll();
    }
  };

  sqrtWorker.postMessage({
    mode: 'compute_sqrt',
    aStr: aVal,
    bStr: bVal,
    cStr: cVal,
    maxDigitsLimit: 5000000
  });
});

stopBtn.addEventListener('click', function(){
  log('Stop requested by user. Terminating workers...');
  stopAll();
});

/* init */
setPhase('Idle', 0);
log('Ready. Enter a, b, c, Max S Range, and press "Calculate S_min & Start".');

</script>
</body>
</html>
