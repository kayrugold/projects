<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Streaming Integer Sqrt — Test (fixed)</title>
<style>
  body{font-family:system-ui,Segoe UI,Roboto,Arial;background:#f6f7fb;color:#111;padding:20px;}
  .wrap{max-width:880px;margin:0 auto;background:white;padding:18px;border-radius:10px;box-shadow:0 8px 30px rgba(20,20,40,.08)}
  label{display:block;margin-top:8px;font-weight:600}
  input{width:100%;padding:8px;margin-top:6px;border-radius:6px;border:1px solid #e6e9ef}
  .row{display:grid;grid-template-columns:1fr 1fr 1fr;gap:12px}
  button{padding:10px 14px;border-radius:8px;border:none;margin-top:12px;font-weight:700;cursor:pointer}
  .start{background:#10b981;color:white}
  .stop{background:#ef4444;color:white}
  pre{background:#0b1220;color:#9ff1c7;padding:12px;border-radius:8px;height:240px;overflow:auto;white-space:pre-wrap}
  .small{font-size:0.9rem;color:#475569}
  .progress{height:14px;background:#eceff6;border-radius:999px;overflow:hidden;margin-top:8px}
  .bar{height:100%;background:#3b82f6;width:0;text-align:center;color:white;font-weight:700;font-size:12px}
  .stat{font-weight:700;font-size:1.05rem}
</style>
</head>
<body>
  <div class="wrap">
    <h2>Streaming Integer √ (fixed test)</h2>
    <p class="small">Computes S<sub>min</sub> = 2·ceil(√N) for N = a^b + c. Built to handle very large exponents for a=10 without JS parse bugs.</p>

    <div class="row">
      <div>
        <label>Base (a)</label>
        <input id="a" value="10">
      </div>
      <div>
        <label>Exponent (b)</label>
        <input id="b" value="30">
      </div>
      <div>
        <label>Addend (c)</label>
        <input id="c" value="-1">
      </div>
    </div>

    <div style="display:flex;gap:8px">
      <button id="start" class="start">Compute S_min</button>
      <button id="stop" class="stop" disabled>Stop</button>
    </div>

    <div style="margin-top:12px">
      <div class="small">Status: <span id="status">Idle</span></div>
      <div class="progress"><div id="bar" class="bar">0%</div></div>
    </div>

    <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-top:12px">
      <div>
        <div class="small">Calculated S_min</div>
        <div id="smin" class="stat">N/A</div>
      </div>
      <div>
        <div class="small">N (preview)</div>
        <div id="npreview" class="stat">N/A</div>
      </div>
    </div>

    <h3 style="margin-top:12px">Log</h3>
    <pre id="log">Ready.</pre>
  </div>

<script>
/* ========= Utility logging/UI ========= */
const startBtn = document.getElementById('start');
const stopBtn  = document.getElementById('stop');
const aInp = document.getElementById('a');
const bInp = document.getElementById('b');
const cInp = document.getElementById('c');
const logEl = document.getElementById('log');
const statusEl = document.getElementById('status');
const barEl = document.getElementById('bar');
const sminEl = document.getElementById('smin');
const nPreview = document.getElementById('npreview');

function log(msg){
  const t = new Date().toLocaleTimeString();
  logEl.textContent += `\n[${t}] ${msg}`;
  logEl.scrollTop = logEl.scrollHeight;
}
function setPhase(text, pct=0){
  statusEl.textContent = text;
  barEl.style.width = pct + '%';
  barEl.textContent = pct.toFixed(2) + '%';
}

/* ========= Worker creation approach =========
   We create the worker from a function's toString() so we avoid
   accidental template-literal interpolation problems that cause
   parse errors like "Unexpected identifier 'Exponent'".
*/
function sqrtWorkerFunction(){
  // Worker code runs in a separate global scope (no DOM).
  const CHUNK_DIGITS = 9;
  const BASE = 10 ** CHUNK_DIGITS;

  function trimChunks(a){
    if(!Array.isArray(a) || a.length===0) return [0];
    let i=0;
    while(i < a.length-1 && a[i]===0) i++;
    return a.slice(i);
  }
  function stringToChunks(s){
    s = (s||'').replace(/^\\+/, '').trim();
    if(s[0] === '+') s = s.slice(1);
    if(s.length === 0) return [0];
    const pad = (CHUNK_DIGITS - (s.length % CHUNK_DIGITS)) % CHUNK_DIGITS;
    s = '0'.repeat(pad) + s;
    const out = [];
    for(let i=0;i<s.length;i+=CHUNK_DIGITS){
      out.push(parseInt(s.substring(i,i+CHUNK_DIGITS),10));
    }
    return trimChunks(out);
  }
  function chunksToString(chunks){
    chunks = trimChunks(chunks);
    if(chunks.length===1 && chunks[0]===0) return '0';
    let s = String(chunks[0]);
    for(let i=1;i<chunks.length;i++) s += String(chunks[i]).padStart(CHUNK_DIGITS,'0');
    return s;
  }
  function cmpChunks(a,b){
    a = trimChunks(a); b = trimChunks(b);
    if(a.length !== b.length) return a.length > b.length ? 1 : -1;
    for(let i=0;i<a.length;i++) if(a[i] !== b[i]) return a[i] > b[i] ? 1 : -1;
    return 0;
  }
  function addChunks(a,b){
    let ar = a.slice().reverse(), br = b.slice().reverse();
    const n = Math.max(ar.length, br.length);
    let carry = 0, out = [];
    for(let i=0;i<n;i++){
      const s = (ar[i]||0) + (br[i]||0) + carry;
      out.push(s % BASE);
      carry = Math.floor(s / BASE);
    }
    if(carry) out.push(carry);
    return trimChunks(out.reverse());
  }
  function subChunks(a,b){
    let ar = a.slice().reverse(), br = b.slice().reverse();
    const n = ar.length;
    let borrow = 0, out = [];
    for(let i=0;i<n;i++){
      let v = (ar[i]||0) - (br[i]||0) - borrow;
      if(v < 0){ v += BASE; borrow = 1; } else borrow = 0;
      out.push(v);
    }
    return trimChunks(out.reverse());
  }
  function mulSmallChunks(a,s){
    if(!Array.isArray(a)||a.length===0) return [0];
    if(s === 0) return [0];
    let a_rev = a.slice().reverse();
    let carry = 0, out = [];
    for(const d of a_rev){
      const p = d * s + carry;
      out.push(p % BASE);
      carry = Math.floor(p / BASE);
    }
    while(carry > 0){
      out.push(carry % BASE);
      carry = Math.floor(carry / BASE);
    }
    return trimChunks(out.reverse());
  }
  function shiftChunks(a,k){
    if(!Array.isArray(a) || a.length === 0) return [0];
    if(k <= 0) return a.slice();
    return a.concat(new Array(k).fill(0));
  }

  // streaming integer sqrt operating on decimal string
  function streamingIntegerSqrt(N_str, onProgress){
    const groupDigits = CHUNK_DIGITS * 2;
    let s = N_str.replace(/^\\+/, '');
    if(s.length === 0) s = '0';
    const pad = (groupDigits - (s.length % groupDigits)) % groupDigits;
    s = '0'.repeat(pad) + s;
    const groups = [];
    for(let i=0;i<s.length;i+=groupDigits) groups.push(s.substring(i,i+groupDigits));

    let root = [0];
    let remainder = [0];
    const total = groups.length;

    for(let idx=0; idx<groups.length; idx++){
      const g = groups[idx];
      const left = g.substring(0, CHUNK_DIGITS);
      const right = g.substring(CHUNK_DIGITS);
      const groupChunks = [parseInt(left,10), parseInt(right,10)];
      remainder = shiftChunks(remainder, 2);
      remainder = addChunks(remainder, trimChunks(groupChunks));

      let prefix = mulSmallChunks(root, 2);

      // binary search digit d in [0, BASE-1]
      let lo = 0, hi = BASE - 1, chosen = 0;
      while(lo <= hi){
        const mid = Math.floor((lo + hi) / 2);
        let t = shiftChunks(prefix, 1);
        t = addChunks(t, [mid]);
        let trial = mulSmallChunks(t, mid);
        if(cmpChunks(trial, remainder) <= 0){
          chosen = mid;
          lo = mid + 1;
        } else {
          hi = mid - 1;
        }
      }

      // subtract chosen trial
      let chosenT = shiftChunks(prefix, 1);
      chosenT = addChunks(chosenT, [chosen]);
      let trialChosen = mulSmallChunks(chosenT, chosen);
      remainder = subChunks(remainder, trialChosen);

      // root = root * BASE + chosen  (root already chunk-array)
      root = addChunks(mulSmallChunks(root, 1), [chosen]);

      if(onProgress && (idx % 50 === 0)) {
        try { onProgress((idx+1)/total * 100); } catch(e){}
      }
    }

    return { root: chunksToString(root), remainder: chunksToString(remainder), digits: N_str.length };
  }

  // Fast BigInt sqrt when decimal string is small enough
  function tryNative(N_str){
    try {
      if(N_str.length < 700) {
        const Nbi = BigInt(N_str);
        // integer sqrt via Newton
        let x = Nbi;
        let y = (x + 1n) >> 1n;
        while(y < x) { x = y; y = (x + Nbi / x) >> 1n; }
        const rem = Nbi - x*x;
        return { root: x.toString(), remainder: rem.toString() };
      }
    } catch(e){}
    return null;
  }

  self.onmessage = function(ev){
    const data = ev.data || {};
    if(data.mode === 'compute_sqrt'){
      try {
        const aStr = String(data.aStr || '10').trim();
        const bStr = String(data.bStr || '0').trim();
        const cStr = String(data.cStr || '0').trim();
        const maxDigitsLimit = Number(data.maxDigitsLimit || 5000000);

        if(aStr !== '10') {
          self.postMessage({ type:'error', message: 'Worker currently supports large exponents for base=10 only.' });
          return;
        }

        const bBig = BigInt(bStr);
        if(bBig < 0n) { self.postMessage({ type:'error', message:'Exponent must be >= 0' }); return; }

        const bNum = Number(bBig);
        if(!Number.isFinite(bNum) || bNum > maxDigitsLimit) {
          self.postMessage({ type:'error', message: 'Exponent too large or not a finite number for this run.' });
          return;
        }

        // Build 10^b as '1' + b zeros
        const powStr = '1' + '0'.repeat(bNum);

        // Add c (string decimal add/sub) -> keep it simple, use chunk add/sub
        function signAndAbs(s){
          s = String(s).trim();
          let sign = 1;
          if(s[0] === '+') s = s.slice(1);
          if(s[0] === '-') { sign = -1; s = s.slice(1); }
          s = s.replace(/^0+/, '') || '0';
          return { sign, s };
        }
        function addDecimalStrings(A, B){
          const a = signAndAbs(A), b = signAndAbs(B);
          if(a.sign === b.sign){
            const ra = stringToChunks(a.s), rb = stringToChunks(b.s);
            return (a.sign < 0 ? '-' : '') + chunksToString(addChunks(ra, rb));
          } else {
            const ra = stringToChunks(a.s), rb = stringToChunks(b.s);
            const cmp = cmpChunks(ra, rb);
            if(cmp === 0) return '0';
            if(cmp > 0) return (a.sign < 0 ? '-' : '') + chunksToString(subChunks(ra, rb));
            return (b.sign < 0 ? '-' : '') + chunksToString(subChunks(rb, ra));
          }
        }

        const combined = addDecimalStrings(powStr, cStr || '0');

        self.postMessage({ type:'log', message: 'N digits: ' + combined.length });

        const fast = tryNative(combined);
        if(fast){
          self.postMessage({ type:'progress', value: 100 });
          self.postMessage({ type:'result', root: fast.root, remainder: fast.remainder, N_str: combined });
          return;
        }

        // streaming
        const result = streamingIntegerSqrt(combined, function(p){
          self.postMessage({ type:'progress', value: p });
        });

        self.postMessage({ type:'progress', value: 100 });
        self.postMessage({ type:'result', root: result.root, remainder: result.remainder, N_str: combined });

      } catch(err){
        self.postMessage({ type:'error', message: err && err.message ? err.message : String(err) });
      }
    }
  };
} // end of worker function

/* ========= Main thread control ========= */
let worker = null;
let stopped = false;

function createWorkerFromFunction(fn){
  const body = '(' + fn.toString() + ')()';
  const blob = new Blob([body], { type: 'application/javascript' });
  return new Worker(URL.createObjectURL(blob));
}

startBtn.addEventListener('click', function(){
  if(worker) return;
  stopped = false;
  log('\\n--- Start requested ---');
  setPhase('Preparing', 1);
  sminEl.textContent = 'Calculating...';

  const a = String(aInp.value || '10').trim();
  const b = String(bInp.value || '0').trim();
  const c = String(cInp.value || '0').trim();

  // create worker and start
  worker = createWorkerFromFunction(sqrtWorkerFunction);
  worker.onmessage = function(ev){
    const d = ev.data || {};
    if(d.type === 'log') log('[worker] ' + d.message);
    else if(d.type === 'progress') {
      setPhase('Streaming sqrt', d.value);
    } else if(d.type === 'result') {
      log('Worker returned result.');
      const rootStr = d.root;
      const remStr = d.remainder || '0';
      const Nstr = d.N_str || ('1' + '0'.repeat(Number(b)));
      nPreview.textContent = Nstr.length > 200 ? (Nstr.slice(0,80) + '…' + Nstr.slice(-80)) : Nstr;
      // compute S_min = 2 * ceil(sqrt(N))
      const rootBig = BigInt(rootStr);
      const remBig = BigInt(remStr);
      let Smin = rootBig * 2n;
      if(remBig > 0n) Smin = Smin + 1n;
      sminEl.textContent = Smin.toString();
      setPhase('Done', 100);
      log('S_min calculated: ' + Smin.toString());
      // cleanup
      try { worker.terminate(); } catch(e){}
      worker = null;
      stopBtn.disabled = true;
      startBtn.disabled = false;
    } else if(d.type === 'error') {
      log('[worker ERROR] ' + d.message);
      setPhase('Error', 0);
      try { worker.terminate(); } catch(e){}
      worker = null;
      startBtn.disabled = false;
      stopBtn.disabled = true;
    }
  };

  // disable controls while running
  startBtn.disabled = true;
  stopBtn.disabled = false;

  worker.postMessage({ mode: 'compute_sqrt', aStr: a, bStr: b, cStr: c, maxDigitsLimit: 2000000 });
});

stopBtn.addEventListener('click', function(){
  if(worker){
    try { worker.terminate(); } catch(e){}
    worker = null;
  }
  stopped = true;
  startBtn.disabled = false;
  stopBtn.disabled = true;
  setPhase('Stopped', 0);
  log('Stopped by user.');
});

/* initial */
setPhase('Idle', 0);
log('Ready — enter a, b, c and click "Compute S_min".');
</script>
</body>
</html>