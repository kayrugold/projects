<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, interactive-widget=resizes-content">
<title>Architect v15 (Stable)</title>
<script src="https://cdn.tailwindcss.com"></script>
<style>
    body { background-color: #000; color: #e2e8f0; font-family: 'Courier New', monospace; padding: 10px; display: flex; flex-direction: column; height: 100vh; overflow: hidden; }
    
    /* HUD - FIXED TOP */
    .hud-panel { background: #0a0a0a; border-bottom: 1px solid #333; padding: 10px; flex-shrink: 0; z-index: 50; }
    
    /* STATS ROW */
    .row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px; }
    .lbl { font-size: 0.65rem; color: #9ca3af; text-transform: uppercase; font-weight: bold; letter-spacing: 1px; }
    .val { font-size: 1rem; color: #fff; font-weight: bold; text-shadow: 0 0 5px rgba(255,255,255,0.2); }
    .val-theme { color: #f87171; }
    .val-sec { color: #fb923c; }

    /* TRACKS */
    .track-container { margin-bottom: 8px; }
    .track { height: 6px; background: #1f1f1f; border-radius: 3px; overflow: hidden; border: 1px solid #333; }
    .fill-mine { height: 100%; background: #dc2626; width: 0%; transition: width 0.1s linear; }
    .fill-solve { height: 100%; background: #ea580c; width: 0%; transition: width 0.1s linear; }

    /* CORE GRID */
    .core-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 4px; margin-bottom: 10px; }
    .core-card { background: #1a0505; border: 1px solid #2b0a0a; padding: 4px; border-radius: 4px; text-align: center; }
    .core-lbl { font-size: 0.55rem; color: #7f1d1d; font-weight: bold; display: block; }
    .core-stat { font-size: 0.7rem; color: #fca5a5; font-weight: bold; }
    .core-active { border-color: #ef4444; background: #450a0a; }
    
    /* LOG - SCROLLABLE MIDDLE */
    .log-area { flex-grow: 1; overflow-y: auto; background: #050505; padding: 10px; font-size: 0.75rem; color: #a3a3a3; font-family: monospace; border-top: 1px solid #222; }
    .log-row { margin-bottom: 3px; border-bottom: 1px solid #111; padding-bottom: 2px; }
    .l-sys { color: #38bdf8; }
    .l-hit { color: #facc15; }
    .l-win { color: #4ade80; font-weight: bold; background: rgba(74, 222, 128, 0.1); padding: 8px; text-align: center; border: 1px solid #4ade80; margin: 10px 0; font-size: 1rem; }
    .l-warn { color: #fb923c; }

    /* INPUTS - FIXED BOTTOM */
    .input-area { padding: 10px; background: #0a0a0a; border-top: 1px solid #333; display: flex; gap: 5px; flex-shrink: 0; }
    input { background: #111; border: 1px solid #333; color: #fff; padding: 12px; border-radius: 6px; flex-grow: 1; font-family: monospace; font-weight: bold; font-size: 0.9rem; outline: none; }
    input:focus { border-color: #ef4444; }
    .btn { background: #1f1f1f; color: #fff; border: 1px solid #333; padding: 0 20px; border-radius: 6px; font-weight: 900; cursor: pointer; text-transform: uppercase; font-size: 0.9rem; }
    .btn-go { background: #991b1b; border-color: #b91c1c; }
    .btn-stop { background: #333; border-color: #555; display: none; }
</style>
</head>
<body>

<div class="hud-panel">
    <div class="row">
        <div><span class="lbl">TARGET (N)</span><div id="dispN" class="val" style="word-break:break-all; font-size:0.85rem;">WAITING</div></div>
        <div style="text-align:right;"><span class="lbl">FACTOR BASE</span><div id="dispFB" class="val val-sec">0</div></div>
    </div>
    
    <div class="track-container">
        <div class="row" style="margin-bottom:2px;"><span class="lbl">MINING</span><span id="relTxt" class="lbl text-red-400">0 / 0</span></div>
        <div class="track"><div id="relBar" class="fill-mine"></div></div>
    </div>

    <div class="track-container">
        <div class="row" style="margin-bottom:2px;"><span class="lbl">SOLVER</span><span id="solTxt" class="lbl text-orange-400">IDLE</span></div>
        <div class="track"><div id="solBar" class="fill-solve"></div></div>
    </div>

    <div class="core-grid" id="coreGrid"></div>
</div>

<div id="log" class="log-area">
    <div class="log-row l-sys">Architect v15 Online.</div>
    <div class="log-row l-sys">System Stable. Ready to Ignite.</div>
</div>

<div class="input-area">
    <input id="inpN" value="1099515822059" placeholder="Enter Target Number">
    <button id="btnRun" class="btn btn-go" onclick="ignite()">IGNITE</button>
    <button id="btnStop" class="btn btn-stop" onclick="abort()">STOP</button>
    
    <select id="coreSelect" style="display:none;"><option value="8" selected>8</option></select>
</div>

<script>
// ==========================================
// WORKER 1: THE MINER (Transferables)
// ==========================================
const minerScript = `
self.onmessage = function(e) {
    const { cmd, N_str, startX, range, fb, primes, threshold } = e.data;
    
    if(cmd === 'mine') {
        const N = BigInt(N_str);
        const sieve = new Float32Array(range);
        const rootN = BigInt(Math.floor(Math.sqrt(Number(N))));
        
        let currentX = BigInt(startX);
        let Q_val = (rootN + currentX)*(rootN + currentX) - N;
        let Slope = 2n * (rootN + currentX) + 1n;
        
        for(let i=0; i<range; i++) {
            let absQ = Q_val < 0n ? -Q_val : Q_val;
            sieve[i] = absQ.toString(2).length; 
            Q_val += Slope;
            Slope += 2n;
        }
        
        for(let i=0; i<primes.length; i++) {
            const p = primes[i];
            const logP = Math.log2(p);
            const roots = fb[i];
            for(let r of roots) {
                let offset = Number((BigInt(r) - rootN - BigInt(startX)) % BigInt(p));
                if (offset < 0) offset += p;
                for(let j=offset; j<range; j+=p) sieve[j] -= logP;
            }
        }
        
        const relations = [];
        for(let j=0; j<range; j++) {
            if(sieve[j] < threshold) {
                const xVal = BigInt(startX + j);
                let Q = (rootN + xVal)*(rootN + xVal) - N;
                if(Q < 0n) Q = -Q;
                
                const vector = new Uint8Array(primes.length);
                const exps = new Uint32Array(primes.length);
                
                for(let k=0; k<primes.length; k++) {
                    const p = BigInt(primes[k]);
                    while(Q % p === 0n) { Q /= p; vector[k] ^= 1; exps[k]++; }
                }
                if(Q === 1n) {
                    relations.push({ x: xVal.toString(), vec: vector.buffer, exps: exps.buffer });
                }
            }
        }
        self.postMessage({ type: 'results', rels: relations }, relations.map(r => r.vec).concat(relations.map(r => r.exps)));
    }
};
`;

// ==========================================
// WORKER 2: THE SOLVER (Fixed Division)
// ==========================================
const solverScript = `
let targetN = 0n;
let rootN = 0n;
let factorBase = [];
let matrix = [];
let relations = [];

function gcd(a, b) { if(a<0n) a=-a; while(b>0n){let t=b;b=a%b;a=t;} return a; }

function solveMatrix() {
    self.postMessage({type:'status', msg:'ELIMINATING PIVOTS'});
    const pivots = new Map(); 
    let dependencies = []; 
    
    const matrixSize = matrix.length;
    const fbSize = factorBase.length;

    for(let i=0; i<matrixSize; i++) {
        let row = matrix[i];
        let mask = row.mask;
        let history = row.history;
        
        for(let col=0; col<fbSize; col++) {
            if ( (mask & (1n << BigInt(col))) !== 0n ) {
                if (pivots.has(col)) {
                    const piv = pivots.get(col);
                    mask ^= piv.mask;
                    history = history.concat(piv.history);
                } else {
                    pivots.set(col, { mask: mask, history: history });
                    mask = 0n; break; 
                }
            }
        }
        
        if (mask === 0n && history.length > 0) {
            dependencies.push(history);
            if(dependencies.length > 5) break; 
        }
        if(i % 100 === 0) self.postMessage({type:'prog', val: i, total: matrixSize});
    }
    
    if(dependencies.length === 0) { self.postMessage({type:'fail'}); return; }

    self.postMessage({type:'status', msg:'CRACKING ROOTS'});
    
    for(let dep of dependencies) {
        let X = 1n;
        const totalExps = new Array(fbSize).fill(0);
        
        for(let idx of dep) {
            const r = relations[idx];
            const x_val = BigInt(r.x) + rootN;
            X = (X * x_val) % targetN;
            for(let k=0; k<r.exps.length; k++) totalExps[k] += r.exps[k];
        }
        
        let Y = 1n;
        for(let k=0; k<fbSize; k++) {
            const p = BigInt(factorBase[k]);
            // FIX: Integer Division via Shift
            const exp = BigInt(totalExps[k] >> 1); 
            
            let base = p, e = exp, res = 1n;
            while(e>0n){ if(e&1n) res=(res*base)%targetN; base=(base*base)%targetN; e>>=1n; }
            Y = (Y * res) % targetN;
        }
        
        const f1 = gcd(X - Y, targetN);
        const f2 = targetN / f1;
        
        if(f1 > 1n && f1 < targetN) {
            self.postMessage({type:'success', f1:f1.toString(), f2:f2.toString()});
            return;
        }
    }
    self.postMessage({type:'trivial'});
}

self.onmessage = function(e) {
    const d = e.data;
    if(d.cmd === 'init') {
        targetN = BigInt(d.targetN_str);
        rootN = BigInt(Math.floor(Math.sqrt(Number(targetN))));
        factorBase = d.factorBase;
        matrix = [];
        relations = []; 
        self.postMessage({type:'status', msg:'MATRIX READY'});
    }
    if(d.cmd === 'add_chunk') {
        const chunk = d.chunk;
        for(let rel of chunk) {
            const vector = new Uint8Array(rel.vec);
            const exponents = new Uint32Array(rel.exps);
            let mask = 0n;
            for(let i=0; i<vector.length; i++) if(vector[i]) mask |= (1n << BigInt(i));
            matrix.push({ mask: mask, history: [relations.length] });
            relations.push({ x: rel.x, exps: exponents });
        }
        self.postMessage({type:'status', msg:'ROWS: ' + matrix.length});
    }
    if(d.cmd === 'solve') {
        solveMatrix();
    }
};
`;

const minerBlob = new Blob([minerScript], {type:'application/javascript'});
const solverBlob = new Blob([solverScript], {type:'application/javascript'});
const minerUrl = URL.createObjectURL(minerBlob);
const solverUrl = URL.createObjectURL(solverBlob);

let miners = [], solver = null;
let factorBase = [], rootsFB = [];
let targetN = 0n, relations = [], neededRels = 0;
let isRunning = false, globalOffset = 0;
const BLOCK_SIZE = 50000;
const BATCH_SIZE = 50; 

document.addEventListener('DOMContentLoaded', () => {
    const cores = navigator.hardwareConcurrency || 4;
    // Auto-set 8 cores for your Note 20
    const sel = document.getElementById('coreSelect');
    sel.value = "8";
    initGrid();
});

function log(msg, type='') {
    const box = document.getElementById('log');
    const d = document.createElement('div');
    d.className = `log-row l-${type||'sys'}`;
    d.innerText = `> ${msg}`;
    box.prepend(d);
}

function initGrid() {
    const n = document.getElementById('coreSelect').value;
    const g = document.getElementById('coreGrid');
    g.innerHTML = '';
    g.style.gridTemplateColumns = `repeat(${Math.min(n,4)}, 1fr)`;
    for(let i=0; i<n; i++) {
        g.innerHTML += `<div class="core-card" id="card${i}"><span class="core-lbl">CORE ${i+1}</span><span class="core-stat" id="c${i}">IDLE</span></div>`;
    }
}

function buildFB(n) {
    const limit = 3000; 
    const fb=[], roots=[], sieve=new Uint8Array(limit).fill(1);
    for(let p=2; p<limit; p++) {
        if(sieve[p]) {
            for(let j=p*p; j<limit; j+=p) sieve[j]=0;
            const bigP = BigInt(p);
            const target = n % bigP;
            let r_sol = [];
            for(let r=0n; r<bigP; r++) { if((r*r)%bigP===target) r_sol.push(Number(r)); }
            if(r_sol.length>0) { fb.push(p); roots.push(r_sol); }
        }
    }
    return {p:fb, r:roots};
}

function ignite() {
    const nStr = document.getElementById('inpN').value.trim();
    try { targetN = BigInt(nStr); } catch{ alert("Invalid N"); return; }
    
    isRunning = true; relations = []; globalOffset = 0;
    document.getElementById('btnRun').style.display = 'none';
    document.getElementById('btnStop').style.display = 'inline-block';
    document.getElementById('log').innerHTML = '';
    document.getElementById('dispN').innerText = nStr;
    document.getElementById('relBar').style.width = '0%';
    document.getElementById('solBar').style.width = '0%';
    
    log(`Target Locked: ${targetN}`, 'sys');
    
    const data = buildFB(targetN);
    factorBase = data.p; rootsFB = data.r;
    neededRels = factorBase.length + 20;
    
    document.getElementById('dispFB').innerText = factorBase.length;
    document.getElementById('relTxt').innerText = `0 / ${neededRels}`;
    
    log(`Generated Factor Base (${factorBase.length} Primes)`, 'sys');
    
    miners.forEach(w=>w.terminate()); miners=[];
    const count = parseInt(document.getElementById('coreSelect').value);
    for(let i=0; i<count; i++) {
        const w = new Worker(minerUrl);
        w.onmessage = e => handleMiner(e, i);
        miners.push(w);
    }
    dispatch();
}

function dispatch() {
    if(!isRunning) return;
    if(relations.length >= neededRels) { launchSolver(); return; }
    miners.forEach((w, i) => {
        w.postMessage({
            cmd:'mine', N_str:targetN.toString(), startX:globalOffset, range:BLOCK_SIZE,
            fb:rootsFB, primes:factorBase, threshold: 5.0
        });
        document.getElementById(`c${i}`).innerText = `${Math.round(globalOffset/1000)}k`;
        document.getElementById(`card${i}`).classList.add('core-active');
        globalOffset += BLOCK_SIZE;
    });
}

function handleMiner(e, id) {
    if(e.data.type === 'results') {
        const hits = e.data.rels;
        if(hits.length > 0) {
            relations.push(...hits);
            const pct = Math.min(100, (relations.length/neededRels)*100);
            document.getElementById('relBar').style.width = pct+'%';
            document.getElementById('relTxt').innerText = `${relations.length} / ${neededRels}`;
            log(`Core ${id+1} found ${hits.length} relations`, 'l-hit');
        }
        setTimeout(()=>document.getElementById(`card${id}`).classList.remove('core-active'), 100);
        
        if(relations.length < neededRels && isRunning) {
            const chunk = globalOffset; globalOffset += BLOCK_SIZE;
            miners[id].postMessage({
                cmd:'mine', N_str:targetN.toString(), startX:chunk, range:BLOCK_SIZE,
                fb:rootsFB, primes:factorBase, threshold: 5.0
            });
            document.getElementById(`c${id}`).innerText = `${Math.round(chunk/1000)}k`;
            document.getElementById(`card${id}`).classList.add('core-active');
        } else if (isRunning && relations.length >= neededRels) {
            launchSolver();
        }
    }
}

function launchSolver() {
    if(solver) return;
    isRunning = false;
    miners.forEach(w=>w.terminate()); miners=[];
    document.querySelectorAll('.core-active').forEach(e=>e.classList.remove('core-active'));
    
    log("Mining Complete. Initiating Solver...", 'sys');
    
    solver = new Worker(solverUrl);
    solver.onmessage = handleSolverMsg;
    
    solver.postMessage({
        cmd: 'init',
        targetN_str: targetN.toString(),
        factorBase: factorBase
    });

    log(`Streaming ${relations.length} relations...`, 'l-sol');
    
    const chunker = () => {
        const sendRels = [];
        const buffers = [];
        
        while(relations.length > 0 && sendRels.length < BATCH_SIZE) {
            const rel = relations.shift();
            sendRels.push(rel);
            buffers.push(rel.vec, rel.exps);
        }
        
        if(sendRels.length > 0) {
            solver.postMessage({ cmd: "add_chunk", chunk: sendRels }, buffers);
            setTimeout(chunker, 10);
        } else {
            log("Matrix populated. Solving...", 'l-sol');
            solver.postMessage({ cmd: "solve" });
        }
    };
    
    chunker();
}

function handleSolverMsg(e) {
    if(e.data.type === 'status') document.getElementById('solTxt').innerText = e.data.msg;
    if(e.data.type === 'prog') {
        const pct = (e.data.val / e.data.total)*100;
        document.getElementById('solBar').style.width = pct+'%';
    }
    if(e.data.type === 'success') {
        log(`FACTOR: ${e.data.f1}`, 'l-win');
        log(`FACTOR: ${e.data.f2}`, 'l-win');
        document.getElementById('solBar').style.width = '100%';
        document.getElementById('solBar').style.backgroundColor = '#4ade80';
        document.getElementById('solTxt').innerText = "CRACKED";
        resetUI();
    }
    if(e.data.type === 'fail' || e.data.type === 'trivial') {
        log(e.data.type === 'fail' ? "Matrix Singular." : "Trivial Solution.", 'l-warn');
        log("Resuming Mining...", 'sys');
        solver.terminate(); solver=null;
        neededRels += 50; 
        isRunning = true;
        ignite(); 
    }
}

function abort() {
    isRunning = false;
    if(miners.length) miners.forEach(w=>w.terminate());
    if(solver) solver.terminate();
    resetUI();
    log("System Halted.", 'l-warn');
}

function resetUI() {
    document.getElementById('btnRun').style.display = 'inline-block';
    document.getElementById('btnStop').style.display = 'none';
    solver = null; miners = [];
}
</script>
</body>
</html>
